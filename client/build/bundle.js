(()=>{var __webpack_modules__={84:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// NAMESPACE OBJECT: ./node_modules/@amcharts/amcharts5/index.js\nvar amcharts5_namespaceObject = {};\n__webpack_require__.r(amcharts5_namespaceObject);\n\n;// CONCATENATED MODULE: ./node_modules/@vue/shared/dist/shared.esm-bundler.js\nfunction shared_esm_bundler_makeMap(str, expectsLowerCase) {\n  const map = /* @__PURE__ */Object.create(null);\n  const list = str.split(",");\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\n}\nconst shared_esm_bundler_EMPTY_OBJ =  false ? 0 : {};\nconst EMPTY_ARR =  false ? 0 : [];\nconst shared_esm_bundler_NOOP = () => {};\nconst shared_esm_bundler_NO = () => false;\nconst onRE = /^on[^a-z]/;\nconst shared_esm_bundler_isOn = key => onRE.test(key);\nconst isModelListener = key => key.startsWith("onUpdate:");\nconst shared_esm_bundler_extend = Object.assign;\nconst remove = (arr, el) => {\n  const i = arr.indexOf(el);\n  if (i > -1) {\n    arr.splice(i, 1);\n  }\n};\nconst shared_esm_bundler_hasOwnProperty = Object.prototype.hasOwnProperty;\nconst shared_esm_bundler_hasOwn = (val, key) => shared_esm_bundler_hasOwnProperty.call(val, key);\nconst shared_esm_bundler_isArray = Array.isArray;\nconst isMap = val => toTypeString(val) === "[object Map]";\nconst shared_esm_bundler_isSet = val => toTypeString(val) === "[object Set]";\nconst isDate = val => toTypeString(val) === "[object Date]";\nconst isRegExp = val => toTypeString(val) === "[object RegExp]";\nconst shared_esm_bundler_isFunction = val => typeof val === "function";\nconst shared_esm_bundler_isString = val => typeof val === "string";\nconst isSymbol = val => typeof val === "symbol";\nconst shared_esm_bundler_isObject = val => val !== null && typeof val === "object";\nconst shared_esm_bundler_isPromise = val => {\n  return shared_esm_bundler_isObject(val) && shared_esm_bundler_isFunction(val.then) && shared_esm_bundler_isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = value => objectToString.call(value);\nconst shared_esm_bundler_toRawType = value => {\n  return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = val => toTypeString(val) === "[object Object]";\nconst isIntegerKey = key => shared_esm_bundler_isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;\nconst shared_esm_bundler_isReservedProp = /* @__PURE__ */shared_esm_bundler_makeMap(\n// the leading comma is intentional so empty string "" is also included\n",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");\nconst shared_esm_bundler_isBuiltInDirective = /* @__PURE__ */(/* unused pure expression or super */ null && (shared_esm_bundler_makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo")));\nconst cacheStringFunction = fn => {\n  const cache = /* @__PURE__ */Object.create(null);\n  return str => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n};\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction(str => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");\n});\nconst hyphenateRE = /\\B([A-Z])/g;\nconst shared_esm_bundler_hyphenate = cacheStringFunction(str => str.replace(hyphenateRE, "-$1").toLowerCase());\nconst shared_esm_bundler_capitalize = cacheStringFunction(str => str.charAt(0).toUpperCase() + str.slice(1));\nconst shared_esm_bundler_toHandlerKey = cacheStringFunction(str => str ? `on${shared_esm_bundler_capitalize(str)}` : ``);\nconst shared_esm_bundler_hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, arg) => {\n  for (let i = 0; i < fns.length; i++) {\n    fns[i](arg);\n  }\n};\nconst def = (obj, key, value) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    value\n  });\n};\nconst looseToNumber = val => {\n  const n = parseFloat(val);\n  return isNaN(n) ? val : n;\n};\nconst shared_esm_bundler_toNumber = val => {\n  const n = shared_esm_bundler_isString(val) ? Number(val) : NaN;\n  return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : {});\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;\n}\nconst PatchFlagNames = {\n  [1]: `TEXT`,\n  [2]: `CLASS`,\n  [4]: `STYLE`,\n  [8]: `PROPS`,\n  [16]: `FULL_PROPS`,\n  [32]: `HYDRATE_EVENTS`,\n  [64]: `STABLE_FRAGMENT`,\n  [128]: `KEYED_FRAGMENT`,\n  [256]: `UNKEYED_FRAGMENT`,\n  [512]: `NEED_PATCH`,\n  [1024]: `DYNAMIC_SLOTS`,\n  [2048]: `DEV_ROOT_FRAGMENT`,\n  [-1]: `HOISTED`,\n  [-2]: `BAIL`\n};\nconst slotFlagsText = {\n  [1]: "STABLE",\n  [2]: "DYNAMIC",\n  [3]: "FORWARDED"\n};\nconst GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console";\nconst isGloballyWhitelisted = /* @__PURE__ */shared_esm_bundler_makeMap(GLOBALS_WHITE_LISTED);\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n  let lines = source.split(/(\\r?\\n)/);\n  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n  lines = lines.filter((_, idx) => idx % 2 === 0);\n  let count = 0;\n  const res = [];\n  for (let i = 0; i < lines.length; i++) {\n    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);\n    if (count >= start) {\n      for (let j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) continue;\n        const line = j + 1;\n        res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\n        const lineLength = lines[j].length;\n        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;\n        if (j === i) {\n          const pad = start - (count - (lineLength + newLineSeqLength));\n          const length = Math.max(1, end > count ? lineLength - pad : end - start);\n          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));\n        } else if (j > i) {\n          if (end > count) {\n            const length = Math.max(Math.min(end - count, lineLength), 1);\n            res.push(`   |  ` + "^".repeat(length));\n          }\n          count += lineLength + newLineSeqLength;\n        }\n      }\n      break;\n    }\n  }\n  return res.join("\\n");\n}\nfunction normalizeStyle(value) {\n  if (shared_esm_bundler_isArray(value)) {\n    const res = {};\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i];\n      const normalized = shared_esm_bundler_isString(item) ? parseStringStyle(item) : normalizeStyle(item);\n      if (normalized) {\n        for (const key in normalized) {\n          res[key] = normalized[key];\n        }\n      }\n    }\n    return res;\n  } else if (shared_esm_bundler_isString(value)) {\n    return value;\n  } else if (shared_esm_bundler_isObject(value)) {\n    return value;\n  }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*[^]*?\\*\\//g;\nfunction parseStringStyle(cssText) {\n  const ret = {};\n  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach(item => {\n    if (item) {\n      const tmp = item.split(propertyDelimiterRE);\n      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return ret;\n}\nfunction stringifyStyle(styles) {\n  let ret = "";\n  if (!styles || shared_esm_bundler_isString(styles)) {\n    return ret;\n  }\n  for (const key in styles) {\n    const value = styles[key];\n    const normalizedKey = key.startsWith(`--`) ? key : shared_esm_bundler_hyphenate(key);\n    if (shared_esm_bundler_isString(value) || typeof value === "number") {\n      ret += `${normalizedKey}:${value};`;\n    }\n  }\n  return ret;\n}\nfunction normalizeClass(value) {\n  let res = "";\n  if (shared_esm_bundler_isString(value)) {\n    res = value;\n  } else if (shared_esm_bundler_isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const normalized = normalizeClass(value[i]);\n      if (normalized) {\n        res += normalized + " ";\n      }\n    }\n  } else if (shared_esm_bundler_isObject(value)) {\n    for (const name in value) {\n      if (value[name]) {\n        res += name + " ";\n      }\n    }\n  }\n  return res.trim();\n}\nfunction normalizeProps(props) {\n  if (!props) return null;\n  let {\n    class: klass,\n    style\n  } = props;\n  if (klass && !shared_esm_bundler_isString(klass)) {\n    props.class = normalizeClass(klass);\n  }\n  if (style) {\n    props.style = normalizeStyle(style);\n  }\n  return props;\n}\nconst HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";\nconst SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";\nconst VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";\nconst shared_esm_bundler_isHTMLTag = /* @__PURE__ */(/* unused pure expression or super */ null && (shared_esm_bundler_makeMap(HTML_TAGS)));\nconst shared_esm_bundler_isSVGTag = /* @__PURE__ */(/* unused pure expression or super */ null && (shared_esm_bundler_makeMap(SVG_TAGS)));\nconst isVoidTag = /* @__PURE__ */(/* unused pure expression or super */ null && (shared_esm_bundler_makeMap(VOID_TAGS)));\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /* @__PURE__ */shared_esm_bundler_makeMap(specialBooleanAttrs);\nconst isBooleanAttr = /* @__PURE__ */shared_esm_bundler_makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);\nfunction includeBooleanAttr(value) {\n  return !!value || value === "";\n}\nconst unsafeAttrCharRE = /[>/="\'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n  if (attrValidationCache.hasOwnProperty(name)) {\n    return attrValidationCache[name];\n  }\n  const isUnsafe = unsafeAttrCharRE.test(name);\n  if (isUnsafe) {\n    console.error(`unsafe attribute name: ${name}`);\n  }\n  return attrValidationCache[name] = !isUnsafe;\n}\nconst propsToAttrMap = {\n  acceptCharset: "accept-charset",\n  className: "class",\n  htmlFor: "for",\n  httpEquiv: "http-equiv"\n};\nconst isKnownHtmlAttr = /* @__PURE__ */(/* unused pure expression or super */ null && (shared_esm_bundler_makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`)));\nconst isKnownSvgAttr = /* @__PURE__ */(/* unused pure expression or super */ null && (shared_esm_bundler_makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`)));\nconst escapeRE = /["\'&<>]/;\nfunction escapeHtml(string) {\n  const str = "" + string;\n  const match = escapeRE.exec(str);\n  if (!match) {\n    return str;\n  }\n  let html = "";\n  let escaped;\n  let index;\n  let lastIndex = 0;\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        escaped = "&quot;";\n        break;\n      case 38:\n        escaped = "&amp;";\n        break;\n      case 39:\n        escaped = "&#39;";\n        break;\n      case 60:\n        escaped = "&lt;";\n        break;\n      case 62:\n        escaped = "&gt;";\n        break;\n      default:\n        continue;\n    }\n    if (lastIndex !== index) {\n      html += str.slice(lastIndex, index);\n    }\n    lastIndex = index + 1;\n    html += escaped;\n  }\n  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\nconst commentStripRE = /^-?>|\x3c!--|--\x3e|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n  return src.replace(commentStripRE, "");\n}\nfunction looseCompareArrays(a, b) {\n  if (a.length !== b.length) return false;\n  let equal = true;\n  for (let i = 0; equal && i < a.length; i++) {\n    equal = shared_esm_bundler_looseEqual(a[i], b[i]);\n  }\n  return equal;\n}\nfunction shared_esm_bundler_looseEqual(a, b) {\n  if (a === b) return true;\n  let aValidType = isDate(a);\n  let bValidType = isDate(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n  }\n  aValidType = isSymbol(a);\n  bValidType = isSymbol(b);\n  if (aValidType || bValidType) {\n    return a === b;\n  }\n  aValidType = shared_esm_bundler_isArray(a);\n  bValidType = shared_esm_bundler_isArray(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n  }\n  aValidType = shared_esm_bundler_isObject(a);\n  bValidType = shared_esm_bundler_isObject(b);\n  if (aValidType || bValidType) {\n    if (!aValidType || !bValidType) {\n      return false;\n    }\n    const aKeysCount = Object.keys(a).length;\n    const bKeysCount = Object.keys(b).length;\n    if (aKeysCount !== bKeysCount) {\n      return false;\n    }\n    for (const key in a) {\n      const aHasKey = a.hasOwnProperty(key);\n      const bHasKey = b.hasOwnProperty(key);\n      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !shared_esm_bundler_looseEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n  }\n  return String(a) === String(b);\n}\nfunction shared_esm_bundler_looseIndexOf(arr, val) {\n  return arr.findIndex(item => shared_esm_bundler_looseEqual(item, val));\n}\nconst toDisplayString = val => {\n  return shared_esm_bundler_isString(val) ? val : val == null ? "" : shared_esm_bundler_isArray(val) || shared_esm_bundler_isObject(val) && (val.toString === objectToString || !shared_esm_bundler_isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);\n};\nconst replacer = (_key, val) => {\n  if (val && val.__v_isRef) {\n    return replacer(_key, val.value);\n  } else if (isMap(val)) {\n    return {\n      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {\n        entries[`${key} =>`] = val2;\n        return entries;\n      }, {})\n    };\n  } else if (shared_esm_bundler_isSet(val)) {\n    return {\n      [`Set(${val.size})`]: [...val.values()]\n    };\n  } else if (shared_esm_bundler_isObject(val) && !shared_esm_bundler_isArray(val) && !isPlainObject(val)) {\n    return String(val);\n  }\n  return val;\n};\n\n;// CONCATENATED MODULE: ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\n\nfunction reactivity_esm_bundler_warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (false) {}\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    activeEffectScope = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    activeEffectScope = this.parent;\n  }\n  stop(fromParent) {\n    if (this._active) {\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n      this._active = false;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n  if (scope && scope.active) {\n    scope.effects.push(effect);\n  }\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (false) {}\n}\nconst createDep = effects => {\n  const dep = new Set(effects);\n  dep.w = 0;\n  dep.n = 0;\n  return dep;\n};\nconst wasTracked = dep => (dep.w & trackOpBit) > 0;\nconst newTracked = dep => (dep.n & trackOpBit) > 0;\nconst initDepMarkers = ({\n  deps\n}) => {\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit;\n    }\n  }\n};\nconst finalizeDepMarkers = effect => {\n  const {\n    deps\n  } = effect;\n  if (deps.length) {\n    let ptr = 0;\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i];\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep.delete(effect);\n      } else {\n        deps[ptr++] = dep;\n      }\n      dep.w &= ~trackOpBit;\n      dep.n &= ~trackOpBit;\n    }\n    deps.length = ptr;\n  }\n};\nconst targetMap = /* @__PURE__ */new WeakMap();\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\nconst maxMarkerBits = 30;\nlet activeEffect;\nconst ITERATE_KEY = Symbol( false ? 0 : "");\nconst MAP_KEY_ITERATE_KEY = Symbol( false ? 0 : "");\nclass ReactiveEffect {\n  constructor(fn, scheduler = null, scope) {\n    this.fn = fn;\n    this.scheduler = scheduler;\n    this.active = true;\n    this.deps = [];\n    this.parent = void 0;\n    recordEffectScope(this, scope);\n  }\n  run() {\n    if (!this.active) {\n      return this.fn();\n    }\n    let parent = activeEffect;\n    let lastShouldTrack = shouldTrack;\n    while (parent) {\n      if (parent === this) {\n        return;\n      }\n      parent = parent.parent;\n    }\n    try {\n      this.parent = activeEffect;\n      activeEffect = this;\n      shouldTrack = true;\n      trackOpBit = 1 << ++effectTrackDepth;\n      if (effectTrackDepth <= maxMarkerBits) {\n        initDepMarkers(this);\n      } else {\n        cleanupEffect(this);\n      }\n      return this.fn();\n    } finally {\n      if (effectTrackDepth <= maxMarkerBits) {\n        finalizeDepMarkers(this);\n      }\n      trackOpBit = 1 << --effectTrackDepth;\n      activeEffect = this.parent;\n      shouldTrack = lastShouldTrack;\n      this.parent = void 0;\n      if (this.deferStop) {\n        this.stop();\n      }\n    }\n  }\n  stop() {\n    if (activeEffect === this) {\n      this.deferStop = true;\n    } else if (this.active) {\n      cleanupEffect(this);\n      if (this.onStop) {\n        this.onStop();\n      }\n      this.active = false;\n    }\n  }\n}\nfunction cleanupEffect(effect2) {\n  const {\n    deps\n  } = effect2;\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect2);\n    }\n    deps.length = 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect) {\n    fn = fn.effect.fn;\n  }\n  const _effect = new ReactiveEffect(fn);\n  if (options) {\n    extend(_effect, options);\n    if (options.scope) recordEffectScope(_effect, options.scope);\n  }\n  if (!options || !options.lazy) {\n    _effect.run();\n  }\n  const runner = _effect.run.bind(_effect);\n  runner.effect = _effect;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction reactivity_esm_bundler_track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = createDep());\n    }\n    const eventInfo =  false ? 0 : void 0;\n    trackEffects(dep, eventInfo);\n  }\n}\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n  let shouldTrack2 = false;\n  if (effectTrackDepth <= maxMarkerBits) {\n    if (!newTracked(dep)) {\n      dep.n |= trackOpBit;\n      shouldTrack2 = !wasTracked(dep);\n    }\n  } else {\n    shouldTrack2 = !dep.has(activeEffect);\n  }\n  if (shouldTrack2) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n    if (false) {}\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    return;\n  }\n  let deps = [];\n  if (type === "clear") {\n    deps = [...depsMap.values()];\n  } else if (key === "length" && shared_esm_bundler_isArray(target)) {\n    const newLength = Number(newValue);\n    depsMap.forEach((dep, key2) => {\n      if (key2 === "length" || key2 >= newLength) {\n        deps.push(dep);\n      }\n    });\n  } else {\n    if (key !== void 0) {\n      deps.push(depsMap.get(key));\n    }\n    switch (type) {\n      case "add":\n        if (!shared_esm_bundler_isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if (isIntegerKey(key)) {\n          deps.push(depsMap.get("length"));\n        }\n        break;\n      case "delete":\n        if (!shared_esm_bundler_isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n        break;\n      case "set":\n        if (isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n        }\n        break;\n    }\n  }\n  const eventInfo =  false ? 0 : void 0;\n  if (deps.length === 1) {\n    if (deps[0]) {\n      if (false) {} else {\n        triggerEffects(deps[0]);\n      }\n    }\n  } else {\n    const effects = [];\n    for (const dep of deps) {\n      if (dep) {\n        effects.push(...dep);\n      }\n    }\n    if (false) {} else {\n      triggerEffects(createDep(effects));\n    }\n  }\n}\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n  const effects = shared_esm_bundler_isArray(dep) ? dep : [...dep];\n  for (const effect2 of effects) {\n    if (effect2.computed) {\n      triggerEffect(effect2, debuggerEventExtraInfo);\n    }\n  }\n  for (const effect2 of effects) {\n    if (!effect2.computed) {\n      triggerEffect(effect2, debuggerEventExtraInfo);\n    }\n  }\n}\nfunction triggerEffect(effect2, debuggerEventExtraInfo) {\n  if (effect2 !== activeEffect || effect2.allowRecurse) {\n    if (false) {}\n    if (effect2.scheduler) {\n      effect2.scheduler();\n    } else {\n      effect2.run();\n    }\n  }\n}\nfunction getDepFromReactive(object, key) {\n  var _a;\n  return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);\n}\nconst isNonTrackableKeys = /* @__PURE__ */shared_esm_bundler_makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set( /* @__PURE__ */Object.getOwnPropertyNames(Symbol).filter(key => key !== "arguments" && key !== "caller").map(key => Symbol[key]).filter(isSymbol));\nconst get$1 = /* @__PURE__ */createGetter();\nconst shallowGet = /* @__PURE__ */createGetter(false, true);\nconst readonlyGet = /* @__PURE__ */createGetter(true);\nconst shallowReadonlyGet = /* @__PURE__ */createGetter(true, true);\nconst arrayInstrumentations = /* @__PURE__ */createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  ["includes", "indexOf", "lastIndexOf"].forEach(key => {\n    instrumentations[key] = function (...args) {\n      const arr = reactivity_esm_bundler_toRaw(this);\n      for (let i = 0, l = this.length; i < l; i++) {\n        reactivity_esm_bundler_track(arr, "get", i + "");\n      }\n      const res = arr[key](...args);\n      if (res === -1 || res === false) {\n        return arr[key](...args.map(reactivity_esm_bundler_toRaw));\n      } else {\n        return res;\n      }\n    };\n  });\n  ["push", "pop", "shift", "unshift", "splice"].forEach(key => {\n    instrumentations[key] = function (...args) {\n      pauseTracking();\n      const res = reactivity_esm_bundler_toRaw(this)[key].apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\nfunction reactivity_esm_bundler_hasOwnProperty(key) {\n  const obj = reactivity_esm_bundler_toRaw(this);\n  reactivity_esm_bundler_track(obj, "has", key);\n  return obj.hasOwnProperty(key);\n}\nfunction createGetter(isReadonly2 = false, shallow = false) {\n  return function get2(target, key, receiver) {\n    if (key === "__v_isReactive") {\n      return !isReadonly2;\n    } else if (key === "__v_isReadonly") {\n      return isReadonly2;\n    } else if (key === "__v_isShallow") {\n      return shallow;\n    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n      return target;\n    }\n    const targetIsArray = shared_esm_bundler_isArray(target);\n    if (!isReadonly2) {\n      if (targetIsArray && shared_esm_bundler_hasOwn(arrayInstrumentations, key)) {\n        return Reflect.get(arrayInstrumentations, key, receiver);\n      }\n      if (key === "hasOwnProperty") {\n        return reactivity_esm_bundler_hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(target, key, receiver);\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      reactivity_esm_bundler_track(target, "get", key);\n    }\n    if (shallow) {\n      return res;\n    }\n    if (reactivity_esm_bundler_isRef(res)) {\n      return targetIsArray && isIntegerKey(key) ? res : res.value;\n    }\n    if (shared_esm_bundler_isObject(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  };\n}\nconst set$1 = /* @__PURE__ */createSetter();\nconst shallowSet = /* @__PURE__ */createSetter(true);\nfunction createSetter(shallow = false) {\n  return function set2(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (reactivity_esm_bundler_isReadonly(oldValue) && reactivity_esm_bundler_isRef(oldValue) && !reactivity_esm_bundler_isRef(value)) {\n      return false;\n    }\n    if (!shallow) {\n      if (!isShallow(value) && !reactivity_esm_bundler_isReadonly(value)) {\n        oldValue = reactivity_esm_bundler_toRaw(oldValue);\n        value = reactivity_esm_bundler_toRaw(value);\n      }\n      if (!shared_esm_bundler_isArray(target) && reactivity_esm_bundler_isRef(oldValue) && !reactivity_esm_bundler_isRef(value)) {\n        oldValue.value = value;\n        return true;\n      }\n    }\n    const hadKey = shared_esm_bundler_isArray(target) && isIntegerKey(key) ? Number(key) < target.length : shared_esm_bundler_hasOwn(target, key);\n    const result = Reflect.set(target, key, value, receiver);\n    if (target === reactivity_esm_bundler_toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, "add", key, value);\n      } else if (shared_esm_bundler_hasChanged(value, oldValue)) {\n        trigger(target, "set", key, value, oldValue);\n      }\n    }\n    return result;\n  };\n}\nfunction deleteProperty(target, key) {\n  const hadKey = shared_esm_bundler_hasOwn(target, key);\n  const oldValue = target[key];\n  const result = Reflect.deleteProperty(target, key);\n  if (result && hadKey) {\n    trigger(target, "delete", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction has$1(target, key) {\n  const result = Reflect.has(target, key);\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\n    reactivity_esm_bundler_track(target, "has", key);\n  }\n  return result;\n}\nfunction ownKeys(target) {\n  reactivity_esm_bundler_track(target, "iterate", shared_esm_bundler_isArray(target) ? "length" : ITERATE_KEY);\n  return Reflect.ownKeys(target);\n}\nconst mutableHandlers = {\n  get: get$1,\n  set: set$1,\n  deleteProperty,\n  has: has$1,\n  ownKeys\n};\nconst readonlyHandlers = {\n  get: readonlyGet,\n  set(target, key) {\n    if (false) {}\n    return true;\n  },\n  deleteProperty(target, key) {\n    if (false) {}\n    return true;\n  }\n};\nconst shallowReactiveHandlers = /* @__PURE__ */shared_esm_bundler_extend({}, mutableHandlers, {\n  get: shallowGet,\n  set: shallowSet\n});\nconst shallowReadonlyHandlers = /* @__PURE__ */shared_esm_bundler_extend({}, readonlyHandlers, {\n  get: shallowReadonlyGet\n});\nconst toShallow = value => value;\nconst getProto = v => Reflect.getPrototypeOf(v);\nfunction get(target, key, isReadonly = false, isShallow = false) {\n  target = target["__v_raw"];\n  const rawTarget = reactivity_esm_bundler_toRaw(target);\n  const rawKey = reactivity_esm_bundler_toRaw(key);\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      reactivity_esm_bundler_track(rawTarget, "get", key);\n    }\n    reactivity_esm_bundler_track(rawTarget, "get", rawKey);\n  }\n  const {\n    has: has2\n  } = getProto(rawTarget);\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n  if (has2.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has2.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    target.get(key);\n  }\n}\nfunction has(key, isReadonly = false) {\n  const target = this["__v_raw"];\n  const rawTarget = reactivity_esm_bundler_toRaw(target);\n  const rawKey = reactivity_esm_bundler_toRaw(key);\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      reactivity_esm_bundler_track(rawTarget, "has", key);\n    }\n    reactivity_esm_bundler_track(rawTarget, "has", rawKey);\n  }\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n  target = target["__v_raw"];\n  !isReadonly && reactivity_esm_bundler_track(reactivity_esm_bundler_toRaw(target), "iterate", ITERATE_KEY);\n  return Reflect.get(target, "size", target);\n}\nfunction add(value) {\n  value = reactivity_esm_bundler_toRaw(value);\n  const target = reactivity_esm_bundler_toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, "add", value, value);\n  }\n  return this;\n}\nfunction set(key, value) {\n  value = reactivity_esm_bundler_toRaw(value);\n  const target = reactivity_esm_bundler_toRaw(this);\n  const {\n    has: has2,\n    get: get2\n  } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = reactivity_esm_bundler_toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (false) {}\n  const oldValue = get2.call(target, key);\n  target.set(key, value);\n  if (!hadKey) {\n    trigger(target, "add", key, value);\n  } else if (shared_esm_bundler_hasChanged(value, oldValue)) {\n    trigger(target, "set", key, value, oldValue);\n  }\n  return this;\n}\nfunction deleteEntry(key) {\n  const target = reactivity_esm_bundler_toRaw(this);\n  const {\n    has: has2,\n    get: get2\n  } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = reactivity_esm_bundler_toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (false) {}\n  const oldValue = get2 ? get2.call(target, key) : void 0;\n  const result = target.delete(key);\n  if (hadKey) {\n    trigger(target, "delete", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction clear() {\n  const target = reactivity_esm_bundler_toRaw(this);\n  const hadItems = target.size !== 0;\n  const oldTarget =  false ? 0 : void 0;\n  const result = target.clear();\n  if (hadItems) {\n    trigger(target, "clear", void 0, void 0, oldTarget);\n  }\n  return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed["__v_raw"];\n    const rawTarget = reactivity_esm_bundler_toRaw(target);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && reactivity_esm_bundler_track(rawTarget, "iterate", ITERATE_KEY);\n    return target.forEach((value, key) => {\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function (...args) {\n    const target = this["__v_raw"];\n    const rawTarget = reactivity_esm_bundler_toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === "keys" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && reactivity_esm_bundler_track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n    return {\n      // iterator protocol\n      next() {\n        const {\n          value,\n          done\n        } = innerIterator.next();\n        return done ? {\n          value,\n          done\n        } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function (...args) {\n    if (false) {}\n    return type === "delete" ? false : this;\n  };\n}\nfunction createInstrumentations() {\n  const mutableInstrumentations2 = {\n    get(key) {\n      return get(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations2 = {\n    get(key) {\n      return get(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod("add"),\n    set: createReadonlyMethod("set"),\n    delete: createReadonlyMethod("delete"),\n    clear: createReadonlyMethod("clear"),\n    forEach: createForEach(true, false)\n  };\n  const shallowReadonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod("add"),\n    set: createReadonlyMethod("set"),\n    delete: createReadonlyMethod("delete"),\n    clear: createReadonlyMethod("clear"),\n    forEach: createForEach(true, true)\n  };\n  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];\n  iteratorMethods.forEach(method => {\n    mutableInstrumentations2[method] = createIterableMethod(method, false, false);\n    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);\n    shallowInstrumentations2[method] = createIterableMethod(method, false, true);\n    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);\n  });\n  return [mutableInstrumentations2, readonlyInstrumentations2, shallowInstrumentations2, shallowReadonlyInstrumentations2];\n}\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === "__v_isReactive") {\n      return !isReadonly;\n    } else if (key === "__v_isReadonly") {\n      return isReadonly;\n    } else if (key === "__v_raw") {\n      return target;\n    }\n    return Reflect.get(shared_esm_bundler_hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has2, key) {\n  const rawKey = reactivity_esm_bundler_toRaw(key);\n  if (rawKey !== key && has2.call(target, rawKey)) {\n    const type = toRawType(target);\n    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);\n  }\n}\nconst reactiveMap = /* @__PURE__ */new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */new WeakMap();\nconst readonlyMap = /* @__PURE__ */new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case "Object":\n    case "Array":\n      return 1 /* COMMON */;\n    case "Map":\n    case "Set":\n    case "WeakMap":\n    case "WeakSet":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\n\nfunction getTargetType(value) {\n  return value["__v_skip"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(shared_esm_bundler_toRawType(value));\n}\nfunction reactive(target) {\n  if (reactivity_esm_bundler_isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\nfunction readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!shared_esm_bundler_isObject(target)) {\n    if (false) {}\n    return target;\n  }\n  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction reactivity_esm_bundler_isReactive(value) {\n  if (reactivity_esm_bundler_isReadonly(value)) {\n    return reactivity_esm_bundler_isReactive(value["__v_raw"]);\n  }\n  return !!(value && value["__v_isReactive"]);\n}\nfunction reactivity_esm_bundler_isReadonly(value) {\n  return !!(value && value["__v_isReadonly"]);\n}\nfunction isShallow(value) {\n  return !!(value && value["__v_isShallow"]);\n}\nfunction isProxy(value) {\n  return reactivity_esm_bundler_isReactive(value) || reactivity_esm_bundler_isReadonly(value);\n}\nfunction reactivity_esm_bundler_toRaw(observed) {\n  const raw = observed && observed["__v_raw"];\n  return raw ? reactivity_esm_bundler_toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  def(value, "__v_skip", true);\n  return value;\n}\nconst toReactive = value => shared_esm_bundler_isObject(value) ? reactive(value) : value;\nconst toReadonly = value => shared_esm_bundler_isObject(value) ? readonly(value) : value;\nfunction trackRefValue(ref2) {\n  if (shouldTrack && activeEffect) {\n    ref2 = reactivity_esm_bundler_toRaw(ref2);\n    if (false) {} else {\n      trackEffects(ref2.dep || (ref2.dep = createDep()));\n    }\n  }\n}\nfunction triggerRefValue(ref2, newVal) {\n  ref2 = reactivity_esm_bundler_toRaw(ref2);\n  const dep = ref2.dep;\n  if (dep) {\n    if (false) {} else {\n      triggerEffects(dep);\n    }\n  }\n}\nfunction reactivity_esm_bundler_isRef(r) {\n  return !!(r && r.__v_isRef === true);\n}\nfunction reactivity_esm_bundler_ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (reactivity_esm_bundler_isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, __v_isShallow) {\n    this.__v_isShallow = __v_isShallow;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this._rawValue = __v_isShallow ? value : reactivity_esm_bundler_toRaw(value);\n    this._value = __v_isShallow ? value : toReactive(value);\n  }\n  get value() {\n    trackRefValue(this);\n    return this._value;\n  }\n  set value(newVal) {\n    const useDirectValue = this.__v_isShallow || isShallow(newVal) || reactivity_esm_bundler_isReadonly(newVal);\n    newVal = useDirectValue ? newVal : reactivity_esm_bundler_toRaw(newVal);\n    if (shared_esm_bundler_hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal;\n      this._value = useDirectValue ? newVal : toReactive(newVal);\n      triggerRefValue(this, newVal);\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  triggerRefValue(ref2,  false ? 0 : void 0);\n}\nfunction unref(ref2) {\n  return reactivity_esm_bundler_isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return isFunction(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (reactivity_esm_bundler_isRef(oldValue) && !reactivity_esm_bundler_isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return reactivity_esm_bundler_isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this.dep = void 0;\n    this.__v_isRef = true;\n    const {\n      get,\n      set\n    } = factory(() => trackRefValue(this), () => triggerRefValue(this));\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (false) {}\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this.__v_isRef = true;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(reactivity_esm_bundler_toRaw(this._object), this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this.__v_isRef = true;\n    this.__v_isReadonly = true;\n  }\n  get value() {\n    return this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (reactivity_esm_bundler_isRef(source)) {\n    return source;\n  } else if (isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return reactivity_esm_bundler_ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return reactivity_esm_bundler_isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);\n}\nclass ComputedRefImpl {\n  constructor(getter, _setter, isReadonly, isSSR) {\n    this._setter = _setter;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this["__v_isReadonly"] = false;\n    this._dirty = true;\n    this.effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true;\n        triggerRefValue(this);\n      }\n    });\n    this.effect.computed = this;\n    this.effect.active = this._cacheable = !isSSR;\n    this["__v_isReadonly"] = isReadonly;\n  }\n  get value() {\n    const self = reactivity_esm_bundler_toRaw(this);\n    trackRefValue(self);\n    if (self._dirty || !self._cacheable) {\n      self._dirty = false;\n      self._value = self.effect.run();\n    }\n    return self._value;\n  }\n  set value(newValue) {\n    this._setter(newValue);\n  }\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  const onlyGetter = shared_esm_bundler_isFunction(getterOrOptions);\n  if (onlyGetter) {\n    getter = getterOrOptions;\n    setter =  false ? 0 : shared_esm_bundler_NOOP;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n  if (false) {}\n  return cRef;\n}\nconst tick = /* @__PURE__ */(/* unused pure expression or super */ null && (Promise.resolve()));\nconst queue = (/* unused pure expression or super */ null && ([]));\nlet queued = false;\nconst scheduler = fn => {\n  queue.push(fn);\n  if (!queued) {\n    queued = true;\n    tick.then(flush);\n  }\n};\nconst flush = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n  queue.length = 0;\n  queued = false;\n};\nclass DeferredComputedRefImpl {\n  constructor(getter) {\n    this.dep = void 0;\n    this._dirty = true;\n    this.__v_isRef = true;\n    this["__v_isReadonly"] = true;\n    let compareTarget;\n    let hasCompareTarget = false;\n    let scheduled = false;\n    this.effect = new ReactiveEffect(getter, computedTrigger => {\n      if (this.dep) {\n        if (computedTrigger) {\n          compareTarget = this._value;\n          hasCompareTarget = true;\n        } else if (!scheduled) {\n          const valueToCompare = hasCompareTarget ? compareTarget : this._value;\n          scheduled = true;\n          hasCompareTarget = false;\n          scheduler(() => {\n            if (this.effect.active && this._get() !== valueToCompare) {\n              triggerRefValue(this);\n            }\n            scheduled = false;\n          });\n        }\n        for (const e of this.dep) {\n          if (e.computed instanceof DeferredComputedRefImpl) {\n            e.scheduler(true\n            /* computedTrigger */);\n          }\n        }\n      }\n\n      this._dirty = true;\n    });\n    this.effect.computed = this;\n  }\n  _get() {\n    if (this._dirty) {\n      this._dirty = false;\n      return this._value = this.effect.run();\n    }\n    return this._value;\n  }\n  get value() {\n    trackRefValue(this);\n    return reactivity_esm_bundler_toRaw(this)._get();\n  }\n}\nfunction deferredComputed(getter) {\n  return new DeferredComputedRefImpl(getter);\n}\n\n;// CONCATENATED MODULE: ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js\n\n\n\n\nconst stack = [];\nfunction pushWarningContext(vnode) {\n  stack.push(vnode);\n}\nfunction popWarningContext() {\n  stack.pop();\n}\nfunction runtime_core_esm_bundler_warn(msg, ...args) {\n  if (true) return;\n  pauseTracking();\n  const instance = stack.length ? stack[stack.length - 1].component : null;\n  const appWarnHandler = instance && instance.appContext.config.warnHandler;\n  const trace = getComponentTrace();\n  if (appWarnHandler) {\n    callWithErrorHandling(appWarnHandler, instance, 11, [msg + args.join(""), instance && instance.proxy, trace.map(({\n      vnode\n    }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\\n"), trace]);\n  } else {\n    const warnArgs = [`[Vue warn]: ${msg}`, ...args];\n    if (trace.length &&\n    // avoid spamming console during tests\n    true) {\n      warnArgs.push(`\n`, ...formatTrace(trace));\n    }\n    console.warn(...warnArgs);\n  }\n  resetTracking();\n}\nfunction getComponentTrace() {\n  let currentVNode = stack[stack.length - 1];\n  if (!currentVNode) {\n    return [];\n  }\n  const normalizedStack = [];\n  while (currentVNode) {\n    const last = normalizedStack[0];\n    if (last && last.vnode === currentVNode) {\n      last.recurseCount++;\n    } else {\n      normalizedStack.push({\n        vnode: currentVNode,\n        recurseCount: 0\n      });\n    }\n    const parentInstance = currentVNode.component && currentVNode.component.parent;\n    currentVNode = parentInstance && parentInstance.vnode;\n  }\n  return normalizedStack;\n}\nfunction formatTrace(trace) {\n  const logs = [];\n  trace.forEach((entry, i) => {\n    logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry));\n  });\n  return logs;\n}\nfunction formatTraceEntry({\n  vnode,\n  recurseCount\n}) {\n  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\n  const isRoot = vnode.component ? vnode.component.parent == null : false;\n  const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\n  const close = `>` + postfix;\n  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];\n}\nfunction formatProps(props) {\n  const res = [];\n  const keys = Object.keys(props);\n  keys.slice(0, 3).forEach(key => {\n    res.push(...formatProp(key, props[key]));\n  });\n  if (keys.length > 3) {\n    res.push(` ...`);\n  }\n  return res;\n}\nfunction formatProp(key, value, raw) {\n  if (shared_esm_bundler_isString(value)) {\n    value = JSON.stringify(value);\n    return raw ? value : [`${key}=${value}`];\n  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {\n    return raw ? value : [`${key}=${value}`];\n  } else if (reactivity_esm_bundler_isRef(value)) {\n    value = formatProp(key, reactivity_esm_bundler_toRaw(value.value), true);\n    return raw ? value : [`${key}=Ref<`, value, `>`];\n  } else if (shared_esm_bundler_isFunction(value)) {\n    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\n  } else {\n    value = reactivity_esm_bundler_toRaw(value);\n    return raw ? value : [`${key}=`, value];\n  }\n}\nfunction assertNumber(val, type) {\n  if (true) return;\n  if (val === void 0) {\n    return;\n  } else if (typeof val !== "number") {\n    runtime_core_esm_bundler_warn(`${type} is not a valid number - got ${JSON.stringify(val)}.`);\n  } else if (isNaN(val)) {\n    runtime_core_esm_bundler_warn(`${type} is NaN - the duration expression might be incorrect.`);\n  }\n}\nconst ErrorTypeStrings = {\n  ["sp"]: "serverPrefetch hook",\n  ["bc"]: "beforeCreate hook",\n  ["c"]: "created hook",\n  ["bm"]: "beforeMount hook",\n  ["m"]: "mounted hook",\n  ["bu"]: "beforeUpdate hook",\n  ["u"]: "updated",\n  ["bum"]: "beforeUnmount hook",\n  ["um"]: "unmounted hook",\n  ["a"]: "activated hook",\n  ["da"]: "deactivated hook",\n  ["ec"]: "errorCaptured hook",\n  ["rtc"]: "renderTracked hook",\n  ["rtg"]: "renderTriggered hook",\n  [0]: "setup function",\n  [1]: "render function",\n  [2]: "watcher getter",\n  [3]: "watcher callback",\n  [4]: "watcher cleanup function",\n  [5]: "native event handler",\n  [6]: "component event handler",\n  [7]: "vnode hook",\n  [8]: "directive hook",\n  [9]: "transition hook",\n  [10]: "app errorHandler",\n  [11]: "app warnHandler",\n  [12]: "ref function",\n  [13]: "async component loader",\n  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"\n};\nfunction callWithErrorHandling(fn, instance, type, args) {\n  let res;\n  try {\n    res = args ? fn(...args) : fn();\n  } catch (err) {\n    handleError(err, instance, type);\n  }\n  return res;\n}\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\n  if (shared_esm_bundler_isFunction(fn)) {\n    const res = callWithErrorHandling(fn, instance, type, args);\n    if (res && shared_esm_bundler_isPromise(res)) {\n      res.catch(err => {\n        handleError(err, instance, type);\n      });\n    }\n    return res;\n  }\n  const values = [];\n  for (let i = 0; i < fn.length; i++) {\n    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\n  }\n  return values;\n}\nfunction handleError(err, instance, type, throwInDev = true) {\n  const contextVNode = instance ? instance.vnode : null;\n  if (instance) {\n    let cur = instance.parent;\n    const exposedInstance = instance.proxy;\n    const errorInfo =  false ? 0 : type;\n    while (cur) {\n      const errorCapturedHooks = cur.ec;\n      if (errorCapturedHooks) {\n        for (let i = 0; i < errorCapturedHooks.length; i++) {\n          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\n            return;\n          }\n        }\n      }\n      cur = cur.parent;\n    }\n    const appErrorHandler = instance.appContext.config.errorHandler;\n    if (appErrorHandler) {\n      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);\n      return;\n    }\n  }\n  logError(err, type, contextVNode, throwInDev);\n}\nfunction logError(err, type, contextVNode, throwInDev = true) {\n  if (false) {} else {\n    console.error(err);\n  }\n}\nlet isFlushing = false;\nlet isFlushPending = false;\nconst runtime_core_esm_bundler_queue = [];\nlet flushIndex = 0;\nconst pendingPostFlushCbs = [];\nlet activePostFlushCbs = null;\nlet postFlushIndex = 0;\nconst resolvedPromise = /* @__PURE__ */Promise.resolve();\nlet currentFlushPromise = null;\nconst RECURSION_LIMIT = 100;\nfunction runtime_core_esm_bundler_nextTick(fn) {\n  const p = currentFlushPromise || resolvedPromise;\n  return fn ? p.then(this ? fn.bind(this) : fn) : p;\n}\nfunction findInsertionIndex(id) {\n  let start = flushIndex + 1;\n  let end = runtime_core_esm_bundler_queue.length;\n  while (start < end) {\n    const middle = start + end >>> 1;\n    const middleJobId = getId(runtime_core_esm_bundler_queue[middle]);\n    middleJobId < id ? start = middle + 1 : end = middle;\n  }\n  return start;\n}\nfunction queueJob(job) {\n  if (!runtime_core_esm_bundler_queue.length || !runtime_core_esm_bundler_queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {\n    if (job.id == null) {\n      runtime_core_esm_bundler_queue.push(job);\n    } else {\n      runtime_core_esm_bundler_queue.splice(findInsertionIndex(job.id), 0, job);\n    }\n    queueFlush();\n  }\n}\nfunction queueFlush() {\n  if (!isFlushing && !isFlushPending) {\n    isFlushPending = true;\n    currentFlushPromise = resolvedPromise.then(flushJobs);\n  }\n}\nfunction invalidateJob(job) {\n  const i = runtime_core_esm_bundler_queue.indexOf(job);\n  if (i > flushIndex) {\n    runtime_core_esm_bundler_queue.splice(i, 1);\n  }\n}\nfunction queuePostFlushCb(cb) {\n  if (!shared_esm_bundler_isArray(cb)) {\n    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {\n      pendingPostFlushCbs.push(cb);\n    }\n  } else {\n    pendingPostFlushCbs.push(...cb);\n  }\n  queueFlush();\n}\nfunction flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {\n  if (false) {}\n  for (; i < runtime_core_esm_bundler_queue.length; i++) {\n    const cb = runtime_core_esm_bundler_queue[i];\n    if (cb && cb.pre) {\n      if (false) {}\n      runtime_core_esm_bundler_queue.splice(i, 1);\n      i--;\n      cb();\n    }\n  }\n}\nfunction flushPostFlushCbs(seen) {\n  if (pendingPostFlushCbs.length) {\n    const deduped = [...new Set(pendingPostFlushCbs)];\n    pendingPostFlushCbs.length = 0;\n    if (activePostFlushCbs) {\n      activePostFlushCbs.push(...deduped);\n      return;\n    }\n    activePostFlushCbs = deduped;\n    if (false) {}\n    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\n    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\n      if (false) {}\n      activePostFlushCbs[postFlushIndex]();\n    }\n    activePostFlushCbs = null;\n    postFlushIndex = 0;\n  }\n}\nconst getId = job => job.id == null ? Infinity : job.id;\nconst comparator = (a, b) => {\n  const diff = getId(a) - getId(b);\n  if (diff === 0) {\n    if (a.pre && !b.pre) return -1;\n    if (b.pre && !a.pre) return 1;\n  }\n  return diff;\n};\nfunction flushJobs(seen) {\n  isFlushPending = false;\n  isFlushing = true;\n  if (false) {}\n  runtime_core_esm_bundler_queue.sort(comparator);\n  const check =  false ? 0 : shared_esm_bundler_NOOP;\n  try {\n    for (flushIndex = 0; flushIndex < runtime_core_esm_bundler_queue.length; flushIndex++) {\n      const job = runtime_core_esm_bundler_queue[flushIndex];\n      if (job && job.active !== false) {\n        if (false) {}\n        callWithErrorHandling(job, null, 14);\n      }\n    }\n  } finally {\n    flushIndex = 0;\n    runtime_core_esm_bundler_queue.length = 0;\n    flushPostFlushCbs(seen);\n    isFlushing = false;\n    currentFlushPromise = null;\n    if (runtime_core_esm_bundler_queue.length || pendingPostFlushCbs.length) {\n      flushJobs(seen);\n    }\n  }\n}\nfunction checkRecursiveUpdates(seen, fn) {\n  if (!seen.has(fn)) {\n    seen.set(fn, 1);\n  } else {\n    const count = seen.get(fn);\n    if (count > RECURSION_LIMIT) {\n      const instance = fn.ownerInstance;\n      const componentName = instance && getComponentName(instance.type);\n      runtime_core_esm_bundler_warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);\n      return true;\n    } else {\n      seen.set(fn, count + 1);\n    }\n  }\n}\nlet isHmrUpdating = false;\nconst hmrDirtyComponents = /* @__PURE__ */new Set();\nif (false) {}\nconst map = /* @__PURE__ */new Map();\nfunction registerHMR(instance) {\n  const id = instance.type.__hmrId;\n  let record = map.get(id);\n  if (!record) {\n    createRecord(id, instance.type);\n    record = map.get(id);\n  }\n  record.instances.add(instance);\n}\nfunction unregisterHMR(instance) {\n  map.get(instance.type.__hmrId).instances.delete(instance);\n}\nfunction createRecord(id, initialDef) {\n  if (map.has(id)) {\n    return false;\n  }\n  map.set(id, {\n    initialDef: normalizeClassComponent(initialDef),\n    instances: /* @__PURE__ */new Set()\n  });\n  return true;\n}\nfunction normalizeClassComponent(component) {\n  return isClassComponent(component) ? component.__vccOpts : component;\n}\nfunction rerender(id, newRender) {\n  const record = map.get(id);\n  if (!record) {\n    return;\n  }\n  record.initialDef.render = newRender;\n  [...record.instances].forEach(instance => {\n    if (newRender) {\n      instance.render = newRender;\n      normalizeClassComponent(instance.type).render = newRender;\n    }\n    instance.renderCache = [];\n    isHmrUpdating = true;\n    instance.update();\n    isHmrUpdating = false;\n  });\n}\nfunction reload(id, newComp) {\n  const record = map.get(id);\n  if (!record) return;\n  newComp = normalizeClassComponent(newComp);\n  updateComponentDef(record.initialDef, newComp);\n  const instances = [...record.instances];\n  for (const instance of instances) {\n    const oldComp = normalizeClassComponent(instance.type);\n    if (!hmrDirtyComponents.has(oldComp)) {\n      if (oldComp !== record.initialDef) {\n        updateComponentDef(oldComp, newComp);\n      }\n      hmrDirtyComponents.add(oldComp);\n    }\n    instance.appContext.propsCache.delete(instance.type);\n    instance.appContext.emitsCache.delete(instance.type);\n    instance.appContext.optionsCache.delete(instance.type);\n    if (instance.ceReload) {\n      hmrDirtyComponents.add(oldComp);\n      instance.ceReload(newComp.styles);\n      hmrDirtyComponents.delete(oldComp);\n    } else if (instance.parent) {\n      queueJob(instance.parent.update);\n    } else if (instance.appContext.reload) {\n      instance.appContext.reload();\n    } else if (typeof window !== "undefined") {\n      window.location.reload();\n    } else {\n      console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");\n    }\n  }\n  queuePostFlushCb(() => {\n    for (const instance of instances) {\n      hmrDirtyComponents.delete(normalizeClassComponent(instance.type));\n    }\n  });\n}\nfunction updateComponentDef(oldComp, newComp) {\n  extend(oldComp, newComp);\n  for (const key in oldComp) {\n    if (key !== "__file" && !(key in newComp)) {\n      delete oldComp[key];\n    }\n  }\n}\nfunction tryWrap(fn) {\n  return (id, arg) => {\n    try {\n      return fn(id, arg);\n    } catch (e) {\n      console.error(e);\n      console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);\n    }\n  };\n}\nlet devtools;\nlet buffer = [];\nlet devtoolsNotInstalled = false;\nfunction emit$1(event, ...args) {\n  if (devtools) {\n    devtools.emit(event, ...args);\n  } else if (!devtoolsNotInstalled) {\n    buffer.push({\n      event,\n      args\n    });\n  }\n}\nfunction setDevtoolsHook(hook, target) {\n  var _a, _b;\n  devtools = hook;\n  if (devtools) {\n    devtools.enabled = true;\n    buffer.forEach(({\n      event,\n      args\n    }) => devtools.emit(event, ...args));\n    buffer = [];\n  } else if (\n  // handle late devtools injection - only do this if we are in an actual\n  // browser environment to avoid the timer handle stalling test runner exit\n  // (#4815)\n  typeof window !== "undefined" &&\n  // some envs mock window but not fully\n  window.HTMLElement &&\n  // also exclude jsdom\n  !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))) {\n    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];\n    replay.push(newHook => {\n      setDevtoolsHook(newHook, target);\n    });\n    setTimeout(() => {\n      if (!devtools) {\n        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;\n        devtoolsNotInstalled = true;\n        buffer = [];\n      }\n    }, 3e3);\n  } else {\n    devtoolsNotInstalled = true;\n    buffer = [];\n  }\n}\nfunction devtoolsInitApp(app, version) {\n  emit$1("app:init" /* APP_INIT */, app, version, {\n    Fragment: runtime_core_esm_bundler_Fragment,\n    Text,\n    Comment,\n    Static: runtime_core_esm_bundler_Static\n  });\n}\nfunction devtoolsUnmountApp(app) {\n  emit$1("app:unmount" /* APP_UNMOUNT */, app);\n}\nconst devtoolsComponentAdded = /* @__PURE__ */createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */);\n\nconst devtoolsComponentUpdated = /* @__PURE__ */createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */);\nconst _devtoolsComponentRemoved = /* @__PURE__ */createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */);\n\nconst devtoolsComponentRemoved = component => {\n  if (devtools && typeof devtools.cleanupBuffer === "function" &&\n  // remove the component if it wasn\'t buffered\n  !devtools.cleanupBuffer(component)) {\n    _devtoolsComponentRemoved(component);\n  }\n};\nfunction createDevtoolsComponentHook(hook) {\n  return component => {\n    emit$1(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);\n  };\n}\nconst devtoolsPerfStart = /* @__PURE__ */(/* unused pure expression or super */ null && (createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */)));\n\nconst devtoolsPerfEnd = /* @__PURE__ */(/* unused pure expression or super */ null && (createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */)));\n\nfunction createDevtoolsPerformanceHook(hook) {\n  return (component, type, time) => {\n    emit$1(hook, component.appContext.app, component.uid, component, type, time);\n  };\n}\nfunction devtoolsComponentEmit(component, event, params) {\n  emit$1("component:emit" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);\n}\nfunction emit(instance, event, ...rawArgs) {\n  if (instance.isUnmounted) return;\n  const props = instance.vnode.props || shared_esm_bundler_EMPTY_OBJ;\n  if (false) {}\n  let args = rawArgs;\n  const isModelListener = event.startsWith("update:");\n  const modelArg = isModelListener && event.slice(7);\n  if (modelArg && modelArg in props) {\n    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;\n    const {\n      number,\n      trim\n    } = props[modifiersKey] || shared_esm_bundler_EMPTY_OBJ;\n    if (trim) {\n      args = rawArgs.map(a => shared_esm_bundler_isString(a) ? a.trim() : a);\n    }\n    if (number) {\n      args = rawArgs.map(looseToNumber);\n    }\n  }\n  if ( false || __VUE_PROD_DEVTOOLS__) {\n    devtoolsComponentEmit(instance, event, args);\n  }\n  if (false) {}\n  let handlerName;\n  let handler = props[handlerName = shared_esm_bundler_toHandlerKey(event)] ||\n  // also try camelCase event handler (#2249)\n  props[handlerName = shared_esm_bundler_toHandlerKey(camelize(event))];\n  if (!handler && isModelListener) {\n    handler = props[handlerName = shared_esm_bundler_toHandlerKey(shared_esm_bundler_hyphenate(event))];\n  }\n  if (handler) {\n    callWithAsyncErrorHandling(handler, instance, 6, args);\n  }\n  const onceHandler = props[handlerName + `Once`];\n  if (onceHandler) {\n    if (!instance.emitted) {\n      instance.emitted = {};\n    } else if (instance.emitted[handlerName]) {\n      return;\n    }\n    instance.emitted[handlerName] = true;\n    callWithAsyncErrorHandling(onceHandler, instance, 6, args);\n  }\n}\nfunction normalizeEmitsOptions(comp, appContext, asMixin = false) {\n  const cache = appContext.emitsCache;\n  const cached = cache.get(comp);\n  if (cached !== void 0) {\n    return cached;\n  }\n  const raw = comp.emits;\n  let normalized = {};\n  let hasExtends = false;\n  if (__VUE_OPTIONS_API__ && !shared_esm_bundler_isFunction(comp)) {\n    const extendEmits = raw2 => {\n      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);\n      if (normalizedFromExtend) {\n        hasExtends = true;\n        shared_esm_bundler_extend(normalized, normalizedFromExtend);\n      }\n    };\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendEmits);\n    }\n    if (comp.extends) {\n      extendEmits(comp.extends);\n    }\n    if (comp.mixins) {\n      comp.mixins.forEach(extendEmits);\n    }\n  }\n  if (!raw && !hasExtends) {\n    if (shared_esm_bundler_isObject(comp)) {\n      cache.set(comp, null);\n    }\n    return null;\n  }\n  if (shared_esm_bundler_isArray(raw)) {\n    raw.forEach(key => normalized[key] = null);\n  } else {\n    shared_esm_bundler_extend(normalized, raw);\n  }\n  if (shared_esm_bundler_isObject(comp)) {\n    cache.set(comp, normalized);\n  }\n  return normalized;\n}\nfunction isEmitListener(options, key) {\n  if (!options || !shared_esm_bundler_isOn(key)) {\n    return false;\n  }\n  key = key.slice(2).replace(/Once$/, "");\n  return shared_esm_bundler_hasOwn(options, key[0].toLowerCase() + key.slice(1)) || shared_esm_bundler_hasOwn(options, shared_esm_bundler_hyphenate(key)) || shared_esm_bundler_hasOwn(options, key);\n}\nlet currentRenderingInstance = null;\nlet currentScopeId = null;\nfunction setCurrentRenderingInstance(instance) {\n  const prev = currentRenderingInstance;\n  currentRenderingInstance = instance;\n  currentScopeId = instance && instance.type.__scopeId || null;\n  return prev;\n}\nfunction pushScopeId(id) {\n  currentScopeId = id;\n}\nfunction popScopeId() {\n  currentScopeId = null;\n}\nconst withScopeId = _id => withCtx;\nfunction withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {\n  if (!ctx) return fn;\n  if (fn._n) {\n    return fn;\n  }\n  const renderFnWithContext = (...args) => {\n    if (renderFnWithContext._d) {\n      setBlockTracking(-1);\n    }\n    const prevInstance = setCurrentRenderingInstance(ctx);\n    let res;\n    try {\n      res = fn(...args);\n    } finally {\n      setCurrentRenderingInstance(prevInstance);\n      if (renderFnWithContext._d) {\n        setBlockTracking(1);\n      }\n    }\n    if ( false || __VUE_PROD_DEVTOOLS__) {\n      devtoolsComponentUpdated(ctx);\n    }\n    return res;\n  };\n  renderFnWithContext._n = true;\n  renderFnWithContext._c = true;\n  renderFnWithContext._d = true;\n  return renderFnWithContext;\n}\nlet accessedAttrs = false;\nfunction markAttrsAccessed() {\n  accessedAttrs = true;\n}\nfunction renderComponentRoot(instance) {\n  const {\n    type: Component,\n    vnode,\n    proxy,\n    withProxy,\n    props,\n    propsOptions: [propsOptions],\n    slots,\n    attrs,\n    emit,\n    render,\n    renderCache,\n    data,\n    setupState,\n    ctx,\n    inheritAttrs\n  } = instance;\n  let result;\n  let fallthroughAttrs;\n  const prev = setCurrentRenderingInstance(instance);\n  if (false) {}\n  try {\n    if (vnode.shapeFlag & 4) {\n      const proxyToUse = withProxy || proxy;\n      result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));\n      fallthroughAttrs = attrs;\n    } else {\n      const render2 = Component;\n      if (false) {}\n      result = normalizeVNode(render2.length > 1 ? render2(props,  false ? 0 : {\n        attrs,\n        slots,\n        emit\n      }) : render2(props, null\n      /* we know it doesn\'t need it */));\n\n      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);\n    }\n  } catch (err) {\n    blockStack.length = 0;\n    handleError(err, instance, 1);\n    result = runtime_core_esm_bundler_createVNode(Comment);\n  }\n  let root = result;\n  let setRoot = void 0;\n  if (false) {}\n  if (fallthroughAttrs && inheritAttrs !== false) {\n    const keys = Object.keys(fallthroughAttrs);\n    const {\n      shapeFlag\n    } = root;\n    if (keys.length) {\n      if (shapeFlag & (1 | 6)) {\n        if (propsOptions && keys.some(isModelListener)) {\n          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);\n        }\n        root = cloneVNode(root, fallthroughAttrs);\n      } else if (false) {}\n    }\n  }\n  if (vnode.dirs) {\n    if (false) {}\n    root = cloneVNode(root);\n    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;\n  }\n  if (vnode.transition) {\n    if (false) {}\n    root.transition = vnode.transition;\n  }\n  if (false) {} else {\n    result = root;\n  }\n  setCurrentRenderingInstance(prev);\n  return result;\n}\nconst getChildRoot = vnode => {\n  const rawChildren = vnode.children;\n  const dynamicChildren = vnode.dynamicChildren;\n  const childRoot = filterSingleRoot(rawChildren);\n  if (!childRoot) {\n    return [vnode, void 0];\n  }\n  const index = rawChildren.indexOf(childRoot);\n  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;\n  const setRoot = updatedRoot => {\n    rawChildren[index] = updatedRoot;\n    if (dynamicChildren) {\n      if (dynamicIndex > -1) {\n        dynamicChildren[dynamicIndex] = updatedRoot;\n      } else if (updatedRoot.patchFlag > 0) {\n        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];\n      }\n    }\n  };\n  return [normalizeVNode(childRoot), setRoot];\n};\nfunction filterSingleRoot(children) {\n  let singleRoot;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (isVNode(child)) {\n      if (child.type !== Comment || child.children === "v-if") {\n        if (singleRoot) {\n          return;\n        } else {\n          singleRoot = child;\n        }\n      }\n    } else {\n      return;\n    }\n  }\n  return singleRoot;\n}\nconst getFunctionalFallthrough = attrs => {\n  let res;\n  for (const key in attrs) {\n    if (key === "class" || key === "style" || shared_esm_bundler_isOn(key)) {\n      (res || (res = {}))[key] = attrs[key];\n    }\n  }\n  return res;\n};\nconst filterModelListeners = (attrs, props) => {\n  const res = {};\n  for (const key in attrs) {\n    if (!isModelListener(key) || !(key.slice(9) in props)) {\n      res[key] = attrs[key];\n    }\n  }\n  return res;\n};\nconst isElementRoot = vnode => {\n  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;\n};\nfunction shouldUpdateComponent(prevVNode, nextVNode, optimized) {\n  const {\n    props: prevProps,\n    children: prevChildren,\n    component\n  } = prevVNode;\n  const {\n    props: nextProps,\n    children: nextChildren,\n    patchFlag\n  } = nextVNode;\n  const emits = component.emitsOptions;\n  if (false) {}\n  if (nextVNode.dirs || nextVNode.transition) {\n    return true;\n  }\n  if (optimized && patchFlag >= 0) {\n    if (patchFlag & 1024) {\n      return true;\n    }\n    if (patchFlag & 16) {\n      if (!prevProps) {\n        return !!nextProps;\n      }\n      return hasPropsChanged(prevProps, nextProps, emits);\n    } else if (patchFlag & 8) {\n      const dynamicProps = nextVNode.dynamicProps;\n      for (let i = 0; i < dynamicProps.length; i++) {\n        const key = dynamicProps[i];\n        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {\n          return true;\n        }\n      }\n    }\n  } else {\n    if (prevChildren || nextChildren) {\n      if (!nextChildren || !nextChildren.$stable) {\n        return true;\n      }\n    }\n    if (prevProps === nextProps) {\n      return false;\n    }\n    if (!prevProps) {\n      return !!nextProps;\n    }\n    if (!nextProps) {\n      return true;\n    }\n    return hasPropsChanged(prevProps, nextProps, emits);\n  }\n  return false;\n}\nfunction hasPropsChanged(prevProps, nextProps, emitsOptions) {\n  const nextKeys = Object.keys(nextProps);\n  if (nextKeys.length !== Object.keys(prevProps).length) {\n    return true;\n  }\n  for (let i = 0; i < nextKeys.length; i++) {\n    const key = nextKeys[i];\n    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction updateHOCHostEl({\n  vnode,\n  parent\n}, el) {\n  while (parent && parent.subTree === vnode) {\n    (vnode = parent.vnode).el = el;\n    parent = parent.parent;\n  }\n}\nconst isSuspense = type => type.__isSuspense;\nconst SuspenseImpl = {\n  name: "Suspense",\n  // In order to make Suspense tree-shakable, we need to avoid importing it\n  // directly in the renderer. The renderer checks for the __isSuspense flag\n  // on a vnode\'s type and calls the `process` method, passing in renderer\n  // internals.\n  __isSuspense: true,\n  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {\n    if (n1 == null) {\n      mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);\n    } else {\n      patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);\n    }\n  },\n  hydrate: hydrateSuspense,\n  create: createSuspenseBoundary,\n  normalize: normalizeSuspenseChildren\n};\nconst Suspense = (/* unused pure expression or super */ null && (SuspenseImpl));\nfunction triggerEvent(vnode, name) {\n  const eventListener = vnode.props && vnode.props[name];\n  if (shared_esm_bundler_isFunction(eventListener)) {\n    eventListener();\n  }\n}\nfunction mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {\n  const {\n    p: patch,\n    o: {\n      createElement\n    }\n  } = rendererInternals;\n  const hiddenContainer = createElement("div");\n  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);\n  patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);\n  if (suspense.deps > 0) {\n    triggerEvent(vnode, "onPending");\n    triggerEvent(vnode, "onFallback");\n    patch(null, vnode.ssFallback, container, anchor, parentComponent, null,\n    // fallback tree will not have suspense context\n    isSVG, slotScopeIds);\n    setActiveBranch(suspense, vnode.ssFallback);\n  } else {\n    suspense.resolve(false, true);\n  }\n}\nfunction patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, {\n  p: patch,\n  um: unmount,\n  o: {\n    createElement\n  }\n}) {\n  const suspense = n2.suspense = n1.suspense;\n  suspense.vnode = n2;\n  n2.el = n1.el;\n  const newBranch = n2.ssContent;\n  const newFallback = n2.ssFallback;\n  const {\n    activeBranch,\n    pendingBranch,\n    isInFallback,\n    isHydrating\n  } = suspense;\n  if (pendingBranch) {\n    suspense.pendingBranch = newBranch;\n    if (isSameVNodeType(newBranch, pendingBranch)) {\n      patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n      if (suspense.deps <= 0) {\n        suspense.resolve();\n      } else if (isInFallback) {\n        patch(activeBranch, newFallback, container, anchor, parentComponent, null,\n        // fallback tree will not have suspense context\n        isSVG, slotScopeIds, optimized);\n        setActiveBranch(suspense, newFallback);\n      }\n    } else {\n      suspense.pendingId++;\n      if (isHydrating) {\n        suspense.isHydrating = false;\n        suspense.activeBranch = pendingBranch;\n      } else {\n        unmount(pendingBranch, parentComponent, suspense);\n      }\n      suspense.deps = 0;\n      suspense.effects.length = 0;\n      suspense.hiddenContainer = createElement("div");\n      if (isInFallback) {\n        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n        if (suspense.deps <= 0) {\n          suspense.resolve();\n        } else {\n          patch(activeBranch, newFallback, container, anchor, parentComponent, null,\n          // fallback tree will not have suspense context\n          isSVG, slotScopeIds, optimized);\n          setActiveBranch(suspense, newFallback);\n        }\n      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n        suspense.resolve(true);\n      } else {\n        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n        if (suspense.deps <= 0) {\n          suspense.resolve();\n        }\n      }\n    }\n  } else {\n    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n      patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n      setActiveBranch(suspense, newBranch);\n    } else {\n      triggerEvent(n2, "onPending");\n      suspense.pendingBranch = newBranch;\n      suspense.pendingId++;\n      patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n      if (suspense.deps <= 0) {\n        suspense.resolve();\n      } else {\n        const {\n          timeout,\n          pendingId\n        } = suspense;\n        if (timeout > 0) {\n          setTimeout(() => {\n            if (suspense.pendingId === pendingId) {\n              suspense.fallback(newFallback);\n            }\n          }, timeout);\n        } else if (timeout === 0) {\n          suspense.fallback(newFallback);\n        }\n      }\n    }\n  }\n}\nlet hasWarned = false;\nfunction createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {\n  if (false) {}\n  const {\n    p: patch,\n    m: move,\n    um: unmount,\n    n: next,\n    o: {\n      parentNode,\n      remove\n    }\n  } = rendererInternals;\n  let parentSuspenseId;\n  const isSuspensible = isVNodeSuspensible(vnode);\n  if (isSuspensible) {\n    if (parentSuspense == null ? void 0 : parentSuspense.pendingBranch) {\n      parentSuspenseId = parentSuspense.pendingId;\n      parentSuspense.deps++;\n    }\n  }\n  const timeout = vnode.props ? shared_esm_bundler_toNumber(vnode.props.timeout) : void 0;\n  if (false) {}\n  const suspense = {\n    vnode,\n    parent: parentSuspense,\n    parentComponent,\n    isSVG,\n    container,\n    hiddenContainer,\n    anchor,\n    deps: 0,\n    pendingId: 0,\n    timeout: typeof timeout === "number" ? timeout : -1,\n    activeBranch: null,\n    pendingBranch: null,\n    isInFallback: true,\n    isHydrating,\n    isUnmounted: false,\n    effects: [],\n    resolve(resume = false, sync = false) {\n      if (false) {}\n      const {\n        vnode: vnode2,\n        activeBranch,\n        pendingBranch,\n        pendingId,\n        effects,\n        parentComponent: parentComponent2,\n        container: container2\n      } = suspense;\n      if (suspense.isHydrating) {\n        suspense.isHydrating = false;\n      } else if (!resume) {\n        const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";\n        if (delayEnter) {\n          activeBranch.transition.afterLeave = () => {\n            if (pendingId === suspense.pendingId) {\n              move(pendingBranch, container2, anchor2, 0);\n            }\n          };\n        }\n        let {\n          anchor: anchor2\n        } = suspense;\n        if (activeBranch) {\n          anchor2 = next(activeBranch);\n          unmount(activeBranch, parentComponent2, suspense, true);\n        }\n        if (!delayEnter) {\n          move(pendingBranch, container2, anchor2, 0);\n        }\n      }\n      setActiveBranch(suspense, pendingBranch);\n      suspense.pendingBranch = null;\n      suspense.isInFallback = false;\n      let parent = suspense.parent;\n      let hasUnresolvedAncestor = false;\n      while (parent) {\n        if (parent.pendingBranch) {\n          parent.effects.push(...effects);\n          hasUnresolvedAncestor = true;\n          break;\n        }\n        parent = parent.parent;\n      }\n      if (!hasUnresolvedAncestor) {\n        queuePostFlushCb(effects);\n      }\n      suspense.effects = [];\n      if (isSuspensible) {\n        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {\n          parentSuspense.deps--;\n          if (parentSuspense.deps === 0 && !sync) {\n            parentSuspense.resolve();\n          }\n        }\n      }\n      triggerEvent(vnode2, "onResolve");\n    },\n    fallback(fallbackVNode) {\n      if (!suspense.pendingBranch) {\n        return;\n      }\n      const {\n        vnode: vnode2,\n        activeBranch,\n        parentComponent: parentComponent2,\n        container: container2,\n        isSVG: isSVG2\n      } = suspense;\n      triggerEvent(vnode2, "onFallback");\n      const anchor2 = next(activeBranch);\n      const mountFallback = () => {\n        if (!suspense.isInFallback) {\n          return;\n        }\n        patch(null, fallbackVNode, container2, anchor2, parentComponent2, null,\n        // fallback tree will not have suspense context\n        isSVG2, slotScopeIds, optimized);\n        setActiveBranch(suspense, fallbackVNode);\n      };\n      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";\n      if (delayEnter) {\n        activeBranch.transition.afterLeave = mountFallback;\n      }\n      suspense.isInFallback = true;\n      unmount(activeBranch, parentComponent2, null,\n      // no suspense so unmount hooks fire now\n      true\n      // shouldRemove\n      );\n\n      if (!delayEnter) {\n        mountFallback();\n      }\n    },\n    move(container2, anchor2, type) {\n      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);\n      suspense.container = container2;\n    },\n    next() {\n      return suspense.activeBranch && next(suspense.activeBranch);\n    },\n    registerDep(instance, setupRenderEffect) {\n      const isInPendingSuspense = !!suspense.pendingBranch;\n      if (isInPendingSuspense) {\n        suspense.deps++;\n      }\n      const hydratedEl = instance.vnode.el;\n      instance.asyncDep.catch(err => {\n        handleError(err, instance, 0);\n      }).then(asyncSetupResult => {\n        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {\n          return;\n        }\n        instance.asyncResolved = true;\n        const {\n          vnode: vnode2\n        } = instance;\n        if (false) {}\n        handleSetupResult(instance, asyncSetupResult, false);\n        if (hydratedEl) {\n          vnode2.el = hydratedEl;\n        }\n        const placeholder = !hydratedEl && instance.subTree.el;\n        setupRenderEffect(instance, vnode2,\n        // component may have been moved before resolve.\n        // if this is not a hydration, instance.subTree will be the comment\n        // placeholder.\n        parentNode(hydratedEl || instance.subTree.el),\n        // anchor will not be used if this is hydration, so only need to\n        // consider the comment placeholder case.\n        hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);\n        if (placeholder) {\n          remove(placeholder);\n        }\n        updateHOCHostEl(instance, vnode2.el);\n        if (false) {}\n        if (isInPendingSuspense && --suspense.deps === 0) {\n          suspense.resolve();\n        }\n      });\n    },\n    unmount(parentSuspense2, doRemove) {\n      suspense.isUnmounted = true;\n      if (suspense.activeBranch) {\n        unmount(suspense.activeBranch, parentComponent, parentSuspense2, doRemove);\n      }\n      if (suspense.pendingBranch) {\n        unmount(suspense.pendingBranch, parentComponent, parentSuspense2, doRemove);\n      }\n    }\n  };\n  return suspense;\n}\nfunction hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {\n  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement("div"), null, isSVG, slotScopeIds, optimized, rendererInternals, true\n  /* hydrating */);\n\n  const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);\n  if (suspense.deps === 0) {\n    suspense.resolve(false, true);\n  }\n  return result;\n}\nfunction normalizeSuspenseChildren(vnode) {\n  const {\n    shapeFlag,\n    children\n  } = vnode;\n  const isSlotChildren = shapeFlag & 32;\n  vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);\n  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : runtime_core_esm_bundler_createVNode(Comment);\n}\nfunction normalizeSuspenseSlot(s) {\n  let block;\n  if (shared_esm_bundler_isFunction(s)) {\n    const trackBlock = isBlockTreeEnabled && s._c;\n    if (trackBlock) {\n      s._d = false;\n      openBlock();\n    }\n    s = s();\n    if (trackBlock) {\n      s._d = true;\n      block = currentBlock;\n      closeBlock();\n    }\n  }\n  if (shared_esm_bundler_isArray(s)) {\n    const singleChild = filterSingleRoot(s);\n    if (false) {}\n    s = singleChild;\n  }\n  s = normalizeVNode(s);\n  if (block && !s.dynamicChildren) {\n    s.dynamicChildren = block.filter(c => c !== s);\n  }\n  return s;\n}\nfunction queueEffectWithSuspense(fn, suspense) {\n  if (suspense && suspense.pendingBranch) {\n    if (shared_esm_bundler_isArray(fn)) {\n      suspense.effects.push(...fn);\n    } else {\n      suspense.effects.push(fn);\n    }\n  } else {\n    queuePostFlushCb(fn);\n  }\n}\nfunction setActiveBranch(suspense, branch) {\n  suspense.activeBranch = branch;\n  const {\n    vnode,\n    parentComponent\n  } = suspense;\n  const el = vnode.el = branch.el;\n  if (parentComponent && parentComponent.subTree === vnode) {\n    parentComponent.vnode.el = el;\n    updateHOCHostEl(parentComponent, el);\n  }\n}\nfunction isVNodeSuspensible(vnode) {\n  var _a;\n  return ((_a = vnode.props) == null ? void 0 : _a.suspensible) != null && vnode.props.suspensible !== false;\n}\nfunction watchEffect(effect, options) {\n  return doWatch(effect, null, options);\n}\nfunction runtime_core_esm_bundler_watchPostEffect(effect, options) {\n  return doWatch(effect, null,  false ? 0 : {\n    flush: "post"\n  });\n}\nfunction watchSyncEffect(effect, options) {\n  return doWatch(effect, null,  false ? 0 : {\n    flush: "sync"\n  });\n}\nconst INITIAL_WATCHER_VALUE = {};\nfunction watch(source, cb, options) {\n  if (false) {}\n  return doWatch(source, cb, options);\n}\nfunction doWatch(source, cb, {\n  immediate,\n  deep,\n  flush,\n  onTrack,\n  onTrigger\n} = shared_esm_bundler_EMPTY_OBJ) {\n  var _a;\n  if (false) {}\n  const warnInvalidSource = s => {\n    runtime_core_esm_bundler_warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);\n  };\n  const instance = getCurrentScope() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;\n  let getter;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if (reactivity_esm_bundler_isRef(source)) {\n    getter = () => source.value;\n    forceTrigger = isShallow(source);\n  } else if (reactivity_esm_bundler_isReactive(source)) {\n    getter = () => source;\n    deep = true;\n  } else if (shared_esm_bundler_isArray(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some(s => reactivity_esm_bundler_isReactive(s) || isShallow(s));\n    getter = () => source.map(s => {\n      if (reactivity_esm_bundler_isRef(s)) {\n        return s.value;\n      } else if (reactivity_esm_bundler_isReactive(s)) {\n        return traverse(s);\n      } else if (shared_esm_bundler_isFunction(s)) {\n        return callWithErrorHandling(s, instance, 2);\n      } else {\n         false && 0;\n      }\n    });\n  } else if (shared_esm_bundler_isFunction(source)) {\n    if (cb) {\n      getter = () => callWithErrorHandling(source, instance, 2);\n    } else {\n      getter = () => {\n        if (instance && instance.isUnmounted) {\n          return;\n        }\n        if (cleanup) {\n          cleanup();\n        }\n        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);\n      };\n    }\n  } else {\n    getter = shared_esm_bundler_NOOP;\n     false && 0;\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    getter = () => traverse(baseGetter());\n  }\n  let cleanup;\n  let onCleanup = fn => {\n    cleanup = effect.onStop = () => {\n      callWithErrorHandling(fn, instance, 4);\n    };\n  };\n  let ssrCleanup;\n  if (isInSSRComponentSetup) {\n    onCleanup = shared_esm_bundler_NOOP;\n    if (!cb) {\n      getter();\n    } else if (immediate) {\n      callWithAsyncErrorHandling(cb, instance, 3, [getter(), isMultiSource ? [] : void 0, onCleanup]);\n    }\n    if (flush === "sync") {\n      const ctx = useSSRContext();\n      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);\n    } else {\n      return shared_esm_bundler_NOOP;\n    }\n  }\n  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n  const job = () => {\n    if (!effect.active) {\n      return;\n    }\n    if (cb) {\n      const newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => shared_esm_bundler_hasChanged(v, oldValue[i])) : shared_esm_bundler_hasChanged(newValue, oldValue)) || false) {\n        if (cleanup) {\n          cleanup();\n        }\n        callWithAsyncErrorHandling(cb, instance, 3, [newValue,\n        // pass undefined as the old value when it\'s changed for the first time\n        oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue, onCleanup]);\n        oldValue = newValue;\n      }\n    } else {\n      effect.run();\n    }\n  };\n  job.allowRecurse = !!cb;\n  let scheduler;\n  if (flush === "sync") {\n    scheduler = job;\n  } else if (flush === "post") {\n    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\n  } else {\n    job.pre = true;\n    if (instance) job.id = instance.uid;\n    scheduler = () => queueJob(job);\n  }\n  const effect = new ReactiveEffect(getter, scheduler);\n  if (false) {}\n  if (cb) {\n    if (immediate) {\n      job();\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (flush === "post") {\n    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);\n  } else {\n    effect.run();\n  }\n  const unwatch = () => {\n    effect.stop();\n    if (instance && instance.scope) {\n      remove(instance.scope.effects, effect);\n    }\n  };\n  if (ssrCleanup) ssrCleanup.push(unwatch);\n  return unwatch;\n}\nfunction instanceWatch(source, value, options) {\n  const publicThis = this.proxy;\n  const getter = shared_esm_bundler_isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);\n  let cb;\n  if (shared_esm_bundler_isFunction(value)) {\n    cb = value;\n  } else {\n    cb = value.handler;\n    options = value;\n  }\n  const cur = currentInstance;\n  setCurrentInstance(this);\n  const res = doWatch(getter, cb.bind(publicThis), options);\n  if (cur) {\n    setCurrentInstance(cur);\n  } else {\n    unsetCurrentInstance();\n  }\n  return res;\n}\nfunction createPathGetter(ctx, path) {\n  const segments = path.split(".");\n  return () => {\n    let cur = ctx;\n    for (let i = 0; i < segments.length && cur; i++) {\n      cur = cur[segments[i]];\n    }\n    return cur;\n  };\n}\nfunction traverse(value, seen) {\n  if (!shared_esm_bundler_isObject(value) || value["__v_skip"]) {\n    return value;\n  }\n  seen = seen || /* @__PURE__ */new Set();\n  if (seen.has(value)) {\n    return value;\n  }\n  seen.add(value);\n  if (reactivity_esm_bundler_isRef(value)) {\n    traverse(value.value, seen);\n  } else if (shared_esm_bundler_isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], seen);\n    }\n  } else if (shared_esm_bundler_isSet(value) || isMap(value)) {\n    value.forEach(v => {\n      traverse(v, seen);\n    });\n  } else if (isPlainObject(value)) {\n    for (const key in value) {\n      traverse(value[key], seen);\n    }\n  }\n  return value;\n}\nfunction validateDirectiveName(name) {\n  if (isBuiltInDirective(name)) {\n    runtime_core_esm_bundler_warn("Do not use built-in directive ids as custom directive id: " + name);\n  }\n}\nfunction withDirectives(vnode, directives) {\n  const internalInstance = currentRenderingInstance;\n  if (internalInstance === null) {\n     false && 0;\n    return vnode;\n  }\n  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;\n  const bindings = vnode.dirs || (vnode.dirs = []);\n  for (let i = 0; i < directives.length; i++) {\n    let [dir, value, arg, modifiers = shared_esm_bundler_EMPTY_OBJ] = directives[i];\n    if (dir) {\n      if (shared_esm_bundler_isFunction(dir)) {\n        dir = {\n          mounted: dir,\n          updated: dir\n        };\n      }\n      if (dir.deep) {\n        traverse(value);\n      }\n      bindings.push({\n        dir,\n        instance,\n        value,\n        oldValue: void 0,\n        arg,\n        modifiers\n      });\n    }\n  }\n  return vnode;\n}\nfunction invokeDirectiveHook(vnode, prevVNode, instance, name) {\n  const bindings = vnode.dirs;\n  const oldBindings = prevVNode && prevVNode.dirs;\n  for (let i = 0; i < bindings.length; i++) {\n    const binding = bindings[i];\n    if (oldBindings) {\n      binding.oldValue = oldBindings[i].value;\n    }\n    let hook = binding.dir[name];\n    if (hook) {\n      pauseTracking();\n      callWithAsyncErrorHandling(hook, instance, 8, [vnode.el, binding, vnode, prevVNode]);\n      resetTracking();\n    }\n  }\n}\nfunction useTransitionState() {\n  const state = {\n    isMounted: false,\n    isLeaving: false,\n    isUnmounting: false,\n    leavingVNodes: /* @__PURE__ */new Map()\n  };\n  runtime_core_esm_bundler_onMounted(() => {\n    state.isMounted = true;\n  });\n  onBeforeUnmount(() => {\n    state.isUnmounting = true;\n  });\n  return state;\n}\nconst TransitionHookValidator = [Function, Array];\nconst BaseTransitionPropsValidators = {\n  mode: String,\n  appear: Boolean,\n  persisted: Boolean,\n  // enter\n  onBeforeEnter: TransitionHookValidator,\n  onEnter: TransitionHookValidator,\n  onAfterEnter: TransitionHookValidator,\n  onEnterCancelled: TransitionHookValidator,\n  // leave\n  onBeforeLeave: TransitionHookValidator,\n  onLeave: TransitionHookValidator,\n  onAfterLeave: TransitionHookValidator,\n  onLeaveCancelled: TransitionHookValidator,\n  // appear\n  onBeforeAppear: TransitionHookValidator,\n  onAppear: TransitionHookValidator,\n  onAfterAppear: TransitionHookValidator,\n  onAppearCancelled: TransitionHookValidator\n};\nconst BaseTransitionImpl = {\n  name: `BaseTransition`,\n  props: BaseTransitionPropsValidators,\n  setup(props, {\n    slots\n  }) {\n    const instance = runtime_core_esm_bundler_getCurrentInstance();\n    const state = useTransitionState();\n    let prevTransitionKey;\n    return () => {\n      const children = slots.default && getTransitionRawChildren(slots.default(), true);\n      if (!children || !children.length) {\n        return;\n      }\n      let child = children[0];\n      if (children.length > 1) {\n        let hasFound = false;\n        for (const c of children) {\n          if (c.type !== Comment) {\n            if (false) {}\n            child = c;\n            hasFound = true;\n            if (true) break;\n          }\n        }\n      }\n      const rawProps = reactivity_esm_bundler_toRaw(props);\n      const {\n        mode\n      } = rawProps;\n      if (false) {}\n      if (state.isLeaving) {\n        return emptyPlaceholder(child);\n      }\n      const innerChild = getKeepAliveChild(child);\n      if (!innerChild) {\n        return emptyPlaceholder(child);\n      }\n      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);\n      setTransitionHooks(innerChild, enterHooks);\n      const oldChild = instance.subTree;\n      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);\n      let transitionKeyChanged = false;\n      const {\n        getTransitionKey\n      } = innerChild.type;\n      if (getTransitionKey) {\n        const key = getTransitionKey();\n        if (prevTransitionKey === void 0) {\n          prevTransitionKey = key;\n        } else if (key !== prevTransitionKey) {\n          prevTransitionKey = key;\n          transitionKeyChanged = true;\n        }\n      }\n      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {\n        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);\n        setTransitionHooks(oldInnerChild, leavingHooks);\n        if (mode === "out-in") {\n          state.isLeaving = true;\n          leavingHooks.afterLeave = () => {\n            state.isLeaving = false;\n            if (instance.update.active !== false) {\n              instance.update();\n            }\n          };\n          return emptyPlaceholder(child);\n        } else if (mode === "in-out" && innerChild.type !== Comment) {\n          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {\n            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);\n            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;\n            el._leaveCb = () => {\n              earlyRemove();\n              el._leaveCb = void 0;\n              delete enterHooks.delayedLeave;\n            };\n            enterHooks.delayedLeave = delayedLeave;\n          };\n        }\n      }\n      return child;\n    };\n  }\n};\nconst BaseTransition = BaseTransitionImpl;\nfunction getLeavingNodesForType(state, vnode) {\n  const {\n    leavingVNodes\n  } = state;\n  let leavingVNodesCache = leavingVNodes.get(vnode.type);\n  if (!leavingVNodesCache) {\n    leavingVNodesCache = /* @__PURE__ */Object.create(null);\n    leavingVNodes.set(vnode.type, leavingVNodesCache);\n  }\n  return leavingVNodesCache;\n}\nfunction resolveTransitionHooks(vnode, props, state, instance) {\n  const {\n    appear,\n    mode,\n    persisted = false,\n    onBeforeEnter,\n    onEnter,\n    onAfterEnter,\n    onEnterCancelled,\n    onBeforeLeave,\n    onLeave,\n    onAfterLeave,\n    onLeaveCancelled,\n    onBeforeAppear,\n    onAppear,\n    onAfterAppear,\n    onAppearCancelled\n  } = props;\n  const key = String(vnode.key);\n  const leavingVNodesCache = getLeavingNodesForType(state, vnode);\n  const callHook = (hook, args) => {\n    hook && callWithAsyncErrorHandling(hook, instance, 9, args);\n  };\n  const callAsyncHook = (hook, args) => {\n    const done = args[1];\n    callHook(hook, args);\n    if (shared_esm_bundler_isArray(hook)) {\n      if (hook.every(hook2 => hook2.length <= 1)) done();\n    } else if (hook.length <= 1) {\n      done();\n    }\n  };\n  const hooks = {\n    mode,\n    persisted,\n    beforeEnter(el) {\n      let hook = onBeforeEnter;\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onBeforeAppear || onBeforeEnter;\n        } else {\n          return;\n        }\n      }\n      if (el._leaveCb) {\n        el._leaveCb(true\n        /* cancelled */);\n      }\n\n      const leavingVNode = leavingVNodesCache[key];\n      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {\n        leavingVNode.el._leaveCb();\n      }\n      callHook(hook, [el]);\n    },\n    enter(el) {\n      let hook = onEnter;\n      let afterHook = onAfterEnter;\n      let cancelHook = onEnterCancelled;\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onAppear || onEnter;\n          afterHook = onAfterAppear || onAfterEnter;\n          cancelHook = onAppearCancelled || onEnterCancelled;\n        } else {\n          return;\n        }\n      }\n      let called = false;\n      const done = el._enterCb = cancelled => {\n        if (called) return;\n        called = true;\n        if (cancelled) {\n          callHook(cancelHook, [el]);\n        } else {\n          callHook(afterHook, [el]);\n        }\n        if (hooks.delayedLeave) {\n          hooks.delayedLeave();\n        }\n        el._enterCb = void 0;\n      };\n      if (hook) {\n        callAsyncHook(hook, [el, done]);\n      } else {\n        done();\n      }\n    },\n    leave(el, remove) {\n      const key2 = String(vnode.key);\n      if (el._enterCb) {\n        el._enterCb(true\n        /* cancelled */);\n      }\n\n      if (state.isUnmounting) {\n        return remove();\n      }\n      callHook(onBeforeLeave, [el]);\n      let called = false;\n      const done = el._leaveCb = cancelled => {\n        if (called) return;\n        called = true;\n        remove();\n        if (cancelled) {\n          callHook(onLeaveCancelled, [el]);\n        } else {\n          callHook(onAfterLeave, [el]);\n        }\n        el._leaveCb = void 0;\n        if (leavingVNodesCache[key2] === vnode) {\n          delete leavingVNodesCache[key2];\n        }\n      };\n      leavingVNodesCache[key2] = vnode;\n      if (onLeave) {\n        callAsyncHook(onLeave, [el, done]);\n      } else {\n        done();\n      }\n    },\n    clone(vnode2) {\n      return resolveTransitionHooks(vnode2, props, state, instance);\n    }\n  };\n  return hooks;\n}\nfunction emptyPlaceholder(vnode) {\n  if (isKeepAlive(vnode)) {\n    vnode = cloneVNode(vnode);\n    vnode.children = null;\n    return vnode;\n  }\n}\nfunction getKeepAliveChild(vnode) {\n  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;\n}\nfunction setTransitionHooks(vnode, hooks) {\n  if (vnode.shapeFlag & 6 && vnode.component) {\n    setTransitionHooks(vnode.component.subTree, hooks);\n  } else if (vnode.shapeFlag & 128) {\n    vnode.ssContent.transition = hooks.clone(vnode.ssContent);\n    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);\n  } else {\n    vnode.transition = hooks;\n  }\n}\nfunction getTransitionRawChildren(children, keepComment = false, parentKey) {\n  let ret = [];\n  let keyedFragmentCount = 0;\n  for (let i = 0; i < children.length; i++) {\n    let child = children[i];\n    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);\n    if (child.type === runtime_core_esm_bundler_Fragment) {\n      if (child.patchFlag & 128) keyedFragmentCount++;\n      ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));\n    } else if (keepComment || child.type !== Comment) {\n      ret.push(key != null ? cloneVNode(child, {\n        key\n      }) : child);\n    }\n  }\n  if (keyedFragmentCount > 1) {\n    for (let i = 0; i < ret.length; i++) {\n      ret[i].patchFlag = -2;\n    }\n  }\n  return ret;\n}\nfunction runtime_core_esm_bundler_defineComponent(options, extraOptions) {\n  return shared_esm_bundler_isFunction(options) ?\n  // #8326: extend call and options.name access are considered side-effects\n  // by Rollup, so we have to wrap it in a pure-annotated IIFE.\n  /* @__PURE__ */\n  (() => shared_esm_bundler_extend({\n    name: options.name\n  }, extraOptions, {\n    setup: options\n  }))() : options;\n}\nconst isAsyncWrapper = i => !!i.type.__asyncLoader;\nfunction defineAsyncComponent(source) {\n  if (isFunction(source)) {\n    source = {\n      loader: source\n    };\n  }\n  const {\n    loader,\n    loadingComponent,\n    errorComponent,\n    delay = 200,\n    timeout,\n    // undefined = never times out\n    suspensible = true,\n    onError: userOnError\n  } = source;\n  let pendingRequest = null;\n  let resolvedComp;\n  let retries = 0;\n  const retry = () => {\n    retries++;\n    pendingRequest = null;\n    return load();\n  };\n  const load = () => {\n    let thisRequest;\n    return pendingRequest || (thisRequest = pendingRequest = loader().catch(err => {\n      err = err instanceof Error ? err : new Error(String(err));\n      if (userOnError) {\n        return new Promise((resolve, reject) => {\n          const userRetry = () => resolve(retry());\n          const userFail = () => reject(err);\n          userOnError(err, userRetry, userFail, retries + 1);\n        });\n      } else {\n        throw err;\n      }\n    }).then(comp => {\n      if (thisRequest !== pendingRequest && pendingRequest) {\n        return pendingRequest;\n      }\n      if (false) {}\n      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {\n        comp = comp.default;\n      }\n      if (false) {}\n      resolvedComp = comp;\n      return comp;\n    }));\n  };\n  return runtime_core_esm_bundler_defineComponent({\n    name: "AsyncComponentWrapper",\n    __asyncLoader: load,\n    get __asyncResolved() {\n      return resolvedComp;\n    },\n    setup() {\n      const instance = currentInstance;\n      if (resolvedComp) {\n        return () => createInnerComp(resolvedComp, instance);\n      }\n      const onError = err => {\n        pendingRequest = null;\n        handleError(err, instance, 13, !errorComponent\n        /* do not throw in dev if user provided error component */);\n      };\n\n      if (suspensible && instance.suspense || isInSSRComponentSetup) {\n        return load().then(comp => {\n          return () => createInnerComp(comp, instance);\n        }).catch(err => {\n          onError(err);\n          return () => errorComponent ? runtime_core_esm_bundler_createVNode(errorComponent, {\n            error: err\n          }) : null;\n        });\n      }\n      const loaded = ref(false);\n      const error = ref();\n      const delayed = ref(!!delay);\n      if (delay) {\n        setTimeout(() => {\n          delayed.value = false;\n        }, delay);\n      }\n      if (timeout != null) {\n        setTimeout(() => {\n          if (!loaded.value && !error.value) {\n            const err = new Error(`Async component timed out after ${timeout}ms.`);\n            onError(err);\n            error.value = err;\n          }\n        }, timeout);\n      }\n      load().then(() => {\n        loaded.value = true;\n        if (instance.parent && isKeepAlive(instance.parent.vnode)) {\n          queueJob(instance.parent.update);\n        }\n      }).catch(err => {\n        onError(err);\n        error.value = err;\n      });\n      return () => {\n        if (loaded.value && resolvedComp) {\n          return createInnerComp(resolvedComp, instance);\n        } else if (error.value && errorComponent) {\n          return runtime_core_esm_bundler_createVNode(errorComponent, {\n            error: error.value\n          });\n        } else if (loadingComponent && !delayed.value) {\n          return runtime_core_esm_bundler_createVNode(loadingComponent);\n        }\n      };\n    }\n  });\n}\nfunction createInnerComp(comp, parent) {\n  const {\n    ref: ref2,\n    props,\n    children,\n    ce\n  } = parent.vnode;\n  const vnode = runtime_core_esm_bundler_createVNode(comp, props, children);\n  vnode.ref = ref2;\n  vnode.ce = ce;\n  delete parent.vnode.ce;\n  return vnode;\n}\nconst isKeepAlive = vnode => vnode.type.__isKeepAlive;\nconst KeepAliveImpl = {\n  name: `KeepAlive`,\n  // Marker for special handling inside the renderer. We are not using a ===\n  // check directly on KeepAlive in the renderer, because importing it directly\n  // would prevent it from being tree-shaken.\n  __isKeepAlive: true,\n  props: {\n    include: [String, RegExp, Array],\n    exclude: [String, RegExp, Array],\n    max: [String, Number]\n  },\n  setup(props, {\n    slots\n  }) {\n    const instance = runtime_core_esm_bundler_getCurrentInstance();\n    const sharedContext = instance.ctx;\n    if (!sharedContext.renderer) {\n      return () => {\n        const children = slots.default && slots.default();\n        return children && children.length === 1 ? children[0] : children;\n      };\n    }\n    const cache = /* @__PURE__ */new Map();\n    const keys = /* @__PURE__ */new Set();\n    let current = null;\n    if ( false || __VUE_PROD_DEVTOOLS__) {\n      instance.__v_cache = cache;\n    }\n    const parentSuspense = instance.suspense;\n    const {\n      renderer: {\n        p: patch,\n        m: move,\n        um: _unmount,\n        o: {\n          createElement\n        }\n      }\n    } = sharedContext;\n    const storageContainer = createElement("div");\n    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {\n      const instance2 = vnode.component;\n      move(vnode, container, anchor, 0, parentSuspense);\n      patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, isSVG, vnode.slotScopeIds, optimized);\n      queuePostRenderEffect(() => {\n        instance2.isDeactivated = false;\n        if (instance2.a) {\n          invokeArrayFns(instance2.a);\n        }\n        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance2.parent, vnode);\n        }\n      }, parentSuspense);\n      if ( false || __VUE_PROD_DEVTOOLS__) {\n        devtoolsComponentAdded(instance2);\n      }\n    };\n    sharedContext.deactivate = vnode => {\n      const instance2 = vnode.component;\n      move(vnode, storageContainer, null, 1, parentSuspense);\n      queuePostRenderEffect(() => {\n        if (instance2.da) {\n          invokeArrayFns(instance2.da);\n        }\n        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance2.parent, vnode);\n        }\n        instance2.isDeactivated = true;\n      }, parentSuspense);\n      if ( false || __VUE_PROD_DEVTOOLS__) {\n        devtoolsComponentAdded(instance2);\n      }\n    };\n    function unmount(vnode) {\n      resetShapeFlag(vnode);\n      _unmount(vnode, instance, parentSuspense, true);\n    }\n    function pruneCache(filter) {\n      cache.forEach((vnode, key) => {\n        const name = getComponentName(vnode.type);\n        if (name && (!filter || !filter(name))) {\n          pruneCacheEntry(key);\n        }\n      });\n    }\n    function pruneCacheEntry(key) {\n      const cached = cache.get(key);\n      if (!current || !isSameVNodeType(cached, current)) {\n        unmount(cached);\n      } else if (current) {\n        resetShapeFlag(current);\n      }\n      cache.delete(key);\n      keys.delete(key);\n    }\n    watch(() => [props.include, props.exclude], ([include, exclude]) => {\n      include && pruneCache(name => matches(include, name));\n      exclude && pruneCache(name => !matches(exclude, name));\n    },\n    // prune post-render after `current` has been updated\n    {\n      flush: "post",\n      deep: true\n    });\n    let pendingCacheKey = null;\n    const cacheSubtree = () => {\n      if (pendingCacheKey != null) {\n        cache.set(pendingCacheKey, getInnerChild(instance.subTree));\n      }\n    };\n    runtime_core_esm_bundler_onMounted(cacheSubtree);\n    onUpdated(cacheSubtree);\n    onBeforeUnmount(() => {\n      cache.forEach(cached => {\n        const {\n          subTree,\n          suspense\n        } = instance;\n        const vnode = getInnerChild(subTree);\n        if (cached.type === vnode.type && cached.key === vnode.key) {\n          resetShapeFlag(vnode);\n          const da = vnode.component.da;\n          da && queuePostRenderEffect(da, suspense);\n          return;\n        }\n        unmount(cached);\n      });\n    });\n    return () => {\n      pendingCacheKey = null;\n      if (!slots.default) {\n        return null;\n      }\n      const children = slots.default();\n      const rawVNode = children[0];\n      if (children.length > 1) {\n        if (false) {}\n        current = null;\n        return children;\n      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {\n        current = null;\n        return rawVNode;\n      }\n      let vnode = getInnerChild(rawVNode);\n      const comp = vnode.type;\n      const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);\n      const {\n        include,\n        exclude,\n        max\n      } = props;\n      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {\n        current = vnode;\n        return rawVNode;\n      }\n      const key = vnode.key == null ? comp : vnode.key;\n      const cachedVNode = cache.get(key);\n      if (vnode.el) {\n        vnode = cloneVNode(vnode);\n        if (rawVNode.shapeFlag & 128) {\n          rawVNode.ssContent = vnode;\n        }\n      }\n      pendingCacheKey = key;\n      if (cachedVNode) {\n        vnode.el = cachedVNode.el;\n        vnode.component = cachedVNode.component;\n        if (vnode.transition) {\n          setTransitionHooks(vnode, vnode.transition);\n        }\n        vnode.shapeFlag |= 512;\n        keys.delete(key);\n        keys.add(key);\n      } else {\n        keys.add(key);\n        if (max && keys.size > parseInt(max, 10)) {\n          pruneCacheEntry(keys.values().next().value);\n        }\n      }\n      vnode.shapeFlag |= 256;\n      current = vnode;\n      return isSuspense(rawVNode.type) ? rawVNode : vnode;\n    };\n  }\n};\nconst KeepAlive = (/* unused pure expression or super */ null && (KeepAliveImpl));\nfunction matches(pattern, name) {\n  if (shared_esm_bundler_isArray(pattern)) {\n    return pattern.some(p => matches(p, name));\n  } else if (shared_esm_bundler_isString(pattern)) {\n    return pattern.split(",").includes(name);\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name);\n  }\n  return false;\n}\nfunction runtime_core_esm_bundler_onActivated(hook, target) {\n  registerKeepAliveHook(hook, "a", target);\n}\nfunction runtime_core_esm_bundler_onDeactivated(hook, target) {\n  registerKeepAliveHook(hook, "da", target);\n}\nfunction registerKeepAliveHook(hook, type, target = currentInstance) {\n  const wrappedHook = hook.__wdc || (hook.__wdc = () => {\n    let current = target;\n    while (current) {\n      if (current.isDeactivated) {\n        return;\n      }\n      current = current.parent;\n    }\n    return hook();\n  });\n  injectHook(type, wrappedHook, target);\n  if (target) {\n    let current = target.parent;\n    while (current && current.parent) {\n      if (isKeepAlive(current.parent.vnode)) {\n        injectToKeepAliveRoot(wrappedHook, type, target, current);\n      }\n      current = current.parent;\n    }\n  }\n}\nfunction injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {\n  const injected = injectHook(type, hook, keepAliveRoot, true\n  /* prepend */);\n\n  runtime_core_esm_bundler_onUnmounted(() => {\n    remove(keepAliveRoot[type], injected);\n  }, target);\n}\nfunction resetShapeFlag(vnode) {\n  vnode.shapeFlag &= ~256;\n  vnode.shapeFlag &= ~512;\n}\nfunction getInnerChild(vnode) {\n  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;\n}\nfunction injectHook(type, hook, target = currentInstance, prepend = false) {\n  if (target) {\n    const hooks = target[type] || (target[type] = []);\n    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {\n      if (target.isUnmounted) {\n        return;\n      }\n      pauseTracking();\n      setCurrentInstance(target);\n      const res = callWithAsyncErrorHandling(hook, target, type, args);\n      unsetCurrentInstance();\n      resetTracking();\n      return res;\n    });\n    if (prepend) {\n      hooks.unshift(wrappedHook);\n    } else {\n      hooks.push(wrappedHook);\n    }\n    return wrappedHook;\n  } else if (false) {}\n}\nconst createHook = lifecycle => (hook, target = currentInstance) =>\n// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)\n(!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target);\nconst onBeforeMount = createHook("bm");\nconst runtime_core_esm_bundler_onMounted = createHook("m");\nconst onBeforeUpdate = createHook("bu");\nconst onUpdated = createHook("u");\nconst onBeforeUnmount = createHook("bum");\nconst runtime_core_esm_bundler_onUnmounted = createHook("um");\nconst onServerPrefetch = createHook("sp");\nconst onRenderTriggered = createHook("rtg");\nconst onRenderTracked = createHook("rtc");\nfunction onErrorCaptured(hook, target = currentInstance) {\n  injectHook("ec", hook, target);\n}\nconst COMPONENTS = "components";\nconst DIRECTIVES = "directives";\nfunction resolveComponent(name, maybeSelfReference) {\n  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;\n}\nconst NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");\nfunction resolveDynamicComponent(component) {\n  if (isString(component)) {\n    return resolveAsset(COMPONENTS, component, false) || component;\n  } else {\n    return component || NULL_DYNAMIC_COMPONENT;\n  }\n}\nfunction resolveDirective(name) {\n  return resolveAsset(DIRECTIVES, name);\n}\nfunction resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {\n  const instance = currentRenderingInstance || currentInstance;\n  if (instance) {\n    const Component = instance.type;\n    if (type === COMPONENTS) {\n      const selfName = getComponentName(Component, false\n      /* do not include inferred name to avoid breaking existing code */);\n\n      if (selfName && (selfName === name || selfName === camelize(name) || selfName === shared_esm_bundler_capitalize(camelize(name)))) {\n        return Component;\n      }\n    }\n    const res =\n    // local registration\n    // check instance[type] first which is resolved for options API\n    resolve(instance[type] || Component[type], name) ||\n    // global registration\n    resolve(instance.appContext[type], name);\n    if (!res && maybeSelfReference) {\n      return Component;\n    }\n    if (false) {}\n    return res;\n  } else if (false) {}\n}\nfunction resolve(registry, name) {\n  return registry && (registry[name] || registry[camelize(name)] || registry[shared_esm_bundler_capitalize(camelize(name))]);\n}\nfunction renderList(source, renderItem, cache, index) {\n  let ret;\n  const cached = cache && cache[index];\n  if (shared_esm_bundler_isArray(source) || shared_esm_bundler_isString(source)) {\n    ret = new Array(source.length);\n    for (let i = 0, l = source.length; i < l; i++) {\n      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);\n    }\n  } else if (typeof source === "number") {\n    if (false) {}\n    ret = new Array(source);\n    for (let i = 0; i < source; i++) {\n      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);\n    }\n  } else if (shared_esm_bundler_isObject(source)) {\n    if (source[Symbol.iterator]) {\n      ret = Array.from(source, (item, i) => renderItem(item, i, void 0, cached && cached[i]));\n    } else {\n      const keys = Object.keys(source);\n      ret = new Array(keys.length);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n        ret[i] = renderItem(source[key], key, i, cached && cached[i]);\n      }\n    }\n  } else {\n    ret = [];\n  }\n  if (cache) {\n    cache[index] = ret;\n  }\n  return ret;\n}\nfunction createSlots(slots, dynamicSlots) {\n  for (let i = 0; i < dynamicSlots.length; i++) {\n    const slot = dynamicSlots[i];\n    if (isArray(slot)) {\n      for (let j = 0; j < slot.length; j++) {\n        slots[slot[j].name] = slot[j].fn;\n      }\n    } else if (slot) {\n      slots[slot.name] = slot.key ? (...args) => {\n        const res = slot.fn(...args);\n        if (res) res.key = slot.key;\n        return res;\n      } : slot.fn;\n    }\n  }\n  return slots;\n}\nfunction renderSlot(slots, name, props = {}, fallback, noSlotted) {\n  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {\n    if (name !== "default") props.name = name;\n    return runtime_core_esm_bundler_createVNode("slot", props, fallback && fallback());\n  }\n  let slot = slots[name];\n  if (false) {}\n  if (slot && slot._c) {\n    slot._d = false;\n  }\n  openBlock();\n  const validSlotContent = slot && ensureValidVNode(slot(props));\n  const rendered = createBlock(runtime_core_esm_bundler_Fragment, {\n    key: props.key ||\n    // slot content array of a dynamic conditional slot may have a branch\n    // key attached in the `createSlots` helper, respect that\n    validSlotContent && validSlotContent.key || `_${name}`\n  }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);\n  if (!noSlotted && rendered.scopeId) {\n    rendered.slotScopeIds = [rendered.scopeId + "-s"];\n  }\n  if (slot && slot._c) {\n    slot._d = true;\n  }\n  return rendered;\n}\nfunction ensureValidVNode(vnodes) {\n  return vnodes.some(child => {\n    if (!isVNode(child)) return true;\n    if (child.type === Comment) return false;\n    if (child.type === runtime_core_esm_bundler_Fragment && !ensureValidVNode(child.children)) return false;\n    return true;\n  }) ? vnodes : null;\n}\nfunction toHandlers(obj, preserveCaseIfNecessary) {\n  const ret = {};\n  if (false) {}\n  for (const key in obj) {\n    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];\n  }\n  return ret;\n}\nconst getPublicInstance = i => {\n  if (!i) return null;\n  if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy;\n  return getPublicInstance(i.parent);\n};\nconst publicPropertiesMap =\n// Move PURE marker to new line to workaround compiler discarding it\n// due to type annotation\n/* @__PURE__ */\nshared_esm_bundler_extend( /* @__PURE__ */Object.create(null), {\n  $: i => i,\n  $el: i => i.vnode.el,\n  $data: i => i.data,\n  $props: i =>  false ? 0 : i.props,\n  $attrs: i =>  false ? 0 : i.attrs,\n  $slots: i =>  false ? 0 : i.slots,\n  $refs: i =>  false ? 0 : i.refs,\n  $parent: i => getPublicInstance(i.parent),\n  $root: i => getPublicInstance(i.root),\n  $emit: i => i.emit,\n  $options: i => __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,\n  $forceUpdate: i => i.f || (i.f = () => queueJob(i.update)),\n  $nextTick: i => i.n || (i.n = runtime_core_esm_bundler_nextTick.bind(i.proxy)),\n  $watch: i => __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : shared_esm_bundler_NOOP\n});\nconst isReservedPrefix = key => key === "_" || key === "$";\nconst hasSetupBinding = (state, key) => state !== shared_esm_bundler_EMPTY_OBJ && !state.__isScriptSetup && shared_esm_bundler_hasOwn(state, key);\nconst PublicInstanceProxyHandlers = {\n  get({\n    _: instance\n  }, key) {\n    const {\n      ctx,\n      setupState,\n      data,\n      props,\n      accessCache,\n      type,\n      appContext\n    } = instance;\n    if (false) {}\n    let normalizedProps;\n    if (key[0] !== "$") {\n      const n = accessCache[key];\n      if (n !== void 0) {\n        switch (n) {\n          case 1 /* SETUP */:\n            return setupState[key];\n          case 2 /* DATA */:\n            return data[key];\n          case 4 /* CONTEXT */:\n            return ctx[key];\n          case 3 /* PROPS */:\n            return props[key];\n        }\n      } else if (hasSetupBinding(setupState, key)) {\n        accessCache[key] = 1 /* SETUP */;\n        return setupState[key];\n      } else if (data !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(data, key)) {\n        accessCache[key] = 2 /* DATA */;\n        return data[key];\n      } else if (\n      // only cache other properties when instance has declared (thus stable)\n      // props\n      (normalizedProps = instance.propsOptions[0]) && shared_esm_bundler_hasOwn(normalizedProps, key)) {\n        accessCache[key] = 3 /* PROPS */;\n        return props[key];\n      } else if (ctx !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(ctx, key)) {\n        accessCache[key] = 4 /* CONTEXT */;\n        return ctx[key];\n      } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {\n        accessCache[key] = 0 /* OTHER */;\n      }\n    }\n\n    const publicGetter = publicPropertiesMap[key];\n    let cssModule, globalProperties;\n    if (publicGetter) {\n      if (key === "$attrs") {\n        reactivity_esm_bundler_track(instance, "get", key);\n         false && 0;\n      } else if (false) {}\n      return publicGetter(instance);\n    } else if (\n    // css module (injected by vue-loader)\n    (cssModule = type.__cssModules) && (cssModule = cssModule[key])) {\n      return cssModule;\n    } else if (ctx !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(ctx, key)) {\n      accessCache[key] = 4 /* CONTEXT */;\n      return ctx[key];\n    } else if (\n    // global properties\n    globalProperties = appContext.config.globalProperties, shared_esm_bundler_hasOwn(globalProperties, key)) {\n      {\n        return globalProperties[key];\n      }\n    } else if (false) {}\n  },\n  set({\n    _: instance\n  }, key, value) {\n    const {\n      data,\n      setupState,\n      ctx\n    } = instance;\n    if (hasSetupBinding(setupState, key)) {\n      setupState[key] = value;\n      return true;\n    } else if (false) {} else if (data !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(data, key)) {\n      data[key] = value;\n      return true;\n    } else if (shared_esm_bundler_hasOwn(instance.props, key)) {\n       false && 0;\n      return false;\n    }\n    if (key[0] === "$" && key.slice(1) in instance) {\n       false && 0;\n      return false;\n    } else {\n      if (false) {} else {\n        ctx[key] = value;\n      }\n    }\n    return true;\n  },\n  has({\n    _: {\n      data,\n      setupState,\n      accessCache,\n      ctx,\n      appContext,\n      propsOptions\n    }\n  }, key) {\n    let normalizedProps;\n    return !!accessCache[key] || data !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && shared_esm_bundler_hasOwn(normalizedProps, key) || shared_esm_bundler_hasOwn(ctx, key) || shared_esm_bundler_hasOwn(publicPropertiesMap, key) || shared_esm_bundler_hasOwn(appContext.config.globalProperties, key);\n  },\n  defineProperty(target, key, descriptor) {\n    if (descriptor.get != null) {\n      target._.accessCache[key] = 0;\n    } else if (shared_esm_bundler_hasOwn(descriptor, "value")) {\n      this.set(target, key, descriptor.value, null);\n    }\n    return Reflect.defineProperty(target, key, descriptor);\n  }\n};\nif (false) {}\nconst RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */shared_esm_bundler_extend({}, PublicInstanceProxyHandlers, {\n  get(target, key) {\n    if (key === Symbol.unscopables) {\n      return;\n    }\n    return PublicInstanceProxyHandlers.get(target, key, target);\n  },\n  has(_, key) {\n    const has = key[0] !== "_" && !isGloballyWhitelisted(key);\n    if (false) {}\n    return has;\n  }\n});\nfunction createDevRenderContext(instance) {\n  const target = {};\n  Object.defineProperty(target, `_`, {\n    configurable: true,\n    enumerable: false,\n    get: () => instance\n  });\n  Object.keys(publicPropertiesMap).forEach(key => {\n    Object.defineProperty(target, key, {\n      configurable: true,\n      enumerable: false,\n      get: () => publicPropertiesMap[key](instance),\n      // intercepted by the proxy so no need for implementation,\n      // but needed to prevent set errors\n      set: NOOP\n    });\n  });\n  return target;\n}\nfunction exposePropsOnRenderContext(instance) {\n  const {\n    ctx,\n    propsOptions: [propsOptions]\n  } = instance;\n  if (propsOptions) {\n    Object.keys(propsOptions).forEach(key => {\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => instance.props[key],\n        set: NOOP\n      });\n    });\n  }\n}\nfunction exposeSetupStateOnRenderContext(instance) {\n  const {\n    ctx,\n    setupState\n  } = instance;\n  Object.keys(toRaw(setupState)).forEach(key => {\n    if (!setupState.__isScriptSetup) {\n      if (isReservedPrefix(key[0])) {\n        runtime_core_esm_bundler_warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);\n        return;\n      }\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => setupState[key],\n        set: NOOP\n      });\n    }\n  });\n}\nconst warnRuntimeUsage = method => runtime_core_esm_bundler_warn(`${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`);\nfunction defineProps() {\n  if (false) {}\n  return null;\n}\nfunction defineEmits() {\n  if (false) {}\n  return null;\n}\nfunction defineExpose(exposed) {\n  if (false) {}\n}\nfunction defineOptions(options) {\n  if (false) {}\n}\nfunction defineSlots() {\n  if (false) {}\n  return null;\n}\nfunction defineModel() {\n  if (false) {}\n}\nfunction withDefaults(props, defaults) {\n  if (false) {}\n  return null;\n}\nfunction useSlots() {\n  return getContext().slots;\n}\nfunction useAttrs() {\n  return getContext().attrs;\n}\nfunction useModel(props, name, options) {\n  const i = runtime_core_esm_bundler_getCurrentInstance();\n  if (false) {}\n  if (false) {}\n  if (options && options.local) {\n    const proxy = ref(props[name]);\n    watch(() => props[name], v => proxy.value = v);\n    watch(proxy, value => {\n      if (value !== props[name]) {\n        i.emit(`update:${name}`, value);\n      }\n    });\n    return proxy;\n  } else {\n    return {\n      __v_isRef: true,\n      get value() {\n        return props[name];\n      },\n      set value(value) {\n        i.emit(`update:${name}`, value);\n      }\n    };\n  }\n}\nfunction getContext() {\n  const i = runtime_core_esm_bundler_getCurrentInstance();\n  if (false) {}\n  return i.setupContext || (i.setupContext = createSetupContext(i));\n}\nfunction normalizePropsOrEmits(props) {\n  return shared_esm_bundler_isArray(props) ? props.reduce((normalized, p) => (normalized[p] = null, normalized), {}) : props;\n}\nfunction mergeDefaults(raw, defaults) {\n  const props = normalizePropsOrEmits(raw);\n  for (const key in defaults) {\n    if (key.startsWith("__skip")) continue;\n    let opt = props[key];\n    if (opt) {\n      if (isArray(opt) || isFunction(opt)) {\n        opt = props[key] = {\n          type: opt,\n          default: defaults[key]\n        };\n      } else {\n        opt.default = defaults[key];\n      }\n    } else if (opt === null) {\n      opt = props[key] = {\n        default: defaults[key]\n      };\n    } else if (false) {}\n    if (opt && defaults[`__skip_${key}`]) {\n      opt.skipFactory = true;\n    }\n  }\n  return props;\n}\nfunction mergeModels(a, b) {\n  if (!a || !b) return a || b;\n  if (isArray(a) && isArray(b)) return a.concat(b);\n  return extend({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));\n}\nfunction createPropsRestProxy(props, excludedKeys) {\n  const ret = {};\n  for (const key in props) {\n    if (!excludedKeys.includes(key)) {\n      Object.defineProperty(ret, key, {\n        enumerable: true,\n        get: () => props[key]\n      });\n    }\n  }\n  return ret;\n}\nfunction withAsyncContext(getAwaitable) {\n  const ctx = runtime_core_esm_bundler_getCurrentInstance();\n  if (false) {}\n  let awaitable = getAwaitable();\n  unsetCurrentInstance();\n  if (isPromise(awaitable)) {\n    awaitable = awaitable.catch(e => {\n      setCurrentInstance(ctx);\n      throw e;\n    });\n  }\n  return [awaitable, () => setCurrentInstance(ctx)];\n}\nfunction createDuplicateChecker() {\n  const cache = /* @__PURE__ */Object.create(null);\n  return (type, key) => {\n    if (cache[key]) {\n      runtime_core_esm_bundler_warn(`${type} property "${key}" is already defined in ${cache[key]}.`);\n    } else {\n      cache[key] = type;\n    }\n  };\n}\nlet shouldCacheAccess = true;\nfunction applyOptions(instance) {\n  const options = resolveMergedOptions(instance);\n  const publicThis = instance.proxy;\n  const ctx = instance.ctx;\n  shouldCacheAccess = false;\n  if (options.beforeCreate) {\n    callHook(options.beforeCreate, instance, "bc");\n  }\n  const {\n    // state\n    data: dataOptions,\n    computed: computedOptions,\n    methods,\n    watch: watchOptions,\n    provide: provideOptions,\n    inject: injectOptions,\n    // lifecycle\n    created,\n    beforeMount,\n    mounted,\n    beforeUpdate,\n    updated,\n    activated,\n    deactivated,\n    beforeDestroy,\n    beforeUnmount,\n    destroyed,\n    unmounted,\n    render,\n    renderTracked,\n    renderTriggered,\n    errorCaptured,\n    serverPrefetch,\n    // public API\n    expose,\n    inheritAttrs,\n    // assets\n    components,\n    directives,\n    filters\n  } = options;\n  const checkDuplicateProperties =  false ? 0 : null;\n  if (false) {}\n  if (injectOptions) {\n    resolveInjections(injectOptions, ctx, checkDuplicateProperties);\n  }\n  if (methods) {\n    for (const key in methods) {\n      const methodHandler = methods[key];\n      if (shared_esm_bundler_isFunction(methodHandler)) {\n        if (false) {} else {\n          ctx[key] = methodHandler.bind(publicThis);\n        }\n        if (false) {}\n      } else if (false) {}\n    }\n  }\n  if (dataOptions) {\n    if (false) {}\n    const data = dataOptions.call(publicThis, publicThis);\n    if (false) {}\n    if (!shared_esm_bundler_isObject(data)) {\n       false && 0;\n    } else {\n      instance.data = reactive(data);\n      if (false) {}\n    }\n  }\n  shouldCacheAccess = true;\n  if (computedOptions) {\n    for (const key in computedOptions) {\n      const opt = computedOptions[key];\n      const get = shared_esm_bundler_isFunction(opt) ? opt.bind(publicThis, publicThis) : shared_esm_bundler_isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : shared_esm_bundler_NOOP;\n      if (false) {}\n      const set = !shared_esm_bundler_isFunction(opt) && shared_esm_bundler_isFunction(opt.set) ? opt.set.bind(publicThis) :  false ? 0 : shared_esm_bundler_NOOP;\n      const c = runtime_core_esm_bundler_computed({\n        get,\n        set\n      });\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => c.value,\n        set: v => c.value = v\n      });\n      if (false) {}\n    }\n  }\n  if (watchOptions) {\n    for (const key in watchOptions) {\n      createWatcher(watchOptions[key], ctx, publicThis, key);\n    }\n  }\n  if (provideOptions) {\n    const provides = shared_esm_bundler_isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;\n    Reflect.ownKeys(provides).forEach(key => {\n      provide(key, provides[key]);\n    });\n  }\n  if (created) {\n    callHook(created, instance, "c");\n  }\n  function registerLifecycleHook(register, hook) {\n    if (shared_esm_bundler_isArray(hook)) {\n      hook.forEach(_hook => register(_hook.bind(publicThis)));\n    } else if (hook) {\n      register(hook.bind(publicThis));\n    }\n  }\n  registerLifecycleHook(onBeforeMount, beforeMount);\n  registerLifecycleHook(runtime_core_esm_bundler_onMounted, mounted);\n  registerLifecycleHook(onBeforeUpdate, beforeUpdate);\n  registerLifecycleHook(onUpdated, updated);\n  registerLifecycleHook(runtime_core_esm_bundler_onActivated, activated);\n  registerLifecycleHook(runtime_core_esm_bundler_onDeactivated, deactivated);\n  registerLifecycleHook(onErrorCaptured, errorCaptured);\n  registerLifecycleHook(onRenderTracked, renderTracked);\n  registerLifecycleHook(onRenderTriggered, renderTriggered);\n  registerLifecycleHook(onBeforeUnmount, beforeUnmount);\n  registerLifecycleHook(runtime_core_esm_bundler_onUnmounted, unmounted);\n  registerLifecycleHook(onServerPrefetch, serverPrefetch);\n  if (shared_esm_bundler_isArray(expose)) {\n    if (expose.length) {\n      const exposed = instance.exposed || (instance.exposed = {});\n      expose.forEach(key => {\n        Object.defineProperty(exposed, key, {\n          get: () => publicThis[key],\n          set: val => publicThis[key] = val\n        });\n      });\n    } else if (!instance.exposed) {\n      instance.exposed = {};\n    }\n  }\n  if (render && instance.render === shared_esm_bundler_NOOP) {\n    instance.render = render;\n  }\n  if (inheritAttrs != null) {\n    instance.inheritAttrs = inheritAttrs;\n  }\n  if (components) instance.components = components;\n  if (directives) instance.directives = directives;\n}\nfunction resolveInjections(injectOptions, ctx, checkDuplicateProperties = shared_esm_bundler_NOOP) {\n  if (shared_esm_bundler_isArray(injectOptions)) {\n    injectOptions = normalizeInject(injectOptions);\n  }\n  for (const key in injectOptions) {\n    const opt = injectOptions[key];\n    let injected;\n    if (shared_esm_bundler_isObject(opt)) {\n      if ("default" in opt) {\n        injected = runtime_core_esm_bundler_inject(opt.from || key, opt.default, true\n        /* treat default function as factory */);\n      } else {\n        injected = runtime_core_esm_bundler_inject(opt.from || key);\n      }\n    } else {\n      injected = runtime_core_esm_bundler_inject(opt);\n    }\n    if (reactivity_esm_bundler_isRef(injected)) {\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => injected.value,\n        set: v => injected.value = v\n      });\n    } else {\n      ctx[key] = injected;\n    }\n    if (false) {}\n  }\n}\nfunction callHook(hook, instance, type) {\n  callWithAsyncErrorHandling(shared_esm_bundler_isArray(hook) ? hook.map(h => h.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);\n}\nfunction createWatcher(raw, ctx, publicThis, key) {\n  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];\n  if (shared_esm_bundler_isString(raw)) {\n    const handler = ctx[raw];\n    if (shared_esm_bundler_isFunction(handler)) {\n      watch(getter, handler);\n    } else if (false) {}\n  } else if (shared_esm_bundler_isFunction(raw)) {\n    watch(getter, raw.bind(publicThis));\n  } else if (shared_esm_bundler_isObject(raw)) {\n    if (shared_esm_bundler_isArray(raw)) {\n      raw.forEach(r => createWatcher(r, ctx, publicThis, key));\n    } else {\n      const handler = shared_esm_bundler_isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];\n      if (shared_esm_bundler_isFunction(handler)) {\n        watch(getter, handler, raw);\n      } else if (false) {}\n    }\n  } else if (false) {}\n}\nfunction resolveMergedOptions(instance) {\n  const base = instance.type;\n  const {\n    mixins,\n    extends: extendsOptions\n  } = base;\n  const {\n    mixins: globalMixins,\n    optionsCache: cache,\n    config: {\n      optionMergeStrategies\n    }\n  } = instance.appContext;\n  const cached = cache.get(base);\n  let resolved;\n  if (cached) {\n    resolved = cached;\n  } else if (!globalMixins.length && !mixins && !extendsOptions) {\n    {\n      resolved = base;\n    }\n  } else {\n    resolved = {};\n    if (globalMixins.length) {\n      globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));\n    }\n    mergeOptions(resolved, base, optionMergeStrategies);\n  }\n  if (shared_esm_bundler_isObject(base)) {\n    cache.set(base, resolved);\n  }\n  return resolved;\n}\nfunction mergeOptions(to, from, strats, asMixin = false) {\n  const {\n    mixins,\n    extends: extendsOptions\n  } = from;\n  if (extendsOptions) {\n    mergeOptions(to, extendsOptions, strats, true);\n  }\n  if (mixins) {\n    mixins.forEach(m => mergeOptions(to, m, strats, true));\n  }\n  for (const key in from) {\n    if (asMixin && key === "expose") {\n       false && 0;\n    } else {\n      const strat = internalOptionMergeStrats[key] || strats && strats[key];\n      to[key] = strat ? strat(to[key], from[key]) : from[key];\n    }\n  }\n  return to;\n}\nconst internalOptionMergeStrats = {\n  data: mergeDataFn,\n  props: mergeEmitsOrPropsOptions,\n  emits: mergeEmitsOrPropsOptions,\n  // objects\n  methods: mergeObjectOptions,\n  computed: mergeObjectOptions,\n  // lifecycle\n  beforeCreate: mergeAsArray,\n  created: mergeAsArray,\n  beforeMount: mergeAsArray,\n  mounted: mergeAsArray,\n  beforeUpdate: mergeAsArray,\n  updated: mergeAsArray,\n  beforeDestroy: mergeAsArray,\n  beforeUnmount: mergeAsArray,\n  destroyed: mergeAsArray,\n  unmounted: mergeAsArray,\n  activated: mergeAsArray,\n  deactivated: mergeAsArray,\n  errorCaptured: mergeAsArray,\n  serverPrefetch: mergeAsArray,\n  // assets\n  components: mergeObjectOptions,\n  directives: mergeObjectOptions,\n  // watch\n  watch: mergeWatchOptions,\n  // provide / inject\n  provide: mergeDataFn,\n  inject: mergeInject\n};\nfunction mergeDataFn(to, from) {\n  if (!from) {\n    return to;\n  }\n  if (!to) {\n    return from;\n  }\n  return function mergedDataFn() {\n    return shared_esm_bundler_extend(shared_esm_bundler_isFunction(to) ? to.call(this, this) : to, shared_esm_bundler_isFunction(from) ? from.call(this, this) : from);\n  };\n}\nfunction mergeInject(to, from) {\n  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));\n}\nfunction normalizeInject(raw) {\n  if (shared_esm_bundler_isArray(raw)) {\n    const res = {};\n    for (let i = 0; i < raw.length; i++) {\n      res[raw[i]] = raw[i];\n    }\n    return res;\n  }\n  return raw;\n}\nfunction mergeAsArray(to, from) {\n  return to ? [...new Set([].concat(to, from))] : from;\n}\nfunction mergeObjectOptions(to, from) {\n  return to ? shared_esm_bundler_extend( /* @__PURE__ */Object.create(null), to, from) : from;\n}\nfunction mergeEmitsOrPropsOptions(to, from) {\n  if (to) {\n    if (shared_esm_bundler_isArray(to) && shared_esm_bundler_isArray(from)) {\n      return [... /* @__PURE__ */new Set([...to, ...from])];\n    }\n    return shared_esm_bundler_extend( /* @__PURE__ */Object.create(null), normalizePropsOrEmits(to), normalizePropsOrEmits(from != null ? from : {}));\n  } else {\n    return from;\n  }\n}\nfunction mergeWatchOptions(to, from) {\n  if (!to) return from;\n  if (!from) return to;\n  const merged = shared_esm_bundler_extend( /* @__PURE__ */Object.create(null), to);\n  for (const key in from) {\n    merged[key] = mergeAsArray(to[key], from[key]);\n  }\n  return merged;\n}\nfunction createAppContext() {\n  return {\n    app: null,\n    config: {\n      isNativeTag: shared_esm_bundler_NO,\n      performance: false,\n      globalProperties: {},\n      optionMergeStrategies: {},\n      errorHandler: void 0,\n      warnHandler: void 0,\n      compilerOptions: {}\n    },\n    mixins: [],\n    components: {},\n    directives: {},\n    provides: /* @__PURE__ */Object.create(null),\n    optionsCache: /* @__PURE__ */new WeakMap(),\n    propsCache: /* @__PURE__ */new WeakMap(),\n    emitsCache: /* @__PURE__ */new WeakMap()\n  };\n}\nlet uid$1 = 0;\nfunction createAppAPI(render, hydrate) {\n  return function createApp(rootComponent, rootProps = null) {\n    if (!shared_esm_bundler_isFunction(rootComponent)) {\n      rootComponent = shared_esm_bundler_extend({}, rootComponent);\n    }\n    if (rootProps != null && !shared_esm_bundler_isObject(rootProps)) {\n       false && 0;\n      rootProps = null;\n    }\n    const context = createAppContext();\n    if (false) {}\n    const installedPlugins = /* @__PURE__ */new Set();\n    let isMounted = false;\n    const app = context.app = {\n      _uid: uid$1++,\n      _component: rootComponent,\n      _props: rootProps,\n      _container: null,\n      _context: context,\n      _instance: null,\n      version,\n      get config() {\n        return context.config;\n      },\n      set config(v) {\n        if (false) {}\n      },\n      use(plugin, ...options) {\n        if (installedPlugins.has(plugin)) {\n           false && 0;\n        } else if (plugin && shared_esm_bundler_isFunction(plugin.install)) {\n          installedPlugins.add(plugin);\n          plugin.install(app, ...options);\n        } else if (shared_esm_bundler_isFunction(plugin)) {\n          installedPlugins.add(plugin);\n          plugin(app, ...options);\n        } else if (false) {}\n        return app;\n      },\n      mixin(mixin) {\n        if (__VUE_OPTIONS_API__) {\n          if (!context.mixins.includes(mixin)) {\n            context.mixins.push(mixin);\n          } else if (false) {}\n        } else if (false) {}\n        return app;\n      },\n      component(name, component) {\n        if (false) {}\n        if (!component) {\n          return context.components[name];\n        }\n        if (false) {}\n        context.components[name] = component;\n        return app;\n      },\n      directive(name, directive) {\n        if (false) {}\n        if (!directive) {\n          return context.directives[name];\n        }\n        if (false) {}\n        context.directives[name] = directive;\n        return app;\n      },\n      mount(rootContainer, isHydrate, isSVG) {\n        if (!isMounted) {\n          if (false) {}\n          const vnode = runtime_core_esm_bundler_createVNode(rootComponent, rootProps);\n          vnode.appContext = context;\n          if (false) {}\n          if (isHydrate && hydrate) {\n            hydrate(vnode, rootContainer);\n          } else {\n            render(vnode, rootContainer, isSVG);\n          }\n          isMounted = true;\n          app._container = rootContainer;\n          rootContainer.__vue_app__ = app;\n          if ( false || __VUE_PROD_DEVTOOLS__) {\n            app._instance = vnode.component;\n            devtoolsInitApp(app, version);\n          }\n          return getExposeProxy(vnode.component) || vnode.component.proxy;\n        } else if (false) {}\n      },\n      unmount() {\n        if (isMounted) {\n          render(null, app._container);\n          if ( false || __VUE_PROD_DEVTOOLS__) {\n            app._instance = null;\n            devtoolsUnmountApp(app);\n          }\n          delete app._container.__vue_app__;\n        } else if (false) {}\n      },\n      provide(key, value) {\n        if (false) {}\n        context.provides[key] = value;\n        return app;\n      },\n      runWithContext(fn) {\n        currentApp = app;\n        try {\n          return fn();\n        } finally {\n          currentApp = null;\n        }\n      }\n    };\n    return app;\n  };\n}\nlet currentApp = null;\nfunction provide(key, value) {\n  if (!currentInstance) {\n    if (false) {}\n  } else {\n    let provides = currentInstance.provides;\n    const parentProvides = currentInstance.parent && currentInstance.parent.provides;\n    if (parentProvides === provides) {\n      provides = currentInstance.provides = Object.create(parentProvides);\n    }\n    provides[key] = value;\n  }\n}\nfunction runtime_core_esm_bundler_inject(key, defaultValue, treatDefaultAsFactory = false) {\n  const instance = currentInstance || currentRenderingInstance;\n  if (instance || currentApp) {\n    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;\n    if (provides && key in provides) {\n      return provides[key];\n    } else if (arguments.length > 1) {\n      return treatDefaultAsFactory && shared_esm_bundler_isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;\n    } else if (false) {}\n  } else if (false) {}\n}\nfunction hasInjectionContext() {\n  return !!(currentInstance || currentRenderingInstance || currentApp);\n}\nfunction initProps(instance, rawProps, isStateful, isSSR = false) {\n  const props = {};\n  const attrs = {};\n  def(attrs, InternalObjectKey, 1);\n  instance.propsDefaults = /* @__PURE__ */Object.create(null);\n  setFullProps(instance, rawProps, props, attrs);\n  for (const key in instance.propsOptions[0]) {\n    if (!(key in props)) {\n      props[key] = void 0;\n    }\n  }\n  if (false) {}\n  if (isStateful) {\n    instance.props = isSSR ? props : shallowReactive(props);\n  } else {\n    if (!instance.type.props) {\n      instance.props = attrs;\n    } else {\n      instance.props = props;\n    }\n  }\n  instance.attrs = attrs;\n}\nfunction isInHmrContext(instance) {\n  while (instance) {\n    if (instance.type.__hmrId) return true;\n    instance = instance.parent;\n  }\n}\nfunction updateProps(instance, rawProps, rawPrevProps, optimized) {\n  const {\n    props,\n    attrs,\n    vnode: {\n      patchFlag\n    }\n  } = instance;\n  const rawCurrentProps = reactivity_esm_bundler_toRaw(props);\n  const [options] = instance.propsOptions;\n  let hasAttrsChanged = false;\n  if (\n  // always force full diff in dev\n  // - #1942 if hmr is enabled with sfc component\n  // - vite#872 non-sfc component used by sfc component\n   true && (optimized || patchFlag > 0) && !(patchFlag & 16)) {\n    if (patchFlag & 8) {\n      const propsToUpdate = instance.vnode.dynamicProps;\n      for (let i = 0; i < propsToUpdate.length; i++) {\n        let key = propsToUpdate[i];\n        if (isEmitListener(instance.emitsOptions, key)) {\n          continue;\n        }\n        const value = rawProps[key];\n        if (options) {\n          if (shared_esm_bundler_hasOwn(attrs, key)) {\n            if (value !== attrs[key]) {\n              attrs[key] = value;\n              hasAttrsChanged = true;\n            }\n          } else {\n            const camelizedKey = camelize(key);\n            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false\n            /* isAbsent */);\n          }\n        } else {\n          if (value !== attrs[key]) {\n            attrs[key] = value;\n            hasAttrsChanged = true;\n          }\n        }\n      }\n    }\n  } else {\n    if (setFullProps(instance, rawProps, props, attrs)) {\n      hasAttrsChanged = true;\n    }\n    let kebabKey;\n    for (const key in rawCurrentProps) {\n      if (!rawProps ||\n      // for camelCase\n      !shared_esm_bundler_hasOwn(rawProps, key) && (\n      // it\'s possible the original props was passed in as kebab-case\n      // and converted to camelCase (#955)\n      (kebabKey = shared_esm_bundler_hyphenate(key)) === key || !shared_esm_bundler_hasOwn(rawProps, kebabKey))) {\n        if (options) {\n          if (rawPrevProps && (\n          // for camelCase\n          rawPrevProps[key] !== void 0 ||\n          // for kebab-case\n          rawPrevProps[kebabKey] !== void 0)) {\n            props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true\n            /* isAbsent */);\n          }\n        } else {\n          delete props[key];\n        }\n      }\n    }\n    if (attrs !== rawCurrentProps) {\n      for (const key in attrs) {\n        if (!rawProps || !shared_esm_bundler_hasOwn(rawProps, key) && true) {\n          delete attrs[key];\n          hasAttrsChanged = true;\n        }\n      }\n    }\n  }\n  if (hasAttrsChanged) {\n    trigger(instance, "set", "$attrs");\n  }\n  if (false) {}\n}\nfunction setFullProps(instance, rawProps, props, attrs) {\n  const [options, needCastKeys] = instance.propsOptions;\n  let hasAttrsChanged = false;\n  let rawCastValues;\n  if (rawProps) {\n    for (let key in rawProps) {\n      if (shared_esm_bundler_isReservedProp(key)) {\n        continue;\n      }\n      const value = rawProps[key];\n      let camelKey;\n      if (options && shared_esm_bundler_hasOwn(options, camelKey = camelize(key))) {\n        if (!needCastKeys || !needCastKeys.includes(camelKey)) {\n          props[camelKey] = value;\n        } else {\n          (rawCastValues || (rawCastValues = {}))[camelKey] = value;\n        }\n      } else if (!isEmitListener(instance.emitsOptions, key)) {\n        if (!(key in attrs) || value !== attrs[key]) {\n          attrs[key] = value;\n          hasAttrsChanged = true;\n        }\n      }\n    }\n  }\n  if (needCastKeys) {\n    const rawCurrentProps = reactivity_esm_bundler_toRaw(props);\n    const castValues = rawCastValues || shared_esm_bundler_EMPTY_OBJ;\n    for (let i = 0; i < needCastKeys.length; i++) {\n      const key = needCastKeys[i];\n      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !shared_esm_bundler_hasOwn(castValues, key));\n    }\n  }\n  return hasAttrsChanged;\n}\nfunction resolvePropValue(options, props, key, value, instance, isAbsent) {\n  const opt = options[key];\n  if (opt != null) {\n    const hasDefault = shared_esm_bundler_hasOwn(opt, "default");\n    if (hasDefault && value === void 0) {\n      const defaultValue = opt.default;\n      if (opt.type !== Function && !opt.skipFactory && shared_esm_bundler_isFunction(defaultValue)) {\n        const {\n          propsDefaults\n        } = instance;\n        if (key in propsDefaults) {\n          value = propsDefaults[key];\n        } else {\n          setCurrentInstance(instance);\n          value = propsDefaults[key] = defaultValue.call(null, props);\n          unsetCurrentInstance();\n        }\n      } else {\n        value = defaultValue;\n      }\n    }\n    if (opt[0 /* shouldCast */]) {\n      if (isAbsent && !hasDefault) {\n        value = false;\n      } else if (opt[1 /* shouldCastTrue */] && (value === "" || value === shared_esm_bundler_hyphenate(key))) {\n        value = true;\n      }\n    }\n  }\n  return value;\n}\nfunction normalizePropsOptions(comp, appContext, asMixin = false) {\n  const cache = appContext.propsCache;\n  const cached = cache.get(comp);\n  if (cached) {\n    return cached;\n  }\n  const raw = comp.props;\n  const normalized = {};\n  const needCastKeys = [];\n  let hasExtends = false;\n  if (__VUE_OPTIONS_API__ && !shared_esm_bundler_isFunction(comp)) {\n    const extendProps = raw2 => {\n      hasExtends = true;\n      const [props, keys] = normalizePropsOptions(raw2, appContext, true);\n      shared_esm_bundler_extend(normalized, props);\n      if (keys) needCastKeys.push(...keys);\n    };\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendProps);\n    }\n    if (comp.extends) {\n      extendProps(comp.extends);\n    }\n    if (comp.mixins) {\n      comp.mixins.forEach(extendProps);\n    }\n  }\n  if (!raw && !hasExtends) {\n    if (shared_esm_bundler_isObject(comp)) {\n      cache.set(comp, EMPTY_ARR);\n    }\n    return EMPTY_ARR;\n  }\n  if (shared_esm_bundler_isArray(raw)) {\n    for (let i = 0; i < raw.length; i++) {\n      if (false) {}\n      const normalizedKey = camelize(raw[i]);\n      if (validatePropName(normalizedKey)) {\n        normalized[normalizedKey] = shared_esm_bundler_EMPTY_OBJ;\n      }\n    }\n  } else if (raw) {\n    if (false) {}\n    for (const key in raw) {\n      const normalizedKey = camelize(key);\n      if (validatePropName(normalizedKey)) {\n        const opt = raw[key];\n        const prop = normalized[normalizedKey] = shared_esm_bundler_isArray(opt) || shared_esm_bundler_isFunction(opt) ? {\n          type: opt\n        } : shared_esm_bundler_extend({}, opt);\n        if (prop) {\n          const booleanIndex = getTypeIndex(Boolean, prop.type);\n          const stringIndex = getTypeIndex(String, prop.type);\n          prop[0 /* shouldCast */] = booleanIndex > -1;\n          prop[1 /* shouldCastTrue */] = stringIndex < 0 || booleanIndex < stringIndex;\n          if (booleanIndex > -1 || shared_esm_bundler_hasOwn(prop, "default")) {\n            needCastKeys.push(normalizedKey);\n          }\n        }\n      }\n    }\n  }\n  const res = [normalized, needCastKeys];\n  if (shared_esm_bundler_isObject(comp)) {\n    cache.set(comp, res);\n  }\n  return res;\n}\nfunction validatePropName(key) {\n  if (key[0] !== "$") {\n    return true;\n  } else if (false) {}\n  return false;\n}\nfunction getType(ctor) {\n  const match = ctor && ctor.toString().match(/^\\s*(function|class) (\\w+)/);\n  return match ? match[2] : ctor === null ? "null" : "";\n}\nfunction isSameType(a, b) {\n  return getType(a) === getType(b);\n}\nfunction getTypeIndex(type, expectedTypes) {\n  if (shared_esm_bundler_isArray(expectedTypes)) {\n    return expectedTypes.findIndex(t => isSameType(t, type));\n  } else if (shared_esm_bundler_isFunction(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1;\n  }\n  return -1;\n}\nfunction validateProps(rawProps, props, instance) {\n  const resolvedValues = toRaw(props);\n  const options = instance.propsOptions[0];\n  for (const key in options) {\n    let opt = options[key];\n    if (opt == null) continue;\n    validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)));\n  }\n}\nfunction validateProp(name, value, prop, isAbsent) {\n  const {\n    type,\n    required,\n    validator,\n    skipCheck\n  } = prop;\n  if (required && isAbsent) {\n    runtime_core_esm_bundler_warn(\'Missing required prop: "\' + name + \'"\');\n    return;\n  }\n  if (value == null && !required) {\n    return;\n  }\n  if (type != null && type !== true && !skipCheck) {\n    let isValid = false;\n    const types = isArray(type) ? type : [type];\n    const expectedTypes = [];\n    for (let i = 0; i < types.length && !isValid; i++) {\n      const {\n        valid,\n        expectedType\n      } = assertType(value, types[i]);\n      expectedTypes.push(expectedType || "");\n      isValid = valid;\n    }\n    if (!isValid) {\n      runtime_core_esm_bundler_warn(getInvalidTypeMessage(name, value, expectedTypes));\n      return;\n    }\n  }\n  if (validator && !validator(value)) {\n    runtime_core_esm_bundler_warn(\'Invalid prop: custom validator check failed for prop "\' + name + \'".\');\n  }\n}\nconst isSimpleType = /* @__PURE__ */(/* unused pure expression or super */ null && (makeMap("String,Number,Boolean,Function,Symbol,BigInt")));\nfunction assertType(value, type) {\n  let valid;\n  const expectedType = getType(type);\n  if (isSimpleType(expectedType)) {\n    const t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    if (!valid && t === "object") {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === "Object") {\n    valid = isObject(value);\n  } else if (expectedType === "Array") {\n    valid = isArray(value);\n  } else if (expectedType === "null") {\n    valid = value === null;\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid,\n    expectedType\n  };\n}\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\n  let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;\n  const expectedType = expectedTypes[0];\n  const receivedType = toRawType(value);\n  const expectedValue = styleValue(value, expectedType);\n  const receivedValue = styleValue(value, receivedType);\n  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {\n    message += ` with value ${expectedValue}`;\n  }\n  message += `, got ${receivedType} `;\n  if (isExplicable(receivedType)) {\n    message += `with value ${receivedValue}.`;\n  }\n  return message;\n}\nfunction styleValue(value, type) {\n  if (type === "String") {\n    return `"${value}"`;\n  } else if (type === "Number") {\n    return `${Number(value)}`;\n  } else {\n    return `${value}`;\n  }\n}\nfunction isExplicable(type) {\n  const explicitTypes = ["string", "number", "boolean"];\n  return explicitTypes.some(elem => type.toLowerCase() === elem);\n}\nfunction isBoolean(...args) {\n  return args.some(elem => elem.toLowerCase() === "boolean");\n}\nconst isInternalKey = key => key[0] === "_" || key === "$stable";\nconst normalizeSlotValue = value => shared_esm_bundler_isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];\nconst normalizeSlot = (key, rawSlot, ctx) => {\n  if (rawSlot._n) {\n    return rawSlot;\n  }\n  const normalized = withCtx((...args) => {\n    if (false) {}\n    return normalizeSlotValue(rawSlot(...args));\n  }, ctx);\n  normalized._c = false;\n  return normalized;\n};\nconst normalizeObjectSlots = (rawSlots, slots, instance) => {\n  const ctx = rawSlots._ctx;\n  for (const key in rawSlots) {\n    if (isInternalKey(key)) continue;\n    const value = rawSlots[key];\n    if (shared_esm_bundler_isFunction(value)) {\n      slots[key] = normalizeSlot(key, value, ctx);\n    } else if (value != null) {\n      if (false) {}\n      const normalized = normalizeSlotValue(value);\n      slots[key] = () => normalized;\n    }\n  }\n};\nconst normalizeVNodeSlots = (instance, children) => {\n  if (false) {}\n  const normalized = normalizeSlotValue(children);\n  instance.slots.default = () => normalized;\n};\nconst initSlots = (instance, children) => {\n  if (instance.vnode.shapeFlag & 32) {\n    const type = children._;\n    if (type) {\n      instance.slots = reactivity_esm_bundler_toRaw(children);\n      def(children, "_", type);\n    } else {\n      normalizeObjectSlots(children, instance.slots = {});\n    }\n  } else {\n    instance.slots = {};\n    if (children) {\n      normalizeVNodeSlots(instance, children);\n    }\n  }\n  def(instance.slots, InternalObjectKey, 1);\n};\nconst updateSlots = (instance, children, optimized) => {\n  const {\n    vnode,\n    slots\n  } = instance;\n  let needDeletionCheck = true;\n  let deletionComparisonTarget = shared_esm_bundler_EMPTY_OBJ;\n  if (vnode.shapeFlag & 32) {\n    const type = children._;\n    if (type) {\n      if (false) {} else if (optimized && type === 1) {\n        needDeletionCheck = false;\n      } else {\n        shared_esm_bundler_extend(slots, children);\n        if (!optimized && type === 1) {\n          delete slots._;\n        }\n      }\n    } else {\n      needDeletionCheck = !children.$stable;\n      normalizeObjectSlots(children, slots);\n    }\n    deletionComparisonTarget = children;\n  } else if (children) {\n    normalizeVNodeSlots(instance, children);\n    deletionComparisonTarget = {\n      default: 1\n    };\n  }\n  if (needDeletionCheck) {\n    for (const key in slots) {\n      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {\n        delete slots[key];\n      }\n    }\n  }\n};\nfunction setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {\n  if (shared_esm_bundler_isArray(rawRef)) {\n    rawRef.forEach((r, i) => setRef(r, oldRawRef && (shared_esm_bundler_isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));\n    return;\n  }\n  if (isAsyncWrapper(vnode) && !isUnmount) {\n    return;\n  }\n  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;\n  const value = isUnmount ? null : refValue;\n  const {\n    i: owner,\n    r: ref\n  } = rawRef;\n  if (false) {}\n  const oldRef = oldRawRef && oldRawRef.r;\n  const refs = owner.refs === shared_esm_bundler_EMPTY_OBJ ? owner.refs = {} : owner.refs;\n  const setupState = owner.setupState;\n  if (oldRef != null && oldRef !== ref) {\n    if (shared_esm_bundler_isString(oldRef)) {\n      refs[oldRef] = null;\n      if (shared_esm_bundler_hasOwn(setupState, oldRef)) {\n        setupState[oldRef] = null;\n      }\n    } else if (reactivity_esm_bundler_isRef(oldRef)) {\n      oldRef.value = null;\n    }\n  }\n  if (shared_esm_bundler_isFunction(ref)) {\n    callWithErrorHandling(ref, owner, 12, [value, refs]);\n  } else {\n    const _isString = shared_esm_bundler_isString(ref);\n    const _isRef = reactivity_esm_bundler_isRef(ref);\n    if (_isString || _isRef) {\n      const doSet = () => {\n        if (rawRef.f) {\n          const existing = _isString ? shared_esm_bundler_hasOwn(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;\n          if (isUnmount) {\n            shared_esm_bundler_isArray(existing) && remove(existing, refValue);\n          } else {\n            if (!shared_esm_bundler_isArray(existing)) {\n              if (_isString) {\n                refs[ref] = [refValue];\n                if (shared_esm_bundler_hasOwn(setupState, ref)) {\n                  setupState[ref] = refs[ref];\n                }\n              } else {\n                ref.value = [refValue];\n                if (rawRef.k) refs[rawRef.k] = ref.value;\n              }\n            } else if (!existing.includes(refValue)) {\n              existing.push(refValue);\n            }\n          }\n        } else if (_isString) {\n          refs[ref] = value;\n          if (shared_esm_bundler_hasOwn(setupState, ref)) {\n            setupState[ref] = value;\n          }\n        } else if (_isRef) {\n          ref.value = value;\n          if (rawRef.k) refs[rawRef.k] = value;\n        } else if (false) {}\n      };\n      if (value) {\n        doSet.id = -1;\n        queuePostRenderEffect(doSet, parentSuspense);\n      } else {\n        doSet();\n      }\n    } else if (false) {}\n  }\n}\nlet hasMismatch = false;\nconst isSVGContainer = container => /svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";\nconst isComment = node => node.nodeType === 8 /* COMMENT */;\nfunction createHydrationFunctions(rendererInternals) {\n  const {\n    mt: mountComponent,\n    p: patch,\n    o: {\n      patchProp,\n      createText,\n      nextSibling,\n      parentNode,\n      remove,\n      insert,\n      createComment\n    }\n  } = rendererInternals;\n  const hydrate = (vnode, container) => {\n    if (!container.hasChildNodes()) {\n       false && 0;\n      patch(null, vnode, container);\n      flushPostFlushCbs();\n      container._vnode = vnode;\n      return;\n    }\n    hasMismatch = false;\n    hydrateNode(container.firstChild, vnode, null, null, null);\n    flushPostFlushCbs();\n    container._vnode = vnode;\n    if (hasMismatch && true) {\n      console.error(`Hydration completed but contains mismatches.`);\n    }\n  };\n  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {\n    const isFragmentStart = isComment(node) && node.data === "[";\n    const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);\n    const {\n      type,\n      ref,\n      shapeFlag,\n      patchFlag\n    } = vnode;\n    let domType = node.nodeType;\n    vnode.el = node;\n    if (patchFlag === -2) {\n      optimized = false;\n      vnode.dynamicChildren = null;\n    }\n    let nextNode = null;\n    switch (type) {\n      case Text:\n        if (domType !== 3 /* TEXT */) {\n          if (vnode.children === "") {\n            insert(vnode.el = createText(""), parentNode(node), node);\n            nextNode = node;\n          } else {\n            nextNode = onMismatch();\n          }\n        } else {\n          if (node.data !== vnode.children) {\n            hasMismatch = true;\n             false && 0;\n            node.data = vnode.children;\n          }\n          nextNode = nextSibling(node);\n        }\n        break;\n      case Comment:\n        if (domType !== 8 /* COMMENT */ || isFragmentStart) {\n          nextNode = onMismatch();\n        } else {\n          nextNode = nextSibling(node);\n        }\n        break;\n      case runtime_core_esm_bundler_Static:\n        if (isFragmentStart) {\n          node = nextSibling(node);\n          domType = node.nodeType;\n        }\n        if (domType === 1 /* ELEMENT */ || domType === 3 /* TEXT */) {\n          nextNode = node;\n          const needToAdoptContent = !vnode.children.length;\n          for (let i = 0; i < vnode.staticCount; i++) {\n            if (needToAdoptContent) vnode.children += nextNode.nodeType === 1 /* ELEMENT */ ? nextNode.outerHTML : nextNode.data;\n            if (i === vnode.staticCount - 1) {\n              vnode.anchor = nextNode;\n            }\n            nextNode = nextSibling(nextNode);\n          }\n          return isFragmentStart ? nextSibling(nextNode) : nextNode;\n        } else {\n          onMismatch();\n        }\n        break;\n      case runtime_core_esm_bundler_Fragment:\n        if (!isFragmentStart) {\n          nextNode = onMismatch();\n        } else {\n          nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\n        }\n        break;\n      default:\n        if (shapeFlag & 1) {\n          if (domType !== 1 /* ELEMENT */ || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {\n            nextNode = onMismatch();\n          } else {\n            nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\n          }\n        } else if (shapeFlag & 6) {\n          vnode.slotScopeIds = slotScopeIds;\n          const container = parentNode(node);\n          mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);\n          nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);\n          if (nextNode && isComment(nextNode) && nextNode.data === "teleport end") {\n            nextNode = nextSibling(nextNode);\n          }\n          if (isAsyncWrapper(vnode)) {\n            let subTree;\n            if (isFragmentStart) {\n              subTree = runtime_core_esm_bundler_createVNode(runtime_core_esm_bundler_Fragment);\n              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;\n            } else {\n              subTree = node.nodeType === 3 ? createTextVNode("") : runtime_core_esm_bundler_createVNode("div");\n            }\n            subTree.el = node;\n            vnode.component.subTree = subTree;\n          }\n        } else if (shapeFlag & 64) {\n          if (domType !== 8 /* COMMENT */) {\n            nextNode = onMismatch();\n          } else {\n            nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);\n          }\n        } else if (shapeFlag & 128) {\n          nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);\n        } else if (false) {}\n    }\n    if (ref != null) {\n      setRef(ref, null, parentSuspense, vnode);\n    }\n    return nextNode;\n  };\n  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    optimized = optimized || !!vnode.dynamicChildren;\n    const {\n      type,\n      props,\n      patchFlag,\n      shapeFlag,\n      dirs\n    } = vnode;\n    const forcePatchValue = type === "input" && dirs || type === "option";\n    if ( false || forcePatchValue || patchFlag !== -1) {\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, "created");\n      }\n      if (props) {\n        if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {\n          for (const key in props) {\n            if (forcePatchValue && key.endsWith("value") || isOn(key) && !isReservedProp(key)) {\n              patchProp(el, key, null, props[key], false, void 0, parentComponent);\n            }\n          }\n        } else if (props.onClick) {\n          patchProp(el, "onClick", null, props.onClick, false, void 0, parentComponent);\n        }\n      }\n      let vnodeHooks;\n      if (vnodeHooks = props && props.onVnodeBeforeMount) {\n        invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n      }\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");\n      }\n      if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {\n        queueEffectWithSuspense(() => {\n          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");\n        }, parentSuspense);\n      }\n      if (shapeFlag & 16 &&\n      // skip if element has innerHTML / textContent\n      !(props && (props.innerHTML || props.textContent))) {\n        let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);\n        let hasWarned = false;\n        while (next) {\n          hasMismatch = true;\n          if (false) {}\n          const cur = next;\n          next = next.nextSibling;\n          remove(cur);\n        }\n      } else if (shapeFlag & 8) {\n        if (el.textContent !== vnode.children) {\n          hasMismatch = true;\n           false && 0;\n          el.textContent = vnode.children;\n        }\n      }\n    }\n    return el.nextSibling;\n  };\n  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    optimized = optimized || !!parentVNode.dynamicChildren;\n    const children = parentVNode.children;\n    const l = children.length;\n    let hasWarned = false;\n    for (let i = 0; i < l; i++) {\n      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);\n      if (node) {\n        node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\n      } else if (vnode.type === Text && !vnode.children) {\n        continue;\n      } else {\n        hasMismatch = true;\n        if (false) {}\n        patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);\n      }\n    }\n    return node;\n  };\n  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    const {\n      slotScopeIds: fragmentSlotScopeIds\n    } = vnode;\n    if (fragmentSlotScopeIds) {\n      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;\n    }\n    const container = parentNode(node);\n    const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);\n    if (next && isComment(next) && next.data === "]") {\n      return nextSibling(vnode.anchor = next);\n    } else {\n      hasMismatch = true;\n      insert(vnode.anchor = createComment(`]`), container, next);\n      return next;\n    }\n  };\n  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {\n    hasMismatch = true;\n     false && 0;\n    vnode.el = null;\n    if (isFragment) {\n      const end = locateClosingAsyncAnchor(node);\n      while (true) {\n        const next2 = nextSibling(node);\n        if (next2 && next2 !== end) {\n          remove(next2);\n        } else {\n          break;\n        }\n      }\n    }\n    const next = nextSibling(node);\n    const container = parentNode(node);\n    remove(node);\n    patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);\n    return next;\n  };\n  const locateClosingAsyncAnchor = node => {\n    let match = 0;\n    while (node) {\n      node = nextSibling(node);\n      if (node && isComment(node)) {\n        if (node.data === "[") match++;\n        if (node.data === "]") {\n          if (match === 0) {\n            return nextSibling(node);\n          } else {\n            match--;\n          }\n        }\n      }\n    }\n    return node;\n  };\n  return [hydrate, hydrateNode];\n}\nlet supported;\nlet perf;\nfunction startMeasure(instance, type) {\n  if (instance.appContext.config.performance && isSupported()) {\n    perf.mark(`vue-${type}-${instance.uid}`);\n  }\n  if ( false || __VUE_PROD_DEVTOOLS__) {\n    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());\n  }\n}\nfunction endMeasure(instance, type) {\n  if (instance.appContext.config.performance && isSupported()) {\n    const startTag = `vue-${type}-${instance.uid}`;\n    const endTag = startTag + `:end`;\n    perf.mark(endTag);\n    perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);\n    perf.clearMarks(startTag);\n    perf.clearMarks(endTag);\n  }\n  if ( false || __VUE_PROD_DEVTOOLS__) {\n    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());\n  }\n}\nfunction isSupported() {\n  if (supported !== void 0) {\n    return supported;\n  }\n  if (typeof window !== "undefined" && window.performance) {\n    supported = true;\n    perf = window.performance;\n  } else {\n    supported = false;\n  }\n  return supported;\n}\nfunction initFeatureFlags() {\n  const needWarn = [];\n  if (typeof __VUE_OPTIONS_API__ !== "boolean") {\n     false && 0;\n    getGlobalThis().__VUE_OPTIONS_API__ = true;\n  }\n  if (typeof __VUE_PROD_DEVTOOLS__ !== "boolean") {\n     false && 0;\n    getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;\n  }\n  if (false) {}\n}\nconst queuePostRenderEffect = queueEffectWithSuspense;\nfunction createRenderer(options) {\n  return baseCreateRenderer(options);\n}\nfunction runtime_core_esm_bundler_createHydrationRenderer(options) {\n  return baseCreateRenderer(options, createHydrationFunctions);\n}\nfunction baseCreateRenderer(options, createHydrationFns) {\n  {\n    initFeatureFlags();\n  }\n  const target = getGlobalThis();\n  target.__VUE__ = true;\n  if ( false || __VUE_PROD_DEVTOOLS__) {\n    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);\n  }\n  const {\n    insert: hostInsert,\n    remove: hostRemove,\n    patchProp: hostPatchProp,\n    createElement: hostCreateElement,\n    createText: hostCreateText,\n    createComment: hostCreateComment,\n    setText: hostSetText,\n    setElementText: hostSetElementText,\n    parentNode: hostParentNode,\n    nextSibling: hostNextSibling,\n    setScopeId: hostSetScopeId = shared_esm_bundler_NOOP,\n    insertStaticContent: hostInsertStaticContent\n  } = options;\n  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized =  false ? 0 : !!n2.dynamicChildren) => {\n    if (n1 === n2) {\n      return;\n    }\n    if (n1 && !isSameVNodeType(n1, n2)) {\n      anchor = getNextHostNode(n1);\n      unmount(n1, parentComponent, parentSuspense, true);\n      n1 = null;\n    }\n    if (n2.patchFlag === -2) {\n      optimized = false;\n      n2.dynamicChildren = null;\n    }\n    const {\n      type,\n      ref,\n      shapeFlag\n    } = n2;\n    switch (type) {\n      case Text:\n        processText(n1, n2, container, anchor);\n        break;\n      case Comment:\n        processCommentNode(n1, n2, container, anchor);\n        break;\n      case runtime_core_esm_bundler_Static:\n        if (n1 == null) {\n          mountStaticNode(n2, container, anchor, isSVG);\n        } else if (false) {}\n        break;\n      case runtime_core_esm_bundler_Fragment:\n        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        break;\n      default:\n        if (shapeFlag & 1) {\n          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        } else if (shapeFlag & 6) {\n          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        } else if (shapeFlag & 64) {\n          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);\n        } else if (shapeFlag & 128) {\n          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);\n        } else if (false) {}\n    }\n    if (ref != null && parentComponent) {\n      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);\n    }\n  };\n  const processText = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);\n    } else {\n      const el = n2.el = n1.el;\n      if (n2.children !== n1.children) {\n        hostSetText(el, n2.children);\n      }\n    }\n  };\n  const processCommentNode = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);\n    } else {\n      n2.el = n1.el;\n    }\n  };\n  const mountStaticNode = (n2, container, anchor, isSVG) => {\n    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);\n  };\n  const patchStaticNode = (n1, n2, container, isSVG) => {\n    if (n2.children !== n1.children) {\n      const anchor = hostNextSibling(n1.anchor);\n      removeStaticNode(n1);\n      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\n    } else {\n      n2.el = n1.el;\n      n2.anchor = n1.anchor;\n    }\n  };\n  const moveStaticNode = ({\n    el,\n    anchor\n  }, container, nextSibling) => {\n    let next;\n    while (el && el !== anchor) {\n      next = hostNextSibling(el);\n      hostInsert(el, container, nextSibling);\n      el = next;\n    }\n    hostInsert(anchor, container, nextSibling);\n  };\n  const removeStaticNode = ({\n    el,\n    anchor\n  }) => {\n    let next;\n    while (el && el !== anchor) {\n      next = hostNextSibling(el);\n      hostRemove(el);\n      el = next;\n    }\n    hostRemove(anchor);\n  };\n  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    isSVG = isSVG || n2.type === "svg";\n    if (n1 == null) {\n      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n    } else {\n      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n    }\n  };\n  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    let el;\n    let vnodeHook;\n    const {\n      type,\n      props,\n      shapeFlag,\n      transition,\n      dirs\n    } = vnode;\n    el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);\n    if (shapeFlag & 8) {\n      hostSetElementText(el, vnode.children);\n    } else if (shapeFlag & 16) {\n      mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);\n    }\n    if (dirs) {\n      invokeDirectiveHook(vnode, null, parentComponent, "created");\n    }\n    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);\n    if (props) {\n      for (const key in props) {\n        if (key !== "value" && !shared_esm_bundler_isReservedProp(key)) {\n          hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\n        }\n      }\n      if ("value" in props) {\n        hostPatchProp(el, "value", null, props.value);\n      }\n      if (vnodeHook = props.onVnodeBeforeMount) {\n        invokeVNodeHook(vnodeHook, parentComponent, vnode);\n      }\n    }\n    if ( false || __VUE_PROD_DEVTOOLS__) {\n      Object.defineProperty(el, "__vnode", {\n        value: vnode,\n        enumerable: false\n      });\n      Object.defineProperty(el, "__vueParentComponent", {\n        value: parentComponent,\n        enumerable: false\n      });\n    }\n    if (dirs) {\n      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");\n    }\n    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;\n    if (needCallTransitionHooks) {\n      transition.beforeEnter(el);\n    }\n    hostInsert(el, container, anchor);\n    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        needCallTransitionHooks && transition.enter(el);\n        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");\n      }, parentSuspense);\n    }\n  };\n  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {\n    if (scopeId) {\n      hostSetScopeId(el, scopeId);\n    }\n    if (slotScopeIds) {\n      for (let i = 0; i < slotScopeIds.length; i++) {\n        hostSetScopeId(el, slotScopeIds[i]);\n      }\n    }\n    if (parentComponent) {\n      let subTree = parentComponent.subTree;\n      if (false) {}\n      if (vnode === subTree) {\n        const parentVNode = parentComponent.vnode;\n        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);\n      }\n    }\n  };\n  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {\n    for (let i = start; i < children.length; i++) {\n      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);\n      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n    }\n  };\n  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    const el = n2.el = n1.el;\n    let {\n      patchFlag,\n      dynamicChildren,\n      dirs\n    } = n2;\n    patchFlag |= n1.patchFlag & 16;\n    const oldProps = n1.props || shared_esm_bundler_EMPTY_OBJ;\n    const newProps = n2.props || shared_esm_bundler_EMPTY_OBJ;\n    let vnodeHook;\n    parentComponent && toggleRecurse(parentComponent, false);\n    if (vnodeHook = newProps.onVnodeBeforeUpdate) {\n      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n    }\n    if (dirs) {\n      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");\n    }\n    parentComponent && toggleRecurse(parentComponent, true);\n    if (false) {}\n    const areChildrenSVG = isSVG && n2.type !== "foreignObject";\n    if (dynamicChildren) {\n      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);\n      if (false) {}\n    } else if (!optimized) {\n      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);\n    }\n    if (patchFlag > 0) {\n      if (patchFlag & 16) {\n        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\n      } else {\n        if (patchFlag & 2) {\n          if (oldProps.class !== newProps.class) {\n            hostPatchProp(el, "class", null, newProps.class, isSVG);\n          }\n        }\n        if (patchFlag & 4) {\n          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);\n        }\n        if (patchFlag & 8) {\n          const propsToUpdate = n2.dynamicProps;\n          for (let i = 0; i < propsToUpdate.length; i++) {\n            const key = propsToUpdate[i];\n            const prev = oldProps[key];\n            const next = newProps[key];\n            if (next !== prev || key === "value") {\n              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);\n            }\n          }\n        }\n      }\n      if (patchFlag & 1) {\n        if (n1.children !== n2.children) {\n          hostSetElementText(el, n2.children);\n        }\n      }\n    } else if (!optimized && dynamicChildren == null) {\n      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\n    }\n    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");\n      }, parentSuspense);\n    }\n  };\n  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {\n    for (let i = 0; i < newChildren.length; i++) {\n      const oldVNode = oldChildren[i];\n      const newVNode = newChildren[i];\n      const container =\n      // oldVNode may be an errored async setup() component inside Suspense\n      // which will not have a mounted element\n      oldVNode.el && (\n      // - In the case of a Fragment, we need to provide the actual parent\n      // of the Fragment itself so it can move its children.\n      oldVNode.type === runtime_core_esm_bundler_Fragment ||\n      // - In the case of different nodes, there is going to be a replacement\n      // which also requires the correct parent container\n      !isSameVNodeType(oldVNode, newVNode) ||\n      // - In the case of a component, it could contain anything.\n      oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) :\n      // In other cases, the parent container is not actually used so we\n      // just pass the block element here to avoid a DOM parentNode call.\n      fallbackContainer;\n      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);\n    }\n  };\n  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {\n    if (oldProps !== newProps) {\n      if (oldProps !== shared_esm_bundler_EMPTY_OBJ) {\n        for (const key in oldProps) {\n          if (!shared_esm_bundler_isReservedProp(key) && !(key in newProps)) {\n            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\n          }\n        }\n      }\n      for (const key in newProps) {\n        if (shared_esm_bundler_isReservedProp(key)) continue;\n        const next = newProps[key];\n        const prev = oldProps[key];\n        if (next !== prev && key !== "value") {\n          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\n        }\n      }\n      if ("value" in newProps) {\n        hostPatchProp(el, "value", oldProps.value, newProps.value);\n      }\n    }\n  };\n  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");\n    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");\n    let {\n      patchFlag,\n      dynamicChildren,\n      slotScopeIds: fragmentSlotScopeIds\n    } = n2;\n    if (false) {}\n    if (fragmentSlotScopeIds) {\n      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;\n    }\n    if (n1 == null) {\n      hostInsert(fragmentStartAnchor, container, anchor);\n      hostInsert(fragmentEndAnchor, container, anchor);\n      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n    } else {\n      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren &&\n      // #2715 the previous fragment could\'ve been a BAILed one as a result\n      // of renderSlot() with no valid children\n      n1.dynamicChildren) {\n        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);\n        if (false) {} else if (\n        // #2080 if the stable fragment has a key, it\'s a <template v-for> that may\n        //  get moved around. Make sure all root level vnodes inherit el.\n        // #2134 or if it\'s a component root, it may also get moved around\n        // as the component is being moved.\n        n2.key != null || parentComponent && n2 === parentComponent.subTree) {\n          traverseStaticChildren(n1, n2, true\n          /* shallow */);\n        }\n      } else {\n        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n      }\n    }\n  };\n  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    n2.slotScopeIds = slotScopeIds;\n    if (n1 == null) {\n      if (n2.shapeFlag & 512) {\n        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);\n      } else {\n        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n      }\n    } else {\n      updateComponent(n1, n2, optimized);\n    }\n  };\n  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);\n    if (false) {}\n    if (false) {}\n    if (isKeepAlive(initialVNode)) {\n      instance.ctx.renderer = internals;\n    }\n    {\n      if (false) {}\n      setupComponent(instance);\n      if (false) {}\n    }\n    if (instance.asyncDep) {\n      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);\n      if (!initialVNode.el) {\n        const placeholder = instance.subTree = runtime_core_esm_bundler_createVNode(Comment);\n        processCommentNode(null, placeholder, container, anchor);\n      }\n      return;\n    }\n    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);\n    if (false) {}\n  };\n  const updateComponent = (n1, n2, optimized) => {\n    const instance = n2.component = n1.component;\n    if (shouldUpdateComponent(n1, n2, optimized)) {\n      if (instance.asyncDep && !instance.asyncResolved) {\n        if (false) {}\n        updateComponentPreRender(instance, n2, optimized);\n        if (false) {}\n        return;\n      } else {\n        instance.next = n2;\n        invalidateJob(instance.update);\n        instance.update();\n      }\n    } else {\n      n2.el = n1.el;\n      instance.vnode = n2;\n    }\n  };\n  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n    const componentUpdateFn = () => {\n      if (!instance.isMounted) {\n        let vnodeHook;\n        const {\n          el,\n          props\n        } = initialVNode;\n        const {\n          bm,\n          m,\n          parent\n        } = instance;\n        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);\n        toggleRecurse(instance, false);\n        if (bm) {\n          invokeArrayFns(bm);\n        }\n        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {\n          invokeVNodeHook(vnodeHook, parent, initialVNode);\n        }\n        toggleRecurse(instance, true);\n        if (el && hydrateNode) {\n          const hydrateSubTree = () => {\n            if (false) {}\n            instance.subTree = renderComponentRoot(instance);\n            if (false) {}\n            if (false) {}\n            hydrateNode(el, instance.subTree, instance, parentSuspense, null);\n            if (false) {}\n          };\n          if (isAsyncWrapperVNode) {\n            initialVNode.type.__asyncLoader().then(\n            // note: we are moving the render call into an async callback,\n            // which means it won\'t track dependencies - but it\'s ok because\n            // a server-rendered async wrapper is already in resolved state\n            // and it will never need to change.\n            () => !instance.isUnmounted && hydrateSubTree());\n          } else {\n            hydrateSubTree();\n          }\n        } else {\n          if (false) {}\n          const subTree = instance.subTree = renderComponentRoot(instance);\n          if (false) {}\n          if (false) {}\n          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);\n          if (false) {}\n          initialVNode.el = subTree.el;\n        }\n        if (m) {\n          queuePostRenderEffect(m, parentSuspense);\n        }\n        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {\n          const scopedInitialVNode = initialVNode;\n          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);\n        }\n        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {\n          instance.a && queuePostRenderEffect(instance.a, parentSuspense);\n        }\n        instance.isMounted = true;\n        if ( false || __VUE_PROD_DEVTOOLS__) {\n          devtoolsComponentAdded(instance);\n        }\n        initialVNode = container = anchor = null;\n      } else {\n        let {\n          next,\n          bu,\n          u,\n          parent,\n          vnode\n        } = instance;\n        let originNext = next;\n        let vnodeHook;\n        if (false) {}\n        toggleRecurse(instance, false);\n        if (next) {\n          next.el = vnode.el;\n          updateComponentPreRender(instance, next, optimized);\n        } else {\n          next = vnode;\n        }\n        if (bu) {\n          invokeArrayFns(bu);\n        }\n        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {\n          invokeVNodeHook(vnodeHook, parent, next, vnode);\n        }\n        toggleRecurse(instance, true);\n        if (false) {}\n        const nextTree = renderComponentRoot(instance);\n        if (false) {}\n        const prevTree = instance.subTree;\n        instance.subTree = nextTree;\n        if (false) {}\n        patch(prevTree, nextTree,\n        // parent may have changed if it\'s in a teleport\n        hostParentNode(prevTree.el),\n        // anchor may have changed if it\'s in a fragment\n        getNextHostNode(prevTree), instance, parentSuspense, isSVG);\n        if (false) {}\n        next.el = nextTree.el;\n        if (originNext === null) {\n          updateHOCHostEl(instance, nextTree.el);\n        }\n        if (u) {\n          queuePostRenderEffect(u, parentSuspense);\n        }\n        if (vnodeHook = next.props && next.props.onVnodeUpdated) {\n          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);\n        }\n        if ( false || __VUE_PROD_DEVTOOLS__) {\n          devtoolsComponentUpdated(instance);\n        }\n        if (false) {}\n      }\n    };\n    const effect = instance.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(update), instance.scope\n    // track it in component\'s effect scope\n    );\n\n    const update = instance.update = () => effect.run();\n    update.id = instance.uid;\n    toggleRecurse(instance, true);\n    if (false) {}\n    update();\n  };\n  const updateComponentPreRender = (instance, nextVNode, optimized) => {\n    nextVNode.component = instance;\n    const prevProps = instance.vnode.props;\n    instance.vnode = nextVNode;\n    instance.next = null;\n    updateProps(instance, nextVNode.props, prevProps, optimized);\n    updateSlots(instance, nextVNode.children, optimized);\n    pauseTracking();\n    flushPreFlushCbs();\n    resetTracking();\n  };\n  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {\n    const c1 = n1 && n1.children;\n    const prevShapeFlag = n1 ? n1.shapeFlag : 0;\n    const c2 = n2.children;\n    const {\n      patchFlag,\n      shapeFlag\n    } = n2;\n    if (patchFlag > 0) {\n      if (patchFlag & 128) {\n        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        return;\n      } else if (patchFlag & 256) {\n        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        return;\n      }\n    }\n    if (shapeFlag & 8) {\n      if (prevShapeFlag & 16) {\n        unmountChildren(c1, parentComponent, parentSuspense);\n      }\n      if (c2 !== c1) {\n        hostSetElementText(container, c2);\n      }\n    } else {\n      if (prevShapeFlag & 16) {\n        if (shapeFlag & 16) {\n          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        } else {\n          unmountChildren(c1, parentComponent, parentSuspense, true);\n        }\n      } else {\n        if (prevShapeFlag & 8) {\n          hostSetElementText(container, "");\n        }\n        if (shapeFlag & 16) {\n          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        }\n      }\n    }\n  };\n  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    c1 = c1 || EMPTY_ARR;\n    c2 = c2 || EMPTY_ARR;\n    const oldLength = c1.length;\n    const newLength = c2.length;\n    const commonLength = Math.min(oldLength, newLength);\n    let i;\n    for (i = 0; i < commonLength; i++) {\n      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n    }\n    if (oldLength > newLength) {\n      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);\n    } else {\n      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);\n    }\n  };\n  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    let i = 0;\n    const l2 = c2.length;\n    let e1 = c1.length - 1;\n    let e2 = l2 - 1;\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[i];\n      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n      if (isSameVNodeType(n1, n2)) {\n        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n      } else {\n        break;\n      }\n      i++;\n    }\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[e1];\n      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);\n      if (isSameVNodeType(n1, n2)) {\n        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n      } else {\n        break;\n      }\n      e1--;\n      e2--;\n    }\n    if (i > e1) {\n      if (i <= e2) {\n        const nextPos = e2 + 1;\n        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\n        while (i <= e2) {\n          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n          i++;\n        }\n      }\n    } else if (i > e2) {\n      while (i <= e1) {\n        unmount(c1[i], parentComponent, parentSuspense, true);\n        i++;\n      }\n    } else {\n      const s1 = i;\n      const s2 = i;\n      const keyToNewIndexMap = /* @__PURE__ */new Map();\n      for (i = s2; i <= e2; i++) {\n        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n        if (nextChild.key != null) {\n          if (false) {}\n          keyToNewIndexMap.set(nextChild.key, i);\n        }\n      }\n      let j;\n      let patched = 0;\n      const toBePatched = e2 - s2 + 1;\n      let moved = false;\n      let maxNewIndexSoFar = 0;\n      const newIndexToOldIndexMap = new Array(toBePatched);\n      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;\n      for (i = s1; i <= e1; i++) {\n        const prevChild = c1[i];\n        if (patched >= toBePatched) {\n          unmount(prevChild, parentComponent, parentSuspense, true);\n          continue;\n        }\n        let newIndex;\n        if (prevChild.key != null) {\n          newIndex = keyToNewIndexMap.get(prevChild.key);\n        } else {\n          for (j = s2; j <= e2; j++) {\n            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {\n              newIndex = j;\n              break;\n            }\n          }\n        }\n        if (newIndex === void 0) {\n          unmount(prevChild, parentComponent, parentSuspense, true);\n        } else {\n          newIndexToOldIndexMap[newIndex - s2] = i + 1;\n          if (newIndex >= maxNewIndexSoFar) {\n            maxNewIndexSoFar = newIndex;\n          } else {\n            moved = true;\n          }\n          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n          patched++;\n        }\n      }\n      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;\n      j = increasingNewIndexSequence.length - 1;\n      for (i = toBePatched - 1; i >= 0; i--) {\n        const nextIndex = s2 + i;\n        const nextChild = c2[nextIndex];\n        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;\n        if (newIndexToOldIndexMap[i] === 0) {\n          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        } else if (moved) {\n          if (j < 0 || i !== increasingNewIndexSequence[j]) {\n            move(nextChild, container, anchor, 2);\n          } else {\n            j--;\n          }\n        }\n      }\n    }\n  };\n  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {\n    const {\n      el,\n      type,\n      transition,\n      children,\n      shapeFlag\n    } = vnode;\n    if (shapeFlag & 6) {\n      move(vnode.component.subTree, container, anchor, moveType);\n      return;\n    }\n    if (shapeFlag & 128) {\n      vnode.suspense.move(container, anchor, moveType);\n      return;\n    }\n    if (shapeFlag & 64) {\n      type.move(vnode, container, anchor, internals);\n      return;\n    }\n    if (type === runtime_core_esm_bundler_Fragment) {\n      hostInsert(el, container, anchor);\n      for (let i = 0; i < children.length; i++) {\n        move(children[i], container, anchor, moveType);\n      }\n      hostInsert(vnode.anchor, container, anchor);\n      return;\n    }\n    if (type === runtime_core_esm_bundler_Static) {\n      moveStaticNode(vnode, container, anchor);\n      return;\n    }\n    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;\n    if (needTransition) {\n      if (moveType === 0) {\n        transition.beforeEnter(el);\n        hostInsert(el, container, anchor);\n        queuePostRenderEffect(() => transition.enter(el), parentSuspense);\n      } else {\n        const {\n          leave,\n          delayLeave,\n          afterLeave\n        } = transition;\n        const remove2 = () => hostInsert(el, container, anchor);\n        const performLeave = () => {\n          leave(el, () => {\n            remove2();\n            afterLeave && afterLeave();\n          });\n        };\n        if (delayLeave) {\n          delayLeave(el, remove2, performLeave);\n        } else {\n          performLeave();\n        }\n      }\n    } else {\n      hostInsert(el, container, anchor);\n    }\n  };\n  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {\n    const {\n      type,\n      props,\n      ref,\n      children,\n      dynamicChildren,\n      shapeFlag,\n      patchFlag,\n      dirs\n    } = vnode;\n    if (ref != null) {\n      setRef(ref, null, parentSuspense, vnode, true);\n    }\n    if (shapeFlag & 256) {\n      parentComponent.ctx.deactivate(vnode);\n      return;\n    }\n    const shouldInvokeDirs = shapeFlag & 1 && dirs;\n    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);\n    let vnodeHook;\n    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {\n      invokeVNodeHook(vnodeHook, parentComponent, vnode);\n    }\n    if (shapeFlag & 6) {\n      unmountComponent(vnode.component, parentSuspense, doRemove);\n    } else {\n      if (shapeFlag & 128) {\n        vnode.suspense.unmount(parentSuspense, doRemove);\n        return;\n      }\n      if (shouldInvokeDirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");\n      }\n      if (shapeFlag & 64) {\n        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);\n      } else if (dynamicChildren && (\n      // #1153: fast path should not be taken for non-stable (v-for) fragments\n      type !== runtime_core_esm_bundler_Fragment || patchFlag > 0 && patchFlag & 64)) {\n        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);\n      } else if (type === runtime_core_esm_bundler_Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {\n        unmountChildren(children, parentComponent, parentSuspense);\n      }\n      if (doRemove) {\n        remove(vnode);\n      }\n    }\n    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");\n      }, parentSuspense);\n    }\n  };\n  const remove = vnode => {\n    const {\n      type,\n      el,\n      anchor,\n      transition\n    } = vnode;\n    if (type === runtime_core_esm_bundler_Fragment) {\n      if (false) {} else {\n        removeFragment(el, anchor);\n      }\n      return;\n    }\n    if (type === runtime_core_esm_bundler_Static) {\n      removeStaticNode(vnode);\n      return;\n    }\n    const performRemove = () => {\n      hostRemove(el);\n      if (transition && !transition.persisted && transition.afterLeave) {\n        transition.afterLeave();\n      }\n    };\n    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {\n      const {\n        leave,\n        delayLeave\n      } = transition;\n      const performLeave = () => leave(el, performRemove);\n      if (delayLeave) {\n        delayLeave(vnode.el, performRemove, performLeave);\n      } else {\n        performLeave();\n      }\n    } else {\n      performRemove();\n    }\n  };\n  const removeFragment = (cur, end) => {\n    let next;\n    while (cur !== end) {\n      next = hostNextSibling(cur);\n      hostRemove(cur);\n      cur = next;\n    }\n    hostRemove(end);\n  };\n  const unmountComponent = (instance, parentSuspense, doRemove) => {\n    if (false) {}\n    const {\n      bum,\n      scope,\n      update,\n      subTree,\n      um\n    } = instance;\n    if (bum) {\n      invokeArrayFns(bum);\n    }\n    scope.stop();\n    if (update) {\n      update.active = false;\n      unmount(subTree, instance, parentSuspense, doRemove);\n    }\n    if (um) {\n      queuePostRenderEffect(um, parentSuspense);\n    }\n    queuePostRenderEffect(() => {\n      instance.isUnmounted = true;\n    }, parentSuspense);\n    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {\n      parentSuspense.deps--;\n      if (parentSuspense.deps === 0) {\n        parentSuspense.resolve();\n      }\n    }\n    if ( false || __VUE_PROD_DEVTOOLS__) {\n      devtoolsComponentRemoved(instance);\n    }\n  };\n  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {\n    for (let i = start; i < children.length; i++) {\n      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);\n    }\n  };\n  const getNextHostNode = vnode => {\n    if (vnode.shapeFlag & 6) {\n      return getNextHostNode(vnode.component.subTree);\n    }\n    if (vnode.shapeFlag & 128) {\n      return vnode.suspense.next();\n    }\n    return hostNextSibling(vnode.anchor || vnode.el);\n  };\n  const render = (vnode, container, isSVG) => {\n    if (vnode == null) {\n      if (container._vnode) {\n        unmount(container._vnode, null, null, true);\n      }\n    } else {\n      patch(container._vnode || null, vnode, container, null, null, null, isSVG);\n    }\n    flushPreFlushCbs();\n    flushPostFlushCbs();\n    container._vnode = vnode;\n  };\n  const internals = {\n    p: patch,\n    um: unmount,\n    m: move,\n    r: remove,\n    mt: mountComponent,\n    mc: mountChildren,\n    pc: patchChildren,\n    pbc: patchBlockChildren,\n    n: getNextHostNode,\n    o: options\n  };\n  let hydrate;\n  let hydrateNode;\n  if (createHydrationFns) {\n    [hydrate, hydrateNode] = createHydrationFns(internals);\n  }\n  return {\n    render,\n    hydrate,\n    createApp: createAppAPI(render, hydrate)\n  };\n}\nfunction toggleRecurse({\n  effect,\n  update\n}, allowed) {\n  effect.allowRecurse = update.allowRecurse = allowed;\n}\nfunction traverseStaticChildren(n1, n2, shallow = false) {\n  const ch1 = n1.children;\n  const ch2 = n2.children;\n  if (shared_esm_bundler_isArray(ch1) && shared_esm_bundler_isArray(ch2)) {\n    for (let i = 0; i < ch1.length; i++) {\n      const c1 = ch1[i];\n      let c2 = ch2[i];\n      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {\n        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {\n          c2 = ch2[i] = cloneIfMounted(ch2[i]);\n          c2.el = c1.el;\n        }\n        if (!shallow) traverseStaticChildren(c1, c2);\n      }\n      if (c2.type === Text) {\n        c2.el = c1.el;\n      }\n      if (false) {}\n    }\n  }\n}\nfunction getSequence(arr) {\n  const p = arr.slice();\n  const result = [0];\n  let i, j, u, v, c;\n  const len = arr.length;\n  for (i = 0; i < len; i++) {\n    const arrI = arr[i];\n    if (arrI !== 0) {\n      j = result[result.length - 1];\n      if (arr[j] < arrI) {\n        p[i] = j;\n        result.push(i);\n        continue;\n      }\n      u = 0;\n      v = result.length - 1;\n      while (u < v) {\n        c = u + v >> 1;\n        if (arr[result[c]] < arrI) {\n          u = c + 1;\n        } else {\n          v = c;\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1];\n        }\n        result[u] = i;\n      }\n    }\n  }\n  u = result.length;\n  v = result[u - 1];\n  while (u-- > 0) {\n    result[u] = v;\n    v = p[v];\n  }\n  return result;\n}\nconst isTeleport = type => type.__isTeleport;\nconst isTeleportDisabled = props => props && (props.disabled || props.disabled === "");\nconst isTargetSVG = target => typeof SVGElement !== "undefined" && target instanceof SVGElement;\nconst resolveTarget = (props, select) => {\n  const targetSelector = props && props.to;\n  if (shared_esm_bundler_isString(targetSelector)) {\n    if (!select) {\n       false && 0;\n      return null;\n    } else {\n      const target = select(targetSelector);\n      if (!target) {\n         false && 0;\n      }\n      return target;\n    }\n  } else {\n    if (false) {}\n    return targetSelector;\n  }\n};\nconst TeleportImpl = {\n  __isTeleport: true,\n  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {\n    const {\n      mc: mountChildren,\n      pc: patchChildren,\n      pbc: patchBlockChildren,\n      o: {\n        insert,\n        querySelector,\n        createText,\n        createComment\n      }\n    } = internals;\n    const disabled = isTeleportDisabled(n2.props);\n    let {\n      shapeFlag,\n      children,\n      dynamicChildren\n    } = n2;\n    if (false) {}\n    if (n1 == null) {\n      const placeholder = n2.el =  false ? 0 : createText("");\n      const mainAnchor = n2.anchor =  false ? 0 : createText("");\n      insert(placeholder, container, anchor);\n      insert(mainAnchor, container, anchor);\n      const target = n2.target = resolveTarget(n2.props, querySelector);\n      const targetAnchor = n2.targetAnchor = createText("");\n      if (target) {\n        insert(targetAnchor, target);\n        isSVG = isSVG || isTargetSVG(target);\n      } else if (false) {}\n      const mount = (container2, anchor2) => {\n        if (shapeFlag & 16) {\n          mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        }\n      };\n      if (disabled) {\n        mount(container, mainAnchor);\n      } else if (target) {\n        mount(target, targetAnchor);\n      }\n    } else {\n      n2.el = n1.el;\n      const mainAnchor = n2.anchor = n1.anchor;\n      const target = n2.target = n1.target;\n      const targetAnchor = n2.targetAnchor = n1.targetAnchor;\n      const wasDisabled = isTeleportDisabled(n1.props);\n      const currentContainer = wasDisabled ? container : target;\n      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;\n      isSVG = isSVG || isTargetSVG(target);\n      if (dynamicChildren) {\n        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);\n        traverseStaticChildren(n1, n2, true);\n      } else if (!optimized) {\n        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);\n      }\n      if (disabled) {\n        if (!wasDisabled) {\n          moveTeleport(n2, container, mainAnchor, internals, 1);\n        }\n      } else {\n        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\n          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);\n          if (nextTarget) {\n            moveTeleport(n2, nextTarget, null, internals, 0);\n          } else if (false) {}\n        } else if (wasDisabled) {\n          moveTeleport(n2, target, targetAnchor, internals, 1);\n        }\n      }\n    }\n    updateCssVars(n2);\n  },\n  remove(vnode, parentComponent, parentSuspense, optimized, {\n    um: unmount,\n    o: {\n      remove: hostRemove\n    }\n  }, doRemove) {\n    const {\n      shapeFlag,\n      children,\n      anchor,\n      targetAnchor,\n      target,\n      props\n    } = vnode;\n    if (target) {\n      hostRemove(targetAnchor);\n    }\n    if (doRemove || !isTeleportDisabled(props)) {\n      hostRemove(anchor);\n      if (shapeFlag & 16) {\n        for (let i = 0; i < children.length; i++) {\n          const child = children[i];\n          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);\n        }\n      }\n    }\n  },\n  move: moveTeleport,\n  hydrate: hydrateTeleport\n};\nfunction moveTeleport(vnode, container, parentAnchor, {\n  o: {\n    insert\n  },\n  m: move\n}, moveType = 2) {\n  if (moveType === 0) {\n    insert(vnode.targetAnchor, container, parentAnchor);\n  }\n  const {\n    el,\n    anchor,\n    shapeFlag,\n    children,\n    props\n  } = vnode;\n  const isReorder = moveType === 2;\n  if (isReorder) {\n    insert(el, container, parentAnchor);\n  }\n  if (!isReorder || isTeleportDisabled(props)) {\n    if (shapeFlag & 16) {\n      for (let i = 0; i < children.length; i++) {\n        move(children[i], container, parentAnchor, 2);\n      }\n    }\n  }\n  if (isReorder) {\n    insert(anchor, container, parentAnchor);\n  }\n}\nfunction hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {\n  o: {\n    nextSibling,\n    parentNode,\n    querySelector\n  }\n}, hydrateChildren) {\n  const target = vnode.target = resolveTarget(vnode.props, querySelector);\n  if (target) {\n    const targetNode = target._lpa || target.firstChild;\n    if (vnode.shapeFlag & 16) {\n      if (isTeleportDisabled(vnode.props)) {\n        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);\n        vnode.targetAnchor = targetNode;\n      } else {\n        vnode.anchor = nextSibling(node);\n        let targetAnchor = targetNode;\n        while (targetAnchor) {\n          targetAnchor = nextSibling(targetAnchor);\n          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {\n            vnode.targetAnchor = targetAnchor;\n            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);\n            break;\n          }\n        }\n        hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);\n      }\n    }\n    updateCssVars(vnode);\n  }\n  return vnode.anchor && nextSibling(vnode.anchor);\n}\nconst Teleport = (/* unused pure expression or super */ null && (TeleportImpl));\nfunction updateCssVars(vnode) {\n  const ctx = vnode.ctx;\n  if (ctx && ctx.ut) {\n    let node = vnode.children[0].el;\n    while (node !== vnode.targetAnchor) {\n      if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);\n      node = node.nextSibling;\n    }\n    ctx.ut();\n  }\n}\nconst runtime_core_esm_bundler_Fragment = Symbol.for("v-fgt");\nconst Text = Symbol.for("v-txt");\nconst Comment = Symbol.for("v-cmt");\nconst runtime_core_esm_bundler_Static = Symbol.for("v-stc");\nconst blockStack = [];\nlet currentBlock = null;\nfunction openBlock(disableTracking = false) {\n  blockStack.push(currentBlock = disableTracking ? null : []);\n}\nfunction closeBlock() {\n  blockStack.pop();\n  currentBlock = blockStack[blockStack.length - 1] || null;\n}\nlet isBlockTreeEnabled = 1;\nfunction setBlockTracking(value) {\n  isBlockTreeEnabled += value;\n}\nfunction setupBlock(vnode) {\n  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;\n  closeBlock();\n  if (isBlockTreeEnabled > 0 && currentBlock) {\n    currentBlock.push(vnode);\n  }\n  return vnode;\n}\nfunction createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {\n  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true\n  /* isBlock */));\n}\n\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\n  return setupBlock(runtime_core_esm_bundler_createVNode(type, props, children, patchFlag, dynamicProps, true\n  /* isBlock: prevent a block from tracking itself */));\n}\n\nfunction isVNode(value) {\n  return value ? value.__v_isVNode === true : false;\n}\nfunction isSameVNodeType(n1, n2) {\n  if (false) {}\n  return n1.type === n2.type && n1.key === n2.key;\n}\nlet vnodeArgsTransformer;\nfunction transformVNodeArgs(transformer) {\n  vnodeArgsTransformer = transformer;\n}\nconst createVNodeWithArgsTransform = (...args) => {\n  return _createVNode(...(vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args));\n};\nconst InternalObjectKey = `__vInternal`;\nconst normalizeKey = ({\n  key\n}) => key != null ? key : null;\nconst normalizeRef = ({\n  ref,\n  ref_key,\n  ref_for\n}) => {\n  if (typeof ref === "number") {\n    ref = "" + ref;\n  }\n  return ref != null ? shared_esm_bundler_isString(ref) || reactivity_esm_bundler_isRef(ref) || shared_esm_bundler_isFunction(ref) ? {\n    i: currentRenderingInstance,\n    r: ref,\n    k: ref_key,\n    f: !!ref_for\n  } : ref : null;\n};\nfunction createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === runtime_core_esm_bundler_Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {\n  const vnode = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type,\n    props,\n    key: props && normalizeKey(props),\n    ref: props && normalizeRef(props),\n    scopeId: currentScopeId,\n    slotScopeIds: null,\n    children,\n    component: null,\n    suspense: null,\n    ssContent: null,\n    ssFallback: null,\n    dirs: null,\n    transition: null,\n    el: null,\n    anchor: null,\n    target: null,\n    targetAnchor: null,\n    staticCount: 0,\n    shapeFlag,\n    patchFlag,\n    dynamicProps,\n    dynamicChildren: null,\n    appContext: null,\n    ctx: currentRenderingInstance\n  };\n  if (needFullChildrenNormalization) {\n    normalizeChildren(vnode, children);\n    if (shapeFlag & 128) {\n      type.normalize(vnode);\n    }\n  } else if (children) {\n    vnode.shapeFlag |= shared_esm_bundler_isString(children) ? 8 : 16;\n  }\n  if (false) {}\n  if (isBlockTreeEnabled > 0 &&\n  // avoid a block node from tracking itself\n  !isBlockNode &&\n  // has current parent block\n  currentBlock && (\n  // presence of a patch flag indicates this node needs patching on updates.\n  // component nodes also should always be patched, because even if the\n  // component doesn\'t need to update, it needs to persist the instance on to\n  // the next vnode so that it can be properly unmounted later.\n  vnode.patchFlag > 0 || shapeFlag & 6) &&\n  // the EVENTS flag is only for hydration and if it is the only flag, the\n  // vnode should not be considered dynamic due to handler caching.\n  vnode.patchFlag !== 32) {\n    currentBlock.push(vnode);\n  }\n  return vnode;\n}\nconst runtime_core_esm_bundler_createVNode =  false ? 0 : _createVNode;\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\n  if (!type || type === NULL_DYNAMIC_COMPONENT) {\n    if (false) {}\n    type = Comment;\n  }\n  if (isVNode(type)) {\n    const cloned = cloneVNode(type, props, true\n    /* mergeRef: true */);\n\n    if (children) {\n      normalizeChildren(cloned, children);\n    }\n    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {\n      if (cloned.shapeFlag & 6) {\n        currentBlock[currentBlock.indexOf(type)] = cloned;\n      } else {\n        currentBlock.push(cloned);\n      }\n    }\n    cloned.patchFlag |= -2;\n    return cloned;\n  }\n  if (isClassComponent(type)) {\n    type = type.__vccOpts;\n  }\n  if (props) {\n    props = guardReactiveProps(props);\n    let {\n      class: klass,\n      style\n    } = props;\n    if (klass && !shared_esm_bundler_isString(klass)) {\n      props.class = normalizeClass(klass);\n    }\n    if (shared_esm_bundler_isObject(style)) {\n      if (isProxy(style) && !shared_esm_bundler_isArray(style)) {\n        style = shared_esm_bundler_extend({}, style);\n      }\n      props.style = normalizeStyle(style);\n    }\n  }\n  const shapeFlag = shared_esm_bundler_isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : shared_esm_bundler_isObject(type) ? 4 : shared_esm_bundler_isFunction(type) ? 2 : 0;\n  if (false) {}\n  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);\n}\nfunction guardReactiveProps(props) {\n  if (!props) return null;\n  return isProxy(props) || InternalObjectKey in props ? shared_esm_bundler_extend({}, props) : props;\n}\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\n  const {\n    props,\n    ref,\n    patchFlag,\n    children\n  } = vnode;\n  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\n  const cloned = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type: vnode.type,\n    props: mergedProps,\n    key: mergedProps && normalizeKey(mergedProps),\n    ref: extraProps && extraProps.ref ?\n    // #2078 in the case of <component :is="vnode" ref="extra"/>\n    // if the vnode itself already has a ref, cloneVNode will need to merge\n    // the refs so the single vnode can be set on multiple refs\n    mergeRef && ref ? shared_esm_bundler_isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref,\n    scopeId: vnode.scopeId,\n    slotScopeIds: vnode.slotScopeIds,\n    children:  false ? 0 : children,\n    target: vnode.target,\n    targetAnchor: vnode.targetAnchor,\n    staticCount: vnode.staticCount,\n    shapeFlag: vnode.shapeFlag,\n    // if the vnode is cloned with extra props, we can no longer assume its\n    // existing patch flag to be reliable and need to add the FULL_PROPS flag.\n    // note: preserve flag for fragments since they use the flag for children\n    // fast paths only.\n    patchFlag: extraProps && vnode.type !== runtime_core_esm_bundler_Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,\n    dynamicProps: vnode.dynamicProps,\n    dynamicChildren: vnode.dynamicChildren,\n    appContext: vnode.appContext,\n    dirs: vnode.dirs,\n    transition: vnode.transition,\n    // These should technically only be non-null on mounted VNodes. However,\n    // they *should* be copied for kept-alive vnodes. So we just always copy\n    // them since them being non-null during a mount doesn\'t affect the logic as\n    // they will simply be overwritten.\n    component: vnode.component,\n    suspense: vnode.suspense,\n    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\n    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\n    el: vnode.el,\n    anchor: vnode.anchor,\n    ctx: vnode.ctx,\n    ce: vnode.ce\n  };\n  return cloned;\n}\nfunction deepCloneVNode(vnode) {\n  const cloned = cloneVNode(vnode);\n  if (isArray(vnode.children)) {\n    cloned.children = vnode.children.map(deepCloneVNode);\n  }\n  return cloned;\n}\nfunction createTextVNode(text = " ", flag = 0) {\n  return runtime_core_esm_bundler_createVNode(Text, null, text, flag);\n}\nfunction createStaticVNode(content, numberOfNodes) {\n  const vnode = runtime_core_esm_bundler_createVNode(runtime_core_esm_bundler_Static, null, content);\n  vnode.staticCount = numberOfNodes;\n  return vnode;\n}\nfunction createCommentVNode(text = "", asBlock = false) {\n  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : runtime_core_esm_bundler_createVNode(Comment, null, text);\n}\nfunction normalizeVNode(child) {\n  if (child == null || typeof child === "boolean") {\n    return runtime_core_esm_bundler_createVNode(Comment);\n  } else if (shared_esm_bundler_isArray(child)) {\n    return runtime_core_esm_bundler_createVNode(runtime_core_esm_bundler_Fragment, null,\n    // #3666, avoid reference pollution when reusing vnode\n    child.slice());\n  } else if (typeof child === "object") {\n    return cloneIfMounted(child);\n  } else {\n    return runtime_core_esm_bundler_createVNode(Text, null, String(child));\n  }\n}\nfunction cloneIfMounted(child) {\n  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);\n}\nfunction normalizeChildren(vnode, children) {\n  let type = 0;\n  const {\n    shapeFlag\n  } = vnode;\n  if (children == null) {\n    children = null;\n  } else if (shared_esm_bundler_isArray(children)) {\n    type = 16;\n  } else if (typeof children === "object") {\n    if (shapeFlag & (1 | 64)) {\n      const slot = children.default;\n      if (slot) {\n        slot._c && (slot._d = false);\n        normalizeChildren(vnode, slot());\n        slot._c && (slot._d = true);\n      }\n      return;\n    } else {\n      type = 32;\n      const slotFlag = children._;\n      if (!slotFlag && !(InternalObjectKey in children)) {\n        children._ctx = currentRenderingInstance;\n      } else if (slotFlag === 3 && currentRenderingInstance) {\n        if (currentRenderingInstance.slots._ === 1) {\n          children._ = 1;\n        } else {\n          children._ = 2;\n          vnode.patchFlag |= 1024;\n        }\n      }\n    }\n  } else if (shared_esm_bundler_isFunction(children)) {\n    children = {\n      default: children,\n      _ctx: currentRenderingInstance\n    };\n    type = 32;\n  } else {\n    children = String(children);\n    if (shapeFlag & 64) {\n      type = 16;\n      children = [createTextVNode(children)];\n    } else {\n      type = 8;\n    }\n  }\n  vnode.children = children;\n  vnode.shapeFlag |= type;\n}\nfunction mergeProps(...args) {\n  const ret = {};\n  for (let i = 0; i < args.length; i++) {\n    const toMerge = args[i];\n    for (const key in toMerge) {\n      if (key === "class") {\n        if (ret.class !== toMerge.class) {\n          ret.class = normalizeClass([ret.class, toMerge.class]);\n        }\n      } else if (key === "style") {\n        ret.style = normalizeStyle([ret.style, toMerge.style]);\n      } else if (shared_esm_bundler_isOn(key)) {\n        const existing = ret[key];\n        const incoming = toMerge[key];\n        if (incoming && existing !== incoming && !(shared_esm_bundler_isArray(existing) && existing.includes(incoming))) {\n          ret[key] = existing ? [].concat(existing, incoming) : incoming;\n        }\n      } else if (key !== "") {\n        ret[key] = toMerge[key];\n      }\n    }\n  }\n  return ret;\n}\nfunction invokeVNodeHook(hook, instance, vnode, prevVNode = null) {\n  callWithAsyncErrorHandling(hook, instance, 7, [vnode, prevVNode]);\n}\nconst emptyAppContext = createAppContext();\nlet uid = 0;\nfunction createComponentInstance(vnode, parent, suspense) {\n  const type = vnode.type;\n  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\n  const instance = {\n    uid: uid++,\n    vnode,\n    type,\n    parent,\n    appContext,\n    root: null,\n    // to be immediately set\n    next: null,\n    subTree: null,\n    // will be set synchronously right after creation\n    effect: null,\n    update: null,\n    // will be set synchronously right after creation\n    scope: new EffectScope(true\n    /* detached */),\n\n    render: null,\n    proxy: null,\n    exposed: null,\n    exposeProxy: null,\n    withProxy: null,\n    provides: parent ? parent.provides : Object.create(appContext.provides),\n    accessCache: null,\n    renderCache: [],\n    // local resolved assets\n    components: null,\n    directives: null,\n    // resolved props and emits options\n    propsOptions: normalizePropsOptions(type, appContext),\n    emitsOptions: normalizeEmitsOptions(type, appContext),\n    // emit\n    emit: null,\n    // to be set immediately\n    emitted: null,\n    // props default value\n    propsDefaults: shared_esm_bundler_EMPTY_OBJ,\n    // inheritAttrs\n    inheritAttrs: type.inheritAttrs,\n    // state\n    ctx: shared_esm_bundler_EMPTY_OBJ,\n    data: shared_esm_bundler_EMPTY_OBJ,\n    props: shared_esm_bundler_EMPTY_OBJ,\n    attrs: shared_esm_bundler_EMPTY_OBJ,\n    slots: shared_esm_bundler_EMPTY_OBJ,\n    refs: shared_esm_bundler_EMPTY_OBJ,\n    setupState: shared_esm_bundler_EMPTY_OBJ,\n    setupContext: null,\n    attrsProxy: null,\n    slotsProxy: null,\n    // suspense related\n    suspense,\n    suspenseId: suspense ? suspense.pendingId : 0,\n    asyncDep: null,\n    asyncResolved: false,\n    // lifecycle hooks\n    // not using enums here because it results in computed properties\n    isMounted: false,\n    isUnmounted: false,\n    isDeactivated: false,\n    bc: null,\n    c: null,\n    bm: null,\n    m: null,\n    bu: null,\n    u: null,\n    um: null,\n    bum: null,\n    da: null,\n    a: null,\n    rtg: null,\n    rtc: null,\n    ec: null,\n    sp: null\n  };\n  if (false) {} else {\n    instance.ctx = {\n      _: instance\n    };\n  }\n  instance.root = parent ? parent.root : instance;\n  instance.emit = emit.bind(null, instance);\n  if (vnode.ce) {\n    vnode.ce(instance);\n  }\n  return instance;\n}\nlet currentInstance = null;\nconst runtime_core_esm_bundler_getCurrentInstance = () => currentInstance || currentRenderingInstance;\nlet internalSetCurrentInstance;\nlet globalCurrentInstanceSetters;\nlet settersKey = "__VUE_INSTANCE_SETTERS__";\n{\n  if (!(globalCurrentInstanceSetters = getGlobalThis()[settersKey])) {\n    globalCurrentInstanceSetters = getGlobalThis()[settersKey] = [];\n  }\n  globalCurrentInstanceSetters.push(i => currentInstance = i);\n  internalSetCurrentInstance = instance => {\n    if (globalCurrentInstanceSetters.length > 1) {\n      globalCurrentInstanceSetters.forEach(s => s(instance));\n    } else {\n      globalCurrentInstanceSetters[0](instance);\n    }\n  };\n}\nconst setCurrentInstance = instance => {\n  internalSetCurrentInstance(instance);\n  instance.scope.on();\n};\nconst unsetCurrentInstance = () => {\n  currentInstance && currentInstance.scope.off();\n  internalSetCurrentInstance(null);\n};\nconst isBuiltInTag = /* @__PURE__ */(/* unused pure expression or super */ null && (makeMap("slot,component")));\nfunction validateComponentName(name, config) {\n  const appIsNativeTag = config.isNativeTag || NO;\n  if (isBuiltInTag(name) || appIsNativeTag(name)) {\n    runtime_core_esm_bundler_warn("Do not use built-in or reserved HTML elements as component id: " + name);\n  }\n}\nfunction isStatefulComponent(instance) {\n  return instance.vnode.shapeFlag & 4;\n}\nlet isInSSRComponentSetup = false;\nfunction setupComponent(instance, isSSR = false) {\n  isInSSRComponentSetup = isSSR;\n  const {\n    props,\n    children\n  } = instance.vnode;\n  const isStateful = isStatefulComponent(instance);\n  initProps(instance, props, isStateful, isSSR);\n  initSlots(instance, children);\n  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;\n  isInSSRComponentSetup = false;\n  return setupResult;\n}\nfunction setupStatefulComponent(instance, isSSR) {\n  var _a;\n  const Component = instance.type;\n  if (false) {}\n  instance.accessCache = /* @__PURE__ */Object.create(null);\n  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));\n  if (false) {}\n  const {\n    setup\n  } = Component;\n  if (setup) {\n    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;\n    setCurrentInstance(instance);\n    pauseTracking();\n    const setupResult = callWithErrorHandling(setup, instance, 0, [ false ? 0 : instance.props, setupContext]);\n    resetTracking();\n    unsetCurrentInstance();\n    if (shared_esm_bundler_isPromise(setupResult)) {\n      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);\n      if (isSSR) {\n        return setupResult.then(resolvedResult => {\n          handleSetupResult(instance, resolvedResult, isSSR);\n        }).catch(e => {\n          handleError(e, instance, 0);\n        });\n      } else {\n        instance.asyncDep = setupResult;\n        if (false) {}\n      }\n    } else {\n      handleSetupResult(instance, setupResult, isSSR);\n    }\n  } else {\n    finishComponentSetup(instance, isSSR);\n  }\n}\nfunction handleSetupResult(instance, setupResult, isSSR) {\n  if (shared_esm_bundler_isFunction(setupResult)) {\n    if (instance.type.__ssrInlineRender) {\n      instance.ssrRender = setupResult;\n    } else {\n      instance.render = setupResult;\n    }\n  } else if (shared_esm_bundler_isObject(setupResult)) {\n    if (false) {}\n    if ( false || __VUE_PROD_DEVTOOLS__) {\n      instance.devtoolsRawSetupState = setupResult;\n    }\n    instance.setupState = proxyRefs(setupResult);\n    if (false) {}\n  } else if (false) {}\n  finishComponentSetup(instance, isSSR);\n}\nlet compile;\nlet installWithProxy;\nfunction registerRuntimeCompiler(_compile) {\n  compile = _compile;\n  installWithProxy = i => {\n    if (i.render._rc) {\n      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);\n    }\n  };\n}\nconst runtime_core_esm_bundler_isRuntimeOnly = () => !compile;\nfunction finishComponentSetup(instance, isSSR, skipOptions) {\n  const Component = instance.type;\n  if (!instance.render) {\n    if (!isSSR && compile && !Component.render) {\n      const template = Component.template || resolveMergedOptions(instance).template;\n      if (template) {\n        if (false) {}\n        const {\n          isCustomElement,\n          compilerOptions\n        } = instance.appContext.config;\n        const {\n          delimiters,\n          compilerOptions: componentCompilerOptions\n        } = Component;\n        const finalCompilerOptions = shared_esm_bundler_extend(shared_esm_bundler_extend({\n          isCustomElement,\n          delimiters\n        }, compilerOptions), componentCompilerOptions);\n        Component.render = compile(template, finalCompilerOptions);\n        if (false) {}\n      }\n    }\n    instance.render = Component.render || shared_esm_bundler_NOOP;\n    if (installWithProxy) {\n      installWithProxy(instance);\n    }\n  }\n  if (__VUE_OPTIONS_API__ && true) {\n    setCurrentInstance(instance);\n    pauseTracking();\n    applyOptions(instance);\n    resetTracking();\n    unsetCurrentInstance();\n  }\n  if (false) {}\n}\nfunction getAttrsProxy(instance) {\n  return instance.attrsProxy || (instance.attrsProxy = new Proxy(instance.attrs,  false ? 0 : {\n    get(target, key) {\n      reactivity_esm_bundler_track(instance, "get", "$attrs");\n      return target[key];\n    }\n  }));\n}\nfunction getSlotsProxy(instance) {\n  return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {\n    get(target, key) {\n      track(instance, "get", "$slots");\n      return target[key];\n    }\n  }));\n}\nfunction createSetupContext(instance) {\n  const expose = exposed => {\n    if (false) {}\n    instance.exposed = exposed || {};\n  };\n  if (false) {} else {\n    return {\n      get attrs() {\n        return getAttrsProxy(instance);\n      },\n      slots: instance.slots,\n      emit: instance.emit,\n      expose\n    };\n  }\n}\nfunction getExposeProxy(instance) {\n  if (instance.exposed) {\n    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {\n      get(target, key) {\n        if (key in target) {\n          return target[key];\n        } else if (key in publicPropertiesMap) {\n          return publicPropertiesMap[key](instance);\n        }\n      },\n      has(target, key) {\n        return key in target || key in publicPropertiesMap;\n      }\n    }));\n  }\n}\nconst classifyRE = /(?:^|[-_])(\\w)/g;\nconst classify = str => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, "");\nfunction getComponentName(Component, includeInferred = true) {\n  return shared_esm_bundler_isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;\n}\nfunction formatComponentName(instance, Component, isRoot = false) {\n  let name = getComponentName(Component);\n  if (!name && Component.__file) {\n    const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\n    if (match) {\n      name = match[1];\n    }\n  }\n  if (!name && instance && instance.parent) {\n    const inferFromRegistry = registry => {\n      for (const key in registry) {\n        if (registry[key] === Component) {\n          return key;\n        }\n      }\n    };\n    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\n  }\n  return name ? classify(name) : isRoot ? `App` : `Anonymous`;\n}\nfunction isClassComponent(value) {\n  return shared_esm_bundler_isFunction(value) && "__vccOpts" in value;\n}\nconst runtime_core_esm_bundler_computed = (getterOrOptions, debugOptions) => {\n  return computed(getterOrOptions, debugOptions, isInSSRComponentSetup);\n};\nfunction h(type, propsOrChildren, children) {\n  const l = arguments.length;\n  if (l === 2) {\n    if (shared_esm_bundler_isObject(propsOrChildren) && !shared_esm_bundler_isArray(propsOrChildren)) {\n      if (isVNode(propsOrChildren)) {\n        return runtime_core_esm_bundler_createVNode(type, null, [propsOrChildren]);\n      }\n      return runtime_core_esm_bundler_createVNode(type, propsOrChildren);\n    } else {\n      return runtime_core_esm_bundler_createVNode(type, null, propsOrChildren);\n    }\n  } else {\n    if (l > 3) {\n      children = Array.prototype.slice.call(arguments, 2);\n    } else if (l === 3 && isVNode(children)) {\n      children = [children];\n    }\n    return runtime_core_esm_bundler_createVNode(type, propsOrChildren, children);\n  }\n}\nconst ssrContextKey = Symbol.for("v-scx");\nconst useSSRContext = () => {\n  {\n    const ctx = runtime_core_esm_bundler_inject(ssrContextKey);\n    if (!ctx) {\n       false && 0;\n    }\n    return ctx;\n  }\n};\nfunction runtime_core_esm_bundler_isShallow(value) {\n  return !!(value && value["__v_isShallow"]);\n}\nfunction initCustomFormatter() {\n  if (true) {\n    return;\n  }\n  const vueStyle = {\n    style: "color:#3ba776"\n  };\n  const numberStyle = {\n    style: "color:#0b1bc9"\n  };\n  const stringStyle = {\n    style: "color:#b62e24"\n  };\n  const keywordStyle = {\n    style: "color:#9d288c"\n  };\n  const formatter = {\n    header(obj) {\n      if (!isObject(obj)) {\n        return null;\n      }\n      if (obj.__isVue) {\n        return ["div", vueStyle, `VueInstance`];\n      } else if (isRef(obj)) {\n        return ["div", {}, ["span", vueStyle, genRefFlag(obj)], "<", formatValue(obj.value), `>`];\n      } else if (isReactive(obj)) {\n        return ["div", {}, ["span", vueStyle, runtime_core_esm_bundler_isShallow(obj) ? "ShallowReactive" : "Reactive"], "<", formatValue(obj), `>${isReadonly(obj) ? ` (readonly)` : ``}`];\n      } else if (isReadonly(obj)) {\n        return ["div", {}, ["span", vueStyle, runtime_core_esm_bundler_isShallow(obj) ? "ShallowReadonly" : "Readonly"], "<", formatValue(obj), ">"];\n      }\n      return null;\n    },\n    hasBody(obj) {\n      return obj && obj.__isVue;\n    },\n    body(obj) {\n      if (obj && obj.__isVue) {\n        return ["div", {}, ...formatInstance(obj.$)];\n      }\n    }\n  };\n  function formatInstance(instance) {\n    const blocks = [];\n    if (instance.type.props && instance.props) {\n      blocks.push(createInstanceBlock("props", toRaw(instance.props)));\n    }\n    if (instance.setupState !== EMPTY_OBJ) {\n      blocks.push(createInstanceBlock("setup", instance.setupState));\n    }\n    if (instance.data !== EMPTY_OBJ) {\n      blocks.push(createInstanceBlock("data", toRaw(instance.data)));\n    }\n    const computed = extractKeys(instance, "computed");\n    if (computed) {\n      blocks.push(createInstanceBlock("computed", computed));\n    }\n    const injected = extractKeys(instance, "inject");\n    if (injected) {\n      blocks.push(createInstanceBlock("injected", injected));\n    }\n    blocks.push(["div", {}, ["span", {\n      style: keywordStyle.style + ";opacity:0.66"\n    }, "$ (internal): "], ["object", {\n      object: instance\n    }]]);\n    return blocks;\n  }\n  function createInstanceBlock(type, target) {\n    target = extend({}, target);\n    if (!Object.keys(target).length) {\n      return ["span", {}];\n    }\n    return ["div", {\n      style: "line-height:1.25em;margin-bottom:0.6em"\n    }, ["div", {\n      style: "color:#476582"\n    }, type], ["div", {\n      style: "padding-left:1.25em"\n    }, ...Object.keys(target).map(key => {\n      return ["div", {}, ["span", keywordStyle, key + ": "], formatValue(target[key], false)];\n    })]];\n  }\n  function formatValue(v, asRaw = true) {\n    if (typeof v === "number") {\n      return ["span", numberStyle, v];\n    } else if (typeof v === "string") {\n      return ["span", stringStyle, JSON.stringify(v)];\n    } else if (typeof v === "boolean") {\n      return ["span", keywordStyle, v];\n    } else if (isObject(v)) {\n      return ["object", {\n        object: asRaw ? toRaw(v) : v\n      }];\n    } else {\n      return ["span", stringStyle, String(v)];\n    }\n  }\n  function extractKeys(instance, type) {\n    const Comp = instance.type;\n    if (isFunction(Comp)) {\n      return;\n    }\n    const extracted = {};\n    for (const key in instance.ctx) {\n      if (isKeyOfType(Comp, key, type)) {\n        extracted[key] = instance.ctx[key];\n      }\n    }\n    return extracted;\n  }\n  function isKeyOfType(Comp, key, type) {\n    const opts = Comp[type];\n    if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {\n      return true;\n    }\n    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\n      return true;\n    }\n    if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\n      return true;\n    }\n  }\n  function genRefFlag(v) {\n    if (runtime_core_esm_bundler_isShallow(v)) {\n      return `ShallowRef`;\n    }\n    if (v.effect) {\n      return `ComputedRef`;\n    }\n    return `Ref`;\n  }\n  if (window.devtoolsFormatters) {\n    window.devtoolsFormatters.push(formatter);\n  } else {\n    window.devtoolsFormatters = [formatter];\n  }\n}\nfunction withMemo(memo, render, cache, index) {\n  const cached = cache[index];\n  if (cached && isMemoSame(cached, memo)) {\n    return cached;\n  }\n  const ret = render();\n  ret.memo = memo.slice();\n  return cache[index] = ret;\n}\nfunction isMemoSame(cached, memo) {\n  const prev = cached.memo;\n  if (prev.length != memo.length) {\n    return false;\n  }\n  for (let i = 0; i < prev.length; i++) {\n    if (hasChanged(prev[i], memo[i])) {\n      return false;\n    }\n  }\n  if (isBlockTreeEnabled > 0 && currentBlock) {\n    currentBlock.push(cached);\n  }\n  return true;\n}\nconst version = "3.3.4";\nconst _ssrUtils = {\n  createComponentInstance,\n  setupComponent,\n  renderComponentRoot,\n  setCurrentRenderingInstance,\n  isVNode: isVNode,\n  normalizeVNode\n};\nconst ssrUtils = (/* unused pure expression or super */ null && (_ssrUtils));\nconst resolveFilter = null;\nconst compatUtils = null;\n\n;// CONCATENATED MODULE: ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js\n\n\n\nconst svgNS = "http://www.w3.org/2000/svg";\nconst doc = typeof document !== "undefined" ? document : null;\nconst templateContainer = doc && /* @__PURE__ */doc.createElement("template");\nconst nodeOps = {\n  insert: (child, parent, anchor) => {\n    parent.insertBefore(child, anchor || null);\n  },\n  remove: child => {\n    const parent = child.parentNode;\n    if (parent) {\n      parent.removeChild(child);\n    }\n  },\n  createElement: (tag, isSVG, is, props) => {\n    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? {\n      is\n    } : void 0);\n    if (tag === "select" && props && props.multiple != null) {\n      el.setAttribute("multiple", props.multiple);\n    }\n    return el;\n  },\n  createText: text => doc.createTextNode(text),\n  createComment: text => doc.createComment(text),\n  setText: (node, text) => {\n    node.nodeValue = text;\n  },\n  setElementText: (el, text) => {\n    el.textContent = text;\n  },\n  parentNode: node => node.parentNode,\n  nextSibling: node => node.nextSibling,\n  querySelector: selector => doc.querySelector(selector),\n  setScopeId(el, id) {\n    el.setAttribute(id, "");\n  },\n  // __UNSAFE__\n  // Reason: innerHTML.\n  // Static content here can only come from compiled templates.\n  // As long as the user only uses trusted templates, this is safe.\n  insertStaticContent(content, parent, anchor, isSVG, start, end) {\n    const before = anchor ? anchor.previousSibling : parent.lastChild;\n    if (start && (start === end || start.nextSibling)) {\n      while (true) {\n        parent.insertBefore(start.cloneNode(true), anchor);\n        if (start === end || !(start = start.nextSibling)) break;\n      }\n    } else {\n      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;\n      const template = templateContainer.content;\n      if (isSVG) {\n        const wrapper = template.firstChild;\n        while (wrapper.firstChild) {\n          template.appendChild(wrapper.firstChild);\n        }\n        template.removeChild(wrapper);\n      }\n      parent.insertBefore(template, anchor);\n    }\n    return [\n    // first\n    before ? before.nextSibling : parent.firstChild,\n    // last\n    anchor ? anchor.previousSibling : parent.lastChild];\n  }\n};\nfunction patchClass(el, value, isSVG) {\n  const transitionClasses = el._vtc;\n  if (transitionClasses) {\n    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");\n  }\n  if (value == null) {\n    el.removeAttribute("class");\n  } else if (isSVG) {\n    el.setAttribute("class", value);\n  } else {\n    el.className = value;\n  }\n}\nfunction patchStyle(el, prev, next) {\n  const style = el.style;\n  const isCssString = shared_esm_bundler_isString(next);\n  if (next && !isCssString) {\n    if (prev && !shared_esm_bundler_isString(prev)) {\n      for (const key in prev) {\n        if (next[key] == null) {\n          setStyle(style, key, "");\n        }\n      }\n    }\n    for (const key in next) {\n      setStyle(style, key, next[key]);\n    }\n  } else {\n    const currentDisplay = style.display;\n    if (isCssString) {\n      if (prev !== next) {\n        style.cssText = next;\n      }\n    } else if (prev) {\n      el.removeAttribute("style");\n    }\n    if ("_vod" in el) {\n      style.display = currentDisplay;\n    }\n  }\n}\nconst semicolonRE = /[^\\\\];\\s*$/;\nconst importantRE = /\\s*!important$/;\nfunction setStyle(style, name, val) {\n  if (shared_esm_bundler_isArray(val)) {\n    val.forEach(v => setStyle(style, name, v));\n  } else {\n    if (val == null) val = "";\n    if (false) {}\n    if (name.startsWith("--")) {\n      style.setProperty(name, val);\n    } else {\n      const prefixed = autoPrefix(style, name);\n      if (importantRE.test(val)) {\n        style.setProperty(shared_esm_bundler_hyphenate(prefixed), val.replace(importantRE, ""), "important");\n      } else {\n        style[prefixed] = val;\n      }\n    }\n  }\n}\nconst prefixes = ["Webkit", "Moz", "ms"];\nconst prefixCache = {};\nfunction autoPrefix(style, rawName) {\n  const cached = prefixCache[rawName];\n  if (cached) {\n    return cached;\n  }\n  let name = camelize(rawName);\n  if (name !== "filter" && name in style) {\n    return prefixCache[rawName] = name;\n  }\n  name = shared_esm_bundler_capitalize(name);\n  for (let i = 0; i < prefixes.length; i++) {\n    const prefixed = prefixes[i] + name;\n    if (prefixed in style) {\n      return prefixCache[rawName] = prefixed;\n    }\n  }\n  return rawName;\n}\nconst xlinkNS = "http://www.w3.org/1999/xlink";\nfunction patchAttr(el, key, value, isSVG, instance) {\n  if (isSVG && key.startsWith("xlink:")) {\n    if (value == null) {\n      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    const isBoolean = isSpecialBooleanAttr(key);\n    if (value == null || isBoolean && !includeBooleanAttr(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, isBoolean ? "" : value);\n    }\n  }\n}\nfunction patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {\n  if (key === "innerHTML" || key === "textContent") {\n    if (prevChildren) {\n      unmountChildren(prevChildren, parentComponent, parentSuspense);\n    }\n    el[key] = value == null ? "" : value;\n    return;\n  }\n  const tag = el.tagName;\n  if (key === "value" && tag !== "PROGRESS" &&\n  // custom elements may use _value internally\n  !tag.includes("-")) {\n    el._value = value;\n    const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;\n    const newValue = value == null ? "" : value;\n    if (oldValue !== newValue) {\n      el.value = newValue;\n    }\n    if (value == null) {\n      el.removeAttribute(key);\n    }\n    return;\n  }\n  let needRemove = false;\n  if (value === "" || value == null) {\n    const type = typeof el[key];\n    if (type === "boolean") {\n      value = includeBooleanAttr(value);\n    } else if (value == null && type === "string") {\n      value = "";\n      needRemove = true;\n    } else if (type === "number") {\n      value = 0;\n      needRemove = true;\n    }\n  }\n  try {\n    el[key] = value;\n  } catch (e) {\n    if (false) {}\n  }\n  needRemove && el.removeAttribute(key);\n}\nfunction addEventListener(el, event, handler, options) {\n  el.addEventListener(event, handler, options);\n}\nfunction removeEventListener(el, event, handler, options) {\n  el.removeEventListener(event, handler, options);\n}\nfunction patchEvent(el, rawName, prevValue, nextValue, instance = null) {\n  const invokers = el._vei || (el._vei = {});\n  const existingInvoker = invokers[rawName];\n  if (nextValue && existingInvoker) {\n    existingInvoker.value = nextValue;\n  } else {\n    const [name, options] = parseName(rawName);\n    if (nextValue) {\n      const invoker = invokers[rawName] = createInvoker(nextValue, instance);\n      addEventListener(el, name, invoker, options);\n    } else if (existingInvoker) {\n      removeEventListener(el, name, existingInvoker, options);\n      invokers[rawName] = void 0;\n    }\n  }\n}\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/;\nfunction parseName(name) {\n  let options;\n  if (optionsModifierRE.test(name)) {\n    options = {};\n    let m;\n    while (m = name.match(optionsModifierRE)) {\n      name = name.slice(0, name.length - m[0].length);\n      options[m[0].toLowerCase()] = true;\n    }\n  }\n  const event = name[2] === ":" ? name.slice(3) : shared_esm_bundler_hyphenate(name.slice(2));\n  return [event, options];\n}\nlet cachedNow = 0;\nconst p = /* @__PURE__ */Promise.resolve();\nconst getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());\nfunction createInvoker(initialValue, instance) {\n  const invoker = e => {\n    if (!e._vts) {\n      e._vts = Date.now();\n    } else if (e._vts <= invoker.attached) {\n      return;\n    }\n    callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);\n  };\n  invoker.value = initialValue;\n  invoker.attached = getNow();\n  return invoker;\n}\nfunction patchStopImmediatePropagation(e, value) {\n  if (shared_esm_bundler_isArray(value)) {\n    const originalStop = e.stopImmediatePropagation;\n    e.stopImmediatePropagation = () => {\n      originalStop.call(e);\n      e._stopped = true;\n    };\n    return value.map(fn => e2 => !e2._stopped && fn && fn(e2));\n  } else {\n    return value;\n  }\n}\nconst nativeOnRE = /^on[a-z]/;\nconst patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {\n  if (key === "class") {\n    patchClass(el, nextValue, isSVG);\n  } else if (key === "style") {\n    patchStyle(el, prevValue, nextValue);\n  } else if (shared_esm_bundler_isOn(key)) {\n    if (!isModelListener(key)) {\n      patchEvent(el, key, prevValue, nextValue, parentComponent);\n    }\n  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {\n    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);\n  } else {\n    if (key === "true-value") {\n      el._trueValue = nextValue;\n    } else if (key === "false-value") {\n      el._falseValue = nextValue;\n    }\n    patchAttr(el, key, nextValue, isSVG);\n  }\n};\nfunction shouldSetAsProp(el, key, value, isSVG) {\n  if (isSVG) {\n    if (key === "innerHTML" || key === "textContent") {\n      return true;\n    }\n    if (key in el && nativeOnRE.test(key) && shared_esm_bundler_isFunction(value)) {\n      return true;\n    }\n    return false;\n  }\n  if (key === "spellcheck" || key === "draggable" || key === "translate") {\n    return false;\n  }\n  if (key === "form") {\n    return false;\n  }\n  if (key === "list" && el.tagName === "INPUT") {\n    return false;\n  }\n  if (key === "type" && el.tagName === "TEXTAREA") {\n    return false;\n  }\n  if (nativeOnRE.test(key) && shared_esm_bundler_isString(value)) {\n    return false;\n  }\n  return key in el;\n}\nfunction defineCustomElement(options, hydrate2) {\n  const Comp = defineComponent(options);\n  class VueCustomElement extends VueElement {\n    constructor(initialProps) {\n      super(Comp, initialProps, hydrate2);\n    }\n  }\n  VueCustomElement.def = Comp;\n  return VueCustomElement;\n}\nconst defineSSRCustomElement = options => {\n  return defineCustomElement(options, hydrate);\n};\nconst BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {};\nclass VueElement extends (/* unused pure expression or super */ null && (BaseClass)) {\n  constructor(_def, _props = {}, hydrate2) {\n    super();\n    this._def = _def;\n    this._props = _props;\n    /**\n     * @internal\n     */\n    this._instance = null;\n    this._connected = false;\n    this._resolved = false;\n    this._numberProps = null;\n    if (this.shadowRoot && hydrate2) {\n      hydrate2(this._createVNode(), this.shadowRoot);\n    } else {\n      if (false) {}\n      this.attachShadow({\n        mode: "open"\n      });\n      if (!this._def.__asyncLoader) {\n        this._resolveProps(this._def);\n      }\n    }\n  }\n  connectedCallback() {\n    this._connected = true;\n    if (!this._instance) {\n      if (this._resolved) {\n        this._update();\n      } else {\n        this._resolveDef();\n      }\n    }\n  }\n  disconnectedCallback() {\n    this._connected = false;\n    nextTick(() => {\n      if (!this._connected) {\n        render(null, this.shadowRoot);\n        this._instance = null;\n      }\n    });\n  }\n  /**\n   * resolve inner component definition (handle possible async component)\n   */\n  _resolveDef() {\n    this._resolved = true;\n    for (let i = 0; i < this.attributes.length; i++) {\n      this._setAttr(this.attributes[i].name);\n    }\n    new MutationObserver(mutations => {\n      for (const m of mutations) {\n        this._setAttr(m.attributeName);\n      }\n    }).observe(this, {\n      attributes: true\n    });\n    const resolve = (def, isAsync = false) => {\n      const {\n        props,\n        styles\n      } = def;\n      let numberProps;\n      if (props && !isArray(props)) {\n        for (const key in props) {\n          const opt = props[key];\n          if (opt === Number || opt && opt.type === Number) {\n            if (key in this._props) {\n              this._props[key] = toNumber(this._props[key]);\n            }\n            (numberProps || (numberProps = /* @__PURE__ */Object.create(null)))[camelize$1(key)] = true;\n          }\n        }\n      }\n      this._numberProps = numberProps;\n      if (isAsync) {\n        this._resolveProps(def);\n      }\n      this._applyStyles(styles);\n      this._update();\n    };\n    const asyncDef = this._def.__asyncLoader;\n    if (asyncDef) {\n      asyncDef().then(def => resolve(def, true));\n    } else {\n      resolve(this._def);\n    }\n  }\n  _resolveProps(def) {\n    const {\n      props\n    } = def;\n    const declaredPropKeys = isArray(props) ? props : Object.keys(props || {});\n    for (const key of Object.keys(this)) {\n      if (key[0] !== "_" && declaredPropKeys.includes(key)) {\n        this._setProp(key, this[key], true, false);\n      }\n    }\n    for (const key of declaredPropKeys.map(camelize$1)) {\n      Object.defineProperty(this, key, {\n        get() {\n          return this._getProp(key);\n        },\n        set(val) {\n          this._setProp(key, val);\n        }\n      });\n    }\n  }\n  _setAttr(key) {\n    let value = this.getAttribute(key);\n    const camelKey = camelize$1(key);\n    if (this._numberProps && this._numberProps[camelKey]) {\n      value = toNumber(value);\n    }\n    this._setProp(camelKey, value, false);\n  }\n  /**\n   * @internal\n   */\n  _getProp(key) {\n    return this._props[key];\n  }\n  /**\n   * @internal\n   */\n  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {\n    if (val !== this._props[key]) {\n      this._props[key] = val;\n      if (shouldUpdate && this._instance) {\n        this._update();\n      }\n      if (shouldReflect) {\n        if (val === true) {\n          this.setAttribute(hyphenate(key), "");\n        } else if (typeof val === "string" || typeof val === "number") {\n          this.setAttribute(hyphenate(key), val + "");\n        } else if (!val) {\n          this.removeAttribute(hyphenate(key));\n        }\n      }\n    }\n  }\n  _update() {\n    render(this._createVNode(), this.shadowRoot);\n  }\n  _createVNode() {\n    const vnode = createVNode(this._def, extend({}, this._props));\n    if (!this._instance) {\n      vnode.ce = instance => {\n        this._instance = instance;\n        instance.isCE = true;\n        if (false) {}\n        const dispatch = (event, args) => {\n          this.dispatchEvent(new CustomEvent(event, {\n            detail: args\n          }));\n        };\n        instance.emit = (event, ...args) => {\n          dispatch(event, args);\n          if (hyphenate(event) !== event) {\n            dispatch(hyphenate(event), args);\n          }\n        };\n        let parent = this;\n        while (parent = parent && (parent.parentNode || parent.host)) {\n          if (parent instanceof VueElement) {\n            instance.parent = parent._instance;\n            instance.provides = parent._instance.provides;\n            break;\n          }\n        }\n      };\n    }\n    return vnode;\n  }\n  _applyStyles(styles) {\n    if (styles) {\n      styles.forEach(css => {\n        const s = document.createElement("style");\n        s.textContent = css;\n        this.shadowRoot.appendChild(s);\n        if (false) {}\n      });\n    }\n  }\n}\nfunction useCssModule(name = "$style") {\n  {\n    const instance = getCurrentInstance();\n    if (!instance) {\n       false && 0;\n      return EMPTY_OBJ;\n    }\n    const modules = instance.type.__cssModules;\n    if (!modules) {\n       false && 0;\n      return EMPTY_OBJ;\n    }\n    const mod = modules[name];\n    if (!mod) {\n       false && 0;\n      return EMPTY_OBJ;\n    }\n    return mod;\n  }\n}\nfunction useCssVars(getter) {\n  const instance = getCurrentInstance();\n  if (!instance) {\n     false && 0;\n    return;\n  }\n  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {\n    Array.from(document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)).forEach(node => setVarsOnNode(node, vars));\n  };\n  const setVars = () => {\n    const vars = getter(instance.proxy);\n    setVarsOnVNode(instance.subTree, vars);\n    updateTeleports(vars);\n  };\n  watchPostEffect(setVars);\n  onMounted(() => {\n    const ob = new MutationObserver(setVars);\n    ob.observe(instance.subTree.el.parentNode, {\n      childList: true\n    });\n    onUnmounted(() => ob.disconnect());\n  });\n}\nfunction setVarsOnVNode(vnode, vars) {\n  if (vnode.shapeFlag & 128) {\n    const suspense = vnode.suspense;\n    vnode = suspense.activeBranch;\n    if (suspense.pendingBranch && !suspense.isHydrating) {\n      suspense.effects.push(() => {\n        setVarsOnVNode(suspense.activeBranch, vars);\n      });\n    }\n  }\n  while (vnode.component) {\n    vnode = vnode.component.subTree;\n  }\n  if (vnode.shapeFlag & 1 && vnode.el) {\n    setVarsOnNode(vnode.el, vars);\n  } else if (vnode.type === Fragment) {\n    vnode.children.forEach(c => setVarsOnVNode(c, vars));\n  } else if (vnode.type === Static) {\n    let {\n      el,\n      anchor\n    } = vnode;\n    while (el) {\n      setVarsOnNode(el, vars);\n      if (el === anchor) break;\n      el = el.nextSibling;\n    }\n  }\n}\nfunction setVarsOnNode(el, vars) {\n  if (el.nodeType === 1) {\n    const style = el.style;\n    for (const key in vars) {\n      style.setProperty(`--${key}`, vars[key]);\n    }\n  }\n}\nconst TRANSITION = "transition";\nconst ANIMATION = "animation";\nconst Transition = (props, {\n  slots\n}) => h(BaseTransition, resolveTransitionProps(props), slots);\nTransition.displayName = "Transition";\nconst DOMTransitionPropsValidators = {\n  name: String,\n  type: String,\n  css: {\n    type: Boolean,\n    default: true\n  },\n  duration: [String, Number, Object],\n  enterFromClass: String,\n  enterActiveClass: String,\n  enterToClass: String,\n  appearFromClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  leaveFromClass: String,\n  leaveActiveClass: String,\n  leaveToClass: String\n};\nconst TransitionPropsValidators = Transition.props = /* @__PURE__ */shared_esm_bundler_extend({}, BaseTransitionPropsValidators, DOMTransitionPropsValidators);\nconst runtime_dom_esm_bundler_callHook = (hook, args = []) => {\n  if (shared_esm_bundler_isArray(hook)) {\n    hook.forEach(h2 => h2(...args));\n  } else if (hook) {\n    hook(...args);\n  }\n};\nconst hasExplicitCallback = hook => {\n  return hook ? shared_esm_bundler_isArray(hook) ? hook.some(h2 => h2.length > 1) : hook.length > 1 : false;\n};\nfunction resolveTransitionProps(rawProps) {\n  const baseProps = {};\n  for (const key in rawProps) {\n    if (!(key in DOMTransitionPropsValidators)) {\n      baseProps[key] = rawProps[key];\n    }\n  }\n  if (rawProps.css === false) {\n    return baseProps;\n  }\n  const {\n    name = "v",\n    type,\n    duration,\n    enterFromClass = `${name}-enter-from`,\n    enterActiveClass = `${name}-enter-active`,\n    enterToClass = `${name}-enter-to`,\n    appearFromClass = enterFromClass,\n    appearActiveClass = enterActiveClass,\n    appearToClass = enterToClass,\n    leaveFromClass = `${name}-leave-from`,\n    leaveActiveClass = `${name}-leave-active`,\n    leaveToClass = `${name}-leave-to`\n  } = rawProps;\n  const durations = normalizeDuration(duration);\n  const enterDuration = durations && durations[0];\n  const leaveDuration = durations && durations[1];\n  const {\n    onBeforeEnter,\n    onEnter,\n    onEnterCancelled,\n    onLeave,\n    onLeaveCancelled,\n    onBeforeAppear = onBeforeEnter,\n    onAppear = onEnter,\n    onAppearCancelled = onEnterCancelled\n  } = baseProps;\n  const finishEnter = (el, isAppear, done) => {\n    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);\n    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);\n    done && done();\n  };\n  const finishLeave = (el, done) => {\n    el._isLeaving = false;\n    removeTransitionClass(el, leaveFromClass);\n    removeTransitionClass(el, leaveToClass);\n    removeTransitionClass(el, leaveActiveClass);\n    done && done();\n  };\n  const makeEnterHook = isAppear => {\n    return (el, done) => {\n      const hook = isAppear ? onAppear : onEnter;\n      const resolve = () => finishEnter(el, isAppear, done);\n      runtime_dom_esm_bundler_callHook(hook, [el, resolve]);\n      nextFrame(() => {\n        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);\n        addTransitionClass(el, isAppear ? appearToClass : enterToClass);\n        if (!hasExplicitCallback(hook)) {\n          whenTransitionEnds(el, type, enterDuration, resolve);\n        }\n      });\n    };\n  };\n  return shared_esm_bundler_extend(baseProps, {\n    onBeforeEnter(el) {\n      runtime_dom_esm_bundler_callHook(onBeforeEnter, [el]);\n      addTransitionClass(el, enterFromClass);\n      addTransitionClass(el, enterActiveClass);\n    },\n    onBeforeAppear(el) {\n      runtime_dom_esm_bundler_callHook(onBeforeAppear, [el]);\n      addTransitionClass(el, appearFromClass);\n      addTransitionClass(el, appearActiveClass);\n    },\n    onEnter: makeEnterHook(false),\n    onAppear: makeEnterHook(true),\n    onLeave(el, done) {\n      el._isLeaving = true;\n      const resolve = () => finishLeave(el, done);\n      addTransitionClass(el, leaveFromClass);\n      forceReflow();\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(() => {\n        if (!el._isLeaving) {\n          return;\n        }\n        removeTransitionClass(el, leaveFromClass);\n        addTransitionClass(el, leaveToClass);\n        if (!hasExplicitCallback(onLeave)) {\n          whenTransitionEnds(el, type, leaveDuration, resolve);\n        }\n      });\n      runtime_dom_esm_bundler_callHook(onLeave, [el, resolve]);\n    },\n    onEnterCancelled(el) {\n      finishEnter(el, false);\n      runtime_dom_esm_bundler_callHook(onEnterCancelled, [el]);\n    },\n    onAppearCancelled(el) {\n      finishEnter(el, true);\n      runtime_dom_esm_bundler_callHook(onAppearCancelled, [el]);\n    },\n    onLeaveCancelled(el) {\n      finishLeave(el);\n      runtime_dom_esm_bundler_callHook(onLeaveCancelled, [el]);\n    }\n  });\n}\nfunction normalizeDuration(duration) {\n  if (duration == null) {\n    return null;\n  } else if (shared_esm_bundler_isObject(duration)) {\n    return [NumberOf(duration.enter), NumberOf(duration.leave)];\n  } else {\n    const n = NumberOf(duration);\n    return [n, n];\n  }\n}\nfunction NumberOf(val) {\n  const res = shared_esm_bundler_toNumber(val);\n  if (false) {}\n  return res;\n}\nfunction addTransitionClass(el, cls) {\n  cls.split(/\\s+/).forEach(c => c && el.classList.add(c));\n  (el._vtc || (el._vtc = /* @__PURE__ */new Set())).add(cls);\n}\nfunction removeTransitionClass(el, cls) {\n  cls.split(/\\s+/).forEach(c => c && el.classList.remove(c));\n  const {\n    _vtc\n  } = el;\n  if (_vtc) {\n    _vtc.delete(cls);\n    if (!_vtc.size) {\n      el._vtc = void 0;\n    }\n  }\n}\nfunction nextFrame(cb) {\n  requestAnimationFrame(() => {\n    requestAnimationFrame(cb);\n  });\n}\nlet endId = 0;\nfunction whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {\n  const id = el._endId = ++endId;\n  const resolveIfNotStale = () => {\n    if (id === el._endId) {\n      resolve();\n    }\n  };\n  if (explicitTimeout) {\n    return setTimeout(resolveIfNotStale, explicitTimeout);\n  }\n  const {\n    type,\n    timeout,\n    propCount\n  } = getTransitionInfo(el, expectedType);\n  if (!type) {\n    return resolve();\n  }\n  const endEvent = type + "end";\n  let ended = 0;\n  const end = () => {\n    el.removeEventListener(endEvent, onEnd);\n    resolveIfNotStale();\n  };\n  const onEnd = e => {\n    if (e.target === el && ++ended >= propCount) {\n      end();\n    }\n  };\n  setTimeout(() => {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(endEvent, onEnd);\n}\nfunction getTransitionInfo(el, expectedType) {\n  const styles = window.getComputedStyle(el);\n  const getStyleProperties = key => (styles[key] || "").split(", ");\n  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);\n  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);\n  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);\n  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);\n  const animationTimeout = getTimeout(animationDelays, animationDurations);\n  let type = null;\n  let timeout = 0;\n  let propCount = 0;\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n  }\n  const hasTransform = type === TRANSITION && /\\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());\n  return {\n    type,\n    timeout,\n    propCount,\n    hasTransform\n  };\n}\nfunction getTimeout(delays, durations) {\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));\n}\nfunction toMs(s) {\n  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;\n}\nfunction forceReflow() {\n  return document.body.offsetHeight;\n}\nconst positionMap = /* @__PURE__ */new WeakMap();\nconst newPositionMap = /* @__PURE__ */new WeakMap();\nconst TransitionGroupImpl = {\n  name: "TransitionGroup",\n  props: /* @__PURE__ */shared_esm_bundler_extend({}, TransitionPropsValidators, {\n    tag: String,\n    moveClass: String\n  }),\n  setup(props, {\n    slots\n  }) {\n    const instance = runtime_core_esm_bundler_getCurrentInstance();\n    const state = useTransitionState();\n    let prevChildren;\n    let children;\n    onUpdated(() => {\n      if (!prevChildren.length) {\n        return;\n      }\n      const moveClass = props.moveClass || `${props.name || "v"}-move`;\n      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {\n        return;\n      }\n      prevChildren.forEach(callPendingCbs);\n      prevChildren.forEach(recordPosition);\n      const movedChildren = prevChildren.filter(applyTranslation);\n      forceReflow();\n      movedChildren.forEach(c => {\n        const el = c.el;\n        const style = el.style;\n        addTransitionClass(el, moveClass);\n        style.transform = style.webkitTransform = style.transitionDuration = "";\n        const cb = el._moveCb = e => {\n          if (e && e.target !== el) {\n            return;\n          }\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener("transitionend", cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        };\n        el.addEventListener("transitionend", cb);\n      });\n    });\n    return () => {\n      const rawProps = reactivity_esm_bundler_toRaw(props);\n      const cssTransitionProps = resolveTransitionProps(rawProps);\n      let tag = rawProps.tag || runtime_core_esm_bundler_Fragment;\n      prevChildren = children;\n      children = slots.default ? getTransitionRawChildren(slots.default()) : [];\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (child.key != null) {\n          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));\n        } else if (false) {}\n      }\n      if (prevChildren) {\n        for (let i = 0; i < prevChildren.length; i++) {\n          const child = prevChildren[i];\n          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));\n          positionMap.set(child, child.el.getBoundingClientRect());\n        }\n      }\n      return runtime_core_esm_bundler_createVNode(tag, null, children);\n    };\n  }\n};\nconst removeMode = props => delete props.mode;\n/* @__PURE__ */\nremoveMode(TransitionGroupImpl.props);\nconst TransitionGroup = (/* unused pure expression or super */ null && (TransitionGroupImpl));\nfunction callPendingCbs(c) {\n  const el = c.el;\n  if (el._moveCb) {\n    el._moveCb();\n  }\n  if (el._enterCb) {\n    el._enterCb();\n  }\n}\nfunction recordPosition(c) {\n  newPositionMap.set(c, c.el.getBoundingClientRect());\n}\nfunction applyTranslation(c) {\n  const oldPos = positionMap.get(c);\n  const newPos = newPositionMap.get(c);\n  const dx = oldPos.left - newPos.left;\n  const dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    const s = c.el.style;\n    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;\n    s.transitionDuration = "0s";\n    return c;\n  }\n}\nfunction hasCSSTransform(el, root, moveClass) {\n  const clone = el.cloneNode();\n  if (el._vtc) {\n    el._vtc.forEach(cls => {\n      cls.split(/\\s+/).forEach(c => c && clone.classList.remove(c));\n    });\n  }\n  moveClass.split(/\\s+/).forEach(c => c && clone.classList.add(c));\n  clone.style.display = "none";\n  const container = root.nodeType === 1 ? root : root.parentNode;\n  container.appendChild(clone);\n  const {\n    hasTransform\n  } = getTransitionInfo(clone);\n  container.removeChild(clone);\n  return hasTransform;\n}\nconst getModelAssigner = vnode => {\n  const fn = vnode.props["onUpdate:modelValue"] || false;\n  return shared_esm_bundler_isArray(fn) ? value => invokeArrayFns(fn, value) : fn;\n};\nfunction onCompositionStart(e) {\n  e.target.composing = true;\n}\nfunction onCompositionEnd(e) {\n  const target = e.target;\n  if (target.composing) {\n    target.composing = false;\n    target.dispatchEvent(new Event("input"));\n  }\n}\nconst vModelText = {\n  created(el, {\n    modifiers: {\n      lazy,\n      trim,\n      number\n    }\n  }, vnode) {\n    el._assign = getModelAssigner(vnode);\n    const castToNumber = number || vnode.props && vnode.props.type === "number";\n    addEventListener(el, lazy ? "change" : "input", e => {\n      if (e.target.composing) return;\n      let domValue = el.value;\n      if (trim) {\n        domValue = domValue.trim();\n      }\n      if (castToNumber) {\n        domValue = looseToNumber(domValue);\n      }\n      el._assign(domValue);\n    });\n    if (trim) {\n      addEventListener(el, "change", () => {\n        el.value = el.value.trim();\n      });\n    }\n    if (!lazy) {\n      addEventListener(el, "compositionstart", onCompositionStart);\n      addEventListener(el, "compositionend", onCompositionEnd);\n      addEventListener(el, "change", onCompositionEnd);\n    }\n  },\n  // set value on mounted so it\'s after min/max for type="range"\n  mounted(el, {\n    value\n  }) {\n    el.value = value == null ? "" : value;\n  },\n  beforeUpdate(el, {\n    value,\n    modifiers: {\n      lazy,\n      trim,\n      number\n    }\n  }, vnode) {\n    el._assign = getModelAssigner(vnode);\n    if (el.composing) return;\n    if (document.activeElement === el && el.type !== "range") {\n      if (lazy) {\n        return;\n      }\n      if (trim && el.value.trim() === value) {\n        return;\n      }\n      if ((number || el.type === "number") && looseToNumber(el.value) === value) {\n        return;\n      }\n    }\n    const newValue = value == null ? "" : value;\n    if (el.value !== newValue) {\n      el.value = newValue;\n    }\n  }\n};\nconst vModelCheckbox = {\n  // #4096 array checkboxes need to be deep traversed\n  deep: true,\n  created(el, _, vnode) {\n    el._assign = getModelAssigner(vnode);\n    addEventListener(el, "change", () => {\n      const modelValue = el._modelValue;\n      const elementValue = getValue(el);\n      const checked = el.checked;\n      const assign = el._assign;\n      if (shared_esm_bundler_isArray(modelValue)) {\n        const index = shared_esm_bundler_looseIndexOf(modelValue, elementValue);\n        const found = index !== -1;\n        if (checked && !found) {\n          assign(modelValue.concat(elementValue));\n        } else if (!checked && found) {\n          const filtered = [...modelValue];\n          filtered.splice(index, 1);\n          assign(filtered);\n        }\n      } else if (shared_esm_bundler_isSet(modelValue)) {\n        const cloned = new Set(modelValue);\n        if (checked) {\n          cloned.add(elementValue);\n        } else {\n          cloned.delete(elementValue);\n        }\n        assign(cloned);\n      } else {\n        assign(getCheckboxValue(el, checked));\n      }\n    });\n  },\n  // set initial checked on mount to wait for true-value/false-value\n  mounted: setChecked,\n  beforeUpdate(el, binding, vnode) {\n    el._assign = getModelAssigner(vnode);\n    setChecked(el, binding, vnode);\n  }\n};\nfunction setChecked(el, {\n  value,\n  oldValue\n}, vnode) {\n  el._modelValue = value;\n  if (shared_esm_bundler_isArray(value)) {\n    el.checked = shared_esm_bundler_looseIndexOf(value, vnode.props.value) > -1;\n  } else if (shared_esm_bundler_isSet(value)) {\n    el.checked = value.has(vnode.props.value);\n  } else if (value !== oldValue) {\n    el.checked = shared_esm_bundler_looseEqual(value, getCheckboxValue(el, true));\n  }\n}\nconst vModelRadio = {\n  created(el, {\n    value\n  }, vnode) {\n    el.checked = shared_esm_bundler_looseEqual(value, vnode.props.value);\n    el._assign = getModelAssigner(vnode);\n    addEventListener(el, "change", () => {\n      el._assign(getValue(el));\n    });\n  },\n  beforeUpdate(el, {\n    value,\n    oldValue\n  }, vnode) {\n    el._assign = getModelAssigner(vnode);\n    if (value !== oldValue) {\n      el.checked = shared_esm_bundler_looseEqual(value, vnode.props.value);\n    }\n  }\n};\nconst vModelSelect = {\n  // <select multiple> value need to be deep traversed\n  deep: true,\n  created(el, {\n    value,\n    modifiers: {\n      number\n    }\n  }, vnode) {\n    const isSetModel = shared_esm_bundler_isSet(value);\n    addEventListener(el, "change", () => {\n      const selectedVal = Array.prototype.filter.call(el.options, o => o.selected).map(o => number ? looseToNumber(getValue(o)) : getValue(o));\n      el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);\n    });\n    el._assign = getModelAssigner(vnode);\n  },\n  // set value in mounted & updated because <select> relies on its children\n  // <option>s.\n  mounted(el, {\n    value\n  }) {\n    setSelected(el, value);\n  },\n  beforeUpdate(el, _binding, vnode) {\n    el._assign = getModelAssigner(vnode);\n  },\n  updated(el, {\n    value\n  }) {\n    setSelected(el, value);\n  }\n};\nfunction setSelected(el, value) {\n  const isMultiple = el.multiple;\n  if (isMultiple && !shared_esm_bundler_isArray(value) && !shared_esm_bundler_isSet(value)) {\n     false && 0;\n    return;\n  }\n  for (let i = 0, l = el.options.length; i < l; i++) {\n    const option = el.options[i];\n    const optionValue = getValue(option);\n    if (isMultiple) {\n      if (shared_esm_bundler_isArray(value)) {\n        option.selected = shared_esm_bundler_looseIndexOf(value, optionValue) > -1;\n      } else {\n        option.selected = value.has(optionValue);\n      }\n    } else {\n      if (shared_esm_bundler_looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) el.selectedIndex = i;\n        return;\n      }\n    }\n  }\n  if (!isMultiple && el.selectedIndex !== -1) {\n    el.selectedIndex = -1;\n  }\n}\nfunction getValue(el) {\n  return "_value" in el ? el._value : el.value;\n}\nfunction getCheckboxValue(el, checked) {\n  const key = checked ? "_trueValue" : "_falseValue";\n  return key in el ? el[key] : checked;\n}\nconst vModelDynamic = {\n  created(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, "created");\n  },\n  mounted(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, "mounted");\n  },\n  beforeUpdate(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");\n  },\n  updated(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, "updated");\n  }\n};\nfunction resolveDynamicModel(tagName, type) {\n  switch (tagName) {\n    case "SELECT":\n      return vModelSelect;\n    case "TEXTAREA":\n      return vModelText;\n    default:\n      switch (type) {\n        case "checkbox":\n          return vModelCheckbox;\n        case "radio":\n          return vModelRadio;\n        default:\n          return vModelText;\n      }\n  }\n}\nfunction callModelHook(el, binding, vnode, prevVNode, hook) {\n  const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);\n  const fn = modelToUse[hook];\n  fn && fn(el, binding, vnode, prevVNode);\n}\nfunction initVModelForSSR() {\n  vModelText.getSSRProps = ({\n    value\n  }) => ({\n    value\n  });\n  vModelRadio.getSSRProps = ({\n    value\n  }, vnode) => {\n    if (vnode.props && looseEqual(vnode.props.value, value)) {\n      return {\n        checked: true\n      };\n    }\n  };\n  vModelCheckbox.getSSRProps = ({\n    value\n  }, vnode) => {\n    if (isArray(value)) {\n      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {\n        return {\n          checked: true\n        };\n      }\n    } else if (isSet(value)) {\n      if (vnode.props && value.has(vnode.props.value)) {\n        return {\n          checked: true\n        };\n      }\n    } else if (value) {\n      return {\n        checked: true\n      };\n    }\n  };\n  vModelDynamic.getSSRProps = (binding, vnode) => {\n    if (typeof vnode.type !== "string") {\n      return;\n    }\n    const modelToUse = resolveDynamicModel(\n    // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase\n    vnode.type.toUpperCase(), vnode.props && vnode.props.type);\n    if (modelToUse.getSSRProps) {\n      return modelToUse.getSSRProps(binding, vnode);\n    }\n  };\n}\nconst systemModifiers = ["ctrl", "shift", "alt", "meta"];\nconst modifierGuards = {\n  stop: e => e.stopPropagation(),\n  prevent: e => e.preventDefault(),\n  self: e => e.target !== e.currentTarget,\n  ctrl: e => !e.ctrlKey,\n  shift: e => !e.shiftKey,\n  alt: e => !e.altKey,\n  meta: e => !e.metaKey,\n  left: e => "button" in e && e.button !== 0,\n  middle: e => "button" in e && e.button !== 1,\n  right: e => "button" in e && e.button !== 2,\n  exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))\n};\nconst withModifiers = (fn, modifiers) => {\n  return (event, ...args) => {\n    for (let i = 0; i < modifiers.length; i++) {\n      const guard = modifierGuards[modifiers[i]];\n      if (guard && guard(event, modifiers)) return;\n    }\n    return fn(event, ...args);\n  };\n};\nconst keyNames = {\n  esc: "escape",\n  space: " ",\n  up: "arrow-up",\n  left: "arrow-left",\n  right: "arrow-right",\n  down: "arrow-down",\n  delete: "backspace"\n};\nconst withKeys = (fn, modifiers) => {\n  return event => {\n    if (!("key" in event)) {\n      return;\n    }\n    const eventKey = hyphenate(event.key);\n    if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {\n      return fn(event);\n    }\n  };\n};\nconst vShow = {\n  beforeMount(el, {\n    value\n  }, {\n    transition\n  }) {\n    el._vod = el.style.display === "none" ? "" : el.style.display;\n    if (transition && value) {\n      transition.beforeEnter(el);\n    } else {\n      setDisplay(el, value);\n    }\n  },\n  mounted(el, {\n    value\n  }, {\n    transition\n  }) {\n    if (transition && value) {\n      transition.enter(el);\n    }\n  },\n  updated(el, {\n    value,\n    oldValue\n  }, {\n    transition\n  }) {\n    if (!value === !oldValue) return;\n    if (transition) {\n      if (value) {\n        transition.beforeEnter(el);\n        setDisplay(el, true);\n        transition.enter(el);\n      } else {\n        transition.leave(el, () => {\n          setDisplay(el, false);\n        });\n      }\n    } else {\n      setDisplay(el, value);\n    }\n  },\n  beforeUnmount(el, {\n    value\n  }) {\n    setDisplay(el, value);\n  }\n};\nfunction setDisplay(el, value) {\n  el.style.display = value ? el._vod : "none";\n}\nfunction initVShowForSSR() {\n  vShow.getSSRProps = ({\n    value\n  }) => {\n    if (!value) {\n      return {\n        style: {\n          display: "none"\n        }\n      };\n    }\n  };\n}\nconst rendererOptions = /* @__PURE__ */shared_esm_bundler_extend({\n  patchProp\n}, nodeOps);\nlet renderer;\nlet enabledHydration = false;\nfunction ensureRenderer() {\n  return renderer || (renderer = createRenderer(rendererOptions));\n}\nfunction ensureHydrationRenderer() {\n  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);\n  enabledHydration = true;\n  return renderer;\n}\nconst render = (...args) => {\n  ensureRenderer().render(...args);\n};\nconst hydrate = (...args) => {\n  ensureHydrationRenderer().hydrate(...args);\n};\nconst createApp = (...args) => {\n  const app = ensureRenderer().createApp(...args);\n  if (false) {}\n  const {\n    mount\n  } = app;\n  app.mount = containerOrSelector => {\n    const container = normalizeContainer(containerOrSelector);\n    if (!container) return;\n    const component = app._component;\n    if (!shared_esm_bundler_isFunction(component) && !component.render && !component.template) {\n      component.template = container.innerHTML;\n    }\n    container.innerHTML = "";\n    const proxy = mount(container, false, container instanceof SVGElement);\n    if (container instanceof Element) {\n      container.removeAttribute("v-cloak");\n      container.setAttribute("data-v-app", "");\n    }\n    return proxy;\n  };\n  return app;\n};\nconst createSSRApp = (...args) => {\n  const app = ensureHydrationRenderer().createApp(...args);\n  if (false) {}\n  const {\n    mount\n  } = app;\n  app.mount = containerOrSelector => {\n    const container = normalizeContainer(containerOrSelector);\n    if (container) {\n      return mount(container, true, container instanceof SVGElement);\n    }\n  };\n  return app;\n};\nfunction injectNativeTagCheck(app) {\n  Object.defineProperty(app.config, "isNativeTag", {\n    value: tag => isHTMLTag(tag) || isSVGTag(tag),\n    writable: false\n  });\n}\nfunction injectCompilerOptionsCheck(app) {\n  if (isRuntimeOnly()) {\n    const isCustomElement = app.config.isCustomElement;\n    Object.defineProperty(app.config, "isCustomElement", {\n      get() {\n        return isCustomElement;\n      },\n      set() {\n        warn(`The \\`isCustomElement\\` config option is deprecated. Use \\`compilerOptions.isCustomElement\\` instead.`);\n      }\n    });\n    const compilerOptions = app.config.compilerOptions;\n    const msg = `The \\`compilerOptions\\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \\`compilerOptions\\` must be passed to \\`@vue/compiler-dom\\` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s \\`compilerOptions\\` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;\n    Object.defineProperty(app.config, "compilerOptions", {\n      get() {\n        warn(msg);\n        return compilerOptions;\n      },\n      set() {\n        warn(msg);\n      }\n    });\n  }\n}\nfunction normalizeContainer(container) {\n  if (shared_esm_bundler_isString(container)) {\n    const res = document.querySelector(container);\n    if (false) {}\n    return res;\n  }\n  if (false) {}\n  return container;\n}\nlet ssrDirectiveInitialized = false;\nconst initDirectivesForSSR = () => {\n  if (!ssrDirectiveInitialized) {\n    ssrDirectiveInitialized = true;\n    initVModelForSSR();\n    initVShowForSSR();\n  }\n};\n\n;// CONCATENATED MODULE: ./node_modules/@vue/devtools-api/lib/esm/env.js\nfunction getDevtoolsGlobalHook() {\n  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;\n}\nfunction getTarget() {\n  // @ts-ignore\n  return typeof navigator !== \'undefined\' && typeof window !== \'undefined\' ? window : typeof __webpack_require__.g !== \'undefined\' ? __webpack_require__.g : {};\n}\nconst isProxyAvailable = typeof Proxy === \'function\';\n;// CONCATENATED MODULE: ./node_modules/@vue/devtools-api/lib/esm/const.js\nconst HOOK_SETUP = \'devtools-plugin:setup\';\nconst HOOK_PLUGIN_SETTINGS_SET = \'plugin:settings:set\';\n;// CONCATENATED MODULE: ./node_modules/@vue/devtools-api/lib/esm/time.js\nlet time_supported;\nlet time_perf;\nfunction isPerformanceSupported() {\n  var _a;\n  if (time_supported !== undefined) {\n    return time_supported;\n  }\n  if (typeof window !== \'undefined\' && window.performance) {\n    time_supported = true;\n    time_perf = window.performance;\n  } else if (typeof __webpack_require__.g !== \'undefined\' && ((_a = __webpack_require__.g.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {\n    time_supported = true;\n    time_perf = __webpack_require__.g.perf_hooks.performance;\n  } else {\n    time_supported = false;\n  }\n  return time_supported;\n}\nfunction now() {\n  return isPerformanceSupported() ? time_perf.now() : Date.now();\n}\n;// CONCATENATED MODULE: ./node_modules/@vue/devtools-api/lib/esm/proxy.js\n\n\nclass ApiProxy {\n  constructor(plugin, hook) {\n    this.target = null;\n    this.targetQueue = [];\n    this.onQueue = [];\n    this.plugin = plugin;\n    this.hook = hook;\n    const defaultSettings = {};\n    if (plugin.settings) {\n      for (const id in plugin.settings) {\n        const item = plugin.settings[id];\n        defaultSettings[id] = item.defaultValue;\n      }\n    }\n    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;\n    let currentSettings = Object.assign({}, defaultSettings);\n    try {\n      const raw = localStorage.getItem(localSettingsSaveId);\n      const data = JSON.parse(raw);\n      Object.assign(currentSettings, data);\n    } catch (e) {\n      // noop\n    }\n    this.fallbacks = {\n      getSettings() {\n        return currentSettings;\n      },\n      setSettings(value) {\n        try {\n          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));\n        } catch (e) {\n          // noop\n        }\n        currentSettings = value;\n      },\n      now() {\n        return now();\n      }\n    };\n    if (hook) {\n      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {\n        if (pluginId === this.plugin.id) {\n          this.fallbacks.setSettings(value);\n        }\n      });\n    }\n    this.proxiedOn = new Proxy({}, {\n      get: (_target, prop) => {\n        if (this.target) {\n          return this.target.on[prop];\n        } else {\n          return (...args) => {\n            this.onQueue.push({\n              method: prop,\n              args\n            });\n          };\n        }\n      }\n    });\n    this.proxiedTarget = new Proxy({}, {\n      get: (_target, prop) => {\n        if (this.target) {\n          return this.target[prop];\n        } else if (prop === \'on\') {\n          return this.proxiedOn;\n        } else if (Object.keys(this.fallbacks).includes(prop)) {\n          return (...args) => {\n            this.targetQueue.push({\n              method: prop,\n              args,\n              resolve: () => {}\n            });\n            return this.fallbacks[prop](...args);\n          };\n        } else {\n          return (...args) => {\n            return new Promise(resolve => {\n              this.targetQueue.push({\n                method: prop,\n                args,\n                resolve\n              });\n            });\n          };\n        }\n      }\n    });\n  }\n  async setRealTarget(target) {\n    this.target = target;\n    for (const item of this.onQueue) {\n      this.target.on[item.method](...item.args);\n    }\n    for (const item of this.targetQueue) {\n      item.resolve(await this.target[item.method](...item.args));\n    }\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@vue/devtools-api/lib/esm/index.js\n\n\n\n\n\n\nfunction setupDevtoolsPlugin(pluginDescriptor, setupFn) {\n  const descriptor = pluginDescriptor;\n  const target = getTarget();\n  const hook = getDevtoolsGlobalHook();\n  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;\n  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {\n    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);\n  } else {\n    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;\n    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];\n    list.push({\n      pluginDescriptor: descriptor,\n      setupFn,\n      proxy\n    });\n    if (proxy) setupFn(proxy.proxiedTarget);\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/vue-router/dist/vue-router.mjs\n/*!\n  * vue-router v4.2.4\n  * (c) 2023 Eduardo San Martin Morote\n  * @license MIT\n  */\n\n\n\nconst isBrowser = typeof window !== \'undefined\';\n\nfunction isESModule(obj) {\n    return obj.__esModule || obj[Symbol.toStringTag] === \'Module\';\n}\nconst vue_router_assign = Object.assign;\nfunction applyToParams(fn, params) {\n    const newParams = {};\n    for (const key in params) {\n        const value = params[key];\n        newParams[key] = vue_router_isArray(value)\n            ? value.map(fn)\n            : fn(value);\n    }\n    return newParams;\n}\nconst noop = () => { };\n/**\n * Typesafe alternative to Array.isArray\n * https://github.com/microsoft/TypeScript/pull/48228\n */\nconst vue_router_isArray = Array.isArray;\n\nfunction vue_router_warn(msg) {\n    // avoid using ...args as it breaks in older Edge builds\n    const args = Array.from(arguments).slice(1);\n    console.warn.apply(console, [\'[Vue Router warn]: \' + msg].concat(args));\n}\n\nconst TRAILING_SLASH_RE = /\\/$/;\nconst removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, \'\');\n/**\n * Transforms a URI into a normalized history location\n *\n * @param parseQuery\n * @param location - URI to normalize\n * @param currentLocation - current absolute location. Allows resolving relative\n * paths. Must start with `/`. Defaults to `/`\n * @returns a normalized history location\n */\nfunction parseURL(parseQuery, location, currentLocation = \'/\') {\n    let path, query = {}, searchString = \'\', hash = \'\';\n    // Could use URL and URLSearchParams but IE 11 doesn\'t support it\n    // TODO: move to new URL()\n    const hashPos = location.indexOf(\'#\');\n    let searchPos = location.indexOf(\'?\');\n    // the hash appears before the search, so it\'s not part of the search string\n    if (hashPos < searchPos && hashPos >= 0) {\n        searchPos = -1;\n    }\n    if (searchPos > -1) {\n        path = location.slice(0, searchPos);\n        searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);\n        query = parseQuery(searchString);\n    }\n    if (hashPos > -1) {\n        path = path || location.slice(0, hashPos);\n        // keep the # character\n        hash = location.slice(hashPos, location.length);\n    }\n    // no search and no query\n    path = resolveRelativePath(path != null ? path : location, currentLocation);\n    // empty path means a relative query or hash `?foo=f`, `#thing`\n    return {\n        fullPath: path + (searchString && \'?\') + searchString + hash,\n        path,\n        query,\n        hash,\n    };\n}\n/**\n * Stringifies a URL object\n *\n * @param stringifyQuery\n * @param location\n */\nfunction stringifyURL(stringifyQuery, location) {\n    const query = location.query ? stringifyQuery(location.query) : \'\';\n    return location.path + (query && \'?\') + query + (location.hash || \'\');\n}\n/**\n * Strips off the base from the beginning of a location.pathname in a non-case-sensitive way.\n *\n * @param pathname - location.pathname\n * @param base - base to strip off\n */\nfunction stripBase(pathname, base) {\n    // no base or base is not found at the beginning\n    if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))\n        return pathname;\n    return pathname.slice(base.length) || \'/\';\n}\n/**\n * Checks if two RouteLocation are equal. This means that both locations are\n * pointing towards the same {@link RouteRecord} and that all `params`, `query`\n * parameters and `hash` are the same\n *\n * @param stringifyQuery - A function that takes a query object of type LocationQueryRaw and returns a string representation of it.\n * @param a - first {@link RouteLocation}\n * @param b - second {@link RouteLocation}\n */\nfunction isSameRouteLocation(stringifyQuery, a, b) {\n    const aLastIndex = a.matched.length - 1;\n    const bLastIndex = b.matched.length - 1;\n    return (aLastIndex > -1 &&\n        aLastIndex === bLastIndex &&\n        isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) &&\n        isSameRouteLocationParams(a.params, b.params) &&\n        stringifyQuery(a.query) === stringifyQuery(b.query) &&\n        a.hash === b.hash);\n}\n/**\n * Check if two `RouteRecords` are equal. Takes into account aliases: they are\n * considered equal to the `RouteRecord` they are aliasing.\n *\n * @param a - first {@link RouteRecord}\n * @param b - second {@link RouteRecord}\n */\nfunction isSameRouteRecord(a, b) {\n    // since the original record has an undefined value for aliasOf\n    // but all aliases point to the original record, this will always compare\n    // the original record\n    return (a.aliasOf || a) === (b.aliasOf || b);\n}\nfunction isSameRouteLocationParams(a, b) {\n    if (Object.keys(a).length !== Object.keys(b).length)\n        return false;\n    for (const key in a) {\n        if (!isSameRouteLocationParamsValue(a[key], b[key]))\n            return false;\n    }\n    return true;\n}\nfunction isSameRouteLocationParamsValue(a, b) {\n    return vue_router_isArray(a)\n        ? isEquivalentArray(a, b)\n        : vue_router_isArray(b)\n            ? isEquivalentArray(b, a)\n            : a === b;\n}\n/**\n * Check if two arrays are the same or if an array with one single entry is the\n * same as another primitive value. Used to check query and parameters\n *\n * @param a - array of values\n * @param b - array of values or a single value\n */\nfunction isEquivalentArray(a, b) {\n    return vue_router_isArray(b)\n        ? a.length === b.length && a.every((value, i) => value === b[i])\n        : a.length === 1 && a[0] === b;\n}\n/**\n * Resolves a relative path that starts with `.`.\n *\n * @param to - path location we are resolving\n * @param from - currentLocation.path, should start with `/`\n */\nfunction resolveRelativePath(to, from) {\n    if (to.startsWith(\'/\'))\n        return to;\n    if (false) {}\n    if (!to)\n        return from;\n    const fromSegments = from.split(\'/\');\n    const toSegments = to.split(\'/\');\n    const lastToSegment = toSegments[toSegments.length - 1];\n    // make . and ./ the same (../ === .., ../../ === ../..)\n    // this is the same behavior as new URL()\n    if (lastToSegment === \'..\' || lastToSegment === \'.\') {\n        toSegments.push(\'\');\n    }\n    let position = fromSegments.length - 1;\n    let toPosition;\n    let segment;\n    for (toPosition = 0; toPosition < toSegments.length; toPosition++) {\n        segment = toSegments[toPosition];\n        // we stay on the same position\n        if (segment === \'.\')\n            continue;\n        // go up in the from array\n        if (segment === \'..\') {\n            // we can\'t go below zero, but we still need to increment toPosition\n            if (position > 1)\n                position--;\n            // continue\n        }\n        // we reached a non-relative path, we stop here\n        else\n            break;\n    }\n    return (fromSegments.slice(0, position).join(\'/\') +\n        \'/\' +\n        toSegments\n            // ensure we use at least the last element in the toSegments\n            .slice(toPosition - (toPosition === toSegments.length ? 1 : 0))\n            .join(\'/\'));\n}\n\nvar NavigationType;\n(function (NavigationType) {\n    NavigationType["pop"] = "pop";\n    NavigationType["push"] = "push";\n})(NavigationType || (NavigationType = {}));\nvar NavigationDirection;\n(function (NavigationDirection) {\n    NavigationDirection["back"] = "back";\n    NavigationDirection["forward"] = "forward";\n    NavigationDirection["unknown"] = "";\n})(NavigationDirection || (NavigationDirection = {}));\n/**\n * Starting location for Histories\n */\nconst START = \'\';\n// Generic utils\n/**\n * Normalizes a base by removing any trailing slash and reading the base tag if\n * present.\n *\n * @param base - base to normalize\n */\nfunction normalizeBase(base) {\n    if (!base) {\n        if (isBrowser) {\n            // respect <base> tag\n            const baseEl = document.querySelector(\'base\');\n            base = (baseEl && baseEl.getAttribute(\'href\')) || \'/\';\n            // strip full URL origin\n            base = base.replace(/^\\w+:\\/\\/[^\\/]+/, \'\');\n        }\n        else {\n            base = \'/\';\n        }\n    }\n    // ensure leading slash when it was removed by the regex above avoid leading\n    // slash with hash because the file could be read from the disk like file://\n    // and the leading slash would cause problems\n    if (base[0] !== \'/\' && base[0] !== \'#\')\n        base = \'/\' + base;\n    // remove the trailing slash so all other method can just do `base + fullPath`\n    // to build an href\n    return removeTrailingSlash(base);\n}\n// remove any character before the hash\nconst BEFORE_HASH_RE = /^[^#]+#/;\nfunction createHref(base, location) {\n    return base.replace(BEFORE_HASH_RE, \'#\') + location;\n}\n\nfunction getElementPosition(el, offset) {\n    const docRect = document.documentElement.getBoundingClientRect();\n    const elRect = el.getBoundingClientRect();\n    return {\n        behavior: offset.behavior,\n        left: elRect.left - docRect.left - (offset.left || 0),\n        top: elRect.top - docRect.top - (offset.top || 0),\n    };\n}\nconst computeScrollPosition = () => ({\n    left: window.pageXOffset,\n    top: window.pageYOffset,\n});\nfunction scrollToPosition(position) {\n    let scrollToOptions;\n    if (\'el\' in position) {\n        const positionEl = position.el;\n        const isIdSelector = typeof positionEl === \'string\' && positionEl.startsWith(\'#\');\n        /**\n         * `id`s can accept pretty much any characters, including CSS combinators\n         * like `>` or `~`. It\'s still possible to retrieve elements using\n         * `document.getElementById(\'~\')` but it needs to be escaped when using\n         * `document.querySelector(\'#\\\\~\')` for it to be valid. The only\n         * requirements for `id`s are them to be unique on the page and to not be\n         * empty (`id=""`). Because of that, when passing an id selector, it should\n         * be properly escaped for it to work with `querySelector`. We could check\n         * for the id selector to be simple (no CSS combinators `+ >~`) but that\n         * would make things inconsistent since they are valid characters for an\n         * `id` but would need to be escaped when using `querySelector`, breaking\n         * their usage and ending up in no selector returned. Selectors need to be\n         * escaped:\n         *\n         * - `#1-thing` becomes `#\\31 -thing`\n         * - `#with~symbols` becomes `#with\\\\~symbols`\n         *\n         * - More information about  the topic can be found at\n         *   https://mathiasbynens.be/notes/html5-id-class.\n         * - Practical example: https://mathiasbynens.be/demo/html5-id\n         */\n        if (false) {}\n        const el = typeof positionEl === \'string\'\n            ? isIdSelector\n                ? document.getElementById(positionEl.slice(1))\n                : document.querySelector(positionEl)\n            : positionEl;\n        if (!el) {\n            ( false) &&\n                0;\n            return;\n        }\n        scrollToOptions = getElementPosition(el, position);\n    }\n    else {\n        scrollToOptions = position;\n    }\n    if (\'scrollBehavior\' in document.documentElement.style)\n        window.scrollTo(scrollToOptions);\n    else {\n        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);\n    }\n}\nfunction getScrollKey(path, delta) {\n    const position = history.state ? history.state.position - delta : -1;\n    return position + path;\n}\nconst scrollPositions = new Map();\nfunction saveScrollPosition(key, scrollPosition) {\n    scrollPositions.set(key, scrollPosition);\n}\nfunction getSavedScrollPosition(key) {\n    const scroll = scrollPositions.get(key);\n    // consume it so it\'s not used again\n    scrollPositions.delete(key);\n    return scroll;\n}\n// TODO: RFC about how to save scroll position\n/**\n * ScrollBehavior instance used by the router to compute and restore the scroll\n * position when navigating.\n */\n// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {\n//   // returns a scroll position that can be saved in history\n//   compute(): ScrollPositionEntry\n//   // can take an extended ScrollPositionEntry\n//   scroll(position: ScrollPosition): void\n// }\n// export const scrollHandler: ScrollHandler<ScrollPosition> = {\n//   compute: computeScroll,\n//   scroll: scrollToPosition,\n// }\n\nlet createBaseLocation = () => location.protocol + \'//\' + location.host;\n/**\n * Creates a normalized history location from a window.location object\n * @param base - The base path\n * @param location - The window.location object\n */\nfunction createCurrentLocation(base, location) {\n    const { pathname, search, hash } = location;\n    // allows hash bases like #, /#, #/, #!, #!/, /#!/, or even /folder#end\n    const hashPos = base.indexOf(\'#\');\n    if (hashPos > -1) {\n        let slicePos = hash.includes(base.slice(hashPos))\n            ? base.slice(hashPos).length\n            : 1;\n        let pathFromHash = hash.slice(slicePos);\n        // prepend the starting slash to hash so the url starts with /#\n        if (pathFromHash[0] !== \'/\')\n            pathFromHash = \'/\' + pathFromHash;\n        return stripBase(pathFromHash, \'\');\n    }\n    const path = stripBase(pathname, base);\n    return path + search + hash;\n}\nfunction useHistoryListeners(base, historyState, currentLocation, replace) {\n    let listeners = [];\n    let teardowns = [];\n    // TODO: should it be a stack? a Dict. Check if the popstate listener\n    // can trigger twice\n    let pauseState = null;\n    const popStateHandler = ({ state, }) => {\n        const to = createCurrentLocation(base, location);\n        const from = currentLocation.value;\n        const fromState = historyState.value;\n        let delta = 0;\n        if (state) {\n            currentLocation.value = to;\n            historyState.value = state;\n            // ignore the popstate and reset the pauseState\n            if (pauseState && pauseState === from) {\n                pauseState = null;\n                return;\n            }\n            delta = fromState ? state.position - fromState.position : 0;\n        }\n        else {\n            replace(to);\n        }\n        // console.log({ deltaFromCurrent })\n        // Here we could also revert the navigation by calling history.go(-delta)\n        // this listener will have to be adapted to not trigger again and to wait for the url\n        // to be updated before triggering the listeners. Some kind of validation function would also\n        // need to be passed to the listeners so the navigation can be accepted\n        // call all listeners\n        listeners.forEach(listener => {\n            listener(currentLocation.value, from, {\n                delta,\n                type: NavigationType.pop,\n                direction: delta\n                    ? delta > 0\n                        ? NavigationDirection.forward\n                        : NavigationDirection.back\n                    : NavigationDirection.unknown,\n            });\n        });\n    };\n    function pauseListeners() {\n        pauseState = currentLocation.value;\n    }\n    function listen(callback) {\n        // set up the listener and prepare teardown callbacks\n        listeners.push(callback);\n        const teardown = () => {\n            const index = listeners.indexOf(callback);\n            if (index > -1)\n                listeners.splice(index, 1);\n        };\n        teardowns.push(teardown);\n        return teardown;\n    }\n    function beforeUnloadListener() {\n        const { history } = window;\n        if (!history.state)\n            return;\n        history.replaceState(vue_router_assign({}, history.state, { scroll: computeScrollPosition() }), \'\');\n    }\n    function destroy() {\n        for (const teardown of teardowns)\n            teardown();\n        teardowns = [];\n        window.removeEventListener(\'popstate\', popStateHandler);\n        window.removeEventListener(\'beforeunload\', beforeUnloadListener);\n    }\n    // set up the listeners and prepare teardown callbacks\n    window.addEventListener(\'popstate\', popStateHandler);\n    // TODO: could we use \'pagehide\' or \'visibilitychange\' instead?\n    // https://developer.chrome.com/blog/page-lifecycle-api/\n    window.addEventListener(\'beforeunload\', beforeUnloadListener, {\n        passive: true,\n    });\n    return {\n        pauseListeners,\n        listen,\n        destroy,\n    };\n}\n/**\n * Creates a state object\n */\nfunction buildState(back, current, forward, replaced = false, computeScroll = false) {\n    return {\n        back,\n        current,\n        forward,\n        replaced,\n        position: window.history.length,\n        scroll: computeScroll ? computeScrollPosition() : null,\n    };\n}\nfunction useHistoryStateNavigation(base) {\n    const { history, location } = window;\n    // private variables\n    const currentLocation = {\n        value: createCurrentLocation(base, location),\n    };\n    const historyState = { value: history.state };\n    // build current history entry as this is a fresh navigation\n    if (!historyState.value) {\n        changeLocation(currentLocation.value, {\n            back: null,\n            current: currentLocation.value,\n            forward: null,\n            // the length is off by one, we need to decrease it\n            position: history.length - 1,\n            replaced: true,\n            // don\'t add a scroll as the user may have an anchor, and we want\n            // scrollBehavior to be triggered without a saved position\n            scroll: null,\n        }, true);\n    }\n    function changeLocation(to, state, replace) {\n        /**\n         * if a base tag is provided, and we are on a normal domain, we have to\n         * respect the provided `base` attribute because pushState() will use it and\n         * potentially erase anything before the `#` like at\n         * https://github.com/vuejs/router/issues/685 where a base of\n         * `/folder/#` but a base of `/` would erase the `/folder/` section. If\n         * there is no host, the `<base>` tag makes no sense and if there isn\'t a\n         * base tag we can just use everything after the `#`.\n         */\n        const hashIndex = base.indexOf(\'#\');\n        const url = hashIndex > -1\n            ? (location.host && document.querySelector(\'base\')\n                ? base\n                : base.slice(hashIndex)) + to\n            : createBaseLocation() + base + to;\n        try {\n            // BROWSER QUIRK\n            // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds\n            history[replace ? \'replaceState\' : \'pushState\'](state, \'\', url);\n            historyState.value = state;\n        }\n        catch (err) {\n            if ((false)) {}\n            else {\n                console.error(err);\n            }\n            // Force the navigation, this also resets the call count\n            location[replace ? \'replace\' : \'assign\'](url);\n        }\n    }\n    function replace(to, data) {\n        const state = vue_router_assign({}, history.state, buildState(historyState.value.back, \n        // keep back and forward entries but override current position\n        to, historyState.value.forward, true), data, { position: historyState.value.position });\n        changeLocation(to, state, true);\n        currentLocation.value = to;\n    }\n    function push(to, data) {\n        // Add to current entry the information of where we are going\n        // as well as saving the current position\n        const currentState = vue_router_assign({}, \n        // use current history state to gracefully handle a wrong call to\n        // history.replaceState\n        // https://github.com/vuejs/router/issues/366\n        historyState.value, history.state, {\n            forward: to,\n            scroll: computeScrollPosition(),\n        });\n        if (false) {}\n        changeLocation(currentState.current, currentState, true);\n        const state = vue_router_assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);\n        changeLocation(to, state, false);\n        currentLocation.value = to;\n    }\n    return {\n        location: currentLocation,\n        state: historyState,\n        push,\n        replace,\n    };\n}\n/**\n * Creates an HTML5 history. Most common history for single page applications.\n *\n * @param base -\n */\nfunction createWebHistory(base) {\n    base = normalizeBase(base);\n    const historyNavigation = useHistoryStateNavigation(base);\n    const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);\n    function go(delta, triggerListeners = true) {\n        if (!triggerListeners)\n            historyListeners.pauseListeners();\n        history.go(delta);\n    }\n    const routerHistory = vue_router_assign({\n        // it\'s overridden right after\n        location: \'\',\n        base,\n        go,\n        createHref: createHref.bind(null, base),\n    }, historyNavigation, historyListeners);\n    Object.defineProperty(routerHistory, \'location\', {\n        enumerable: true,\n        get: () => historyNavigation.location.value,\n    });\n    Object.defineProperty(routerHistory, \'state\', {\n        enumerable: true,\n        get: () => historyNavigation.state.value,\n    });\n    return routerHistory;\n}\n\n/**\n * Creates an in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.\n * It\'s up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.\n *\n * @param base - Base applied to all urls, defaults to \'/\'\n * @returns a history object that can be passed to the router constructor\n */\nfunction createMemoryHistory(base = \'\') {\n    let listeners = [];\n    let queue = [START];\n    let position = 0;\n    base = normalizeBase(base);\n    function setLocation(location) {\n        position++;\n        if (position === queue.length) {\n            // we are at the end, we can simply append a new entry\n            queue.push(location);\n        }\n        else {\n            // we are in the middle, we remove everything from here in the queue\n            queue.splice(position);\n            queue.push(location);\n        }\n    }\n    function triggerListeners(to, from, { direction, delta }) {\n        const info = {\n            direction,\n            delta,\n            type: NavigationType.pop,\n        };\n        for (const callback of listeners) {\n            callback(to, from, info);\n        }\n    }\n    const routerHistory = {\n        // rewritten by Object.defineProperty\n        location: START,\n        // TODO: should be kept in queue\n        state: {},\n        base,\n        createHref: createHref.bind(null, base),\n        replace(to) {\n            // remove current entry and decrement position\n            queue.splice(position--, 1);\n            setLocation(to);\n        },\n        push(to, data) {\n            setLocation(to);\n        },\n        listen(callback) {\n            listeners.push(callback);\n            return () => {\n                const index = listeners.indexOf(callback);\n                if (index > -1)\n                    listeners.splice(index, 1);\n            };\n        },\n        destroy() {\n            listeners = [];\n            queue = [START];\n            position = 0;\n        },\n        go(delta, shouldTrigger = true) {\n            const from = this.location;\n            const direction = \n            // we are considering delta === 0 going forward, but in abstract mode\n            // using 0 for the delta doesn\'t make sense like it does in html5 where\n            // it reloads the page\n            delta < 0 ? NavigationDirection.back : NavigationDirection.forward;\n            position = Math.max(0, Math.min(position + delta, queue.length - 1));\n            if (shouldTrigger) {\n                triggerListeners(this.location, from, {\n                    direction,\n                    delta,\n                });\n            }\n        },\n    };\n    Object.defineProperty(routerHistory, \'location\', {\n        enumerable: true,\n        get: () => queue[position],\n    });\n    return routerHistory;\n}\n\n/**\n * Creates a hash history. Useful for web applications with no host (e.g. `file://`) or when configuring a server to\n * handle any URL is not possible.\n *\n * @param base - optional base to provide. Defaults to `location.pathname + location.search` If there is a `<base>` tag\n * in the `head`, its value will be ignored in favor of this parameter **but note it affects all the history.pushState()\n * calls**, meaning that if you use a `<base>` tag, it\'s `href` value **has to match this parameter** (ignoring anything\n * after the `#`).\n *\n * @example\n * ```js\n * // at https://example.com/folder\n * createWebHashHistory() // gives a url of `https://example.com/folder#`\n * createWebHashHistory(\'/folder/\') // gives a url of `https://example.com/folder/#`\n * // if the `#` is provided in the base, it won\'t be added by `createWebHashHistory`\n * createWebHashHistory(\'/folder/#/app/\') // gives a url of `https://example.com/folder/#/app/`\n * // you should avoid doing this because it changes the original url and breaks copying urls\n * createWebHashHistory(\'/other-folder/\') // gives a url of `https://example.com/other-folder/#`\n *\n * // at file:///usr/etc/folder/index.html\n * // for locations with no `host`, the base is ignored\n * createWebHashHistory(\'/iAmIgnored\') // gives a url of `file:///usr/etc/folder/index.html#`\n * ```\n */\nfunction createWebHashHistory(base) {\n    // Make sure this implementation is fine in terms of encoding, specially for IE11\n    // for `file://`, directly use the pathname and ignore the base\n    // location.pathname contains an initial `/` even at the root: `https://example.com`\n    base = location.host ? base || location.pathname + location.search : \'\';\n    // allow the user to provide a `#` in the middle: `/base/#/app`\n    if (!base.includes(\'#\'))\n        base += \'#\';\n    if (false) {}\n    return createWebHistory(base);\n}\n\nfunction isRouteLocation(route) {\n    return typeof route === \'string\' || (route && typeof route === \'object\');\n}\nfunction isRouteName(name) {\n    return typeof name === \'string\' || typeof name === \'symbol\';\n}\n\n/**\n * Initial route location where the router is. Can be used in navigation guards\n * to differentiate the initial navigation.\n *\n * @example\n * ```js\n * import { START_LOCATION } from \'vue-router\'\n *\n * router.beforeEach((to, from) => {\n *   if (from === START_LOCATION) {\n *     // initial navigation\n *   }\n * })\n * ```\n */\nconst START_LOCATION_NORMALIZED = {\n    path: \'/\',\n    name: undefined,\n    params: {},\n    query: {},\n    hash: \'\',\n    fullPath: \'/\',\n    matched: [],\n    meta: {},\n    redirectedFrom: undefined,\n};\n\nconst NavigationFailureSymbol = Symbol(( false) ? 0 : \'\');\n/**\n * Enumeration with all possible types for navigation failures. Can be passed to\n * {@link isNavigationFailure} to check for specific failures.\n */\nvar NavigationFailureType;\n(function (NavigationFailureType) {\n    /**\n     * An aborted navigation is a navigation that failed because a navigation\n     * guard returned `false` or called `next(false)`\n     */\n    NavigationFailureType[NavigationFailureType["aborted"] = 4] = "aborted";\n    /**\n     * A cancelled navigation is a navigation that failed because a more recent\n     * navigation finished started (not necessarily finished).\n     */\n    NavigationFailureType[NavigationFailureType["cancelled"] = 8] = "cancelled";\n    /**\n     * A duplicated navigation is a navigation that failed because it was\n     * initiated while already being at the exact same location.\n     */\n    NavigationFailureType[NavigationFailureType["duplicated"] = 16] = "duplicated";\n})(NavigationFailureType || (NavigationFailureType = {}));\n// DEV only debug messages\nconst ErrorTypeMessages = {\n    [1 /* ErrorTypes.MATCHER_NOT_FOUND */]({ location, currentLocation }) {\n        return `No match for\\n ${JSON.stringify(location)}${currentLocation\n            ? \'\\nwhile being at\\n\' + JSON.stringify(currentLocation)\n            : \'\'}`;\n    },\n    [2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */]({ from, to, }) {\n        return `Redirected from "${from.fullPath}" to "${stringifyRoute(to)}" via a navigation guard.`;\n    },\n    [4 /* ErrorTypes.NAVIGATION_ABORTED */]({ from, to }) {\n        return `Navigation aborted from "${from.fullPath}" to "${to.fullPath}" via a navigation guard.`;\n    },\n    [8 /* ErrorTypes.NAVIGATION_CANCELLED */]({ from, to }) {\n        return `Navigation cancelled from "${from.fullPath}" to "${to.fullPath}" with a new navigation.`;\n    },\n    [16 /* ErrorTypes.NAVIGATION_DUPLICATED */]({ from, to }) {\n        return `Avoided redundant navigation to current location: "${from.fullPath}".`;\n    },\n};\nfunction createRouterError(type, params) {\n    // keep full error messages in cjs versions\n    if (false) {}\n    else {\n        return vue_router_assign(new Error(), {\n            type,\n            [NavigationFailureSymbol]: true,\n        }, params);\n    }\n}\nfunction isNavigationFailure(error, type) {\n    return (error instanceof Error &&\n        NavigationFailureSymbol in error &&\n        (type == null || !!(error.type & type)));\n}\nconst propertiesToLog = [\'params\', \'query\', \'hash\'];\nfunction stringifyRoute(to) {\n    if (typeof to === \'string\')\n        return to;\n    if (\'path\' in to)\n        return to.path;\n    const location = {};\n    for (const key of propertiesToLog) {\n        if (key in to)\n            location[key] = to[key];\n    }\n    return JSON.stringify(location, null, 2);\n}\n\n// default pattern for a param: non-greedy everything but /\nconst BASE_PARAM_PATTERN = \'[^/]+?\';\nconst BASE_PATH_PARSER_OPTIONS = {\n    sensitive: false,\n    strict: false,\n    start: true,\n    end: true,\n};\n// Special Regex characters that must be escaped in static tokens\nconst REGEX_CHARS_RE = /[.+*?^${}()[\\]/\\\\]/g;\n/**\n * Creates a path parser from an array of Segments (a segment is an array of Tokens)\n *\n * @param segments - array of segments returned by tokenizePath\n * @param extraOptions - optional options for the regexp\n * @returns a PathParser\n */\nfunction tokensToParser(segments, extraOptions) {\n    const options = vue_router_assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);\n    // the amount of scores is the same as the length of segments except for the root segment "/"\n    const score = [];\n    // the regexp as a string\n    let pattern = options.start ? \'^\' : \'\';\n    // extracted keys\n    const keys = [];\n    for (const segment of segments) {\n        // the root segment needs special treatment\n        const segmentScores = segment.length ? [] : [90 /* PathScore.Root */];\n        // allow trailing slash\n        if (options.strict && !segment.length)\n            pattern += \'/\';\n        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {\n            const token = segment[tokenIndex];\n            // resets the score if we are inside a sub-segment /:a-other-:b\n            let subSegmentScore = 40 /* PathScore.Segment */ +\n                (options.sensitive ? 0.25 /* PathScore.BonusCaseSensitive */ : 0);\n            if (token.type === 0 /* TokenType.Static */) {\n                // prepend the slash if we are starting a new segment\n                if (!tokenIndex)\n                    pattern += \'/\';\n                pattern += token.value.replace(REGEX_CHARS_RE, \'\\\\$&\');\n                subSegmentScore += 40 /* PathScore.Static */;\n            }\n            else if (token.type === 1 /* TokenType.Param */) {\n                const { value, repeatable, optional, regexp } = token;\n                keys.push({\n                    name: value,\n                    repeatable,\n                    optional,\n                });\n                const re = regexp ? regexp : BASE_PARAM_PATTERN;\n                // the user provided a custom regexp /:id(\\\\d+)\n                if (re !== BASE_PARAM_PATTERN) {\n                    subSegmentScore += 10 /* PathScore.BonusCustomRegExp */;\n                    // make sure the regexp is valid before using it\n                    try {\n                        new RegExp(`(${re})`);\n                    }\n                    catch (err) {\n                        throw new Error(`Invalid custom RegExp for param "${value}" (${re}): ` +\n                            err.message);\n                    }\n                }\n                // when we repeat we must take care of the repeating leading slash\n                let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;\n                // prepend the slash if we are starting a new segment\n                if (!tokenIndex)\n                    subPattern =\n                        // avoid an optional / if there are more segments e.g. /:p?-static\n                        // or /:p?-:p2\n                        optional && segment.length < 2\n                            ? `(?:/${subPattern})`\n                            : \'/\' + subPattern;\n                if (optional)\n                    subPattern += \'?\';\n                pattern += subPattern;\n                subSegmentScore += 20 /* PathScore.Dynamic */;\n                if (optional)\n                    subSegmentScore += -8 /* PathScore.BonusOptional */;\n                if (repeatable)\n                    subSegmentScore += -20 /* PathScore.BonusRepeatable */;\n                if (re === \'.*\')\n                    subSegmentScore += -50 /* PathScore.BonusWildcard */;\n            }\n            segmentScores.push(subSegmentScore);\n        }\n        // an empty array like /home/ -> [[{home}], []]\n        // if (!segment.length) pattern += \'/\'\n        score.push(segmentScores);\n    }\n    // only apply the strict bonus to the last score\n    if (options.strict && options.end) {\n        const i = score.length - 1;\n        score[i][score[i].length - 1] += 0.7000000000000001 /* PathScore.BonusStrict */;\n    }\n    // TODO: dev only warn double trailing slash\n    if (!options.strict)\n        pattern += \'/?\';\n    if (options.end)\n        pattern += \'$\';\n    // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else\n    else if (options.strict)\n        pattern += \'(?:/|$)\';\n    const re = new RegExp(pattern, options.sensitive ? \'\' : \'i\');\n    function parse(path) {\n        const match = path.match(re);\n        const params = {};\n        if (!match)\n            return null;\n        for (let i = 1; i < match.length; i++) {\n            const value = match[i] || \'\';\n            const key = keys[i - 1];\n            params[key.name] = value && key.repeatable ? value.split(\'/\') : value;\n        }\n        return params;\n    }\n    function stringify(params) {\n        let path = \'\';\n        // for optional parameters to allow to be empty\n        let avoidDuplicatedSlash = false;\n        for (const segment of segments) {\n            if (!avoidDuplicatedSlash || !path.endsWith(\'/\'))\n                path += \'/\';\n            avoidDuplicatedSlash = false;\n            for (const token of segment) {\n                if (token.type === 0 /* TokenType.Static */) {\n                    path += token.value;\n                }\n                else if (token.type === 1 /* TokenType.Param */) {\n                    const { value, repeatable, optional } = token;\n                    const param = value in params ? params[value] : \'\';\n                    if (vue_router_isArray(param) && !repeatable) {\n                        throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);\n                    }\n                    const text = vue_router_isArray(param)\n                        ? param.join(\'/\')\n                        : param;\n                    if (!text) {\n                        if (optional) {\n                            // if we have more than one optional param like /:a?-static we don\'t need to care about the optional param\n                            if (segment.length < 2) {\n                                // remove the last slash as we could be at the end\n                                if (path.endsWith(\'/\'))\n                                    path = path.slice(0, -1);\n                                // do not append a slash on the next iteration\n                                else\n                                    avoidDuplicatedSlash = true;\n                            }\n                        }\n                        else\n                            throw new Error(`Missing required param "${value}"`);\n                    }\n                    path += text;\n                }\n            }\n        }\n        // avoid empty path when we have multiple optional params\n        return path || \'/\';\n    }\n    return {\n        re,\n        score,\n        keys,\n        parse,\n        stringify,\n    };\n}\n/**\n * Compares an array of numbers as used in PathParser.score and returns a\n * number. This function can be used to `sort` an array\n *\n * @param a - first array of numbers\n * @param b - second array of numbers\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\n * should be sorted first\n */\nfunction compareScoreArray(a, b) {\n    let i = 0;\n    while (i < a.length && i < b.length) {\n        const diff = b[i] - a[i];\n        // only keep going if diff === 0\n        if (diff)\n            return diff;\n        i++;\n    }\n    // if the last subsegment was Static, the shorter segments should be sorted first\n    // otherwise sort the longest segment first\n    if (a.length < b.length) {\n        return a.length === 1 && a[0] === 40 /* PathScore.Static */ + 40 /* PathScore.Segment */\n            ? -1\n            : 1;\n    }\n    else if (a.length > b.length) {\n        return b.length === 1 && b[0] === 40 /* PathScore.Static */ + 40 /* PathScore.Segment */\n            ? 1\n            : -1;\n    }\n    return 0;\n}\n/**\n * Compare function that can be used with `sort` to sort an array of PathParser\n *\n * @param a - first PathParser\n * @param b - second PathParser\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\n */\nfunction comparePathParserScore(a, b) {\n    let i = 0;\n    const aScore = a.score;\n    const bScore = b.score;\n    while (i < aScore.length && i < bScore.length) {\n        const comp = compareScoreArray(aScore[i], bScore[i]);\n        // do not return if both are equal\n        if (comp)\n            return comp;\n        i++;\n    }\n    if (Math.abs(bScore.length - aScore.length) === 1) {\n        if (isLastScoreNegative(aScore))\n            return 1;\n        if (isLastScoreNegative(bScore))\n            return -1;\n    }\n    // if a and b share the same score entries but b has more, sort b first\n    return bScore.length - aScore.length;\n    // this is the ternary version\n    // return aScore.length < bScore.length\n    //   ? 1\n    //   : aScore.length > bScore.length\n    //   ? -1\n    //   : 0\n}\n/**\n * This allows detecting splats at the end of a path: /home/:id(.*)*\n *\n * @param score - score to check\n * @returns true if the last entry is negative\n */\nfunction isLastScoreNegative(score) {\n    const last = score[score.length - 1];\n    return score.length > 0 && last[last.length - 1] < 0;\n}\n\nconst ROOT_TOKEN = {\n    type: 0 /* TokenType.Static */,\n    value: \'\',\n};\nconst VALID_PARAM_RE = /[a-zA-Z0-9_]/;\n// After some profiling, the cache seems to be unnecessary because tokenizePath\n// (the slowest part of adding a route) is very fast\n// const tokenCache = new Map<string, Token[][]>()\nfunction tokenizePath(path) {\n    if (!path)\n        return [[]];\n    if (path === \'/\')\n        return [[ROOT_TOKEN]];\n    if (!path.startsWith(\'/\')) {\n        throw new Error(( false)\n            ? 0\n            : `Invalid path "${path}"`);\n    }\n    // if (tokenCache.has(path)) return tokenCache.get(path)!\n    function crash(message) {\n        throw new Error(`ERR (${state})/"${buffer}": ${message}`);\n    }\n    let state = 0 /* TokenizerState.Static */;\n    let previousState = state;\n    const tokens = [];\n    // the segment will always be valid because we get into the initial state\n    // with the leading /\n    let segment;\n    function finalizeSegment() {\n        if (segment)\n            tokens.push(segment);\n        segment = [];\n    }\n    // index on the path\n    let i = 0;\n    // char at index\n    let char;\n    // buffer of the value read\n    let buffer = \'\';\n    // custom regexp for a param\n    let customRe = \'\';\n    function consumeBuffer() {\n        if (!buffer)\n            return;\n        if (state === 0 /* TokenizerState.Static */) {\n            segment.push({\n                type: 0 /* TokenType.Static */,\n                value: buffer,\n            });\n        }\n        else if (state === 1 /* TokenizerState.Param */ ||\n            state === 2 /* TokenizerState.ParamRegExp */ ||\n            state === 3 /* TokenizerState.ParamRegExpEnd */) {\n            if (segment.length > 1 && (char === \'*\' || char === \'+\'))\n                crash(`A repeatable param (${buffer}) must be alone in its segment. eg: \'/:ids+.`);\n            segment.push({\n                type: 1 /* TokenType.Param */,\n                value: buffer,\n                regexp: customRe,\n                repeatable: char === \'*\' || char === \'+\',\n                optional: char === \'*\' || char === \'?\',\n            });\n        }\n        else {\n            crash(\'Invalid state to consume buffer\');\n        }\n        buffer = \'\';\n    }\n    function addCharToBuffer() {\n        buffer += char;\n    }\n    while (i < path.length) {\n        char = path[i++];\n        if (char === \'\\\\\' && state !== 2 /* TokenizerState.ParamRegExp */) {\n            previousState = state;\n            state = 4 /* TokenizerState.EscapeNext */;\n            continue;\n        }\n        switch (state) {\n            case 0 /* TokenizerState.Static */:\n                if (char === \'/\') {\n                    if (buffer) {\n                        consumeBuffer();\n                    }\n                    finalizeSegment();\n                }\n                else if (char === \':\') {\n                    consumeBuffer();\n                    state = 1 /* TokenizerState.Param */;\n                }\n                else {\n                    addCharToBuffer();\n                }\n                break;\n            case 4 /* TokenizerState.EscapeNext */:\n                addCharToBuffer();\n                state = previousState;\n                break;\n            case 1 /* TokenizerState.Param */:\n                if (char === \'(\') {\n                    state = 2 /* TokenizerState.ParamRegExp */;\n                }\n                else if (VALID_PARAM_RE.test(char)) {\n                    addCharToBuffer();\n                }\n                else {\n                    consumeBuffer();\n                    state = 0 /* TokenizerState.Static */;\n                    // go back one character if we were not modifying\n                    if (char !== \'*\' && char !== \'?\' && char !== \'+\')\n                        i--;\n                }\n                break;\n            case 2 /* TokenizerState.ParamRegExp */:\n                // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)\n                // it already works by escaping the closing )\n                // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#\n                // is this really something people need since you can also write\n                // /prefix_:p()_suffix\n                if (char === \')\') {\n                    // handle the escaped )\n                    if (customRe[customRe.length - 1] == \'\\\\\')\n                        customRe = customRe.slice(0, -1) + char;\n                    else\n                        state = 3 /* TokenizerState.ParamRegExpEnd */;\n                }\n                else {\n                    customRe += char;\n                }\n                break;\n            case 3 /* TokenizerState.ParamRegExpEnd */:\n                // same as finalizing a param\n                consumeBuffer();\n                state = 0 /* TokenizerState.Static */;\n                // go back one character if we were not modifying\n                if (char !== \'*\' && char !== \'?\' && char !== \'+\')\n                    i--;\n                customRe = \'\';\n                break;\n            default:\n                crash(\'Unknown state\');\n                break;\n        }\n    }\n    if (state === 2 /* TokenizerState.ParamRegExp */)\n        crash(`Unfinished custom RegExp for param "${buffer}"`);\n    consumeBuffer();\n    finalizeSegment();\n    // tokenCache.set(path, tokens)\n    return tokens;\n}\n\nfunction createRouteRecordMatcher(record, parent, options) {\n    const parser = tokensToParser(tokenizePath(record.path), options);\n    // warn against params with the same name\n    if ((false)) {}\n    const matcher = vue_router_assign(parser, {\n        record,\n        parent,\n        // these needs to be populated by the parent\n        children: [],\n        alias: [],\n    });\n    if (parent) {\n        // both are aliases or both are not aliases\n        // we don\'t want to mix them because the order is used when\n        // passing originalRecord in Matcher.addRoute\n        if (!matcher.record.aliasOf === !parent.record.aliasOf)\n            parent.children.push(matcher);\n    }\n    return matcher;\n}\n\n/**\n * Creates a Router Matcher.\n *\n * @internal\n * @param routes - array of initial routes\n * @param globalOptions - global route options\n */\nfunction createRouterMatcher(routes, globalOptions) {\n    // normalized ordered array of matchers\n    const matchers = [];\n    const matcherMap = new Map();\n    globalOptions = vue_router_mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);\n    function getRecordMatcher(name) {\n        return matcherMap.get(name);\n    }\n    function addRoute(record, parent, originalRecord) {\n        // used later on to remove by name\n        const isRootAdd = !originalRecord;\n        const mainNormalizedRecord = normalizeRouteRecord(record);\n        if ((false)) {}\n        // we might be the child of an alias\n        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;\n        const options = vue_router_mergeOptions(globalOptions, record);\n        // generate an array of records to correctly handle aliases\n        const normalizedRecords = [\n            mainNormalizedRecord,\n        ];\n        if (\'alias\' in record) {\n            const aliases = typeof record.alias === \'string\' ? [record.alias] : record.alias;\n            for (const alias of aliases) {\n                normalizedRecords.push(vue_router_assign({}, mainNormalizedRecord, {\n                    // this allows us to hold a copy of the `components` option\n                    // so that async components cache is hold on the original record\n                    components: originalRecord\n                        ? originalRecord.record.components\n                        : mainNormalizedRecord.components,\n                    path: alias,\n                    // we might be the child of an alias\n                    aliasOf: originalRecord\n                        ? originalRecord.record\n                        : mainNormalizedRecord,\n                    // the aliases are always of the same kind as the original since they\n                    // are defined on the same record\n                }));\n            }\n        }\n        let matcher;\n        let originalMatcher;\n        for (const normalizedRecord of normalizedRecords) {\n            const { path } = normalizedRecord;\n            // Build up the path for nested routes if the child isn\'t an absolute\n            // route. Only add the / delimiter if the child path isn\'t empty and if the\n            // parent path doesn\'t have a trailing slash\n            if (parent && path[0] !== \'/\') {\n                const parentPath = parent.record.path;\n                const connectingSlash = parentPath[parentPath.length - 1] === \'/\' ? \'\' : \'/\';\n                normalizedRecord.path =\n                    parent.record.path + (path && connectingSlash + path);\n            }\n            if (false) {}\n            // create the object beforehand, so it can be passed to children\n            matcher = createRouteRecordMatcher(normalizedRecord, parent, options);\n            if (false)\n                {}\n            // if we are an alias we must tell the original record that we exist,\n            // so we can be removed\n            if (originalRecord) {\n                originalRecord.alias.push(matcher);\n                if ((false)) {}\n            }\n            else {\n                // otherwise, the first record is the original and others are aliases\n                originalMatcher = originalMatcher || matcher;\n                if (originalMatcher !== matcher)\n                    originalMatcher.alias.push(matcher);\n                // remove the route if named and only for the top record (avoid in nested calls)\n                // this works because the original record is the first one\n                if (isRootAdd && record.name && !isAliasRecord(matcher))\n                    removeRoute(record.name);\n            }\n            if (mainNormalizedRecord.children) {\n                const children = mainNormalizedRecord.children;\n                for (let i = 0; i < children.length; i++) {\n                    addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);\n                }\n            }\n            // if there was no original record, then the first one was not an alias and all\n            // other aliases (if any) need to reference this record when adding children\n            originalRecord = originalRecord || matcher;\n            // TODO: add normalized records for more flexibility\n            // if (parent && isAliasRecord(originalRecord)) {\n            //   parent.children.push(originalRecord)\n            // }\n            // Avoid adding a record that doesn\'t display anything. This allows passing through records without a component to\n            // not be reached and pass through the catch all route\n            if ((matcher.record.components &&\n                Object.keys(matcher.record.components).length) ||\n                matcher.record.name ||\n                matcher.record.redirect) {\n                insertMatcher(matcher);\n            }\n        }\n        return originalMatcher\n            ? () => {\n                // since other matchers are aliases, they should be removed by the original matcher\n                removeRoute(originalMatcher);\n            }\n            : noop;\n    }\n    function removeRoute(matcherRef) {\n        if (isRouteName(matcherRef)) {\n            const matcher = matcherMap.get(matcherRef);\n            if (matcher) {\n                matcherMap.delete(matcherRef);\n                matchers.splice(matchers.indexOf(matcher), 1);\n                matcher.children.forEach(removeRoute);\n                matcher.alias.forEach(removeRoute);\n            }\n        }\n        else {\n            const index = matchers.indexOf(matcherRef);\n            if (index > -1) {\n                matchers.splice(index, 1);\n                if (matcherRef.record.name)\n                    matcherMap.delete(matcherRef.record.name);\n                matcherRef.children.forEach(removeRoute);\n                matcherRef.alias.forEach(removeRoute);\n            }\n        }\n    }\n    function getRoutes() {\n        return matchers;\n    }\n    function insertMatcher(matcher) {\n        let i = 0;\n        while (i < matchers.length &&\n            comparePathParserScore(matcher, matchers[i]) >= 0 &&\n            // Adding children with empty path should still appear before the parent\n            // https://github.com/vuejs/router/issues/1124\n            (matcher.record.path !== matchers[i].record.path ||\n                !isRecordChildOf(matcher, matchers[i])))\n            i++;\n        matchers.splice(i, 0, matcher);\n        // only add the original record to the name map\n        if (matcher.record.name && !isAliasRecord(matcher))\n            matcherMap.set(matcher.record.name, matcher);\n    }\n    function resolve(location, currentLocation) {\n        let matcher;\n        let params = {};\n        let path;\n        let name;\n        if (\'name\' in location && location.name) {\n            matcher = matcherMap.get(location.name);\n            if (!matcher)\n                throw createRouterError(1 /* ErrorTypes.MATCHER_NOT_FOUND */, {\n                    location,\n                });\n            // warn if the user is passing invalid params so they can debug it better when they get removed\n            if ((false)) {}\n            name = matcher.record.name;\n            params = vue_router_assign(\n            // paramsFromLocation is a new object\n            paramsFromLocation(currentLocation.params, \n            // only keep params that exist in the resolved location\n            // TODO: only keep optional params coming from a parent record\n            matcher.keys.filter(k => !k.optional).map(k => k.name)), \n            // discard any existing params in the current location that do not exist here\n            // #1497 this ensures better active/exact matching\n            location.params &&\n                paramsFromLocation(location.params, matcher.keys.map(k => k.name)));\n            // throws if cannot be stringified\n            path = matcher.stringify(params);\n        }\n        else if (\'path\' in location) {\n            // no need to resolve the path with the matcher as it was provided\n            // this also allows the user to control the encoding\n            path = location.path;\n            if (false) {}\n            matcher = matchers.find(m => m.re.test(path));\n            // matcher should have a value after the loop\n            if (matcher) {\n                // we know the matcher works because we tested the regexp\n                params = matcher.parse(path);\n                name = matcher.record.name;\n            }\n            // location is a relative path\n        }\n        else {\n            // match by name or path of current route\n            matcher = currentLocation.name\n                ? matcherMap.get(currentLocation.name)\n                : matchers.find(m => m.re.test(currentLocation.path));\n            if (!matcher)\n                throw createRouterError(1 /* ErrorTypes.MATCHER_NOT_FOUND */, {\n                    location,\n                    currentLocation,\n                });\n            name = matcher.record.name;\n            // since we are navigating to the same location, we don\'t need to pick the\n            // params like when `name` is provided\n            params = vue_router_assign({}, currentLocation.params, location.params);\n            path = matcher.stringify(params);\n        }\n        const matched = [];\n        let parentMatcher = matcher;\n        while (parentMatcher) {\n            // reversed order so parents are at the beginning\n            matched.unshift(parentMatcher.record);\n            parentMatcher = parentMatcher.parent;\n        }\n        return {\n            name,\n            path,\n            params,\n            matched,\n            meta: mergeMetaFields(matched),\n        };\n    }\n    // add initial routes\n    routes.forEach(route => addRoute(route));\n    return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };\n}\nfunction paramsFromLocation(params, keys) {\n    const newParams = {};\n    for (const key of keys) {\n        if (key in params)\n            newParams[key] = params[key];\n    }\n    return newParams;\n}\n/**\n * Normalizes a RouteRecordRaw. Creates a copy\n *\n * @param record\n * @returns the normalized version\n */\nfunction normalizeRouteRecord(record) {\n    return {\n        path: record.path,\n        redirect: record.redirect,\n        name: record.name,\n        meta: record.meta || {},\n        aliasOf: undefined,\n        beforeEnter: record.beforeEnter,\n        props: normalizeRecordProps(record),\n        children: record.children || [],\n        instances: {},\n        leaveGuards: new Set(),\n        updateGuards: new Set(),\n        enterCallbacks: {},\n        components: \'components\' in record\n            ? record.components || null\n            : record.component && { default: record.component },\n    };\n}\n/**\n * Normalize the optional `props` in a record to always be an object similar to\n * components. Also accept a boolean for components.\n * @param record\n */\nfunction normalizeRecordProps(record) {\n    const propsObject = {};\n    // props does not exist on redirect records, but we can set false directly\n    const props = record.props || false;\n    if (\'component\' in record) {\n        propsObject.default = props;\n    }\n    else {\n        // NOTE: we could also allow a function to be applied to every component.\n        // Would need user feedback for use cases\n        for (const name in record.components)\n            propsObject[name] = typeof props === \'object\' ? props[name] : props;\n    }\n    return propsObject;\n}\n/**\n * Checks if a record or any of its parent is an alias\n * @param record\n */\nfunction isAliasRecord(record) {\n    while (record) {\n        if (record.record.aliasOf)\n            return true;\n        record = record.parent;\n    }\n    return false;\n}\n/**\n * Merge meta fields of an array of records\n *\n * @param matched - array of matched records\n */\nfunction mergeMetaFields(matched) {\n    return matched.reduce((meta, record) => vue_router_assign(meta, record.meta), {});\n}\nfunction vue_router_mergeOptions(defaults, partialOptions) {\n    const options = {};\n    for (const key in defaults) {\n        options[key] = key in partialOptions ? partialOptions[key] : defaults[key];\n    }\n    return options;\n}\nfunction isSameParam(a, b) {\n    return (a.name === b.name &&\n        a.optional === b.optional &&\n        a.repeatable === b.repeatable);\n}\n/**\n * Check if a path and its alias have the same required params\n *\n * @param a - original record\n * @param b - alias record\n */\nfunction checkSameParams(a, b) {\n    for (const key of a.keys) {\n        if (!key.optional && !b.keys.find(isSameParam.bind(null, key)))\n            return vue_router_warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" must have the exact same param named "${key.name}"`);\n    }\n    for (const key of b.keys) {\n        if (!key.optional && !a.keys.find(isSameParam.bind(null, key)))\n            return vue_router_warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" must have the exact same param named "${key.name}"`);\n    }\n}\n/**\n * A route with a name and a child with an empty path without a name should warn when adding the route\n *\n * @param mainNormalizedRecord - RouteRecordNormalized\n * @param parent - RouteRecordMatcher\n */\nfunction checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent) {\n    if (parent &&\n        parent.record.name &&\n        !mainNormalizedRecord.name &&\n        !mainNormalizedRecord.path) {\n        vue_router_warn(`The route named "${String(parent.record.name)}" has a child without a name and an empty path. Using that name won\'t render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning.`);\n    }\n}\nfunction checkMissingParamsInAbsolutePath(record, parent) {\n    for (const key of parent.keys) {\n        if (!record.keys.find(isSameParam.bind(null, key)))\n            return vue_router_warn(`Absolute path "${record.record.path}" must have the exact same param named "${key.name}" as its parent "${parent.record.path}".`);\n    }\n}\nfunction isRecordChildOf(record, parent) {\n    return parent.children.some(child => child === record || isRecordChildOf(record, child));\n}\n\n/**\n * Encoding Rules ␣ = Space Path: ␣ " < > # ? { } Query: ␣ " < > # & = Hash: ␣ "\n * < > `\n *\n * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)\n * defines some extra characters to be encoded. Most browsers do not encode them\n * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to\n * also encode `!\'()*`. Leaving un-encoded only ASCII alphanumeric(`a-zA-Z0-9`)\n * plus `-._~`. This extra safety should be applied to query by patching the\n * string returned by encodeURIComponent encodeURI also encodes `[\\]^`. `\\`\n * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\\`\n * into a `/` if directly typed in. The _backtick_ (`````) should also be\n * encoded everywhere because some browsers like FF encode it when directly\n * written while others don\'t. Safari and IE don\'t encode ``"<>{}``` in hash.\n */\n// const EXTRA_RESERVED_RE = /[!\'()*]/g\n// const encodeReservedReplacer = (c: string) => \'%\' + c.charCodeAt(0).toString(16)\nconst HASH_RE = /#/g; // %23\nconst AMPERSAND_RE = /&/g; // %26\nconst SLASH_RE = /\\//g; // %2F\nconst EQUAL_RE = /=/g; // %3D\nconst IM_RE = /\\?/g; // %3F\nconst PLUS_RE = /\\+/g; // %2B\n/**\n * NOTE: It\'s not clear to me if we should encode the + symbol in queries, it\n * seems to be less flexible than not doing so and I can\'t find out the legacy\n * systems requiring this for regular requests like text/html. In the standard,\n * the encoding of the plus character is only mentioned for\n * application/x-www-form-urlencoded\n * (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo\n * leave the plus character as is in queries. To be more flexible, we allow the\n * plus character on the query, but it can also be manually encoded by the user.\n *\n * Resources:\n * - https://url.spec.whatwg.org/#urlencoded-parsing\n * - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20\n */\nconst ENC_BRACKET_OPEN_RE = /%5B/g; // [\nconst ENC_BRACKET_CLOSE_RE = /%5D/g; // ]\nconst ENC_CARET_RE = /%5E/g; // ^\nconst ENC_BACKTICK_RE = /%60/g; // `\nconst ENC_CURLY_OPEN_RE = /%7B/g; // {\nconst ENC_PIPE_RE = /%7C/g; // |\nconst ENC_CURLY_CLOSE_RE = /%7D/g; // }\nconst ENC_SPACE_RE = /%20/g; // }\n/**\n * Encode characters that need to be encoded on the path, search and hash\n * sections of the URL.\n *\n * @internal\n * @param text - string to encode\n * @returns encoded string\n */\nfunction commonEncode(text) {\n    return encodeURI(\'\' + text)\n        .replace(ENC_PIPE_RE, \'|\')\n        .replace(ENC_BRACKET_OPEN_RE, \'[\')\n        .replace(ENC_BRACKET_CLOSE_RE, \']\');\n}\n/**\n * Encode characters that need to be encoded on the hash section of the URL.\n *\n * @param text - string to encode\n * @returns encoded string\n */\nfunction encodeHash(text) {\n    return commonEncode(text)\n        .replace(ENC_CURLY_OPEN_RE, \'{\')\n        .replace(ENC_CURLY_CLOSE_RE, \'}\')\n        .replace(ENC_CARET_RE, \'^\');\n}\n/**\n * Encode characters that need to be encoded query values on the query\n * section of the URL.\n *\n * @param text - string to encode\n * @returns encoded string\n */\nfunction encodeQueryValue(text) {\n    return (commonEncode(text)\n        // Encode the space as +, encode the + to differentiate it from the space\n        .replace(PLUS_RE, \'%2B\')\n        .replace(ENC_SPACE_RE, \'+\')\n        .replace(HASH_RE, \'%23\')\n        .replace(AMPERSAND_RE, \'%26\')\n        .replace(ENC_BACKTICK_RE, \'`\')\n        .replace(ENC_CURLY_OPEN_RE, \'{\')\n        .replace(ENC_CURLY_CLOSE_RE, \'}\')\n        .replace(ENC_CARET_RE, \'^\'));\n}\n/**\n * Like `encodeQueryValue` but also encodes the `=` character.\n *\n * @param text - string to encode\n */\nfunction encodeQueryKey(text) {\n    return encodeQueryValue(text).replace(EQUAL_RE, \'%3D\');\n}\n/**\n * Encode characters that need to be encoded on the path section of the URL.\n *\n * @param text - string to encode\n * @returns encoded string\n */\nfunction encodePath(text) {\n    return commonEncode(text).replace(HASH_RE, \'%23\').replace(IM_RE, \'%3F\');\n}\n/**\n * Encode characters that need to be encoded on the path section of the URL as a\n * param. This function encodes everything {@link encodePath} does plus the\n * slash (`/`) character. If `text` is `null` or `undefined`, returns an empty\n * string instead.\n *\n * @param text - string to encode\n * @returns encoded string\n */\nfunction encodeParam(text) {\n    return text == null ? \'\' : encodePath(text).replace(SLASH_RE, \'%2F\');\n}\n/**\n * Decode text using `decodeURIComponent`. Returns the original text if it\n * fails.\n *\n * @param text - string to decode\n * @returns decoded string\n */\nfunction decode(text) {\n    try {\n        return decodeURIComponent(\'\' + text);\n    }\n    catch (err) {\n        ( false) && 0;\n    }\n    return \'\' + text;\n}\n\n/**\n * Transforms a queryString into a {@link LocationQuery} object. Accept both, a\n * version with the leading `?` and without Should work as URLSearchParams\n\n * @internal\n *\n * @param search - search string to parse\n * @returns a query object\n */\nfunction parseQuery(search) {\n    const query = {};\n    // avoid creating an object with an empty key and empty value\n    // because of split(\'&\')\n    if (search === \'\' || search === \'?\')\n        return query;\n    const hasLeadingIM = search[0] === \'?\';\n    const searchParams = (hasLeadingIM ? search.slice(1) : search).split(\'&\');\n    for (let i = 0; i < searchParams.length; ++i) {\n        // pre decode the + into space\n        const searchParam = searchParams[i].replace(PLUS_RE, \' \');\n        // allow the = character\n        const eqPos = searchParam.indexOf(\'=\');\n        const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));\n        const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));\n        if (key in query) {\n            // an extra variable for ts types\n            let currentValue = query[key];\n            if (!vue_router_isArray(currentValue)) {\n                currentValue = query[key] = [currentValue];\n            }\n            currentValue.push(value);\n        }\n        else {\n            query[key] = value;\n        }\n    }\n    return query;\n}\n/**\n * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it\n * doesn\'t prepend a `?`\n *\n * @internal\n *\n * @param query - query object to stringify\n * @returns string version of the query without the leading `?`\n */\nfunction stringifyQuery(query) {\n    let search = \'\';\n    for (let key in query) {\n        const value = query[key];\n        key = encodeQueryKey(key);\n        if (value == null) {\n            // only null adds the value\n            if (value !== undefined) {\n                search += (search.length ? \'&\' : \'\') + key;\n            }\n            continue;\n        }\n        // keep null values\n        const values = vue_router_isArray(value)\n            ? value.map(v => v && encodeQueryValue(v))\n            : [value && encodeQueryValue(value)];\n        values.forEach(value => {\n            // skip undefined values in arrays as if they were not present\n            // smaller code than using filter\n            if (value !== undefined) {\n                // only append & with non-empty search\n                search += (search.length ? \'&\' : \'\') + key;\n                if (value != null)\n                    search += \'=\' + value;\n            }\n        });\n    }\n    return search;\n}\n/**\n * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting\n * numbers into strings, removing keys with an undefined value and replacing\n * undefined with null in arrays\n *\n * @param query - query object to normalize\n * @returns a normalized query object\n */\nfunction normalizeQuery(query) {\n    const normalizedQuery = {};\n    for (const key in query) {\n        const value = query[key];\n        if (value !== undefined) {\n            normalizedQuery[key] = vue_router_isArray(value)\n                ? value.map(v => (v == null ? null : \'\' + v))\n                : value == null\n                    ? value\n                    : \'\' + value;\n        }\n    }\n    return normalizedQuery;\n}\n\n/**\n * RouteRecord being rendered by the closest ancestor Router View. Used for\n * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View\n * Location Matched\n *\n * @internal\n */\nconst matchedRouteKey = Symbol(( false) ? 0 : \'\');\n/**\n * Allows overriding the router view depth to control which component in\n * `matched` is rendered. rvd stands for Router View Depth\n *\n * @internal\n */\nconst viewDepthKey = Symbol(( false) ? 0 : \'\');\n/**\n * Allows overriding the router instance returned by `useRouter` in tests. r\n * stands for router\n *\n * @internal\n */\nconst routerKey = Symbol(( false) ? 0 : \'\');\n/**\n * Allows overriding the current route returned by `useRoute` in tests. rl\n * stands for route location\n *\n * @internal\n */\nconst routeLocationKey = Symbol(( false) ? 0 : \'\');\n/**\n * Allows overriding the current route used by router-view. Internally this is\n * used when the `route` prop is passed.\n *\n * @internal\n */\nconst routerViewLocationKey = Symbol(( false) ? 0 : \'\');\n\n/**\n * Create a list of callbacks that can be reset. Used to create before and after navigation guards list\n */\nfunction useCallbacks() {\n    let handlers = [];\n    function add(handler) {\n        handlers.push(handler);\n        return () => {\n            const i = handlers.indexOf(handler);\n            if (i > -1)\n                handlers.splice(i, 1);\n        };\n    }\n    function reset() {\n        handlers = [];\n    }\n    return {\n        add,\n        list: () => handlers.slice(),\n        reset,\n    };\n}\n\nfunction registerGuard(record, name, guard) {\n    const removeFromList = () => {\n        record[name].delete(guard);\n    };\n    onUnmounted(removeFromList);\n    onDeactivated(removeFromList);\n    onActivated(() => {\n        record[name].add(guard);\n    });\n    record[name].add(guard);\n}\n/**\n * Add a navigation guard that triggers whenever the component for the current\n * location is about to be left. Similar to {@link beforeRouteLeave} but can be\n * used in any component. The guard is removed when the component is unmounted.\n *\n * @param leaveGuard - {@link NavigationGuard}\n */\nfunction onBeforeRouteLeave(leaveGuard) {\n    if (false) {}\n    const activeRecord = inject(matchedRouteKey, \n    // to avoid warning\n    {}).value;\n    if (!activeRecord) {\n        ( false) &&\n            0;\n        return;\n    }\n    registerGuard(activeRecord, \'leaveGuards\', leaveGuard);\n}\n/**\n * Add a navigation guard that triggers whenever the current location is about\n * to be updated. Similar to {@link beforeRouteUpdate} but can be used in any\n * component. The guard is removed when the component is unmounted.\n *\n * @param updateGuard - {@link NavigationGuard}\n */\nfunction onBeforeRouteUpdate(updateGuard) {\n    if (false) {}\n    const activeRecord = inject(matchedRouteKey, \n    // to avoid warning\n    {}).value;\n    if (!activeRecord) {\n        ( false) &&\n            0;\n        return;\n    }\n    registerGuard(activeRecord, \'updateGuards\', updateGuard);\n}\nfunction guardToPromiseFn(guard, to, from, record, name) {\n    // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place\n    const enterCallbackArray = record &&\n        // name is defined if record is because of the function overload\n        (record.enterCallbacks[name] = record.enterCallbacks[name] || []);\n    return () => new Promise((resolve, reject) => {\n        const next = (valid) => {\n            if (valid === false) {\n                reject(createRouterError(4 /* ErrorTypes.NAVIGATION_ABORTED */, {\n                    from,\n                    to,\n                }));\n            }\n            else if (valid instanceof Error) {\n                reject(valid);\n            }\n            else if (isRouteLocation(valid)) {\n                reject(createRouterError(2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */, {\n                    from: to,\n                    to: valid,\n                }));\n            }\n            else {\n                if (enterCallbackArray &&\n                    // since enterCallbackArray is truthy, both record and name also are\n                    record.enterCallbacks[name] === enterCallbackArray &&\n                    typeof valid === \'function\') {\n                    enterCallbackArray.push(valid);\n                }\n                resolve();\n            }\n        };\n        // wrapping with Promise.resolve allows it to work with both async and sync guards\n        const guardReturn = guard.call(record && record.instances[name], to, from, ( false) ? 0 : next);\n        let guardCall = Promise.resolve(guardReturn);\n        if (guard.length < 3)\n            guardCall = guardCall.then(next);\n        if (false) {}\n        guardCall.catch(err => reject(err));\n    });\n}\nfunction canOnlyBeCalledOnce(next, to, from) {\n    let called = 0;\n    return function () {\n        if (called++ === 1)\n            vue_router_warn(`The "next" callback was called more than once in one navigation guard when going from "${from.fullPath}" to "${to.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`);\n        // @ts-expect-error: we put it in the original one because it\'s easier to check\n        next._called = true;\n        if (called === 1)\n            next.apply(null, arguments);\n    };\n}\nfunction extractComponentsGuards(matched, guardType, to, from) {\n    const guards = [];\n    for (const record of matched) {\n        if (false) {}\n        for (const name in record.components) {\n            let rawComponent = record.components[name];\n            if ((false)) {}\n            // skip update and leave guards if the route component is not mounted\n            if (guardType !== \'beforeRouteEnter\' && !record.instances[name])\n                continue;\n            if (isRouteComponent(rawComponent)) {\n                // __vccOpts is added by vue-class-component and contain the regular options\n                const options = rawComponent.__vccOpts || rawComponent;\n                const guard = options[guardType];\n                guard && guards.push(guardToPromiseFn(guard, to, from, record, name));\n            }\n            else {\n                // start requesting the chunk already\n                let componentPromise = rawComponent();\n                if (false) {}\n                guards.push(() => componentPromise.then(resolved => {\n                    if (!resolved)\n                        return Promise.reject(new Error(`Couldn\'t resolve component "${name}" at "${record.path}"`));\n                    const resolvedComponent = isESModule(resolved)\n                        ? resolved.default\n                        : resolved;\n                    // replace the function with the resolved component\n                    // cannot be null or undefined because we went into the for loop\n                    record.components[name] = resolvedComponent;\n                    // __vccOpts is added by vue-class-component and contain the regular options\n                    const options = resolvedComponent.__vccOpts || resolvedComponent;\n                    const guard = options[guardType];\n                    return guard && guardToPromiseFn(guard, to, from, record, name)();\n                }));\n            }\n        }\n    }\n    return guards;\n}\n/**\n * Allows differentiating lazy components from functional components and vue-class-component\n * @internal\n *\n * @param component\n */\nfunction isRouteComponent(component) {\n    return (typeof component === \'object\' ||\n        \'displayName\' in component ||\n        \'props\' in component ||\n        \'__vccOpts\' in component);\n}\n/**\n * Ensures a route is loaded, so it can be passed as o prop to `<RouterView>`.\n *\n * @param route - resolved route to load\n */\nfunction loadRouteLocation(route) {\n    return route.matched.every(record => record.redirect)\n        ? Promise.reject(new Error(\'Cannot load a route that redirects.\'))\n        : Promise.all(route.matched.map(record => record.components &&\n            Promise.all(Object.keys(record.components).reduce((promises, name) => {\n                const rawComponent = record.components[name];\n                if (typeof rawComponent === \'function\' &&\n                    !(\'displayName\' in rawComponent)) {\n                    promises.push(rawComponent().then(resolved => {\n                        if (!resolved)\n                            return Promise.reject(new Error(`Couldn\'t resolve component "${name}" at "${record.path}". Ensure you passed a function that returns a promise.`));\n                        const resolvedComponent = isESModule(resolved)\n                            ? resolved.default\n                            : resolved;\n                        // replace the function with the resolved component\n                        // cannot be null or undefined because we went into the for loop\n                        record.components[name] = resolvedComponent;\n                        return;\n                    }));\n                }\n                return promises;\n            }, [])))).then(() => route);\n}\n\n// TODO: we could allow currentRoute as a prop to expose `isActive` and\n// `isExactActive` behavior should go through an RFC\nfunction useLink(props) {\n    const router = runtime_core_esm_bundler_inject(routerKey);\n    const currentRoute = runtime_core_esm_bundler_inject(routeLocationKey);\n    const route = runtime_core_esm_bundler_computed(() => router.resolve(unref(props.to)));\n    const activeRecordIndex = runtime_core_esm_bundler_computed(() => {\n        const { matched } = route.value;\n        const { length } = matched;\n        const routeMatched = matched[length - 1];\n        const currentMatched = currentRoute.matched;\n        if (!routeMatched || !currentMatched.length)\n            return -1;\n        const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));\n        if (index > -1)\n            return index;\n        // possible parent record\n        const parentRecordPath = getOriginalPath(matched[length - 2]);\n        return (\n        // we are dealing with nested routes\n        length > 1 &&\n            // if the parent and matched route have the same path, this link is\n            // referring to the empty child. Or we currently are on a different\n            // child of the same parent\n            getOriginalPath(routeMatched) === parentRecordPath &&\n            // avoid comparing the child with its parent\n            currentMatched[currentMatched.length - 1].path !== parentRecordPath\n            ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2]))\n            : index);\n    });\n    const isActive = runtime_core_esm_bundler_computed(() => activeRecordIndex.value > -1 &&\n        includesParams(currentRoute.params, route.value.params));\n    const isExactActive = runtime_core_esm_bundler_computed(() => activeRecordIndex.value > -1 &&\n        activeRecordIndex.value === currentRoute.matched.length - 1 &&\n        isSameRouteLocationParams(currentRoute.params, route.value.params));\n    function navigate(e = {}) {\n        if (guardEvent(e)) {\n            return router[unref(props.replace) ? \'replace\' : \'push\'](unref(props.to)\n            // avoid uncaught errors are they are logged anyway\n            ).catch(noop);\n        }\n        return Promise.resolve();\n    }\n    // devtools only\n    if ((( false) || __VUE_PROD_DEVTOOLS__) && isBrowser) {\n        const instance = runtime_core_esm_bundler_getCurrentInstance();\n        if (instance) {\n            const linkContextDevtools = {\n                route: route.value,\n                isActive: isActive.value,\n                isExactActive: isExactActive.value,\n            };\n            // @ts-expect-error: this is internal\n            instance.__vrl_devtools = instance.__vrl_devtools || [];\n            // @ts-expect-error: this is internal\n            instance.__vrl_devtools.push(linkContextDevtools);\n            watchEffect(() => {\n                linkContextDevtools.route = route.value;\n                linkContextDevtools.isActive = isActive.value;\n                linkContextDevtools.isExactActive = isExactActive.value;\n            }, { flush: \'post\' });\n        }\n    }\n    /**\n     * NOTE: update {@link _RouterLinkI}\'s `$slots` type when updating this\n     */\n    return {\n        route,\n        href: runtime_core_esm_bundler_computed(() => route.value.href),\n        isActive,\n        isExactActive,\n        navigate,\n    };\n}\nconst RouterLinkImpl = /*#__PURE__*/ runtime_core_esm_bundler_defineComponent({\n    name: \'RouterLink\',\n    compatConfig: { MODE: 3 },\n    props: {\n        to: {\n            type: [String, Object],\n            required: true,\n        },\n        replace: Boolean,\n        activeClass: String,\n        // inactiveClass: String,\n        exactActiveClass: String,\n        custom: Boolean,\n        ariaCurrentValue: {\n            type: String,\n            default: \'page\',\n        },\n    },\n    useLink,\n    setup(props, { slots }) {\n        const link = reactive(useLink(props));\n        const { options } = runtime_core_esm_bundler_inject(routerKey);\n        const elClass = runtime_core_esm_bundler_computed(() => ({\n            [getLinkClass(props.activeClass, options.linkActiveClass, \'router-link-active\')]: link.isActive,\n            // [getLinkClass(\n            //   props.inactiveClass,\n            //   options.linkInactiveClass,\n            //   \'router-link-inactive\'\n            // )]: !link.isExactActive,\n            [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, \'router-link-exact-active\')]: link.isExactActive,\n        }));\n        return () => {\n            const children = slots.default && slots.default(link);\n            return props.custom\n                ? children\n                : h(\'a\', {\n                    \'aria-current\': link.isExactActive\n                        ? props.ariaCurrentValue\n                        : null,\n                    href: link.href,\n                    // this would override user added attrs but Vue will still add\n                    // the listener, so we end up triggering both\n                    onClick: link.navigate,\n                    class: elClass.value,\n                }, children);\n        };\n    },\n});\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n/**\n * Component to render a link that triggers a navigation on click.\n */\nconst RouterLink = RouterLinkImpl;\nfunction guardEvent(e) {\n    // don\'t redirect with control keys\n    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n        return;\n    // don\'t redirect when preventDefault called\n    if (e.defaultPrevented)\n        return;\n    // don\'t redirect on right click\n    if (e.button !== undefined && e.button !== 0)\n        return;\n    // don\'t redirect if `target="_blank"`\n    // @ts-expect-error getAttribute does exist\n    if (e.currentTarget && e.currentTarget.getAttribute) {\n        // @ts-expect-error getAttribute exists\n        const target = e.currentTarget.getAttribute(\'target\');\n        if (/\\b_blank\\b/i.test(target))\n            return;\n    }\n    // this may be a Weex event which doesn\'t have this method\n    if (e.preventDefault)\n        e.preventDefault();\n    return true;\n}\nfunction includesParams(outer, inner) {\n    for (const key in inner) {\n        const innerValue = inner[key];\n        const outerValue = outer[key];\n        if (typeof innerValue === \'string\') {\n            if (innerValue !== outerValue)\n                return false;\n        }\n        else {\n            if (!vue_router_isArray(outerValue) ||\n                outerValue.length !== innerValue.length ||\n                innerValue.some((value, i) => value !== outerValue[i]))\n                return false;\n        }\n    }\n    return true;\n}\n/**\n * Get the original path value of a record by following its aliasOf\n * @param record\n */\nfunction getOriginalPath(record) {\n    return record ? (record.aliasOf ? record.aliasOf.path : record.path) : \'\';\n}\n/**\n * Utility class to get the active class based on defaults.\n * @param propClass\n * @param globalClass\n * @param defaultClass\n */\nconst getLinkClass = (propClass, globalClass, defaultClass) => propClass != null\n    ? propClass\n    : globalClass != null\n        ? globalClass\n        : defaultClass;\n\nconst RouterViewImpl = /*#__PURE__*/ runtime_core_esm_bundler_defineComponent({\n    name: \'RouterView\',\n    // #674 we manually inherit them\n    inheritAttrs: false,\n    props: {\n        name: {\n            type: String,\n            default: \'default\',\n        },\n        route: Object,\n    },\n    // Better compat for @vue/compat users\n    // https://github.com/vuejs/router/issues/1315\n    compatConfig: { MODE: 3 },\n    setup(props, { attrs, slots }) {\n        ( false) && 0;\n        const injectedRoute = runtime_core_esm_bundler_inject(routerViewLocationKey);\n        const routeToDisplay = runtime_core_esm_bundler_computed(() => props.route || injectedRoute.value);\n        const injectedDepth = runtime_core_esm_bundler_inject(viewDepthKey, 0);\n        // The depth changes based on empty components option, which allows passthrough routes e.g. routes with children\n        // that are used to reuse the `path` property\n        const depth = runtime_core_esm_bundler_computed(() => {\n            let initialDepth = unref(injectedDepth);\n            const { matched } = routeToDisplay.value;\n            let matchedRoute;\n            while ((matchedRoute = matched[initialDepth]) &&\n                !matchedRoute.components) {\n                initialDepth++;\n            }\n            return initialDepth;\n        });\n        const matchedRouteRef = runtime_core_esm_bundler_computed(() => routeToDisplay.value.matched[depth.value]);\n        provide(viewDepthKey, runtime_core_esm_bundler_computed(() => depth.value + 1));\n        provide(matchedRouteKey, matchedRouteRef);\n        provide(routerViewLocationKey, routeToDisplay);\n        const viewRef = reactivity_esm_bundler_ref();\n        // watch at the same time the component instance, the route record we are\n        // rendering, and the name\n        watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {\n            // copy reused instances\n            if (to) {\n                // this will update the instance for new instances as well as reused\n                // instances when navigating to a new route\n                to.instances[name] = instance;\n                // the component instance is reused for a different route or name, so\n                // we copy any saved update or leave guards. With async setup, the\n                // mounting component will mount before the matchedRoute changes,\n                // making instance === oldInstance, so we check if guards have been\n                // added before. This works because we remove guards when\n                // unmounting/deactivating components\n                if (from && from !== to && instance && instance === oldInstance) {\n                    if (!to.leaveGuards.size) {\n                        to.leaveGuards = from.leaveGuards;\n                    }\n                    if (!to.updateGuards.size) {\n                        to.updateGuards = from.updateGuards;\n                    }\n                }\n            }\n            // trigger beforeRouteEnter next callbacks\n            if (instance &&\n                to &&\n                // if there is no instance but to and from are the same this might be\n                // the first visit\n                (!from || !isSameRouteRecord(to, from) || !oldInstance)) {\n                (to.enterCallbacks[name] || []).forEach(callback => callback(instance));\n            }\n        }, { flush: \'post\' });\n        return () => {\n            const route = routeToDisplay.value;\n            // we need the value at the time we render because when we unmount, we\n            // navigated to a different location so the value is different\n            const currentName = props.name;\n            const matchedRoute = matchedRouteRef.value;\n            const ViewComponent = matchedRoute && matchedRoute.components[currentName];\n            if (!ViewComponent) {\n                return vue_router_normalizeSlot(slots.default, { Component: ViewComponent, route });\n            }\n            // props from route configuration\n            const routePropsOption = matchedRoute.props[currentName];\n            const routeProps = routePropsOption\n                ? routePropsOption === true\n                    ? route.params\n                    : typeof routePropsOption === \'function\'\n                        ? routePropsOption(route)\n                        : routePropsOption\n                : null;\n            const onVnodeUnmounted = vnode => {\n                // remove the instance reference to prevent leak\n                if (vnode.component.isUnmounted) {\n                    matchedRoute.instances[currentName] = null;\n                }\n            };\n            const component = h(ViewComponent, vue_router_assign({}, routeProps, attrs, {\n                onVnodeUnmounted,\n                ref: viewRef,\n            }));\n            if ((( false) || __VUE_PROD_DEVTOOLS__) &&\n                isBrowser &&\n                component.ref) {\n                // TODO: can display if it\'s an alias, its props\n                const info = {\n                    depth: depth.value,\n                    name: matchedRoute.name,\n                    path: matchedRoute.path,\n                    meta: matchedRoute.meta,\n                };\n                const internalInstances = vue_router_isArray(component.ref)\n                    ? component.ref.map(r => r.i)\n                    : [component.ref.i];\n                internalInstances.forEach(instance => {\n                    // @ts-expect-error\n                    instance.__vrv_devtools = info;\n                });\n            }\n            return (\n            // pass the vnode to the slot as a prop.\n            // h and <component :is="..."> both accept vnodes\n            vue_router_normalizeSlot(slots.default, { Component: component, route }) ||\n                component);\n        };\n    },\n});\nfunction vue_router_normalizeSlot(slot, data) {\n    if (!slot)\n        return null;\n    const slotContent = slot(data);\n    return slotContent.length === 1 ? slotContent[0] : slotContent;\n}\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n/**\n * Component to display the current route the user is at.\n */\nconst RouterView = RouterViewImpl;\n// warn against deprecated usage with <transition> & <keep-alive>\n// due to functional component being no longer eager in Vue 3\nfunction warnDeprecatedUsage() {\n    const instance = getCurrentInstance();\n    const parentName = instance.parent && instance.parent.type.name;\n    const parentSubTreeType = instance.parent && instance.parent.subTree && instance.parent.subTree.type;\n    if (parentName &&\n        (parentName === \'KeepAlive\' || parentName.includes(\'Transition\')) &&\n        typeof parentSubTreeType === \'object\' &&\n        parentSubTreeType.name === \'RouterView\') {\n        const comp = parentName === \'KeepAlive\' ? \'keep-alive\' : \'transition\';\n        vue_router_warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\\n` +\n            `Use slot props instead:\\n\\n` +\n            `<router-view v-slot="{ Component }">\\n` +\n            `  <${comp}>\\n` +\n            `    <component :is="Component" />\\n` +\n            `  </${comp}>\\n` +\n            `</router-view>`);\n    }\n}\n\n/**\n * Copies a route location and removes any problematic properties that cannot be shown in devtools (e.g. Vue instances).\n *\n * @param routeLocation - routeLocation to format\n * @param tooltip - optional tooltip\n * @returns a copy of the routeLocation\n */\nfunction formatRouteLocation(routeLocation, tooltip) {\n    const copy = vue_router_assign({}, routeLocation, {\n        // remove variables that can contain vue instances\n        matched: routeLocation.matched.map(matched => omit(matched, [\'instances\', \'children\', \'aliasOf\'])),\n    });\n    return {\n        _custom: {\n            type: null,\n            readOnly: true,\n            display: routeLocation.fullPath,\n            tooltip,\n            value: copy,\n        },\n    };\n}\nfunction formatDisplay(display) {\n    return {\n        _custom: {\n            display,\n        },\n    };\n}\n// to support multiple router instances\nlet routerId = 0;\nfunction addDevtools(app, router, matcher) {\n    // Take over router.beforeEach and afterEach\n    // make sure we are not registering the devtool twice\n    if (router.__hasDevtools)\n        return;\n    router.__hasDevtools = true;\n    // increment to support multiple router instances\n    const id = routerId++;\n    setupDevtoolsPlugin({\n        id: \'org.vuejs.router\' + (id ? \'.\' + id : \'\'),\n        label: \'Vue Router\',\n        packageName: \'vue-router\',\n        homepage: \'https://router.vuejs.org\',\n        logo: \'https://router.vuejs.org/logo.png\',\n        componentStateTypes: [\'Routing\'],\n        app,\n    }, api => {\n        if (typeof api.now !== \'function\') {\n            console.warn(\'[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.\');\n        }\n        // display state added by the router\n        api.on.inspectComponent((payload, ctx) => {\n            if (payload.instanceData) {\n                payload.instanceData.state.push({\n                    type: \'Routing\',\n                    key: \'$route\',\n                    editable: false,\n                    value: formatRouteLocation(router.currentRoute.value, \'Current Route\'),\n                });\n            }\n        });\n        // mark router-link as active and display tags on router views\n        api.on.visitComponentTree(({ treeNode: node, componentInstance }) => {\n            if (componentInstance.__vrv_devtools) {\n                const info = componentInstance.__vrv_devtools;\n                node.tags.push({\n                    label: (info.name ? `${info.name.toString()}: ` : \'\') + info.path,\n                    textColor: 0,\n                    tooltip: \'This component is rendered by &lt;router-view&gt;\',\n                    backgroundColor: PINK_500,\n                });\n            }\n            // if multiple useLink are used\n            if (vue_router_isArray(componentInstance.__vrl_devtools)) {\n                componentInstance.__devtoolsApi = api;\n                componentInstance.__vrl_devtools.forEach(devtoolsData => {\n                    let backgroundColor = ORANGE_400;\n                    let tooltip = \'\';\n                    if (devtoolsData.isExactActive) {\n                        backgroundColor = LIME_500;\n                        tooltip = \'This is exactly active\';\n                    }\n                    else if (devtoolsData.isActive) {\n                        backgroundColor = BLUE_600;\n                        tooltip = \'This link is active\';\n                    }\n                    node.tags.push({\n                        label: devtoolsData.route.path,\n                        textColor: 0,\n                        tooltip,\n                        backgroundColor,\n                    });\n                });\n            }\n        });\n        watch(router.currentRoute, () => {\n            // refresh active state\n            refreshRoutesView();\n            api.notifyComponentUpdate();\n            api.sendInspectorTree(routerInspectorId);\n            api.sendInspectorState(routerInspectorId);\n        });\n        const navigationsLayerId = \'router:navigations:\' + id;\n        api.addTimelineLayer({\n            id: navigationsLayerId,\n            label: `Router${id ? \' \' + id : \'\'} Navigations`,\n            color: 0x40a8c4,\n        });\n        // const errorsLayerId = \'router:errors\'\n        // api.addTimelineLayer({\n        //   id: errorsLayerId,\n        //   label: \'Router Errors\',\n        //   color: 0xea5455,\n        // })\n        router.onError((error, to) => {\n            api.addTimelineEvent({\n                layerId: navigationsLayerId,\n                event: {\n                    title: \'Error during Navigation\',\n                    subtitle: to.fullPath,\n                    logType: \'error\',\n                    time: api.now(),\n                    data: { error },\n                    groupId: to.meta.__navigationId,\n                },\n            });\n        });\n        // attached to `meta` and used to group events\n        let navigationId = 0;\n        router.beforeEach((to, from) => {\n            const data = {\n                guard: formatDisplay(\'beforeEach\'),\n                from: formatRouteLocation(from, \'Current Location during this navigation\'),\n                to: formatRouteLocation(to, \'Target location\'),\n            };\n            // Used to group navigations together, hide from devtools\n            Object.defineProperty(to.meta, \'__navigationId\', {\n                value: navigationId++,\n            });\n            api.addTimelineEvent({\n                layerId: navigationsLayerId,\n                event: {\n                    time: api.now(),\n                    title: \'Start of navigation\',\n                    subtitle: to.fullPath,\n                    data,\n                    groupId: to.meta.__navigationId,\n                },\n            });\n        });\n        router.afterEach((to, from, failure) => {\n            const data = {\n                guard: formatDisplay(\'afterEach\'),\n            };\n            if (failure) {\n                data.failure = {\n                    _custom: {\n                        type: Error,\n                        readOnly: true,\n                        display: failure ? failure.message : \'\',\n                        tooltip: \'Navigation Failure\',\n                        value: failure,\n                    },\n                };\n                data.status = formatDisplay(\'❌\');\n            }\n            else {\n                data.status = formatDisplay(\'✅\');\n            }\n            // we set here to have the right order\n            data.from = formatRouteLocation(from, \'Current Location during this navigation\');\n            data.to = formatRouteLocation(to, \'Target location\');\n            api.addTimelineEvent({\n                layerId: navigationsLayerId,\n                event: {\n                    title: \'End of navigation\',\n                    subtitle: to.fullPath,\n                    time: api.now(),\n                    data,\n                    logType: failure ? \'warning\' : \'default\',\n                    groupId: to.meta.__navigationId,\n                },\n            });\n        });\n        /**\n         * Inspector of Existing routes\n         */\n        const routerInspectorId = \'router-inspector:\' + id;\n        api.addInspector({\n            id: routerInspectorId,\n            label: \'Routes\' + (id ? \' \' + id : \'\'),\n            icon: \'book\',\n            treeFilterPlaceholder: \'Search routes\',\n        });\n        function refreshRoutesView() {\n            // the routes view isn\'t active\n            if (!activeRoutesPayload)\n                return;\n            const payload = activeRoutesPayload;\n            // children routes will appear as nested\n            let routes = matcher.getRoutes().filter(route => !route.parent);\n            // reset match state to false\n            routes.forEach(resetMatchStateOnRouteRecord);\n            // apply a match state if there is a payload\n            if (payload.filter) {\n                routes = routes.filter(route => \n                // save matches state based on the payload\n                isRouteMatching(route, payload.filter.toLowerCase()));\n            }\n            // mark active routes\n            routes.forEach(route => markRouteRecordActive(route, router.currentRoute.value));\n            payload.rootNodes = routes.map(formatRouteRecordForInspector);\n        }\n        let activeRoutesPayload;\n        api.on.getInspectorTree(payload => {\n            activeRoutesPayload = payload;\n            if (payload.app === app && payload.inspectorId === routerInspectorId) {\n                refreshRoutesView();\n            }\n        });\n        /**\n         * Display information about the currently selected route record\n         */\n        api.on.getInspectorState(payload => {\n            if (payload.app === app && payload.inspectorId === routerInspectorId) {\n                const routes = matcher.getRoutes();\n                const route = routes.find(route => route.record.__vd_id === payload.nodeId);\n                if (route) {\n                    payload.state = {\n                        options: formatRouteRecordMatcherForStateInspector(route),\n                    };\n                }\n            }\n        });\n        api.sendInspectorTree(routerInspectorId);\n        api.sendInspectorState(routerInspectorId);\n    });\n}\nfunction modifierForKey(key) {\n    if (key.optional) {\n        return key.repeatable ? \'*\' : \'?\';\n    }\n    else {\n        return key.repeatable ? \'+\' : \'\';\n    }\n}\nfunction formatRouteRecordMatcherForStateInspector(route) {\n    const { record } = route;\n    const fields = [\n        { editable: false, key: \'path\', value: record.path },\n    ];\n    if (record.name != null) {\n        fields.push({\n            editable: false,\n            key: \'name\',\n            value: record.name,\n        });\n    }\n    fields.push({ editable: false, key: \'regexp\', value: route.re });\n    if (route.keys.length) {\n        fields.push({\n            editable: false,\n            key: \'keys\',\n            value: {\n                _custom: {\n                    type: null,\n                    readOnly: true,\n                    display: route.keys\n                        .map(key => `${key.name}${modifierForKey(key)}`)\n                        .join(\' \'),\n                    tooltip: \'Param keys\',\n                    value: route.keys,\n                },\n            },\n        });\n    }\n    if (record.redirect != null) {\n        fields.push({\n            editable: false,\n            key: \'redirect\',\n            value: record.redirect,\n        });\n    }\n    if (route.alias.length) {\n        fields.push({\n            editable: false,\n            key: \'aliases\',\n            value: route.alias.map(alias => alias.record.path),\n        });\n    }\n    if (Object.keys(route.record.meta).length) {\n        fields.push({\n            editable: false,\n            key: \'meta\',\n            value: route.record.meta,\n        });\n    }\n    fields.push({\n        key: \'score\',\n        editable: false,\n        value: {\n            _custom: {\n                type: null,\n                readOnly: true,\n                display: route.score.map(score => score.join(\', \')).join(\' | \'),\n                tooltip: \'Score used to sort routes\',\n                value: route.score,\n            },\n        },\n    });\n    return fields;\n}\n/**\n * Extracted from tailwind palette\n */\nconst PINK_500 = 0xec4899;\nconst BLUE_600 = 0x2563eb;\nconst LIME_500 = 0x84cc16;\nconst CYAN_400 = 0x22d3ee;\nconst ORANGE_400 = 0xfb923c;\n// const GRAY_100 = 0xf4f4f5\nconst DARK = 0x666666;\nfunction formatRouteRecordForInspector(route) {\n    const tags = [];\n    const { record } = route;\n    if (record.name != null) {\n        tags.push({\n            label: String(record.name),\n            textColor: 0,\n            backgroundColor: CYAN_400,\n        });\n    }\n    if (record.aliasOf) {\n        tags.push({\n            label: \'alias\',\n            textColor: 0,\n            backgroundColor: ORANGE_400,\n        });\n    }\n    if (route.__vd_match) {\n        tags.push({\n            label: \'matches\',\n            textColor: 0,\n            backgroundColor: PINK_500,\n        });\n    }\n    if (route.__vd_exactActive) {\n        tags.push({\n            label: \'exact\',\n            textColor: 0,\n            backgroundColor: LIME_500,\n        });\n    }\n    if (route.__vd_active) {\n        tags.push({\n            label: \'active\',\n            textColor: 0,\n            backgroundColor: BLUE_600,\n        });\n    }\n    if (record.redirect) {\n        tags.push({\n            label: typeof record.redirect === \'string\'\n                ? `redirect: ${record.redirect}`\n                : \'redirects\',\n            textColor: 0xffffff,\n            backgroundColor: DARK,\n        });\n    }\n    // add an id to be able to select it. Using the `path` is not possible because\n    // empty path children would collide with their parents\n    let id = record.__vd_id;\n    if (id == null) {\n        id = String(routeRecordId++);\n        record.__vd_id = id;\n    }\n    return {\n        id,\n        label: record.path,\n        tags,\n        children: route.children.map(formatRouteRecordForInspector),\n    };\n}\n//  incremental id for route records and inspector state\nlet routeRecordId = 0;\nconst EXTRACT_REGEXP_RE = /^\\/(.*)\\/([a-z]*)$/;\nfunction markRouteRecordActive(route, currentRoute) {\n    // no route will be active if matched is empty\n    // reset the matching state\n    const isExactActive = currentRoute.matched.length &&\n        isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);\n    route.__vd_exactActive = route.__vd_active = isExactActive;\n    if (!isExactActive) {\n        route.__vd_active = currentRoute.matched.some(match => isSameRouteRecord(match, route.record));\n    }\n    route.children.forEach(childRoute => markRouteRecordActive(childRoute, currentRoute));\n}\nfunction resetMatchStateOnRouteRecord(route) {\n    route.__vd_match = false;\n    route.children.forEach(resetMatchStateOnRouteRecord);\n}\nfunction isRouteMatching(route, filter) {\n    const found = String(route.re).match(EXTRACT_REGEXP_RE);\n    route.__vd_match = false;\n    if (!found || found.length < 3) {\n        return false;\n    }\n    // use a regexp without $ at the end to match nested routes better\n    const nonEndingRE = new RegExp(found[1].replace(/\\$$/, \'\'), found[2]);\n    if (nonEndingRE.test(filter)) {\n        // mark children as matches\n        route.children.forEach(child => isRouteMatching(child, filter));\n        // exception case: `/`\n        if (route.record.path !== \'/\' || filter === \'/\') {\n            route.__vd_match = route.re.test(filter);\n            return true;\n        }\n        // hide the / route\n        return false;\n    }\n    const path = route.record.path.toLowerCase();\n    const decodedPath = decode(path);\n    // also allow partial matching on the path\n    if (!filter.startsWith(\'/\') &&\n        (decodedPath.includes(filter) || path.includes(filter)))\n        return true;\n    if (decodedPath.startsWith(filter) || path.startsWith(filter))\n        return true;\n    if (route.record.name && String(route.record.name).includes(filter))\n        return true;\n    return route.children.some(child => isRouteMatching(child, filter));\n}\nfunction omit(obj, keys) {\n    const ret = {};\n    for (const key in obj) {\n        if (!keys.includes(key)) {\n            // @ts-expect-error\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n}\n\n/**\n * Creates a Router instance that can be used by a Vue app.\n *\n * @param options - {@link RouterOptions}\n */\nfunction createRouter(options) {\n    const matcher = createRouterMatcher(options.routes, options);\n    const parseQuery$1 = options.parseQuery || parseQuery;\n    const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;\n    const routerHistory = options.history;\n    if (false)\n        {}\n    const beforeGuards = useCallbacks();\n    const beforeResolveGuards = useCallbacks();\n    const afterGuards = useCallbacks();\n    const currentRoute = shallowRef(START_LOCATION_NORMALIZED);\n    let pendingLocation = START_LOCATION_NORMALIZED;\n    // leave the scrollRestoration if no scrollBehavior is provided\n    if (isBrowser && options.scrollBehavior && \'scrollRestoration\' in history) {\n        history.scrollRestoration = \'manual\';\n    }\n    const normalizeParams = applyToParams.bind(null, paramValue => \'\' + paramValue);\n    const encodeParams = applyToParams.bind(null, encodeParam);\n    const decodeParams = \n    // @ts-expect-error: intentionally avoid the type check\n    applyToParams.bind(null, decode);\n    function addRoute(parentOrRoute, route) {\n        let parent;\n        let record;\n        if (isRouteName(parentOrRoute)) {\n            parent = matcher.getRecordMatcher(parentOrRoute);\n            record = route;\n        }\n        else {\n            record = parentOrRoute;\n        }\n        return matcher.addRoute(record, parent);\n    }\n    function removeRoute(name) {\n        const recordMatcher = matcher.getRecordMatcher(name);\n        if (recordMatcher) {\n            matcher.removeRoute(recordMatcher);\n        }\n        else if ((false)) {}\n    }\n    function getRoutes() {\n        return matcher.getRoutes().map(routeMatcher => routeMatcher.record);\n    }\n    function hasRoute(name) {\n        return !!matcher.getRecordMatcher(name);\n    }\n    function resolve(rawLocation, currentLocation) {\n        // const objectLocation = routerLocationAsObject(rawLocation)\n        // we create a copy to modify it later\n        currentLocation = vue_router_assign({}, currentLocation || currentRoute.value);\n        if (typeof rawLocation === \'string\') {\n            const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);\n            const matchedRoute = matcher.resolve({ path: locationNormalized.path }, currentLocation);\n            const href = routerHistory.createHref(locationNormalized.fullPath);\n            if ((false)) {}\n            // locationNormalized is always a new object\n            return vue_router_assign(locationNormalized, matchedRoute, {\n                params: decodeParams(matchedRoute.params),\n                hash: decode(locationNormalized.hash),\n                redirectedFrom: undefined,\n                href,\n            });\n        }\n        let matcherLocation;\n        // path could be relative in object as well\n        if (\'path\' in rawLocation) {\n            if (false) {}\n            matcherLocation = vue_router_assign({}, rawLocation, {\n                path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path,\n            });\n        }\n        else {\n            // remove any nullish param\n            const targetParams = vue_router_assign({}, rawLocation.params);\n            for (const key in targetParams) {\n                if (targetParams[key] == null) {\n                    delete targetParams[key];\n                }\n            }\n            // pass encoded values to the matcher, so it can produce encoded path and fullPath\n            matcherLocation = vue_router_assign({}, rawLocation, {\n                params: encodeParams(targetParams),\n            });\n            // current location params are decoded, we need to encode them in case the\n            // matcher merges the params\n            currentLocation.params = encodeParams(currentLocation.params);\n        }\n        const matchedRoute = matcher.resolve(matcherLocation, currentLocation);\n        const hash = rawLocation.hash || \'\';\n        if (false) {}\n        // the matcher might have merged current location params, so\n        // we need to run the decoding again\n        matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));\n        const fullPath = stringifyURL(stringifyQuery$1, vue_router_assign({}, rawLocation, {\n            hash: encodeHash(hash),\n            path: matchedRoute.path,\n        }));\n        const href = routerHistory.createHref(fullPath);\n        if ((false)) {}\n        return vue_router_assign({\n            fullPath,\n            // keep the hash encoded so fullPath is effectively path + encodedQuery +\n            // hash\n            hash,\n            query: \n            // if the user is using a custom query lib like qs, we might have\n            // nested objects, so we keep the query as is, meaning it can contain\n            // numbers at `$route.query`, but at the point, the user will have to\n            // use their own type anyway.\n            // https://github.com/vuejs/router/issues/328#issuecomment-649481567\n            stringifyQuery$1 === stringifyQuery\n                ? normalizeQuery(rawLocation.query)\n                : (rawLocation.query || {}),\n        }, matchedRoute, {\n            redirectedFrom: undefined,\n            href,\n        });\n    }\n    function locationAsObject(to) {\n        return typeof to === \'string\'\n            ? parseURL(parseQuery$1, to, currentRoute.value.path)\n            : vue_router_assign({}, to);\n    }\n    function checkCanceledNavigation(to, from) {\n        if (pendingLocation !== to) {\n            return createRouterError(8 /* ErrorTypes.NAVIGATION_CANCELLED */, {\n                from,\n                to,\n            });\n        }\n    }\n    function push(to) {\n        return pushWithRedirect(to);\n    }\n    function replace(to) {\n        return push(vue_router_assign(locationAsObject(to), { replace: true }));\n    }\n    function handleRedirectRecord(to) {\n        const lastMatched = to.matched[to.matched.length - 1];\n        if (lastMatched && lastMatched.redirect) {\n            const { redirect } = lastMatched;\n            let newTargetLocation = typeof redirect === \'function\' ? redirect(to) : redirect;\n            if (typeof newTargetLocation === \'string\') {\n                newTargetLocation =\n                    newTargetLocation.includes(\'?\') || newTargetLocation.includes(\'#\')\n                        ? (newTargetLocation = locationAsObject(newTargetLocation))\n                        : // force empty params\n                            { path: newTargetLocation };\n                // @ts-expect-error: force empty params when a string is passed to let\n                // the router parse them again\n                newTargetLocation.params = {};\n            }\n            if (false) {}\n            return vue_router_assign({\n                query: to.query,\n                hash: to.hash,\n                // avoid transferring params if the redirect has a path\n                params: \'path\' in newTargetLocation ? {} : to.params,\n            }, newTargetLocation);\n        }\n    }\n    function pushWithRedirect(to, redirectedFrom) {\n        const targetLocation = (pendingLocation = resolve(to));\n        const from = currentRoute.value;\n        const data = to.state;\n        const force = to.force;\n        // to could be a string where `replace` is a function\n        const replace = to.replace === true;\n        const shouldRedirect = handleRedirectRecord(targetLocation);\n        if (shouldRedirect)\n            return pushWithRedirect(vue_router_assign(locationAsObject(shouldRedirect), {\n                state: typeof shouldRedirect === \'object\'\n                    ? vue_router_assign({}, data, shouldRedirect.state)\n                    : data,\n                force,\n                replace,\n            }), \n            // keep original redirectedFrom if it exists\n            redirectedFrom || targetLocation);\n        // if it was a redirect we already called `pushWithRedirect` above\n        const toLocation = targetLocation;\n        toLocation.redirectedFrom = redirectedFrom;\n        let failure;\n        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {\n            failure = createRouterError(16 /* ErrorTypes.NAVIGATION_DUPLICATED */, { to: toLocation, from });\n            // trigger scroll to allow scrolling to the same anchor\n            handleScroll(from, from, \n            // this is a push, the only way for it to be triggered from a\n            // history.listen is with a redirect, which makes it become a push\n            true, \n            // This cannot be the first navigation because the initial location\n            // cannot be manually navigated to\n            false);\n        }\n        return (failure ? Promise.resolve(failure) : navigate(toLocation, from))\n            .catch((error) => isNavigationFailure(error)\n            ? // navigation redirects still mark the router as ready\n                isNavigationFailure(error, 2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */)\n                    ? error\n                    : markAsReady(error) // also returns the error\n            : // reject any unknown error\n                triggerError(error, toLocation, from))\n            .then((failure) => {\n            if (failure) {\n                if (isNavigationFailure(failure, 2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */)) {\n                    if (false) {}\n                    return pushWithRedirect(\n                    // keep options\n                    vue_router_assign({\n                        // preserve an existing replacement but allow the redirect to override it\n                        replace,\n                    }, locationAsObject(failure.to), {\n                        state: typeof failure.to === \'object\'\n                            ? vue_router_assign({}, data, failure.to.state)\n                            : data,\n                        force,\n                    }), \n                    // preserve the original redirectedFrom if any\n                    redirectedFrom || toLocation);\n                }\n            }\n            else {\n                // if we fail we don\'t finalize the navigation\n                failure = finalizeNavigation(toLocation, from, true, replace, data);\n            }\n            triggerAfterEach(toLocation, from, failure);\n            return failure;\n        });\n    }\n    /**\n     * Helper to reject and skip all navigation guards if a new navigation happened\n     * @param to\n     * @param from\n     */\n    function checkCanceledNavigationAndReject(to, from) {\n        const error = checkCanceledNavigation(to, from);\n        return error ? Promise.reject(error) : Promise.resolve();\n    }\n    function runWithContext(fn) {\n        const app = installedApps.values().next().value;\n        // support Vue < 3.3\n        return app && typeof app.runWithContext === \'function\'\n            ? app.runWithContext(fn)\n            : fn();\n    }\n    // TODO: refactor the whole before guards by internally using router.beforeEach\n    function navigate(to, from) {\n        let guards;\n        const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);\n        // all components here have been resolved once because we are leaving\n        guards = extractComponentsGuards(leavingRecords.reverse(), \'beforeRouteLeave\', to, from);\n        // leavingRecords is already reversed\n        for (const record of leavingRecords) {\n            record.leaveGuards.forEach(guard => {\n                guards.push(guardToPromiseFn(guard, to, from));\n            });\n        }\n        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);\n        guards.push(canceledNavigationCheck);\n        // run the queue of per route beforeRouteLeave guards\n        return (runGuardQueue(guards)\n            .then(() => {\n            // check global guards beforeEach\n            guards = [];\n            for (const guard of beforeGuards.list()) {\n                guards.push(guardToPromiseFn(guard, to, from));\n            }\n            guards.push(canceledNavigationCheck);\n            return runGuardQueue(guards);\n        })\n            .then(() => {\n            // check in components beforeRouteUpdate\n            guards = extractComponentsGuards(updatingRecords, \'beforeRouteUpdate\', to, from);\n            for (const record of updatingRecords) {\n                record.updateGuards.forEach(guard => {\n                    guards.push(guardToPromiseFn(guard, to, from));\n                });\n            }\n            guards.push(canceledNavigationCheck);\n            // run the queue of per route beforeEnter guards\n            return runGuardQueue(guards);\n        })\n            .then(() => {\n            // check the route beforeEnter\n            guards = [];\n            for (const record of enteringRecords) {\n                // do not trigger beforeEnter on reused views\n                if (record.beforeEnter) {\n                    if (vue_router_isArray(record.beforeEnter)) {\n                        for (const beforeEnter of record.beforeEnter)\n                            guards.push(guardToPromiseFn(beforeEnter, to, from));\n                    }\n                    else {\n                        guards.push(guardToPromiseFn(record.beforeEnter, to, from));\n                    }\n                }\n            }\n            guards.push(canceledNavigationCheck);\n            // run the queue of per route beforeEnter guards\n            return runGuardQueue(guards);\n        })\n            .then(() => {\n            // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>\n            // clear existing enterCallbacks, these are added by extractComponentsGuards\n            to.matched.forEach(record => (record.enterCallbacks = {}));\n            // check in-component beforeRouteEnter\n            guards = extractComponentsGuards(enteringRecords, \'beforeRouteEnter\', to, from);\n            guards.push(canceledNavigationCheck);\n            // run the queue of per route beforeEnter guards\n            return runGuardQueue(guards);\n        })\n            .then(() => {\n            // check global guards beforeResolve\n            guards = [];\n            for (const guard of beforeResolveGuards.list()) {\n                guards.push(guardToPromiseFn(guard, to, from));\n            }\n            guards.push(canceledNavigationCheck);\n            return runGuardQueue(guards);\n        })\n            // catch any navigation canceled\n            .catch(err => isNavigationFailure(err, 8 /* ErrorTypes.NAVIGATION_CANCELLED */)\n            ? err\n            : Promise.reject(err)));\n    }\n    function triggerAfterEach(to, from, failure) {\n        // navigation is confirmed, call afterGuards\n        // TODO: wrap with error handlers\n        afterGuards\n            .list()\n            .forEach(guard => runWithContext(() => guard(to, from, failure)));\n    }\n    /**\n     * - Cleans up any navigation guards\n     * - Changes the url if necessary\n     * - Calls the scrollBehavior\n     */\n    function finalizeNavigation(toLocation, from, isPush, replace, data) {\n        // a more recent navigation took place\n        const error = checkCanceledNavigation(toLocation, from);\n        if (error)\n            return error;\n        // only consider as push if it\'s not the first navigation\n        const isFirstNavigation = from === START_LOCATION_NORMALIZED;\n        const state = !isBrowser ? {} : history.state;\n        // change URL only if the user did a push/replace and if it\'s not the initial navigation because\n        // it\'s just reflecting the url\n        if (isPush) {\n            // on the initial navigation, we want to reuse the scroll position from\n            // history state if it exists\n            if (replace || isFirstNavigation)\n                routerHistory.replace(toLocation.fullPath, vue_router_assign({\n                    scroll: isFirstNavigation && state && state.scroll,\n                }, data));\n            else\n                routerHistory.push(toLocation.fullPath, data);\n        }\n        // accept current navigation\n        currentRoute.value = toLocation;\n        handleScroll(toLocation, from, isPush, isFirstNavigation);\n        markAsReady();\n    }\n    let removeHistoryListener;\n    // attach listener to history to trigger navigations\n    function setupListeners() {\n        // avoid setting up listeners twice due to an invalid first navigation\n        if (removeHistoryListener)\n            return;\n        removeHistoryListener = routerHistory.listen((to, _from, info) => {\n            if (!router.listening)\n                return;\n            // cannot be a redirect route because it was in history\n            const toLocation = resolve(to);\n            // due to dynamic routing, and to hash history with manual navigation\n            // (manually changing the url or calling history.hash = \'#/somewhere\'),\n            // there could be a redirect record in history\n            const shouldRedirect = handleRedirectRecord(toLocation);\n            if (shouldRedirect) {\n                pushWithRedirect(vue_router_assign(shouldRedirect, { replace: true }), toLocation).catch(noop);\n                return;\n            }\n            pendingLocation = toLocation;\n            const from = currentRoute.value;\n            // TODO: should be moved to web history?\n            if (isBrowser) {\n                saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());\n            }\n            navigate(toLocation, from)\n                .catch((error) => {\n                if (isNavigationFailure(error, 4 /* ErrorTypes.NAVIGATION_ABORTED */ | 8 /* ErrorTypes.NAVIGATION_CANCELLED */)) {\n                    return error;\n                }\n                if (isNavigationFailure(error, 2 /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */)) {\n                    // Here we could call if (info.delta) routerHistory.go(-info.delta,\n                    // false) but this is bug prone as we have no way to wait the\n                    // navigation to be finished before calling pushWithRedirect. Using\n                    // a setTimeout of 16ms seems to work but there is no guarantee for\n                    // it to work on every browser. So instead we do not restore the\n                    // history entry and trigger a new navigation as requested by the\n                    // navigation guard.\n                    // the error is already handled by router.push we just want to avoid\n                    // logging the error\n                    pushWithRedirect(error.to, toLocation\n                    // avoid an uncaught rejection, let push call triggerError\n                    )\n                        .then(failure => {\n                        // manual change in hash history #916 ending up in the URL not\n                        // changing, but it was changed by the manual url change, so we\n                        // need to manually change it ourselves\n                        if (isNavigationFailure(failure, 4 /* ErrorTypes.NAVIGATION_ABORTED */ |\n                            16 /* ErrorTypes.NAVIGATION_DUPLICATED */) &&\n                            !info.delta &&\n                            info.type === NavigationType.pop) {\n                            routerHistory.go(-1, false);\n                        }\n                    })\n                        .catch(noop);\n                    // avoid the then branch\n                    return Promise.reject();\n                }\n                // do not restore history on unknown direction\n                if (info.delta) {\n                    routerHistory.go(-info.delta, false);\n                }\n                // unrecognized error, transfer to the global handler\n                return triggerError(error, toLocation, from);\n            })\n                .then((failure) => {\n                failure =\n                    failure ||\n                        finalizeNavigation(\n                        // after navigation, all matched components are resolved\n                        toLocation, from, false);\n                // revert the navigation\n                if (failure) {\n                    if (info.delta &&\n                        // a new navigation has been triggered, so we do not want to revert, that will change the current history\n                        // entry while a different route is displayed\n                        !isNavigationFailure(failure, 8 /* ErrorTypes.NAVIGATION_CANCELLED */)) {\n                        routerHistory.go(-info.delta, false);\n                    }\n                    else if (info.type === NavigationType.pop &&\n                        isNavigationFailure(failure, 4 /* ErrorTypes.NAVIGATION_ABORTED */ | 16 /* ErrorTypes.NAVIGATION_DUPLICATED */)) {\n                        // manual change in hash history #916\n                        // it\'s like a push but lacks the information of the direction\n                        routerHistory.go(-1, false);\n                    }\n                }\n                triggerAfterEach(toLocation, from, failure);\n            })\n                .catch(noop);\n        });\n    }\n    // Initialization and Errors\n    let readyHandlers = useCallbacks();\n    let errorHandlers = useCallbacks();\n    let ready;\n    /**\n     * Trigger errorHandlers added via onError and throws the error as well\n     *\n     * @param error - error to throw\n     * @param to - location we were navigating to when the error happened\n     * @param from - location we were navigating from when the error happened\n     * @returns the error as a rejected promise\n     */\n    function triggerError(error, to, from) {\n        markAsReady(error);\n        const list = errorHandlers.list();\n        if (list.length) {\n            list.forEach(handler => handler(error, to, from));\n        }\n        else {\n            if ((false)) {}\n            console.error(error);\n        }\n        return Promise.reject(error);\n    }\n    function isReady() {\n        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)\n            return Promise.resolve();\n        return new Promise((resolve, reject) => {\n            readyHandlers.add([resolve, reject]);\n        });\n    }\n    function markAsReady(err) {\n        if (!ready) {\n            // still not ready if an error happened\n            ready = !err;\n            setupListeners();\n            readyHandlers\n                .list()\n                .forEach(([resolve, reject]) => (err ? reject(err) : resolve()));\n            readyHandlers.reset();\n        }\n        return err;\n    }\n    // Scroll behavior\n    function handleScroll(to, from, isPush, isFirstNavigation) {\n        const { scrollBehavior } = options;\n        if (!isBrowser || !scrollBehavior)\n            return Promise.resolve();\n        const scrollPosition = (!isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0))) ||\n            ((isFirstNavigation || !isPush) &&\n                history.state &&\n                history.state.scroll) ||\n            null;\n        return runtime_core_esm_bundler_nextTick()\n            .then(() => scrollBehavior(to, from, scrollPosition))\n            .then(position => position && scrollToPosition(position))\n            .catch(err => triggerError(err, to, from));\n    }\n    const go = (delta) => routerHistory.go(delta);\n    let started;\n    const installedApps = new Set();\n    const router = {\n        currentRoute,\n        listening: true,\n        addRoute,\n        removeRoute,\n        hasRoute,\n        getRoutes,\n        resolve,\n        options,\n        push,\n        replace,\n        go,\n        back: () => go(-1),\n        forward: () => go(1),\n        beforeEach: beforeGuards.add,\n        beforeResolve: beforeResolveGuards.add,\n        afterEach: afterGuards.add,\n        onError: errorHandlers.add,\n        isReady,\n        install(app) {\n            const router = this;\n            app.component(\'RouterLink\', RouterLink);\n            app.component(\'RouterView\', RouterView);\n            app.config.globalProperties.$router = router;\n            Object.defineProperty(app.config.globalProperties, \'$route\', {\n                enumerable: true,\n                get: () => unref(currentRoute),\n            });\n            // this initial navigation is only necessary on client, on server it doesn\'t\n            // make sense because it will create an extra unnecessary navigation and could\n            // lead to problems\n            if (isBrowser &&\n                // used for the initial navigation client side to avoid pushing\n                // multiple times when the router is used in multiple apps\n                !started &&\n                currentRoute.value === START_LOCATION_NORMALIZED) {\n                // see above\n                started = true;\n                push(routerHistory.location).catch(err => {\n                    if ((false))\n                        {}\n                });\n            }\n            const reactiveRoute = {};\n            for (const key in START_LOCATION_NORMALIZED) {\n                Object.defineProperty(reactiveRoute, key, {\n                    get: () => currentRoute.value[key],\n                    enumerable: true,\n                });\n            }\n            app.provide(routerKey, router);\n            app.provide(routeLocationKey, shallowReactive(reactiveRoute));\n            app.provide(routerViewLocationKey, currentRoute);\n            const unmountApp = app.unmount;\n            installedApps.add(app);\n            app.unmount = function () {\n                installedApps.delete(app);\n                // the router is not attached to an app anymore\n                if (installedApps.size < 1) {\n                    // invalidate the current navigation\n                    pendingLocation = START_LOCATION_NORMALIZED;\n                    removeHistoryListener && removeHistoryListener();\n                    removeHistoryListener = null;\n                    currentRoute.value = START_LOCATION_NORMALIZED;\n                    started = false;\n                    ready = false;\n                }\n                unmountApp();\n            };\n            // TODO: this probably needs to be updated so it can be used by vue-termui\n            if ((( false) || __VUE_PROD_DEVTOOLS__) && isBrowser) {\n                addDevtools(app, router, matcher);\n            }\n        },\n    };\n    // TODO: type this as NavigationGuardReturn or similar instead of any\n    function runGuardQueue(guards) {\n        return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());\n    }\n    return router;\n}\nfunction extractChangingRecords(to, from) {\n    const leavingRecords = [];\n    const updatingRecords = [];\n    const enteringRecords = [];\n    const len = Math.max(from.matched.length, to.matched.length);\n    for (let i = 0; i < len; i++) {\n        const recordFrom = from.matched[i];\n        if (recordFrom) {\n            if (to.matched.find(record => isSameRouteRecord(record, recordFrom)))\n                updatingRecords.push(recordFrom);\n            else\n                leavingRecords.push(recordFrom);\n        }\n        const recordTo = to.matched[i];\n        if (recordTo) {\n            // the type doesn\'t matter because we are comparing per reference\n            if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) {\n                enteringRecords.push(recordTo);\n            }\n        }\n    }\n    return [leavingRecords, updatingRecords, enteringRecords];\n}\n\n/**\n * Returns the router instance. Equivalent to using `$router` inside\n * templates.\n */\nfunction useRouter() {\n    return inject(routerKey);\n}\n/**\n * Returns the current route location. Equivalent to using `$route` inside\n * templates.\n */\nfunction useRoute() {\n    return inject(routeLocationKey);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./client/views/pages/main/Main.vue?vue&type=template&id=d4956396&scoped=true\n\nconst _withScopeId = n => (pushScopeId("data-v-d4956396"), n = n(), popScopeId(), n);\nconst _hoisted_1 = {\n  class: "layout"\n};\nconst _hoisted_2 = {\n  class: "sidebar"\n};\nconst _hoisted_3 = /*#__PURE__*/_withScopeId(() => /*#__PURE__*/createBaseVNode("summary", null, "정보보기", -1 /* HOISTED */));\nconst _hoisted_4 = {\n  class: "main-button"\n};\nconst _hoisted_5 = {\n  key: 0\n};\nconst _hoisted_6 = {\n  key: 1,\n  class: "main-button"\n};\nconst _hoisted_7 = {\n  key: 2\n};\nconst _hoisted_8 = {\n  key: 3,\n  class: "main-button"\n};\nconst _hoisted_9 = {\n  key: 4\n};\nconst _hoisted_10 = {\n  key: 5,\n  class: "main-button"\n};\nconst _hoisted_11 = {\n  key: 6\n};\nconst _hoisted_12 = {\n  key: 7,\n  class: "safety-categories"\n};\nconst _hoisted_13 = {\n  key: 8\n};\nconst _hoisted_14 = {\n  key: 9,\n  class: "main-button"\n};\nconst _hoisted_15 = {\n  class: "mapSection",\n  ref: "map"\n};\nconst _hoisted_16 = {\n  key: 0,\n  class: "legend"\n};\nconst _hoisted_17 = /*#__PURE__*/createStaticVNode("<h3 data-v-d4956396>안전지수 범례</h3><div class=\\"legend-item\\" data-v-d4956396><span class=\\"legend-color\\" style=\\"background-color:#1F77B4;\\" data-v-d4956396></span><span class=\\"legend-label\\" data-v-d4956396>1단계</span></div><div class=\\"legend-item\\" data-v-d4956396><span class=\\"legend-color\\" style=\\"background-color:#2CA02C;\\" data-v-d4956396></span><span class=\\"legend-label\\" data-v-d4956396>2단계</span></div><div class=\\"legend-item\\" data-v-d4956396><span class=\\"legend-color\\" style=\\"background-color:#FFD700;\\" data-v-d4956396></span><span class=\\"legend-label\\" data-v-d4956396>3단계</span></div><div class=\\"legend-item\\" data-v-d4956396><span class=\\"legend-color\\" style=\\"background-color:#FFA500;\\" data-v-d4956396></span><span class=\\"legend-label\\" data-v-d4956396>4단계</span></div><div class=\\"legend-item\\" data-v-d4956396><span class=\\"legend-color\\" style=\\"background-color:#FF0000;\\" data-v-d4956396></span><span class=\\"legend-label\\" data-v-d4956396>5단계</span></div><div data-v-d4956396>* 높을수록 위험</div>", 7);\nconst _hoisted_24 = [_hoisted_17];\nfunction Mainvue_type_template_id_d4956396_scoped_true_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, null, [createBaseVNode("section", _hoisted_1, [createBaseVNode("div", _hoisted_2, [createBaseVNode("details", null, [_hoisted_3, createBaseVNode("section", _hoisted_4, [createBaseVNode("button", {\n    onClick: _cache[0] || (_cache[0] = $event => $options.toggleCircle(\'population\'))\n  }, "인구"), createBaseVNode("button", {\n    onClick: _cache[1] || (_cache[1] = $event => $options.toggleCircle(\'welfare\'))\n  }, "복지(공공센터)"), createBaseVNode("button", {\n    onClick: _cache[2] || (_cache[2] = $event => $options.toggleCircle(\'safety\'))\n  }, "안전(안전지수)"), createBaseVNode("button", {\n    onClick: _cache[3] || (_cache[3] = $event => $options.toggleCircle(\'environment\'))\n  }, "환경")])]), $data.sectionOption === \'population\' ? (openBlock(), createElementBlock("summary", _hoisted_5, "지역별 인구분포 보기")) : createCommentVNode("v-if", true), $data.sectionOption === \'population\' ? (openBlock(), createElementBlock("section", _hoisted_6, [createBaseVNode("button", {\n    onClick: _cache[4] || (_cache[4] = $event => $options.filterPopulation(\'북구\'))\n  }, "북구"), createBaseVNode("button", {\n    onClick: _cache[5] || (_cache[5] = $event => $options.filterPopulation(\'중구\'))\n  }, "중구"), createBaseVNode("button", {\n    onClick: _cache[6] || (_cache[6] = $event => $options.filterPopulation(\'남구\'))\n  }, "남구"), createBaseVNode("button", {\n    onClick: _cache[7] || (_cache[7] = $event => $options.filterPopulation(\'동구\'))\n  }, "동구"), createBaseVNode("button", {\n    onClick: _cache[8] || (_cache[8] = $event => $options.filterPopulation(\'서구\'))\n  }, "서구"), createBaseVNode("button", {\n    onClick: _cache[9] || (_cache[9] = $event => $options.filterPopulation(\'수성구\'))\n  }, "수성구"), createBaseVNode("button", {\n    onClick: _cache[10] || (_cache[10] = $event => $options.filterPopulation(\'달서구\'))\n  }, "달서구"), createBaseVNode("button", {\n    onClick: _cache[11] || (_cache[11] = $event => $options.filterPopulation(\'달성군\'))\n  }, "달성군")])) : createCommentVNode("v-if", true), $data.sectionOption === \'welfare\' ? (openBlock(), createElementBlock("summary", _hoisted_7, "지역별 공공센터 보기")) : createCommentVNode("v-if", true), $data.sectionOption === \'welfare\' ? (openBlock(), createElementBlock("section", _hoisted_8, [createBaseVNode("button", {\n    onClick: _cache[12] || (_cache[12] = $event => $options.filterDistrict(\'북구\'))\n  }, "북구"), createBaseVNode("button", {\n    onClick: _cache[13] || (_cache[13] = $event => $options.filterDistrict(\'중구\'))\n  }, "중구"), createBaseVNode("button", {\n    onClick: _cache[14] || (_cache[14] = $event => $options.filterDistrict(\'남구\'))\n  }, "남구"), createBaseVNode("button", {\n    onClick: _cache[15] || (_cache[15] = $event => $options.filterDistrict(\'동구\'))\n  }, "동구"), createBaseVNode("button", {\n    onClick: _cache[16] || (_cache[16] = $event => $options.filterDistrict(\'서구\'))\n  }, "서구"), createBaseVNode("button", {\n    onClick: _cache[17] || (_cache[17] = $event => $options.filterDistrict(\'수성구\'))\n  }, "수성구"), createBaseVNode("button", {\n    onClick: _cache[18] || (_cache[18] = $event => $options.filterDistrict(\'달서구\'))\n  }, "달서구"), createBaseVNode("button", {\n    onClick: _cache[19] || (_cache[19] = $event => $options.filterDistrict(\'달성군\'))\n  }, "달성군")])) : createCommentVNode("v-if", true), $data.sectionOption === \'safety\' ? (openBlock(), createElementBlock("summary", _hoisted_9, "지역별 안전정보 보기")) : createCommentVNode("v-if", true), $data.sectionOption === \'safety\' ? (openBlock(), createElementBlock("section", _hoisted_10, [createBaseVNode("button", {\n    onClick: _cache[20] || (_cache[20] = $event => $options.filterSafety(\'북구\'))\n  }, "북구"), createBaseVNode("button", {\n    onClick: _cache[21] || (_cache[21] = $event => $options.filterSafety(\'중구\'))\n  }, "중구"), createBaseVNode("button", {\n    onClick: _cache[22] || (_cache[22] = $event => $options.filterSafety(\'남구\'))\n  }, "남구"), createBaseVNode("button", {\n    onClick: _cache[23] || (_cache[23] = $event => $options.filterSafety(\'동구\'))\n  }, "동구"), createBaseVNode("button", {\n    onClick: _cache[24] || (_cache[24] = $event => $options.filterSafety(\'서구\'))\n  }, "서구"), createBaseVNode("button", {\n    onClick: _cache[25] || (_cache[25] = $event => $options.filterSafety(\'수성구\'))\n  }, "수성구"), createBaseVNode("button", {\n    onClick: _cache[26] || (_cache[26] = $event => $options.filterSafety(\'달서구\'))\n  }, "달서구"), createBaseVNode("button", {\n    onClick: _cache[27] || (_cache[27] = $event => $options.filterSafety(\'달성군\'))\n  }, "달성군")])) : createCommentVNode("v-if", true), $data.sectionOption === \'safety\' && $data.safetyDistrict ? (openBlock(), createElementBlock("summary", _hoisted_11, "카테고리별 안전지수 보기")) : createCommentVNode("v-if", true), $data.sectionOption === \'safety\' && $data.safetyDistrict ? (openBlock(), createElementBlock("section", _hoisted_12, [createBaseVNode("button", {\n    onClick: _cache[28] || (_cache[28] = $event => $options.filterSafetyCategory(\'safety_traffic\'))\n  }, "교통사고"), createBaseVNode("button", {\n    onClick: _cache[29] || (_cache[29] = $event => $options.filterSafetyCategory(\'safety_fire\'))\n  }, "화재"), createBaseVNode("button", {\n    onClick: _cache[30] || (_cache[30] = $event => $options.filterSafetyCategory(\'safety_crime\'))\n  }, "범죄"), createBaseVNode("button", {\n    onClick: _cache[31] || (_cache[31] = $event => $options.filterSafetyCategory(\'safety_life\'))\n  }, "생활안전"), createBaseVNode("button", {\n    onClick: _cache[32] || (_cache[32] = $event => $options.filterSafetyCategory(\'safety_suicide\'))\n  }, "자살"), createBaseVNode("button", {\n    onClick: _cache[33] || (_cache[33] = $event => $options.filterSafetyCategory(\'safety_disease\'))\n  }, "감염병")])) : createCommentVNode("v-if", true), $data.sectionOption === \'environment\' ? (openBlock(), createElementBlock("summary", _hoisted_13, "지역별 환경정보 보기")) : createCommentVNode("v-if", true), $data.sectionOption === \'environment\' ? (openBlock(), createElementBlock("section", _hoisted_14, [createBaseVNode("button", {\n    onClick: _cache[34] || (_cache[34] = $event => $options.filterEnvironment(\'북구\'))\n  }, "북구"), createBaseVNode("button", {\n    onClick: _cache[35] || (_cache[35] = $event => $options.filterEnvironment(\'중구\'))\n  }, "중구"), createBaseVNode("button", {\n    onClick: _cache[36] || (_cache[36] = $event => $options.filterEnvironment(\'남구\'))\n  }, "남구"), createBaseVNode("button", {\n    onClick: _cache[37] || (_cache[37] = $event => $options.filterEnvironment(\'동구\'))\n  }, "동구"), createBaseVNode("button", {\n    onClick: _cache[38] || (_cache[38] = $event => $options.filterEnvironment(\'서구\'))\n  }, "서구"), createBaseVNode("button", {\n    onClick: _cache[39] || (_cache[39] = $event => $options.filterEnvironment(\'수성구\'))\n  }, "수성구"), createBaseVNode("button", {\n    onClick: _cache[40] || (_cache[40] = $event => $options.filterEnvironment(\'달서구\'))\n  }, "달서구"), createBaseVNode("button", {\n    onClick: _cache[41] || (_cache[41] = $event => $options.filterEnvironment(\'달성군\'))\n  }, "달성군")])) : createCommentVNode("v-if", true), createBaseVNode("button", {\n    id: "addBtn",\n    onClick: _cache[42] || (_cache[42] = $event => $options.clearMap())\n  }, "초기화")]), createBaseVNode("div", _hoisted_15, null, 512 /* NEED_PATCH */)]), createCommentVNode(" 안전(안전지수) 버튼을 누르면 표시되는 범례 "), $data.sectionOption === \'safety\' && $data.safetyDistrict ? (openBlock(), createElementBlock("section", _hoisted_16, _hoisted_24)) : createCommentVNode("v-if", true)], 64 /* STABLE_FRAGMENT */);\n}\n;// CONCATENATED MODULE: ./client/views/pages/main/Main.vue?vue&type=template&id=d4956396&scoped=true\n\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/bind.js\n\n\nfunction bind(fn, thisArg) {\n  return function wrap() {\n    return fn.apply(thisArg, arguments);\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/utils.js\n\n\n\n\n// utils is a library of generic helper functions non-specific to axios\n\nconst {\n  toString: utils_toString\n} = Object.prototype;\nconst {\n  getPrototypeOf\n} = Object;\nconst kindOf = (cache => thing => {\n  const str = utils_toString.call(thing);\n  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n})(Object.create(null));\nconst kindOfTest = type => {\n  type = type.toLowerCase();\n  return thing => kindOf(thing) === type;\n};\nconst typeOfTest = type => thing => typeof thing === type;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */\nconst {\n  isArray: utils_isArray\n} = Array;\n\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nconst isUndefined = typeOfTest(\'undefined\');\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && utils_isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nconst isArrayBuffer = kindOfTest(\'ArrayBuffer\');\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  let result;\n  if (typeof ArrayBuffer !== \'undefined\' && ArrayBuffer.isView) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = val && val.buffer && isArrayBuffer(val.buffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */\nconst utils_isString = typeOfTest(\'string\');\n\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nconst utils_isFunction = typeOfTest(\'function\');\n\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */\nconst isNumber = typeOfTest(\'number\');\n\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */\nconst utils_isObject = thing => thing !== null && typeof thing === \'object\';\n\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */\nconst utils_isBoolean = thing => thing === true || thing === false;\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */\nconst utils_isPlainObject = val => {\n  if (kindOf(val) !== \'object\') {\n    return false;\n  }\n  const prototype = getPrototypeOf(val);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);\n};\n\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */\nconst utils_isDate = kindOfTest(\'Date\');\n\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFile = kindOfTest(\'File\');\n\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nconst isBlob = kindOfTest(\'Blob\');\n\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFileList = kindOfTest(\'FileList\');\n\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nconst isStream = val => utils_isObject(val) && utils_isFunction(val.pipe);\n\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nconst isFormData = thing => {\n  let kind;\n  return thing && (typeof FormData === \'function\' && thing instanceof FormData || utils_isFunction(thing.append) && ((kind = kindOf(thing)) === \'formdata\' ||\n  // detect form-data instance\n  kind === \'object\' && utils_isFunction(thing.toString) && thing.toString() === \'[object FormData]\'));\n};\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nconst isURLSearchParams = kindOfTest(\'URLSearchParams\');\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */\nconst trim = str => str.trim ? str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \'\');\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If \'obj\' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Boolean} [allOwnKeys = false]\n * @returns {any}\n */\nfunction forEach(obj, fn, {\n  allOwnKeys = false\n} = {}) {\n  // Don\'t bother if no value provided\n  if (obj === null || typeof obj === \'undefined\') {\n    return;\n  }\n  let i;\n  let l;\n\n  // Force an array if not already something iterable\n  if (typeof obj !== \'object\') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n  if (utils_isArray(obj)) {\n    // Iterate over array values\n    for (i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n    const len = keys.length;\n    let key;\n    for (i = 0; i < len; i++) {\n      key = keys[i];\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n}\nfunction findKey(obj, key) {\n  key = key.toLowerCase();\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let _key;\n  while (i-- > 0) {\n    _key = keys[i];\n    if (key === _key.toLowerCase()) {\n      return _key;\n    }\n  }\n  return null;\n}\nconst _global = (() => {\n  /*eslint no-undef:0*/\n  if (typeof globalThis !== "undefined") return globalThis;\n  return typeof self !== "undefined" ? self : typeof window !== \'undefined\' ? window : global;\n})();\nconst isContextDefined = context => !isUndefined(context) && context !== _global;\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */\nfunction merge( /* obj1, obj2, obj3, ... */\n) {\n  const {\n    caseless\n  } = isContextDefined(this) && this || {};\n  const result = {};\n  const assignValue = (val, key) => {\n    const targetKey = caseless && findKey(result, key) || key;\n    if (utils_isPlainObject(result[targetKey]) && utils_isPlainObject(val)) {\n      result[targetKey] = merge(result[targetKey], val);\n    } else if (utils_isPlainObject(val)) {\n      result[targetKey] = merge({}, val);\n    } else if (utils_isArray(val)) {\n      result[targetKey] = val.slice();\n    } else {\n      result[targetKey] = val;\n    }\n  };\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    arguments[i] && forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Boolean} [allOwnKeys]\n * @returns {Object} The resulting value of object a\n */\nconst utils_extend = (a, b, thisArg, {\n  allOwnKeys\n} = {}) => {\n  forEach(b, (val, key) => {\n    if (thisArg && utils_isFunction(val)) {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  }, {\n    allOwnKeys\n  });\n  return a;\n};\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */\nconst stripBOM = content => {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n};\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */\nconst inherits = (constructor, superConstructor, props, descriptors) => {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  Object.defineProperty(constructor, \'super\', {\n    value: superConstructor.prototype\n  });\n  props && Object.assign(constructor.prototype, props);\n};\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */\nconst toFlatObject = (sourceObj, destObj, filter, propFilter) => {\n  let props;\n  let i;\n  let prop;\n  const merged = {};\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n  return destObj;\n};\n\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */\nconst endsWith = (str, searchString, position) => {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  const lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n};\n\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */\nconst toArray = thing => {\n  if (!thing) return null;\n  if (utils_isArray(thing)) return thing;\n  let i = thing.length;\n  if (!isNumber(i)) return null;\n  const arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n};\n\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */\n// eslint-disable-next-line func-names\nconst isTypedArray = (TypedArray => {\n  // eslint-disable-next-line func-names\n  return thing => {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== \'undefined\' && getPrototypeOf(Uint8Array));\n\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */\nconst forEachEntry = (obj, fn) => {\n  const generator = obj && obj[Symbol.iterator];\n  const iterator = generator.call(obj);\n  let result;\n  while ((result = iterator.next()) && !result.done) {\n    const pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n};\n\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */\nconst matchAll = (regExp, str) => {\n  let matches;\n  const arr = [];\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n  return arr;\n};\n\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\nconst isHTMLForm = kindOfTest(\'HTMLFormElement\');\nconst toCamelCase = str => {\n  return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g, function replacer(m, p1, p2) {\n    return p1.toUpperCase() + p2;\n  });\n};\n\n/* Creating a function that will check if an object has a property. */\nconst utils_hasOwnProperty = (({\n  hasOwnProperty\n}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);\n\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */\nconst utils_isRegExp = kindOfTest(\'RegExp\');\nconst reduceDescriptors = (obj, reducer) => {\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  const reducedDescriptors = {};\n  forEach(descriptors, (descriptor, name) => {\n    if (reducer(descriptor, name, obj) !== false) {\n      reducedDescriptors[name] = descriptor;\n    }\n  });\n  Object.defineProperties(obj, reducedDescriptors);\n};\n\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */\n\nconst freezeMethods = obj => {\n  reduceDescriptors(obj, (descriptor, name) => {\n    // skip restricted props in strict mode\n    if (utils_isFunction(obj) && [\'arguments\', \'caller\', \'callee\'].indexOf(name) !== -1) {\n      return false;\n    }\n    const value = obj[name];\n    if (!utils_isFunction(value)) return;\n    descriptor.enumerable = false;\n    if (\'writable\' in descriptor) {\n      descriptor.writable = false;\n      return;\n    }\n    if (!descriptor.set) {\n      descriptor.set = () => {\n        throw Error(\'Can not rewrite read-only method \\\'\' + name + \'\\\'\');\n      };\n    }\n  });\n};\nconst toObjectSet = (arrayOrString, delimiter) => {\n  const obj = {};\n  const define = arr => {\n    arr.forEach(value => {\n      obj[value] = true;\n    });\n  };\n  utils_isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n  return obj;\n};\nconst utils_noop = () => {};\nconst toFiniteNumber = (value, defaultValue) => {\n  value = +value;\n  return Number.isFinite(value) ? value : defaultValue;\n};\nconst ALPHA = \'abcdefghijklmnopqrstuvwxyz\';\nconst DIGIT = \'0123456789\';\nconst ALPHABET = {\n  DIGIT,\n  ALPHA,\n  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT\n};\nconst generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {\n  let str = \'\';\n  const {\n    length\n  } = alphabet;\n  while (size--) {\n    str += alphabet[Math.random() * length | 0];\n  }\n  return str;\n};\n\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */\nfunction isSpecCompliantForm(thing) {\n  return !!(thing && utils_isFunction(thing.append) && thing[Symbol.toStringTag] === \'FormData\' && thing[Symbol.iterator]);\n}\nconst toJSONObject = obj => {\n  const stack = new Array(10);\n  const visit = (source, i) => {\n    if (utils_isObject(source)) {\n      if (stack.indexOf(source) >= 0) {\n        return;\n      }\n      if (!(\'toJSON\' in source)) {\n        stack[i] = source;\n        const target = utils_isArray(source) ? [] : {};\n        forEach(source, (value, key) => {\n          const reducedValue = visit(value, i + 1);\n          !isUndefined(reducedValue) && (target[key] = reducedValue);\n        });\n        stack[i] = undefined;\n        return target;\n      }\n    }\n    return source;\n  };\n  return visit(obj, 0);\n};\nconst isAsyncFn = kindOfTest(\'AsyncFunction\');\nconst isThenable = thing => thing && (utils_isObject(thing) || utils_isFunction(thing)) && utils_isFunction(thing.then) && utils_isFunction(thing.catch);\n/* harmony default export */ const utils = ({\n  isArray: utils_isArray,\n  isArrayBuffer,\n  isBuffer,\n  isFormData,\n  isArrayBufferView,\n  isString: utils_isString,\n  isNumber,\n  isBoolean: utils_isBoolean,\n  isObject: utils_isObject,\n  isPlainObject: utils_isPlainObject,\n  isUndefined,\n  isDate: utils_isDate,\n  isFile,\n  isBlob,\n  isRegExp: utils_isRegExp,\n  isFunction: utils_isFunction,\n  isStream,\n  isURLSearchParams,\n  isTypedArray,\n  isFileList,\n  forEach,\n  merge,\n  extend: utils_extend,\n  trim,\n  stripBOM,\n  inherits,\n  toFlatObject,\n  kindOf,\n  kindOfTest,\n  endsWith,\n  toArray,\n  forEachEntry,\n  matchAll,\n  isHTMLForm,\n  hasOwnProperty: utils_hasOwnProperty,\n  hasOwnProp: utils_hasOwnProperty,\n  // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors,\n  freezeMethods,\n  toObjectSet,\n  toCamelCase,\n  noop: utils_noop,\n  toFiniteNumber,\n  findKey,\n  global: _global,\n  isContextDefined,\n  ALPHABET,\n  generateString,\n  isSpecCompliantForm,\n  toJSONObject,\n  isAsyncFn,\n  isThenable\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/AxiosError.js\n\n\n\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, \'ECONNABORTED\').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n *\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = new Error().stack;\n  }\n  this.message = message;\n  this.name = \'AxiosError\';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  response && (this.response = response);\n}\nutils.inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: utils.toJSONObject(this.config),\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  }\n});\nconst AxiosError_prototype = AxiosError.prototype;\nconst descriptors = {};\n[\'ERR_BAD_OPTION_VALUE\', \'ERR_BAD_OPTION\', \'ECONNABORTED\', \'ETIMEDOUT\', \'ERR_NETWORK\', \'ERR_FR_TOO_MANY_REDIRECTS\', \'ERR_DEPRECATED\', \'ERR_BAD_RESPONSE\', \'ERR_BAD_REQUEST\', \'ERR_CANCELED\', \'ERR_NOT_SUPPORT\', \'ERR_INVALID_URL\'\n// eslint-disable-next-line func-names\n].forEach(code => {\n  descriptors[code] = {\n    value: code\n  };\n});\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(AxiosError_prototype, \'isAxiosError\', {\n  value: true\n});\n\n// eslint-disable-next-line func-names\nAxiosError.from = (error, code, config, request, response, customProps) => {\n  const axiosError = Object.create(AxiosError_prototype);\n  utils.toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  }, prop => {\n    return prop !== \'isAxiosError\';\n  });\n  AxiosError.call(axiosError, error.message, code, config, request, response);\n  axiosError.cause = error;\n  axiosError.name = error.name;\n  customProps && Object.assign(axiosError, customProps);\n  return axiosError;\n};\n/* harmony default export */ const core_AxiosError = (AxiosError);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/null.js\n// eslint-disable-next-line strict\n/* harmony default export */ const helpers_null = (null);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/toFormData.js\n\n\n\n\n// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored\n\n\n/**\n * Determines if the given thing is a array or js object.\n *\n * @param {string} thing - The object or array to be visited.\n *\n * @returns {boolean}\n */\nfunction isVisitable(thing) {\n  return utils.isPlainObject(thing) || utils.isArray(thing);\n}\n\n/**\n * It removes the brackets from the end of a string\n *\n * @param {string} key - The key of the parameter.\n *\n * @returns {string} the key without the brackets.\n */\nfunction removeBrackets(key) {\n  return utils.endsWith(key, \'[]\') ? key.slice(0, -2) : key;\n}\n\n/**\n * It takes a path, a key, and a boolean, and returns a string\n *\n * @param {string} path - The path to the current key.\n * @param {string} key - The key of the current object being iterated over.\n * @param {string} dots - If true, the key will be rendered with dots instead of brackets.\n *\n * @returns {string} The path to the current key.\n */\nfunction renderKey(path, key, dots) {\n  if (!path) return key;\n  return path.concat(key).map(function each(token, i) {\n    // eslint-disable-next-line no-param-reassign\n    token = removeBrackets(token);\n    return !dots && i ? \'[\' + token + \']\' : token;\n  }).join(dots ? \'.\' : \'\');\n}\n\n/**\n * If the array is an array and none of its elements are visitable, then it\'s a flat array.\n *\n * @param {Array<any>} arr - The array to check\n *\n * @returns {boolean}\n */\nfunction isFlatArray(arr) {\n  return utils.isArray(arr) && !arr.some(isVisitable);\n}\nconst predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {\n  return /^is[A-Z]/.test(prop);\n});\n\n/**\n * Convert a data object to FormData\n *\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n *\n * @returns {Object}\n **/\n\n/**\n * It converts an object into a FormData object\n *\n * @param {Object<any, any>} obj - The object to convert to form data.\n * @param {string} formData - The FormData object to append to.\n * @param {Object<string, any>} options\n *\n * @returns\n */\nfunction toFormData(obj, formData, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError(\'target must be an object\');\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new (helpers_null || FormData)();\n\n  // eslint-disable-next-line no-param-reassign\n  options = utils.toFlatObject(options, {\n    metaTokens: true,\n    dots: false,\n    indexes: false\n  }, false, function defined(option, source) {\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    return !utils.isUndefined(source[option]);\n  });\n  const metaTokens = options.metaTokens;\n  // eslint-disable-next-line no-use-before-define\n  const visitor = options.visitor || defaultVisitor;\n  const dots = options.dots;\n  const indexes = options.indexes;\n  const _Blob = options.Blob || typeof Blob !== \'undefined\' && Blob;\n  const useBlob = _Blob && utils.isSpecCompliantForm(formData);\n  if (!utils.isFunction(visitor)) {\n    throw new TypeError(\'visitor must be a function\');\n  }\n  function convertValue(value) {\n    if (value === null) return \'\';\n    if (utils.isDate(value)) {\n      return value.toISOString();\n    }\n    if (!useBlob && utils.isBlob(value)) {\n      throw new core_AxiosError(\'Blob is not supported. Use a Buffer instead.\');\n    }\n    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {\n      return useBlob && typeof Blob === \'function\' ? new Blob([value]) : Buffer.from(value);\n    }\n    return value;\n  }\n\n  /**\n   * Default visitor.\n   *\n   * @param {*} value\n   * @param {String|Number} key\n   * @param {Array<String|Number>} path\n   * @this {FormData}\n   *\n   * @returns {boolean} return true to visit the each prop of the value recursively\n   */\n  function defaultVisitor(value, key, path) {\n    let arr = value;\n    if (value && !path && typeof value === \'object\') {\n      if (utils.endsWith(key, \'{}\')) {\n        // eslint-disable-next-line no-param-reassign\n        key = metaTokens ? key : key.slice(0, -2);\n        // eslint-disable-next-line no-param-reassign\n        value = JSON.stringify(value);\n      } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key, \'[]\')) && (arr = utils.toArray(value))) {\n        // eslint-disable-next-line no-param-reassign\n        key = removeBrackets(key);\n        arr.forEach(function each(el, index) {\n          !(utils.isUndefined(el) || el === null) && formData.append(\n          // eslint-disable-next-line no-nested-ternary\n          indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + \'[]\', convertValue(el));\n        });\n        return false;\n      }\n    }\n    if (isVisitable(value)) {\n      return true;\n    }\n    formData.append(renderKey(path, key, dots), convertValue(value));\n    return false;\n  }\n  const stack = [];\n  const exposedHelpers = Object.assign(predicates, {\n    defaultVisitor,\n    convertValue,\n    isVisitable\n  });\n  function build(value, path) {\n    if (utils.isUndefined(value)) return;\n    if (stack.indexOf(value) !== -1) {\n      throw Error(\'Circular reference detected in \' + path.join(\'.\'));\n    }\n    stack.push(value);\n    utils.forEach(value, function each(el, key) {\n      const result = !(utils.isUndefined(el) || el === null) && visitor.call(formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers);\n      if (result === true) {\n        build(el, path ? path.concat(key) : [key]);\n      }\n    });\n    stack.pop();\n  }\n  if (!utils.isObject(obj)) {\n    throw new TypeError(\'data must be an object\');\n  }\n  build(obj);\n  return formData;\n}\n/* harmony default export */ const helpers_toFormData = (toFormData);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/AxiosURLSearchParams.js\n\n\n\n\n/**\n * It encodes a string by replacing all characters that are not in the unreserved set with\n * their percent-encoded equivalents\n *\n * @param {string} str - The string to encode.\n *\n * @returns {string} The encoded string.\n */\nfunction encode(str) {\n  const charMap = {\n    \'!\': \'%21\',\n    "\'": \'%27\',\n    \'(\': \'%28\',\n    \')\': \'%29\',\n    \'~\': \'%7E\',\n    \'%20\': \'+\',\n    \'%00\': \'\\x00\'\n  };\n  return encodeURIComponent(str).replace(/[!\'()~]|%20|%00/g, function replacer(match) {\n    return charMap[match];\n  });\n}\n\n/**\n * It takes a params object and converts it to a FormData object\n *\n * @param {Object<string, any>} params - The parameters to be converted to a FormData object.\n * @param {Object<string, any>} options - The options object passed to the Axios constructor.\n *\n * @returns {void}\n */\nfunction AxiosURLSearchParams(params, options) {\n  this._pairs = [];\n  params && helpers_toFormData(params, this, options);\n}\nconst AxiosURLSearchParams_prototype = AxiosURLSearchParams.prototype;\nAxiosURLSearchParams_prototype.append = function append(name, value) {\n  this._pairs.push([name, value]);\n};\nAxiosURLSearchParams_prototype.toString = function toString(encoder) {\n  const _encode = encoder ? function (value) {\n    return encoder.call(this, value, encode);\n  } : encode;\n  return this._pairs.map(function each(pair) {\n    return _encode(pair[0]) + \'=\' + _encode(pair[1]);\n  }, \'\').join(\'&\');\n};\n/* harmony default export */ const helpers_AxiosURLSearchParams = (AxiosURLSearchParams);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/buildURL.js\n\n\n\n\n\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param {string} val The value to be encoded.\n *\n * @returns {string} The encoded value.\n */\nfunction buildURL_encode(val) {\n  return encodeURIComponent(val).replace(/%3A/gi, \':\').replace(/%24/g, \'$\').replace(/%2C/gi, \',\').replace(/%20/g, \'+\').replace(/%5B/gi, \'[\').replace(/%5D/gi, \']\');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?object} options\n *\n * @returns {string} The formatted url\n */\nfunction buildURL(url, params, options) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n  const _encode = options && options.encode || buildURL_encode;\n  const serializeFn = options && options.serialize;\n  let serializedParams;\n  if (serializeFn) {\n    serializedParams = serializeFn(params, options);\n  } else {\n    serializedParams = utils.isURLSearchParams(params) ? params.toString() : new helpers_AxiosURLSearchParams(params, options).toString(_encode);\n  }\n  if (serializedParams) {\n    const hashmarkIndex = url.indexOf("#");\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n    url += (url.indexOf(\'?\') === -1 ? \'?\' : \'&\') + serializedParams;\n  }\n  return url;\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/InterceptorManager.js\n\n\n\nclass InterceptorManager {\n  constructor() {\n    this.handlers = [];\n  }\n\n  /**\n   * Add a new interceptor to the stack\n   *\n   * @param {Function} fulfilled The function to handle `then` for a `Promise`\n   * @param {Function} rejected The function to handle `reject` for a `Promise`\n   *\n   * @return {Number} An ID used to remove interceptor later\n   */\n  use(fulfilled, rejected, options) {\n    this.handlers.push({\n      fulfilled,\n      rejected,\n      synchronous: options ? options.synchronous : false,\n      runWhen: options ? options.runWhen : null\n    });\n    return this.handlers.length - 1;\n  }\n\n  /**\n   * Remove an interceptor from the stack\n   *\n   * @param {Number} id The ID that was returned by `use`\n   *\n   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise\n   */\n  eject(id) {\n    if (this.handlers[id]) {\n      this.handlers[id] = null;\n    }\n  }\n\n  /**\n   * Clear all interceptors from the stack\n   *\n   * @returns {void}\n   */\n  clear() {\n    if (this.handlers) {\n      this.handlers = [];\n    }\n  }\n\n  /**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become `null` calling `eject`.\n   *\n   * @param {Function} fn The function to call for each interceptor\n   *\n   * @returns {void}\n   */\n  forEach(fn) {\n    utils.forEach(this.handlers, function forEachHandler(h) {\n      if (h !== null) {\n        fn(h);\n      }\n    });\n  }\n}\n/* harmony default export */ const core_InterceptorManager = (InterceptorManager);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/defaults/transitional.js\n\n\n/* harmony default export */ const defaults_transitional = ({\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js\n\n\n\n/* harmony default export */ const classes_URLSearchParams = (typeof URLSearchParams !== \'undefined\' ? URLSearchParams : helpers_AxiosURLSearchParams);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/FormData.js\n\n\n/* harmony default export */ const classes_FormData = (typeof FormData !== \'undefined\' ? FormData : null);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/Blob.js\n\n\n/* harmony default export */ const classes_Blob = (typeof Blob !== \'undefined\' ? Blob : null);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/index.js\n\n\n\n\n/**\n * Determine if we\'re running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> \'ReactNative\'\n * nativescript\n *  navigator.product -> \'NativeScript\' or \'NS\'\n *\n * @returns {boolean}\n */\nconst isStandardBrowserEnv = (() => {\n  let product;\n  if (typeof navigator !== \'undefined\' && ((product = navigator.product) === \'ReactNative\' || product === \'NativeScript\' || product === \'NS\')) {\n    return false;\n  }\n  return typeof window !== \'undefined\' && typeof document !== \'undefined\';\n})();\n\n/**\n * Determine if we\'re running in a standard browser webWorker environment\n *\n * Although the `isStandardBrowserEnv` method indicates that\n * `allows axios to run in a web worker`, the WebWorker will still be\n * filtered out due to its judgment standard\n * `typeof window !== \'undefined\' && typeof document !== \'undefined\'`.\n * This leads to a problem when axios post `FormData` in webWorker\n */\nconst isStandardBrowserWebWorkerEnv = (() => {\n  return typeof WorkerGlobalScope !== \'undefined\' &&\n  // eslint-disable-next-line no-undef\n  self instanceof WorkerGlobalScope && typeof self.importScripts === \'function\';\n})();\n/* harmony default export */ const browser = ({\n  isBrowser: true,\n  classes: {\n    URLSearchParams: classes_URLSearchParams,\n    FormData: classes_FormData,\n    Blob: classes_Blob\n  },\n  isStandardBrowserEnv,\n  isStandardBrowserWebWorkerEnv,\n  protocols: [\'http\', \'https\', \'file\', \'blob\', \'url\', \'data\']\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/toURLEncodedForm.js\n\n\n\n\n\nfunction toURLEncodedForm(data, options) {\n  return helpers_toFormData(data, new browser.classes.URLSearchParams(), Object.assign({\n    visitor: function (value, key, path, helpers) {\n      if (browser.isNode && utils.isBuffer(value)) {\n        this.append(key, value.toString(\'base64\'));\n        return false;\n      }\n      return helpers.defaultVisitor.apply(this, arguments);\n    }\n  }, options));\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/formDataToJSON.js\n\n\n\n\n/**\n * It takes a string like `foo[x][y][z]` and returns an array like `[\'foo\', \'x\', \'y\', \'z\']\n *\n * @param {string} name - The name of the property to get.\n *\n * @returns An array of strings.\n */\nfunction parsePropPath(name) {\n  // foo[x][y][z]\n  // foo.x.y.z\n  // foo-x-y-z\n  // foo x y z\n  return utils.matchAll(/\\w+|\\[(\\w*)]/g, name).map(match => {\n    return match[0] === \'[]\' ? \'\' : match[1] || match[0];\n  });\n}\n\n/**\n * Convert an array to an object.\n *\n * @param {Array<any>} arr - The array to convert to an object.\n *\n * @returns An object with the same keys and values as the array.\n */\nfunction arrayToObject(arr) {\n  const obj = {};\n  const keys = Object.keys(arr);\n  let i;\n  const len = keys.length;\n  let key;\n  for (i = 0; i < len; i++) {\n    key = keys[i];\n    obj[key] = arr[key];\n  }\n  return obj;\n}\n\n/**\n * It takes a FormData object and returns a JavaScript object\n *\n * @param {string} formData The FormData object to convert to JSON.\n *\n * @returns {Object<string, any> | null} The converted object.\n */\nfunction formDataToJSON(formData) {\n  function buildPath(path, value, target, index) {\n    let name = path[index++];\n    const isNumericKey = Number.isFinite(+name);\n    const isLast = index >= path.length;\n    name = !name && utils.isArray(target) ? target.length : name;\n    if (isLast) {\n      if (utils.hasOwnProp(target, name)) {\n        target[name] = [target[name], value];\n      } else {\n        target[name] = value;\n      }\n      return !isNumericKey;\n    }\n    if (!target[name] || !utils.isObject(target[name])) {\n      target[name] = [];\n    }\n    const result = buildPath(path, value, target[name], index);\n    if (result && utils.isArray(target[name])) {\n      target[name] = arrayToObject(target[name]);\n    }\n    return !isNumericKey;\n  }\n  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {\n    const obj = {};\n    utils.forEachEntry(formData, (name, value) => {\n      buildPath(parsePropPath(name), value, obj, 0);\n    });\n    return obj;\n  }\n  return null;\n}\n/* harmony default export */ const helpers_formDataToJSON = (formDataToJSON);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/defaults/index.js\n\n\n\n\n\n\n\n\n\nconst DEFAULT_CONTENT_TYPE = {\n  \'Content-Type\': undefined\n};\n\n/**\n * It takes a string, tries to parse it, and if it fails, it returns the stringified version\n * of the input\n *\n * @param {any} rawValue - The value to be stringified.\n * @param {Function} parser - A function that parses a string into a JavaScript object.\n * @param {Function} encoder - A function that takes a value and returns a string.\n *\n * @returns {string} A stringified version of the rawValue.\n */\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== \'SyntaxError\') {\n        throw e;\n      }\n    }\n  }\n  return (encoder || JSON.stringify)(rawValue);\n}\nconst defaults = {\n  transitional: defaults_transitional,\n  adapter: [\'xhr\', \'http\'],\n  transformRequest: [function transformRequest(data, headers) {\n    const contentType = headers.getContentType() || \'\';\n    const hasJSONContentType = contentType.indexOf(\'application/json\') > -1;\n    const isObjectPayload = utils.isObject(data);\n    if (isObjectPayload && utils.isHTMLForm(data)) {\n      data = new FormData(data);\n    }\n    const isFormData = utils.isFormData(data);\n    if (isFormData) {\n      if (!hasJSONContentType) {\n        return data;\n      }\n      return hasJSONContentType ? JSON.stringify(helpers_formDataToJSON(data)) : data;\n    }\n    if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      headers.setContentType(\'application/x-www-form-urlencoded;charset=utf-8\', false);\n      return data.toString();\n    }\n    let isFileList;\n    if (isObjectPayload) {\n      if (contentType.indexOf(\'application/x-www-form-urlencoded\') > -1) {\n        return toURLEncodedForm(data, this.formSerializer).toString();\n      }\n      if ((isFileList = utils.isFileList(data)) || contentType.indexOf(\'multipart/form-data\') > -1) {\n        const _FormData = this.env && this.env.FormData;\n        return helpers_toFormData(isFileList ? {\n          \'files[]\': data\n        } : data, _FormData && new _FormData(), this.formSerializer);\n      }\n    }\n    if (isObjectPayload || hasJSONContentType) {\n      headers.setContentType(\'application/json\', false);\n      return stringifySafely(data);\n    }\n    return data;\n  }],\n  transformResponse: [function transformResponse(data) {\n    const transitional = this.transitional || defaults.transitional;\n    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    const JSONRequested = this.responseType === \'json\';\n    if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {\n      const silentJSONParsing = transitional && transitional.silentJSONParsing;\n      const strictJSONParsing = !silentJSONParsing && JSONRequested;\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === \'SyntaxError\') {\n            throw core_AxiosError.from(e, core_AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          }\n          throw e;\n        }\n      }\n    }\n    return data;\n  }],\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n  xsrfCookieName: \'XSRF-TOKEN\',\n  xsrfHeaderName: \'X-XSRF-TOKEN\',\n  maxContentLength: -1,\n  maxBodyLength: -1,\n  env: {\n    FormData: browser.classes.FormData,\n    Blob: browser.classes.Blob\n  },\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n  headers: {\n    common: {\n      \'Accept\': \'application/json, text/plain, */*\'\n    }\n  }\n};\nutils.forEach([\'delete\', \'get\', \'head\'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\nutils.forEach([\'post\', \'put\', \'patch\'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n/* harmony default export */ const lib_defaults = (defaults);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/parseHeaders.js\n\n\n\n\n// RawAxiosHeaders whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nconst ignoreDuplicateOf = utils.toObjectSet([\'age\', \'authorization\', \'content-length\', \'content-type\', \'etag\', \'expires\', \'from\', \'host\', \'if-modified-since\', \'if-unmodified-since\', \'last-modified\', \'location\', \'max-forwards\', \'proxy-authorization\', \'referer\', \'retry-after\', \'user-agent\']);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} rawHeaders Headers needing to be parsed\n *\n * @returns {Object} Headers parsed into an object\n */\n/* harmony default export */ const parseHeaders = (rawHeaders => {\n  const parsed = {};\n  let key;\n  let val;\n  let i;\n  rawHeaders && rawHeaders.split(\'\\n\').forEach(function parser(line) {\n    i = line.indexOf(\':\');\n    key = line.substring(0, i).trim().toLowerCase();\n    val = line.substring(i + 1).trim();\n    if (!key || parsed[key] && ignoreDuplicateOf[key]) {\n      return;\n    }\n    if (key === \'set-cookie\') {\n      if (parsed[key]) {\n        parsed[key].push(val);\n      } else {\n        parsed[key] = [val];\n      }\n    } else {\n      parsed[key] = parsed[key] ? parsed[key] + \', \' + val : val;\n    }\n  });\n  return parsed;\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/AxiosHeaders.js\n\n\n\n\nconst $internals = Symbol(\'internals\');\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n  return utils.isArray(value) ? value.map(normalizeValue) : String(value);\n}\nfunction parseTokens(str) {\n  const tokens = Object.create(null);\n  const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let match;\n  while (match = tokensRE.exec(str)) {\n    tokens[match[1]] = match[2];\n  }\n  return tokens;\n}\nconst isValidHeaderName = str => /^[-_a-zA-Z0-9^`|~,!#$%&\'*+.]+$/.test(str.trim());\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n  if (utils.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n  if (isHeaderNameFilter) {\n    value = header;\n  }\n  if (!utils.isString(value)) return;\n  if (utils.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n  if (utils.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\nfunction formatHeader(header) {\n  return header.trim().toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str) => {\n    return char.toUpperCase() + str;\n  });\n}\nfunction buildAccessors(obj, header) {\n  const accessorName = utils.toCamelCase(\' \' + header);\n  [\'get\', \'set\', \'has\'].forEach(methodName => {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function (arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\nclass AxiosHeaders {\n  constructor(headers) {\n    headers && this.set(headers);\n  }\n  set(header, valueOrRewrite, rewrite) {\n    const self = this;\n    function setHeader(_value, _header, _rewrite) {\n      const lHeader = normalizeHeader(_header);\n      if (!lHeader) {\n        throw new Error(\'header name must be a non-empty string\');\n      }\n      const key = utils.findKey(self, lHeader);\n      if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) {\n        self[key || _header] = normalizeValue(_value);\n      }\n    }\n    const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));\n    if (utils.isPlainObject(header) || header instanceof this.constructor) {\n      setHeaders(header, valueOrRewrite);\n    } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n      setHeaders(parseHeaders(header), valueOrRewrite);\n    } else {\n      header != null && setHeader(valueOrRewrite, header, rewrite);\n    }\n    return this;\n  }\n  get(header, parser) {\n    header = normalizeHeader(header);\n    if (header) {\n      const key = utils.findKey(this, header);\n      if (key) {\n        const value = this[key];\n        if (!parser) {\n          return value;\n        }\n        if (parser === true) {\n          return parseTokens(value);\n        }\n        if (utils.isFunction(parser)) {\n          return parser.call(this, value, key);\n        }\n        if (utils.isRegExp(parser)) {\n          return parser.exec(value);\n        }\n        throw new TypeError(\'parser must be boolean|regexp|function\');\n      }\n    }\n  }\n  has(header, matcher) {\n    header = normalizeHeader(header);\n    if (header) {\n      const key = utils.findKey(this, header);\n      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n    }\n    return false;\n  }\n  delete(header, matcher) {\n    const self = this;\n    let deleted = false;\n    function deleteHeader(_header) {\n      _header = normalizeHeader(_header);\n      if (_header) {\n        const key = utils.findKey(self, _header);\n        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n          delete self[key];\n          deleted = true;\n        }\n      }\n    }\n    if (utils.isArray(header)) {\n      header.forEach(deleteHeader);\n    } else {\n      deleteHeader(header);\n    }\n    return deleted;\n  }\n  clear(matcher) {\n    const keys = Object.keys(this);\n    let i = keys.length;\n    let deleted = false;\n    while (i--) {\n      const key = keys[i];\n      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n        delete this[key];\n        deleted = true;\n      }\n    }\n    return deleted;\n  }\n  normalize(format) {\n    const self = this;\n    const headers = {};\n    utils.forEach(this, (value, header) => {\n      const key = utils.findKey(headers, header);\n      if (key) {\n        self[key] = normalizeValue(value);\n        delete self[header];\n        return;\n      }\n      const normalized = format ? formatHeader(header) : String(header).trim();\n      if (normalized !== header) {\n        delete self[header];\n      }\n      self[normalized] = normalizeValue(value);\n      headers[normalized] = true;\n    });\n    return this;\n  }\n  concat(...targets) {\n    return this.constructor.concat(this, ...targets);\n  }\n  toJSON(asStrings) {\n    const obj = Object.create(null);\n    utils.forEach(this, (value, header) => {\n      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(\', \') : value);\n    });\n    return obj;\n  }\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n  toString() {\n    return Object.entries(this.toJSON()).map(([header, value]) => header + \': \' + value).join(\'\\n\');\n  }\n  get [Symbol.toStringTag]() {\n    return \'AxiosHeaders\';\n  }\n  static from(thing) {\n    return thing instanceof this ? thing : new this(thing);\n  }\n  static concat(first, ...targets) {\n    const computed = new this(first);\n    targets.forEach(target => computed.set(target));\n    return computed;\n  }\n  static accessor(header) {\n    const internals = this[$internals] = this[$internals] = {\n      accessors: {}\n    };\n    const accessors = internals.accessors;\n    const prototype = this.prototype;\n    function defineAccessor(_header) {\n      const lHeader = normalizeHeader(_header);\n      if (!accessors[lHeader]) {\n        buildAccessors(prototype, _header);\n        accessors[lHeader] = true;\n      }\n    }\n    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n    return this;\n  }\n}\nAxiosHeaders.accessor([\'Content-Type\', \'Content-Length\', \'Accept\', \'Accept-Encoding\', \'User-Agent\', \'Authorization\']);\nutils.freezeMethods(AxiosHeaders.prototype);\nutils.freezeMethods(AxiosHeaders);\n/* harmony default export */ const core_AxiosHeaders = (AxiosHeaders);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/transformData.js\n\n\n\n\n\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Array|Function} fns A single function or Array of functions\n * @param {?Object} response The response object\n *\n * @returns {*} The resulting transformed data\n */\nfunction transformData(fns, response) {\n  const config = this || lib_defaults;\n  const context = response || config;\n  const headers = core_AxiosHeaders.from(context.headers);\n  let data = context.data;\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);\n  });\n  headers.normalize();\n  return data;\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/isCancel.js\n\n\nfunction isCancel(value) {\n  return !!(value && value.__CANCEL__);\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/CanceledError.js\n\n\n\n\n\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n *\n * @returns {CanceledError} The created error.\n */\nfunction CanceledError(message, config, request) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  core_AxiosError.call(this, message == null ? \'canceled\' : message, core_AxiosError.ERR_CANCELED, config, request);\n  this.name = \'CanceledError\';\n}\nutils.inherits(CanceledError, core_AxiosError, {\n  __CANCEL__: true\n});\n/* harmony default export */ const cancel_CanceledError = (CanceledError);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/settle.js\n\n\n\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n *\n * @returns {object} The response.\n */\nfunction settle(resolve, reject, response) {\n  const validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new core_AxiosError(\'Request failed with status code \' + response.status, [core_AxiosError.ERR_BAD_REQUEST, core_AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/cookies.js\n\n\n\n\n/* harmony default export */ const cookies = (browser.isStandardBrowserEnv ?\n// Standard browser envs support document.cookie\nfunction standardBrowserEnv() {\n  return {\n    write: function write(name, value, expires, path, domain, secure) {\n      const cookie = [];\n      cookie.push(name + \'=\' + encodeURIComponent(value));\n      if (utils.isNumber(expires)) {\n        cookie.push(\'expires=\' + new Date(expires).toGMTString());\n      }\n      if (utils.isString(path)) {\n        cookie.push(\'path=\' + path);\n      }\n      if (utils.isString(domain)) {\n        cookie.push(\'domain=\' + domain);\n      }\n      if (secure === true) {\n        cookie.push(\'secure\');\n      }\n      document.cookie = cookie.join(\'; \');\n    },\n    read: function read(name) {\n      const match = document.cookie.match(new RegExp(\'(^|;\\\\s*)(\' + name + \')=([^;]*)\'));\n      return match ? decodeURIComponent(match[3]) : null;\n    },\n    remove: function remove(name) {\n      this.write(name, \'\', Date.now() - 86400000);\n    }\n  };\n}() :\n// Non standard browser env (web workers, react-native) lack needed support.\nfunction nonStandardBrowserEnv() {\n  return {\n    write: function write() {},\n    read: function read() {\n      return null;\n    },\n    remove: function remove() {}\n  };\n}());\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isAbsoluteURL.js\n\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n *\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nfunction isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/combineURLs.js\n\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n *\n * @returns {string} The combined URL\n */\nfunction combineURLs(baseURL, relativeURL) {\n  return relativeURL ? baseURL.replace(/\\/+$/, \'\') + \'/\' + relativeURL.replace(/^\\/+/, \'\') : baseURL;\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/buildFullPath.js\n\n\n\n\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n *\n * @returns {string} The combined full path\n */\nfunction buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isURLSameOrigin.js\n\n\n\n\n/* harmony default export */ const isURLSameOrigin = (browser.isStandardBrowserEnv ?\n// Standard browser envs have full support of the APIs needed to test\n// whether the request URL is of the same origin as current location.\nfunction standardBrowserEnv() {\n  const msie = /(msie|trident)/i.test(navigator.userAgent);\n  const urlParsingNode = document.createElement(\'a\');\n  let originURL;\n\n  /**\n  * Parse a URL to discover it\'s components\n  *\n  * @param {String} url The URL to be parsed\n  * @returns {Object}\n  */\n  function resolveURL(url) {\n    let href = url;\n    if (msie) {\n      // IE needs attribute set twice to normalize properties\n      urlParsingNode.setAttribute(\'href\', href);\n      href = urlParsingNode.href;\n    }\n    urlParsingNode.setAttribute(\'href\', href);\n\n    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n    return {\n      href: urlParsingNode.href,\n      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, \'\') : \'\',\n      host: urlParsingNode.host,\n      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, \'\') : \'\',\n      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, \'\') : \'\',\n      hostname: urlParsingNode.hostname,\n      port: urlParsingNode.port,\n      pathname: urlParsingNode.pathname.charAt(0) === \'/\' ? urlParsingNode.pathname : \'/\' + urlParsingNode.pathname\n    };\n  }\n  originURL = resolveURL(window.location.href);\n\n  /**\n  * Determine if a URL shares the same origin as the current location\n  *\n  * @param {String} requestURL The URL to test\n  * @returns {boolean} True if URL shares the same origin, otherwise false\n  */\n  return function isURLSameOrigin(requestURL) {\n    const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;\n    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;\n  };\n}() :\n// Non standard browser envs (web workers, react-native) lack needed support.\nfunction nonStandardBrowserEnv() {\n  return function isURLSameOrigin() {\n    return true;\n  };\n}());\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/parseProtocol.js\n\n\nfunction parseProtocol(url) {\n  const match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || \'\';\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/speedometer.js\n\n\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  const bytes = new Array(samplesCount);\n  const timestamps = new Array(samplesCount);\n  let head = 0;\n  let tail = 0;\n  let firstSampleTS;\n  min = min !== undefined ? min : 1000;\n  return function push(chunkLength) {\n    const now = Date.now();\n    const startedAt = timestamps[tail];\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n    let i = tail;\n    let bytesCount = 0;\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n    head = (head + 1) % samplesCount;\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n    if (now - firstSampleTS < min) {\n      return;\n    }\n    const passed = startedAt && now - startedAt;\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\n/* harmony default export */ const helpers_speedometer = (speedometer);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/adapters/xhr.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction progressEventReducer(listener, isDownloadStream) {\n  let bytesNotified = 0;\n  const _speedometer = helpers_speedometer(50, 250);\n  return e => {\n    const loaded = e.loaded;\n    const total = e.lengthComputable ? e.total : undefined;\n    const progressBytes = loaded - bytesNotified;\n    const rate = _speedometer(progressBytes);\n    const inRange = loaded <= total;\n    bytesNotified = loaded;\n    const data = {\n      loaded,\n      total,\n      progress: total ? loaded / total : undefined,\n      bytes: progressBytes,\n      rate: rate ? rate : undefined,\n      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,\n      event: e\n    };\n    data[isDownloadStream ? \'download\' : \'upload\'] = true;\n    listener(data);\n  };\n}\nconst isXHRAdapterSupported = typeof XMLHttpRequest !== \'undefined\';\n/* harmony default export */ const xhr = (isXHRAdapterSupported && function (config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    let requestData = config.data;\n    const requestHeaders = core_AxiosHeaders.from(config.headers).normalize();\n    const responseType = config.responseType;\n    let onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n      if (config.signal) {\n        config.signal.removeEventListener(\'abort\', onCanceled);\n      }\n    }\n    if (utils.isFormData(requestData)) {\n      if (browser.isStandardBrowserEnv || browser.isStandardBrowserWebWorkerEnv) {\n        requestHeaders.setContentType(false); // Let the browser set it\n      } else {\n        requestHeaders.setContentType(\'multipart/form-data;\', false); // mobile/desktop app frameworks\n      }\n    }\n\n    let request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      const username = config.auth.username || \'\';\n      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : \'\';\n      requestHeaders.set(\'Authorization\', \'Basic \' + btoa(username + \':\' + password));\n    }\n    const fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      const responseHeaders = core_AxiosHeaders.from(\'getAllResponseHeaders\' in request && request.getAllResponseHeaders());\n      const responseData = !responseType || responseType === \'text\' || responseType === \'json\' ? request.responseText : request.response;\n      const response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      };\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n    if (\'onloadend\' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn\'t get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it\'s a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf(\'file:\') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next \'tick\'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n      reject(new core_AxiosError(\'Request aborted\', core_AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it\'s a network error\n      reject(new core_AxiosError(\'Network Error\', core_AxiosError.ERR_NETWORK, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      let timeoutErrorMessage = config.timeout ? \'timeout of \' + config.timeout + \'ms exceeded\' : \'timeout exceeded\';\n      const transitional = config.transitional || defaults_transitional;\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(new core_AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? core_AxiosError.ETIMEDOUT : core_AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we\'re in a web worker, or react-native.\n    if (browser.isStandardBrowserEnv) {\n      // Add xsrf header\n      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);\n      if (xsrfValue) {\n        requestHeaders.set(config.xsrfHeaderName, xsrfValue);\n      }\n    }\n\n    // Remove Content-Type if data is undefined\n    requestData === undefined && requestHeaders.setContentType(null);\n\n    // Add headers to the request\n    if (\'setRequestHeader\' in request) {\n      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n        request.setRequestHeader(key, val);\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== \'json\') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === \'function\') {\n      request.addEventListener(\'progress\', progressEventReducer(config.onDownloadProgress, true));\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === \'function\' && request.upload) {\n      request.upload.addEventListener(\'progress\', progressEventReducer(config.onUploadProgress));\n    }\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = cancel => {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new cancel_CanceledError(null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener(\'abort\', onCanceled);\n      }\n    }\n    const protocol = parseProtocol(fullPath);\n    if (protocol && browser.protocols.indexOf(protocol) === -1) {\n      reject(new core_AxiosError(\'Unsupported protocol \' + protocol + \':\', core_AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n    // Send the request\n    request.send(requestData || null);\n  });\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/adapters/adapters.js\n\n\n\n\nconst knownAdapters = {\n  http: helpers_null,\n  xhr: xhr\n};\nutils.forEach(knownAdapters, (fn, value) => {\n  if (fn) {\n    try {\n      Object.defineProperty(fn, \'name\', {\n        value\n      });\n    } catch (e) {\n      // eslint-disable-next-line no-empty\n    }\n    Object.defineProperty(fn, \'adapterName\', {\n      value\n    });\n  }\n});\n/* harmony default export */ const adapters = ({\n  getAdapter: adapters => {\n    adapters = utils.isArray(adapters) ? adapters : [adapters];\n    const {\n      length\n    } = adapters;\n    let nameOrAdapter;\n    let adapter;\n    for (let i = 0; i < length; i++) {\n      nameOrAdapter = adapters[i];\n      if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {\n        break;\n      }\n    }\n    if (!adapter) {\n      if (adapter === false) {\n        throw new core_AxiosError(`Adapter ${nameOrAdapter} is not supported by the environment`, \'ERR_NOT_SUPPORT\');\n      }\n      throw new Error(utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter \'${nameOrAdapter}\' is not available in the build` : `Unknown adapter \'${nameOrAdapter}\'`);\n    }\n    if (!utils.isFunction(adapter)) {\n      throw new TypeError(\'adapter is not a function\');\n    }\n    return adapter;\n  },\n  adapters: knownAdapters\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/dispatchRequest.js\n\n\n\n\n\n\n\n\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n *\n * @param {Object} config The config that is to be used for the request\n *\n * @returns {void}\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n  if (config.signal && config.signal.aborted) {\n    throw new cancel_CanceledError(null, config);\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nfunction dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n  config.headers = core_AxiosHeaders.from(config.headers);\n\n  // Transform request data\n  config.data = transformData.call(config, config.transformRequest);\n  if ([\'post\', \'put\', \'patch\'].indexOf(config.method) !== -1) {\n    config.headers.setContentType(\'application/x-www-form-urlencoded\', false);\n  }\n  const adapter = adapters.getAdapter(config.adapter || lib_defaults.adapter);\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(config, config.transformResponse, response);\n    response.headers = core_AxiosHeaders.from(response.headers);\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(config, config.transformResponse, reason.response);\n        reason.response.headers = core_AxiosHeaders.from(reason.response.headers);\n      }\n    }\n    return Promise.reject(reason);\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/mergeConfig.js\n\n\n\n\nconst headersToObject = thing => thing instanceof core_AxiosHeaders ? thing.toJSON() : thing;\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1\n */\nfunction mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  const config = {};\n  function getMergedValue(target, source, caseless) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge.call({\n        caseless\n      }, target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(a, b, caseless) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(a, b, caseless);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a, caseless);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(a, b, prop) {\n    if (prop in config2) {\n      return getMergedValue(a, b);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, a);\n    }\n  }\n  const mergeMap = {\n    url: valueFromConfig2,\n    method: valueFromConfig2,\n    data: valueFromConfig2,\n    baseURL: defaultToConfig2,\n    transformRequest: defaultToConfig2,\n    transformResponse: defaultToConfig2,\n    paramsSerializer: defaultToConfig2,\n    timeout: defaultToConfig2,\n    timeoutMessage: defaultToConfig2,\n    withCredentials: defaultToConfig2,\n    adapter: defaultToConfig2,\n    responseType: defaultToConfig2,\n    xsrfCookieName: defaultToConfig2,\n    xsrfHeaderName: defaultToConfig2,\n    onUploadProgress: defaultToConfig2,\n    onDownloadProgress: defaultToConfig2,\n    decompress: defaultToConfig2,\n    maxContentLength: defaultToConfig2,\n    maxBodyLength: defaultToConfig2,\n    beforeRedirect: defaultToConfig2,\n    transport: defaultToConfig2,\n    httpAgent: defaultToConfig2,\n    httpsAgent: defaultToConfig2,\n    cancelToken: defaultToConfig2,\n    socketPath: defaultToConfig2,\n    responseEncoding: defaultToConfig2,\n    validateStatus: mergeDirectKeys,\n    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)\n  };\n  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {\n    const merge = mergeMap[prop] || mergeDeepProperties;\n    const configValue = merge(config1[prop], config2[prop], prop);\n    utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);\n  });\n  return config;\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/env/data.js\nconst VERSION = "1.4.0";\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/validator.js\n\n\n\n\nconst validators = {};\n\n// eslint-disable-next-line func-names\n[\'object\', \'boolean\', \'number\', \'function\', \'string\', \'symbol\'].forEach((type, i) => {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || \'a\' + (i < 1 ? \'n \' : \' \') + type;\n  };\n});\nconst deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n *\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n *\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return \'[Axios v\' + VERSION + \'] Transitional option \\\'\' + opt + \'\\\'\' + desc + (message ? \'. \' + message : \'\');\n  }\n\n  // eslint-disable-next-line func-names\n  return (value, opt, opts) => {\n    if (validator === false) {\n      throw new core_AxiosError(formatMessage(opt, \' has been removed\' + (version ? \' in \' + version : \'\')), core_AxiosError.ERR_DEPRECATED);\n    }\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(formatMessage(opt, \' has been deprecated since v\' + version + \' and will be removed in the near future\'));\n    }\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object\'s properties type\n *\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n *\n * @returns {object}\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== \'object\') {\n    throw new core_AxiosError(\'options must be an object\', core_AxiosError.ERR_BAD_OPTION_VALUE);\n  }\n  const keys = Object.keys(options);\n  let i = keys.length;\n  while (i-- > 0) {\n    const opt = keys[i];\n    const validator = schema[opt];\n    if (validator) {\n      const value = options[opt];\n      const result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new core_AxiosError(\'option \' + opt + \' must be \' + result, core_AxiosError.ERR_BAD_OPTION_VALUE);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw new core_AxiosError(\'Unknown option \' + opt, core_AxiosError.ERR_BAD_OPTION);\n    }\n  }\n}\n/* harmony default export */ const validator = ({\n  assertOptions,\n  validators\n});\n;// CONCATENATED MODULE: ./node_modules/axios/lib/core/Axios.js\n\n\n\n\n\n\n\n\n\n\nconst Axios_validators = validator.validators;\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios\n */\nclass Axios {\n  constructor(instanceConfig) {\n    this.defaults = instanceConfig;\n    this.interceptors = {\n      request: new core_InterceptorManager(),\n      response: new core_InterceptorManager()\n    };\n  }\n\n  /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */\n  request(configOrUrl, config) {\n    /*eslint no-param-reassign:0*/\n    // Allow for axios(\'example/url\'[, config]) a la fetch API\n    if (typeof configOrUrl === \'string\') {\n      config = config || {};\n      config.url = configOrUrl;\n    } else {\n      config = configOrUrl || {};\n    }\n    config = mergeConfig(this.defaults, config);\n    const {\n      transitional,\n      paramsSerializer,\n      headers\n    } = config;\n    if (transitional !== undefined) {\n      validator.assertOptions(transitional, {\n        silentJSONParsing: Axios_validators.transitional(Axios_validators.boolean),\n        forcedJSONParsing: Axios_validators.transitional(Axios_validators.boolean),\n        clarifyTimeoutError: Axios_validators.transitional(Axios_validators.boolean)\n      }, false);\n    }\n    if (paramsSerializer != null) {\n      if (utils.isFunction(paramsSerializer)) {\n        config.paramsSerializer = {\n          serialize: paramsSerializer\n        };\n      } else {\n        validator.assertOptions(paramsSerializer, {\n          encode: Axios_validators.function,\n          serialize: Axios_validators.function\n        }, true);\n      }\n    }\n\n    // Set config.method\n    config.method = (config.method || this.defaults.method || \'get\').toLowerCase();\n    let contextHeaders;\n\n    // Flatten headers\n    contextHeaders = headers && utils.merge(headers.common, headers[config.method]);\n    contextHeaders && utils.forEach([\'delete\', \'get\', \'head\', \'post\', \'put\', \'patch\', \'common\'], method => {\n      delete headers[method];\n    });\n    config.headers = core_AxiosHeaders.concat(contextHeaders, headers);\n\n    // filter out skipped interceptors\n    const requestInterceptorChain = [];\n    let synchronousRequestInterceptors = true;\n    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n      if (typeof interceptor.runWhen === \'function\' && interceptor.runWhen(config) === false) {\n        return;\n      }\n      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n    });\n    const responseInterceptorChain = [];\n    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n    });\n    let promise;\n    let i = 0;\n    let len;\n    if (!synchronousRequestInterceptors) {\n      const chain = [dispatchRequest.bind(this), undefined];\n      chain.unshift.apply(chain, requestInterceptorChain);\n      chain.push.apply(chain, responseInterceptorChain);\n      len = chain.length;\n      promise = Promise.resolve(config);\n      while (i < len) {\n        promise = promise.then(chain[i++], chain[i++]);\n      }\n      return promise;\n    }\n    len = requestInterceptorChain.length;\n    let newConfig = config;\n    i = 0;\n    while (i < len) {\n      const onFulfilled = requestInterceptorChain[i++];\n      const onRejected = requestInterceptorChain[i++];\n      try {\n        newConfig = onFulfilled(newConfig);\n      } catch (error) {\n        onRejected.call(this, error);\n        break;\n      }\n    }\n    try {\n      promise = dispatchRequest.call(this, newConfig);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n    i = 0;\n    len = responseInterceptorChain.length;\n    while (i < len) {\n      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n    }\n    return promise;\n  }\n  getUri(config) {\n    config = mergeConfig(this.defaults, config);\n    const fullPath = buildFullPath(config.baseURL, config.url);\n    return buildURL(fullPath, config.params, config.paramsSerializer);\n  }\n}\n\n// Provide aliases for supported request methods\nutils.forEach([\'delete\', \'get\', \'head\', \'options\'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function (url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method,\n      url,\n      data: (config || {}).data\n    }));\n  };\n});\nutils.forEach([\'post\', \'put\', \'patch\'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request(mergeConfig(config || {}, {\n        method,\n        headers: isForm ? {\n          \'Content-Type\': \'multipart/form-data\'\n        } : {},\n        url,\n        data\n      }));\n    };\n  }\n  Axios.prototype[method] = generateHTTPMethod();\n  Axios.prototype[method + \'Form\'] = generateHTTPMethod(true);\n});\n/* harmony default export */ const core_Axios = (Axios);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/CancelToken.js\n\n\n\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */\nclass CancelToken {\n  constructor(executor) {\n    if (typeof executor !== \'function\') {\n      throw new TypeError(\'executor must be a function.\');\n    }\n    let resolvePromise;\n    this.promise = new Promise(function promiseExecutor(resolve) {\n      resolvePromise = resolve;\n    });\n    const token = this;\n\n    // eslint-disable-next-line func-names\n    this.promise.then(cancel => {\n      if (!token._listeners) return;\n      let i = token._listeners.length;\n      while (i-- > 0) {\n        token._listeners[i](cancel);\n      }\n      token._listeners = null;\n    });\n\n    // eslint-disable-next-line func-names\n    this.promise.then = onfulfilled => {\n      let _resolve;\n      // eslint-disable-next-line func-names\n      const promise = new Promise(resolve => {\n        token.subscribe(resolve);\n        _resolve = resolve;\n      }).then(onfulfilled);\n      promise.cancel = function reject() {\n        token.unsubscribe(_resolve);\n      };\n      return promise;\n    };\n    executor(function cancel(message, config, request) {\n      if (token.reason) {\n        // Cancellation has already been requested\n        return;\n      }\n      token.reason = new cancel_CanceledError(message, config, request);\n      resolvePromise(token.reason);\n    });\n  }\n\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  throwIfRequested() {\n    if (this.reason) {\n      throw this.reason;\n    }\n  }\n\n  /**\n   * Subscribe to the cancel signal\n   */\n\n  subscribe(listener) {\n    if (this.reason) {\n      listener(this.reason);\n      return;\n    }\n    if (this._listeners) {\n      this._listeners.push(listener);\n    } else {\n      this._listeners = [listener];\n    }\n  }\n\n  /**\n   * Unsubscribe from the cancel signal\n   */\n\n  unsubscribe(listener) {\n    if (!this._listeners) {\n      return;\n    }\n    const index = this._listeners.indexOf(listener);\n    if (index !== -1) {\n      this._listeners.splice(index, 1);\n    }\n  }\n\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n  static source() {\n    let cancel;\n    const token = new CancelToken(function executor(c) {\n      cancel = c;\n    });\n    return {\n      token,\n      cancel\n    };\n  }\n}\n/* harmony default export */ const cancel_CancelToken = (CancelToken);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/spread.js\n\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n *\n * @returns {Function}\n */\nfunction spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isAxiosError.js\n\n\n\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n *\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nfunction isAxiosError(payload) {\n  return utils.isObject(payload) && payload.isAxiosError === true;\n}\n;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/HttpStatusCode.js\nconst HttpStatusCode = {\n  Continue: 100,\n  SwitchingProtocols: 101,\n  Processing: 102,\n  EarlyHints: 103,\n  Ok: 200,\n  Created: 201,\n  Accepted: 202,\n  NonAuthoritativeInformation: 203,\n  NoContent: 204,\n  ResetContent: 205,\n  PartialContent: 206,\n  MultiStatus: 207,\n  AlreadyReported: 208,\n  ImUsed: 226,\n  MultipleChoices: 300,\n  MovedPermanently: 301,\n  Found: 302,\n  SeeOther: 303,\n  NotModified: 304,\n  UseProxy: 305,\n  Unused: 306,\n  TemporaryRedirect: 307,\n  PermanentRedirect: 308,\n  BadRequest: 400,\n  Unauthorized: 401,\n  PaymentRequired: 402,\n  Forbidden: 403,\n  NotFound: 404,\n  MethodNotAllowed: 405,\n  NotAcceptable: 406,\n  ProxyAuthenticationRequired: 407,\n  RequestTimeout: 408,\n  Conflict: 409,\n  Gone: 410,\n  LengthRequired: 411,\n  PreconditionFailed: 412,\n  PayloadTooLarge: 413,\n  UriTooLong: 414,\n  UnsupportedMediaType: 415,\n  RangeNotSatisfiable: 416,\n  ExpectationFailed: 417,\n  ImATeapot: 418,\n  MisdirectedRequest: 421,\n  UnprocessableEntity: 422,\n  Locked: 423,\n  FailedDependency: 424,\n  TooEarly: 425,\n  UpgradeRequired: 426,\n  PreconditionRequired: 428,\n  TooManyRequests: 429,\n  RequestHeaderFieldsTooLarge: 431,\n  UnavailableForLegalReasons: 451,\n  InternalServerError: 500,\n  NotImplemented: 501,\n  BadGateway: 502,\n  ServiceUnavailable: 503,\n  GatewayTimeout: 504,\n  HttpVersionNotSupported: 505,\n  VariantAlsoNegotiates: 506,\n  InsufficientStorage: 507,\n  LoopDetected: 508,\n  NotExtended: 510,\n  NetworkAuthenticationRequired: 511\n};\nObject.entries(HttpStatusCode).forEach(([key, value]) => {\n  HttpStatusCode[value] = key;\n});\n/* harmony default export */ const helpers_HttpStatusCode = (HttpStatusCode);\n;// CONCATENATED MODULE: ./node_modules/axios/lib/axios.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n *\n * @returns {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  const context = new core_Axios(defaultConfig);\n  const instance = bind(core_Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, core_Axios.prototype, context, {\n    allOwnKeys: true\n  });\n\n  // Copy context to instance\n  utils.extend(instance, context, null, {\n    allOwnKeys: true\n  });\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n  return instance;\n}\n\n// Create the default instance to be exported\nconst axios = createInstance(lib_defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = core_Axios;\n\n// Expose Cancel & CancelToken\naxios.CanceledError = cancel_CanceledError;\naxios.CancelToken = cancel_CancelToken;\naxios.isCancel = isCancel;\naxios.VERSION = VERSION;\naxios.toFormData = helpers_toFormData;\n\n// Expose AxiosError class\naxios.AxiosError = core_AxiosError;\n\n// alias for CanceledError for backward compatibility\naxios.Cancel = axios.CanceledError;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = spread;\n\n// Expose isAxiosError\naxios.isAxiosError = isAxiosError;\n\n// Expose mergeConfig\naxios.mergeConfig = mergeConfig;\naxios.AxiosHeaders = core_AxiosHeaders;\naxios.formToJSON = thing => helpers_formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);\naxios.HttpStatusCode = helpers_HttpStatusCode;\naxios.default = axios;\n\n// this module should only have a default export\n/* harmony default export */ const lib_axios = (axios);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./client/views/pages/main/Main.vue?vue&type=script&lang=js\n\n/* harmony default export */ const Mainvue_type_script_lang_js = ({\n  data() {\n    return {\n      mapInstance: null,\n      circles: [],\n      dataList: [],\n      sectionOption: \'\',\n      safetyDistrict: \'\',\n      markers: [{\n        position: new kakao.maps.LatLng(35.82692778, 128.5350639),\n        title: \'달서구\',\n        content: \'<div style="padding: 10px; margin-bottom: 15px"><strong>인구정보</strong><hr><ul><li>행정구역: 대구 달서구</li><li>총 인구 수: 525,768 명</li><li>인구 증감률 : +2.64%</li><li>고령인구 비율 : 18.3%</li></ul></div>\'\n      }, {\n        position: new kakao.maps.LatLng(35.85520833, 128.6328667),\n        title: \'수성구\',\n        content: \'<div style="padding: 10px; margin-bottom: 15px"><strong>인구정보</strong><hr><ul><li>행정구역: 대구 수성구</li><li>총 인구 수: 411,553 명</li><li>인구 증감률 : +0.49%</li><li>고령인구 비율 : 18.7%</li></ul></div>\'\n      }, {\n        position: new kakao.maps.LatLng(35.846, 128.5752),\n        title: \'남구\',\n        content: \'<div style="padding: 10px; margin-bottom: 15px"><strong>인구정보</strong><hr><ul><li>행정구역: 대구 남구</li><li>총 인구 수: 141,519 명</li><li>인구 증감률 : -5.41%</li><li>고령인구 비율 : 26.8%</li></ul></div>\'\n      }, {\n        position: new kakao.maps.LatLng(35.77475029, 128.4313995),\n        title: \'달성군\',\n        content: \'<div style="padding: 10px; margin-bottom: 15px"><strong>인구정보</strong><hr><ul><li>행정구역: 대구 달성군</li><li>총 인구 수: 263,162 명</li><li>인구 증감률 : -2.61%</li><li>고령인구 비율 : 15.8%</li></ul></div>\'\n      }, {\n        position: new kakao.maps.LatLng(35.88682728, 128.6355584),\n        title: \'동구\',\n        content: \'<div style="padding: 10px; margin-bottom: 15px"><strong>인구정보</strong><hr><ul><li>행정구역: 대구 동구</li><li>총 인구 수: 339,530 명</li><li>인구 증감률 : +4.59%</li><li>고령인구 비율 : 22.8%</li></ul></div>\'\n      }, {\n        position: new kakao.maps.LatLng(35.9265, 128.573),\n        title: \'북구\',\n        content: \'<div style="padding: 10px; margin-bottom: 15px"><strong>인구정보</strong><hr><ul><li>행정구역: 대구 북구</li><li>총 인구 수: 430,912 명</li><li>인구 증감률 : +5.71%</li><li>고령인구 비율 : 18.1%</li></ul></div>\'\n      }, {\n        position: new kakao.maps.LatLng(35.87194054, 128.5591601),\n        title: \'서구\',\n        content: \'<div style="padding: 10px; margin-bottom: 15px"><strong>인구정보</strong><hr><ul><li>행정구역: 대구 서구</li><li>총 인구 수: 159,827 명</li><li>인구 증감률 : -4.25%</li><li>고령인구 비율 : 26.7%</li></ul></div>\'\n      }, {\n        position: new kakao.maps.LatLng(35.8673, 128.5937),\n        title: \'중구\',\n        content: \'<div style="padding: 10px; margin-bottom: 15px"><strong>인구정보</strong><hr><ul><li>행정구역: 대구 중구</li><li>총 인구 수: 91,034 명</li><li>인구 증감률 : +4.16%</li><li>고령인구 비율 : 19.1%</li></ul></div>\'\n      }],\n      polygons: {}\n    };\n  },\n  methods: {\n    toggleCircle(itm) {\n      console.log("선택한 값= ", itm);\n      this.sectionOption = itm;\n    },\n    filterPopulation(district) {\n      console.log("필터링할 지역: ", district);\n      const vm = this;\n\n      // markers 배열에서 선택된 지역의 정보 찾기\n      const selectedMarker = vm.markers.find(marker => marker.title === district);\n\n      // 선택된 지역의 정보가 없으면 종료\n      if (!selectedMarker) {\n        console.error(`"${district}" 지역의 정보를 찾을 수 없습니다.`);\n        return;\n      }\n\n      // 선택된 지역의 위치 정보\n      const position = selectedMarker.position;\n\n      // 원 그리기\n      const circleOptions = {\n        center: position,\n        radius: 1500,\n        // 반지름 설정\n        strokeWeight: 1,\n        strokeColor: \'#333\',\n        strokeOpacity: 0.7,\n        fillColor: \'#1F77B4\',\n        // 파랑색\n        fillOpacity: 0.5\n      };\n      const circle = new kakao.maps.Circle(circleOptions);\n\n      // 원에 클릭 이벤트 추가\n      kakao.maps.event.addListener(circle, \'click\', function () {\n        // 클릭한 원의 내용 표시\n        const infoWindow = new kakao.maps.InfoWindow({\n          position: position,\n          content: selectedMarker.content\n        });\n        infoWindow.open(vm.mapInstance);\n      });\n      circle.setMap(vm.mapInstance); // 지도에 원 표시\n    },\n\n    filterDistrict(district) {\n      console.log("필터링할 구/군: ", district);\n      const vm = this;\n      lib_axios({\n        url: "/welfareData.json",\n        method: "post",\n        headers: {\n          "Content-Type": "application/json"\n        },\n        data: {\n          district: district\n        }\n      }).then(function (response) {\n        console.log("welfareData - response :", response.data);\n        vm.dataList = response.data.filter(item => item.public_center_add === district);\n        vm.showMarkers();\n      }).catch(function (error) {\n        console.log("welfareData - error :", error);\n        alert("공공시설 데이터 조회에 오류가 발생했습니다.");\n      });\n    },\n    filterSafety(district) {\n      console.log("필터링할 구/군: ", district);\n      this.safetyDistrict = district;\n    },\n    filterSafetyCategory(category) {\n      console.log("필터링할 안전 카테고리: ", category);\n      const vm = this;\n      lib_axios({\n        url: "/safetyData.json",\n        method: "post",\n        headers: {\n          "Content-Type": "application/json"\n        },\n        data: {\n          district: this.safetyDistrict,\n          category: category\n        }\n      }).then(function (response) {\n        console.log("safetyData - response :", response.data);\n        const filteredData = response.data.filter(item => item.safety_region === vm.safetyDistrict);\n        filteredData.forEach(safetyData => {\n          const position = new kakao.maps.LatLng(safetyData.safety_latitude, safetyData.safety_longitude);\n          const circleOptions = {\n            center: position,\n            radius: 1500,\n            strokeWeight: 1,\n            strokeColor: \'#333\',\n            strokeOpacity: 0.7,\n            fillColor: vm.getSafetyColor(safetyData[category]),\n            fillOpacity: 0.5\n          };\n          const circle = new kakao.maps.Circle(circleOptions);\n\n          // 클릭 이벤트 리스너 추가\n          kakao.maps.event.addListener(circle, \'click\', function () {\n            // 클릭한 원의 내용 표시\n            const infoWindow = new kakao.maps.InfoWindow({\n              position: position,\n              content: `<div style="padding: 10px; margin-bottom: 15px; text-align: center;">\n                                <strong>${safetyData.safety_region}</strong>\n                                <hr>\n                                <ul>\n                                    <li>안전지수 : ${safetyData[category]}</li>\n                                    <li>경찰서 수 : ${safetyData.safety_police}</li>\n                                </ul>\n                              </div>`\n            });\n            infoWindow.open(vm.mapInstance);\n          });\n          circle.setMap(vm.mapInstance);\n          vm.circles.push({\n            circle\n          });\n        });\n      }).catch(function (error) {\n        console.log("safetyData - error :", error);\n        alert("안전 카테고리 데이터 조회에 오류가 발생했습니다.");\n      });\n    },\n    filterEnvironment(district) {\n      console.log("필터링할 지역: ", district);\n      const vm = this;\n      lib_axios({\n        url: "/environmentData.json",\n        method: "post",\n        headers: {\n          "Content-Type": "application/json"\n        },\n        data: {\n          district: district\n        }\n      }).then(function (response) {\n        console.log("environmentData - response :", response.data);\n\n        // 지역에 해당하는 데이터만 필터링\n        const filteredData = response.data.filter(item => item.env_region === district);\n\n        // 필터링된 데이터를 이용하여 지도에 원 그리기\n        filteredData.forEach(envData => {\n          const position = new kakao.maps.LatLng(envData.env_latitude, envData.env_longitude);\n          const circleOptions = {\n            center: position,\n            radius: 1500,\n            // 반지름 설정\n            strokeWeight: 1,\n            strokeColor: \'#333\',\n            strokeOpacity: 0.7,\n            fillColor: \'#1F77B4\',\n            // 파랑색\n            fillOpacity: 0.5\n          };\n          const circle = new kakao.maps.Circle(circleOptions);\n\n          // 클릭 이벤트 리스너 추가\n          kakao.maps.event.addListener(circle, \'click\', function () {\n            // 클릭한 원의 내용 표시\n            const infoWindow = new kakao.maps.InfoWindow({\n              position: position,\n              content: `<div style="padding: 10px; margin-bottom: 15px; text-align: center;">\n                            <strong>${envData.env_region}</strong>\n                            <hr>\n                            <ul>\n                                <li>환경오염배출사업장 수: ${envData.env_company}개</li>\n                                <li>폐기물 배출량(연간/톤): ${envData.env_waste}</li>\n                            </ul>\n                          </div>`\n            });\n            infoWindow.open(vm.mapInstance);\n          });\n          circle.setMap(vm.mapInstance); // 지도에 원 표시\n          vm.circles.push({\n            circle\n          }); // 원을 circles 배열에 추가\n        });\n      }).catch(function (error) {\n        console.log("environmentData - error :", error);\n        alert("환경 데이터 조회에 오류가 발생했습니다.");\n      });\n    },\n    getSafetyColor(riskIndex) {\n      // 위험지수에 따른 색상 결정\n      if (riskIndex === 1) {\n        return \'#1F77B4\'; // 파랑\n      } else if (riskIndex === 2) {\n        return \'#2CA02C\'; // 초록\n      } else if (riskIndex === 3) {\n        return \'#FFD700\'; // 노랑\n      } else if (riskIndex === 4) {\n        return \'#FFA500\'; // 주황\n      } else {\n        return \'#FF0000\'; // 빨강\n      }\n    },\n\n    showMarkers() {\n      this.dataList.forEach(markerData => {\n        const position = new kakao.maps.LatLng(markerData.public_center_latitude, markerData.public_center_longitude);\n        const marker = new kakao.maps.Marker({\n          position\n        });\n        marker.setMap(this.mapInstance);\n\n        // 클릭 이벤트 리스너 추가\n        kakao.maps.event.addListener(marker, \'click\', () => {\n          const infowindow = new kakao.maps.InfoWindow({\n            content: `<div style="padding: 10px; margin-bottom: 15px"><strong>${markerData.public_center_name}</strong><hr><ul><li></li></ul></div>`\n          });\n          infowindow.open(this.mapInstance, marker);\n        });\n        this.circles.push({\n          marker\n        });\n      });\n    },\n    clearMap() {\n      location.reload();\n    }\n  },\n  mounted() {\n    // Kakao Maps API가 로드되었는지 확인\n    if (window.kakao && window.kakao.maps) {\n      var container = this.$refs.map;\n      var options = {\n        center: new kakao.maps.LatLng(35.8311, 128.5656),\n        level: 7\n      };\n      this.mapInstance = new window.kakao.maps.Map(container, options);\n    } else {\n      console.error("Kakao Maps API가 로드되지 않았습니다.");\n    }\n  }\n});\n;// CONCATENATED MODULE: ./client/views/pages/main/Main.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./client/views/pages/main/Main.vue?vue&type=style&index=0&id=d4956396&scoped=true&lang=css\nvar Mainvue_type_style_index_0_id_d4956396_scoped_true_lang_css = __webpack_require__(628);\n;// CONCATENATED MODULE: ./client/views/pages/main/Main.vue?vue&type=style&index=0&id=d4956396&scoped=true&lang=css\n\n// EXTERNAL MODULE: ./node_modules/vue-loader/dist/exportHelper.js\nvar exportHelper = __webpack_require__(21);\n;// CONCATENATED MODULE: ./client/views/pages/main/Main.vue\n\n\n\n\n;\n\n\nconst __exports__ = /*#__PURE__*/(0,exportHelper/* default */.Z)(Mainvue_type_script_lang_js, [[\'render\',Mainvue_type_template_id_d4956396_scoped_true_render],[\'__scopeId\',"data-v-d4956396"]])\n\n/* harmony default export */ const Main = (__exports__);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./client/views/pages/chart/Safety.vue?vue&type=template&id=d6e86182\n\nconst Safetyvue_type_template_id_d6e86182_hoisted_1 = /*#__PURE__*/createStaticVNode("<div class=\\"container\\"><div class=\\"row\\"><div class=\\"column\\"><h1>경찰서</h1><h2>경찰청 관서별 지역경찰 현황</h2><div id=\\"police\\" class=\\"policediv\\"></div></div><div class=\\"column\\"><h1>소방서</h1><h2>소방관 1인당 관할면적 현황(㎢)</h2><div id=\\"fire\\" class=\\"firediv\\"></div></div></div></div><div class=\\"container\\"><div class=\\"row\\"><div class=\\"column\\"><h2>전년도 대비 범죄 현황</h2><div id=\\"crime\\" class=\\"crimediv\\"></div></div><div class=\\"column\\"><h2>전년도 대비 사고 현황</h2><div id=\\"accident\\" class=\\"accidentdiv\\"></div></div></div></div><div class=\\"container\\"><div class=\\"row\\"><div class=\\"column\\"><h1>통합 안전 지수</h1><br><div class=\\"flex-container\\"><div class=\\"textbox1\\"> 2021 - 2022<br> 범죄 증가율,<br> 사고 증가율에 기반한<br> 통합 안전 지수</div><div id=\\"safety\\" class=\\"safediv\\"></div></div></div><div class=\\"column\\"><h2 style=\\"margin-top:12px;\\">사고 심각도</h2><br><div class=\\"flex-container\\"><div class=\\"textbox2\\"> 2020 - 2022<br> 평균 교통사고<br> 사상자수/사고건수</div><div id=\\"casualty\\" class=\\"casualtydiv\\"></div></div></div></div></div>", 3);\nfunction Safetyvue_type_template_id_d6e86182_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return Safetyvue_type_template_id_d6e86182_hoisted_1;\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js\n/**\r\n * A collection of utility functions for various type checks and conversion\r\n * @hidden\r\n */\n/**\r\n * ============================================================================\r\n * TYPE CHECK\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Returns `true` if value is not a number (NaN).\r\n *\r\n * @param value Input value\r\n * @return Is NaN?\r\n */\nfunction Type_isNaN(value) {\n  return Number(value) !== value;\n}\n/**\r\n * Returns a type of the value.\r\n *\r\n * @param value  Input value\r\n * @return Type of the value\r\n * @ignore\r\n */\nfunction Type_getType(value) {\n  return {}.toString.call(value);\n}\n/**\r\n * Asserts that the condition is true.\r\n *\r\n * @param condition  Condition to check\r\n * @param message    Message to display in the error\r\n * @ignore\r\n */\nfunction assert(condition, message = "Assertion failed") {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n/**\r\n * ============================================================================\r\n * QUICK CONVERSION\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Converts any value into a `number`.\r\n *\r\n * @param value  Source value\r\n * @return Number representation of value\r\n */\nfunction Type_toNumber(value) {\n  if (value != null && !Type_isNumber(value)) {\n    let converted = Number(value);\n    if (Type_isNaN(converted) && Type_isString(value) && value != "") {\n      return Type_toNumber(value.replace(/[^0-9.\\-]+/g, \'\'));\n    }\n    return converted;\n  }\n  return value;\n}\n/**\r\n * Converts anything to Date object.\r\n *\r\n * @param value  A value of any type\r\n * @return Date object representing a value\r\n */\nfunction toDate(value) {\n  if (Type_isDate(value)) {\n    // TODO maybe don\'t create a new Date ?\n    return new Date(value);\n  } else if (Type_isNumber(value)) {\n    return new Date(value);\n  } else {\n    // Try converting to number (assuming timestamp)\n    let num = Number(value);\n    if (!Type_isNumber(num)) {\n      return new Date(value);\n    } else {\n      return new Date(num);\n    }\n  }\n}\n/**\r\n * Converts numeric value into string. Deals with large or small numbers that\r\n * would otherwise use exponents.\r\n *\r\n * @param value  Numeric value\r\n * @return Numeric value as string\r\n */\nfunction numberToString(value) {\n  // TODO handle Infinity and -Infinity\n  if (Type_isNaN(value)) {\n    return "NaN";\n  }\n  if (value === Infinity) {\n    return "Infinity";\n  }\n  if (value === -Infinity) {\n    return "-Infinity";\n  }\n  // Negative 0\n  if (value === 0 && 1 / value === -Infinity) {\n    return "-0";\n  }\n  // Preserve negative and deal with absoute values\n  let negative = value < 0;\n  value = Math.abs(value);\n  // TODO test this\n  let parsed = /^([0-9]+)(?:\\.([0-9]+))?(?:e[\\+\\-]([0-9]+))?$/.exec("" + value);\n  let digits = parsed[1];\n  let decimals = parsed[2] || "";\n  let res;\n  // Leave the nummber as it is if it does not use exponents\n  if (parsed[3] === undefined) {\n    res = decimals === "" ? digits : digits + "." + decimals;\n  } else {\n    let exponent = +parsed[3];\n    // Deal with decimals\n    if (value < 1) {\n      let zeros = exponent - 1;\n      res = "0." + repeat("0", zeros) + digits + decimals;\n      // Deal with integers\n    } else {\n      let zeros = exponent - decimals.length;\n      if (zeros === 0) {\n        res = digits + decimals;\n      } else if (zeros < 0) {\n        res = digits + decimals.slice(0, zeros) + "." + decimals.slice(zeros);\n      } else {\n        res = digits + decimals + repeat("0", zeros);\n      }\n    }\n  }\n  return negative ? "-" + res : res;\n}\n/**\r\n * Repeats a `string` number of times as set in `amount`.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Make this faster\r\n * @param string  Source string\r\n * @param amount  Number of times to repeat string\r\n * @return New string\r\n */\nfunction repeat(string, amount) {\n  return new Array(amount + 1).join(string);\n}\n/**\r\n * ============================================================================\r\n * TYPE CHECK\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Checks if parameter is `Date`.\r\n *\r\n * @param value  Input value\r\n * @return Is Date?\r\n */\nfunction Type_isDate(value) {\n  return Type_getType(value) === "[object Date]";\n}\n/**\r\n * Checks if parameter is `string`.\r\n *\r\n * @param value  Input value\r\n * @return Is string?\r\n */\nfunction Type_isString(value) {\n  return typeof value === "string";\n}\n/**\r\n * Checks if parameter is `number`.\r\n *\r\n * @param value  Input value\r\n * @return Is number?\r\n */\nfunction Type_isNumber(value) {\n  return typeof value === "number" && Number(value) == value;\n}\n/**\r\n * Checks if parameter is `object`.\r\n *\r\n * @param value  Input value\r\n * @return Is object?\r\n */\nfunction Type_isObject(value) {\n  return typeof value === "object" && value !== null;\n}\n/**\r\n * Checks if parameter is `Array`.\r\n *\r\n * @param value  Input value\r\n * @return Is Array?\r\n */\nfunction Type_isArray(value) {\n  return Array.isArray(value);\n}\n/**\r\n * ============================================================================\r\n * STATIC CONSTANTS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * @ignore Exclude from docs\r\n */\nconst PLACEHOLDER = "__§§§__";\n/**\r\n * @ignore Exclude from docs\r\n */\nconst PLACEHOLDER2 = "__§§§§__";\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js\n\n/**\r\n * ============================================================================\r\n * UTILITY FUNCTIONS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Searches `array` for `value`.\r\n *\r\n * Returns -1 if not found.\r\n *\r\n * @param array  Source array\r\n * @param value  Value to search\r\n * @returns Index\r\n */\nfunction indexOf(array, value) {\n  const length = array.length;\n  for (let i = 0; i < length; ++i) {\n    // TODO handle NaN\n    if (array[i] === value) {\n      return i;\n    }\n  }\n  return -1;\n}\n/**\r\n * Calls `test` for each element in `array`.\r\n *\r\n * If `test` returns `true` then it immediately returns `true`.\r\n *\r\n * If `test` returns `false` for all of the elements in `array` then it returns `false`.\r\n *\r\n * @param array  Source array\r\n * @param test   Function which is called on each element\r\n * @returns Whether `test` returned true or not\r\n */\nfunction any(array, test) {\n  const length = array.length;\n  for (let i = 0; i < length; ++i) {\n    if (test(array[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\r\n * Calls `fn` function for every member of array and returns a new array out\r\n * of all outputs.\r\n *\r\n * @param array  Source array\r\n * @param fn     Callback function\r\n * @returns New array\r\n */\nfunction Array_map(array, fn) {\n  const length = array.length;\n  const output = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    output[i] = fn(array[i], i);\n  }\n  return output;\n}\n/**\r\n * Iterates through all items in array and calls `fn` function for each of\r\n * them.\r\n *\r\n * @param array  Source array\r\n * @param fn     Callback function\r\n */\nfunction each(array, fn) {\n  const length = array.length;\n  for (let i = 0; i < length; ++i) {\n    fn(array[i], i);\n  }\n}\n/**\r\n * Iterates through all items in array in reverse order and calls `fn` function for each of\r\n * them.\r\n *\r\n * @param array  Source array\r\n * @param fn     Callback function\r\n */\nfunction eachReverse(array, fn) {\n  let i = array.length;\n  while (i > 0) {\n    --i;\n    fn(array[i], i);\n  }\n}\n/**\r\n * Iterates through all items in array and calls `fn` function for each of\r\n * them.\r\n *\r\n * If `fn` call evaluates to `false`, further iteration is cancelled.\r\n *\r\n * @param array  Source array\r\n * @param fn     Callback function\r\n */\nfunction eachContinue(array, fn) {\n  const length = array.length;\n  for (let i = 0; i < length; ++i) {\n    if (!fn(array[i], i)) {\n      break;\n    }\n  }\n}\n/**\r\n * Shifts an item at `index` towards beginning of the array.\r\n *\r\n * @param array  Source array\r\n * @param index  Target element index\r\n */\nfunction shiftLeft(array, index) {\n  const length = array.length;\n  for (let i = index; i < length; ++i) {\n    array[i - index] = array[i];\n  }\n  array.length = length - index;\n}\n/**\r\n * Returns the last item of the array.\r\n *\r\n * @param array  Source array\r\n * @returns Last item\r\n */\nfunction last(array) {\n  const length = array.length;\n  return length ? array[length - 1] : undefined;\n}\n/**\r\n * Returns the first item of the array.\r\n *\r\n * @param array  Source array\r\n * @returns Last item\r\n */\nfunction first(array) {\n  return array[0];\n}\n/**\r\n * Inserts `element` into `array` at `index`.\r\n *\r\n * Caps `index` to be between `0` and `array.length`\r\n *\r\n * @param array    Source array\r\n * @param element  Item to insert\r\n * @param array    Index to insert item at\r\n */\nfunction insert(array, element, index) {\n  //if (array) {\n  index = Math.max(0, Math.min(index, array.length));\n  array.splice(index, 0, element);\n  //}\n}\n/**\r\n * Removes all copies of `element` from `array` (if they exist) and then\r\n * inserts `element` at `index`.\r\n *\r\n * @param array    Source array\r\n * @param element  Item\r\n * @param array    Index to move item to\r\n */\nfunction setIndex(array, element, index) {\n  Array_remove(array, element);\n  insert(array, element, index);\n}\n/**\r\n * Pushes all of the elements from `input` into `array`.\r\n *\r\n * @param array  Output array\r\n * @param input  Input array\r\n */\nfunction pushAll(array, input) {\n  const length = input.length;\n  for (let i = 0; i < length; ++i) {\n    array.push(input[i]);\n  }\n}\n/**\r\n * Removes `element` from `array`.\r\n *\r\n * If there are multiple copies of `element`, they are all removed.\r\n *\r\n * @param array    Source array\r\n * @param element  Item to remove\r\n */\nfunction Array_remove(array, element) {\n  let found = false;\n  let index = 0;\n  for (;;) {\n    index = array.indexOf(element, index);\n    if (index === -1) {\n      return found;\n    } else {\n      found = true;\n      array.splice(index, 1);\n    }\n  }\n}\nfunction removeFirst(array, element) {\n  let index = array.indexOf(element);\n  if (index !== -1) {\n    array.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n/**\r\n * Adds an `element` to `array`.\r\n *\r\n * If array already contains and item like this, it is removed before adding\r\n * it again.\r\n *\r\n * Optionally `toIndex` can be specified to add element at specific index.\r\n *\r\n * @param array    Source array\r\n * @param element  Item to add\r\n * @param array    Index to move item to\r\n */\nfunction move(array, element, toIndex) {\n  // @todo this implementation must be the same as the List.moveValue method\n  // @todo don\'t do anything if the desired index is the same as the current index\n  let index = indexOf(array, element);\n  // @todo remove all old values rather than only the first ?\n  if (index !== -1) {\n    removeIndex(array, index);\n  }\n  if (toIndex == null) {\n    array.push(element);\n  } else {\n    insertIndex(array, toIndex, element);\n  }\n}\n/**\r\n * Inserts `element` into `array` at `index`.\r\n *\r\n * If `index` is not provided, it will insert `element` at the end of `array`.\r\n *\r\n * @param array    Source array\r\n * @param element  Item to add\r\n * @param array    Index to add item at\r\n */\nfunction Array_add(array, element, index) {\n  // Append to the end if index is not set\n  if (!$type.isNumber(index)) {\n    array.push(element);\n  }\n  // Add to the beginning of array if index is 0\n  else if (index === 0) {\n    array.unshift(element);\n  }\n  // Add to indicated place if index is set\n  else {\n    array.splice(index, 0, element);\n  }\n}\n/**\r\n * Pushes `element` into `array` if it doesn\'t already exist.\r\n *\r\n * @param array    Source array\r\n * @param element  Item to add\r\n */\nfunction pushOne(array, element) {\n  if (array.indexOf(element) === -1) {\n    array.push(element);\n  }\n}\n/**\r\n * Removes `element` from `array` (if it exists) and then inserts `element` at\r\n * `index`.\r\n *\r\n * If `index` is not provided, it will insert `element` at the end of `array`.\r\n *\r\n * @param array    Source array\r\n * @param element  Item to remove\r\n * @param array    Index to move item to\r\n */\nfunction replace(array, element, index) {\n  // check if exists\n  let ind = array.indexOf(element);\n  // remove if exists\n  if (ind !== -1) {\n    array.splice(ind, 1);\n  }\n  // add to end if index is not set\n  if (!$type.isNumber(index)) {\n    array.push(element);\n  }\n  // add to indicated place if index is set\n  else {\n    array.splice(index, 0, element);\n  }\n}\n/**\r\n * Wraps `input` in an array, if it isn\'t already an array.\r\n *\r\n * @param input  Source value\r\n * @return An array\r\n */\nfunction Array_toArray(input) {\n  if (Array.isArray(input)) {\n    return input;\n  } else {\n    return [input];\n  }\n}\n/**\r\n * Returns `true` if `element` exists in `array`.\r\n *\r\n * @param array    Source array\r\n * @param element  Item to search for\r\n * @returns Item in array?\r\n */\nfunction Array_has(array, element) {\n  return indexOf(array, element) !== -1;\n}\n/**\r\n * Returns a shallow copy of `array`.\r\n *\r\n * @param array  Source array\r\n * @returns Copy of the array\r\n */\nfunction copy(array) {\n  const length = array.length;\n  // It\'s faster to create the array with a pre-defined length\n  const output = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    // Because the array has a pre-defined length, we have to assign rather than push\n    // This is also faster than pushing\n    output[i] = array[i];\n  }\n  return output;\n}\n/**\r\n * Returns a copy of `array` which contains all the elements between `start`\r\n * and `end`. (including `start` and excluding `end`)\r\n *\r\n * If `end` is not provided, it defaults to `array.length`.\r\n *\r\n * @param array  Source array\r\n * @param start  Start index\r\n * @param end    End index\r\n * @returns Part of the array\r\n */\nfunction slice(array, start, end = array.length) {\n  const output = new Array(end - start);\n  for (let i = start; i < end; ++i) {\n    output[i - start] = array[i];\n  }\n  return output;\n}\n/**\r\n * Inserts a value into array at specific index.\r\n *\r\n * @param array  Source array\r\n * @param index  Index\r\n * @param value  Value to insert\r\n */\nfunction insertIndex(array, index, value) {\n  array.splice(index, 0, value);\n}\n/**\r\n * Removes a value from array at specific index.\r\n *\r\n * @param array  Source array\r\n * @param index  Index\r\n */\nfunction removeIndex(array, index) {\n  array.splice(index, 1);\n}\n/**\r\n * Searches the array using custom function and returns index of the item if\r\n * found.\r\n *\r\n * Will call `matches` function on all items of the array. If return value\r\n * evaluates to `true`, index is returned.\r\n *\r\n * Otherwise returns -1.\r\n *\r\n * @param array    Source array\r\n * @param matches  Search function\r\n * @returns Index of the item if found\r\n */\nfunction findIndex(array, matches) {\n  const length = array.length;\n  for (let i = 0; i < length; ++i) {\n    if (matches(array[i], i)) {\n      return i;\n    }\n  }\n  return -1;\n}\n/**\r\n * This is the same as `findIndex` except it searches from right to left.\r\n *\r\n * @param array    Source array\r\n * @param matches  Search function\r\n * @returns Index of the item if found\r\n */\nfunction findIndexReverse(array, matches) {\n  let i = array.length;\n  while (i > 0) {\n    --i;\n    if (matches(array[i], i)) {\n      return i;\n    }\n  }\n  return -1;\n}\n/**\r\n * Searches the array using custom function and returns item if found.\r\n *\r\n * Will call `matches` function on all items of the array. If return value\r\n * evaluates to `true`, index is returned.\r\n *\r\n * Otherwise returns `undefined`.\r\n *\r\n * @param array    Source array\r\n * @param matches  Search function\r\n * @returns Item if found\r\n */\nfunction find(array, matches) {\n  const index = findIndex(array, matches);\n  if (index !== -1) {\n    return array[index];\n  }\n}\n/**\r\n * This is the same as `find` except it searches from right to left.\r\n *\r\n * @param array    Source array\r\n * @param matches  Search function\r\n * @returns Item if found\r\n */\nfunction findReverse(array, matches) {\n  const index = findIndexReverse(array, matches);\n  if (index !== -1) {\n    return array[index];\n  }\n}\n/**\r\n * Searches the array using custom function and returns item if found.\r\n *\r\n * Will call `matches` function on all items of the array. If value\r\n * is not `undefined`, it returns it.\r\n *\r\n * Otherwise returns `undefined`.\r\n *\r\n * @param array    Source array\r\n * @param matches  Search function\r\n * @returns Item if found\r\n */\nfunction findMap(array, matches) {\n  const length = array.length;\n  for (let i = 0; i < length; ++i) {\n    const value = matches(array[i], i);\n    if (value !== undefined) {\n      return value;\n    }\n  }\n}\n/**\r\n * Iterates through all items in array and calls `fn` function for each of\r\n * them.\r\n *\r\n * @param array  Source array\r\n * @param fn     Callback function\r\n */\nfunction shuffle(array) {\n  // https://stackoverflow.com/a/2450976/449477\n  let currentIndex = array.length,\n    temporaryValue,\n    randomIndex;\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n    // And swap it with the current element.\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n}\n/**\r\n * Orders an array using specific `ordering` function and returns right-most index of\r\n * the `value`.\r\n *\r\n * @ignore Exclude from docs\r\n * @param array     Source array\r\n * @param ordering  An ordering function\r\n * @returns Result of the search\r\n */\nfunction getSortedIndex(array, ordering) {\n  let start = 0;\n  let end = array.length;\n  let found = false;\n  while (start < end) {\n    // TODO is this faster/slower than using Math.floor ?\n    const pivot = start + end >> 1;\n    const order = ordering(array[pivot]);\n    // less\n    if (order < 0) {\n      start = pivot + 1;\n      // equal\n    } else if (order === 0) {\n      found = true;\n      start = pivot + 1;\n      // more\n    } else {\n      end = pivot;\n    }\n  }\n  return {\n    found: found,\n    index: found ? start - 1 : start\n  };\n}\n/**\r\n * Orders an array using specific `ordering` function and returns left-most index of\r\n * the `value`.\r\n *\r\n * @ignore Exclude from docs\r\n * @param array     Source array\r\n * @param ordering  An ordering function\r\n * @returns Result of the search\r\n */\nfunction getFirstSortedIndex(array, ordering) {\n  let start = 0;\n  let end = array.length;\n  let found = false;\n  while (start < end) {\n    // TODO is this faster/slower than using Math.floor ?\n    const pivot = start + end >> 1;\n    const order = ordering(array[pivot]);\n    // less\n    if (order < 0) {\n      start = pivot + 1;\n      // equal\n    } else if (order === 0) {\n      found = true;\n      end = pivot;\n      // more\n    } else {\n      end = pivot;\n    }\n  }\n  return {\n    found: found,\n    index: start\n  };\n}\nfunction keepIf(array, keep) {\n  let i = array.length;\n  while (i > 0) {\n    --i;\n    if (!keep(array[i])) {\n      array.splice(i, 1);\n    }\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * A base class for disposable objects.\r\n *\r\n * @ignore Exclude from docs\r\n */\nclass Disposer_DisposerClass {\n  /**\r\n   * Constructor.\r\n   */\n  constructor() {\n    /**\r\n     * Is object disposed?\r\n     */\n    Object.defineProperty(this, "_disposed", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._disposed = false;\n  }\n  /**\r\n   * Checks if object is disposed.\r\n   *\r\n   * @return Disposed?\r\n   */\n  isDisposed() {\n    return this._disposed;\n  }\n  /**\r\n   * Disposes the object.\r\n   */\n  dispose() {\n    if (!this._disposed) {\n      this._disposed = true;\n      this._dispose();\n    }\n  }\n}\n/**\r\n * A class for creating an IDisposer.\r\n *\r\n * @ignore Exclude from docs\r\n */\nclass Disposer {\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param dispose  Function that disposes object\r\n   */\n  constructor(dispose) {\n    /**\r\n     * Is object disposed?\r\n     */\n    Object.defineProperty(this, "_disposed", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * Method that disposes the object.\r\n     */\n    Object.defineProperty(this, "_dispose", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._disposed = false;\n    this._dispose = dispose;\n  }\n  /**\r\n   * Checks if object is disposed.\r\n   *\r\n   * @return Disposed?\r\n   */\n  isDisposed() {\n    return this._disposed;\n  }\n  /**\r\n   * Disposes the object.\r\n   */\n  dispose() {\n    if (!this._disposed) {\n      this._disposed = true;\n      this._dispose();\n    }\n  }\n}\n/**\r\n * This can be extended by other classes to add a `_disposers` property.\r\n *\r\n * @ignore Exclude from docs\r\n */\nclass ArrayDisposer extends Disposer_DisposerClass {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_disposers", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n  }\n  _dispose() {\n    each(this._disposers, x => {\n      x.dispose();\n    });\n  }\n}\n/**\r\n * A collection of related disposers that can be disposed in one go.\r\n *\r\n * @ignore Exclude from docs\r\n */\nclass Disposer_MultiDisposer extends Disposer_DisposerClass {\n  constructor(disposers) {\n    super();\n    Object.defineProperty(this, "_disposers", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._disposers = disposers;\n  }\n  _dispose() {\n    each(this._disposers, x => {\n      x.dispose();\n    });\n  }\n  get disposers() {\n    return this._disposers;\n  }\n}\n/**\r\n * A special kind of Disposer that has attached value set.\r\n *\r\n * If a new value is set using `set()` method, the old disposer value is\r\n * disposed.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\nclass MutableValueDisposer extends (/* unused pure expression or super */ null && (Disposer_DisposerClass)) {\n  constructor() {\n    super(...arguments);\n    /**\r\n     * Current disposer.\r\n     */\n    Object.defineProperty(this, "_disposer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * Current value.\r\n     */\n    Object.defineProperty(this, "_value", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  _dispose() {\n    if (this._disposer != null) {\n      this._disposer.dispose();\n      this._disposer = undefined;\n    }\n  }\n  /**\r\n   * Returns current value.\r\n   *\r\n   * @return Value\r\n   */\n  get() {\n    return this._value;\n  }\n  /**\r\n   * Sets value and disposes previous disposer if it was set.\r\n   *\r\n   * @param value     New value\r\n   * @param disposer  Disposer\r\n   */\n  set(value, disposer) {\n    if (this._disposer != null) {\n      this._disposer.dispose();\n    }\n    this._disposer = disposer;\n    this._value = value;\n  }\n  /**\r\n   * Resets the disposer value.\r\n   */\n  reset() {\n    this.set(undefined, undefined);\n  }\n}\n/**\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\nclass CounterDisposer extends Disposer {\n  constructor() {\n    super(...arguments);\n    /**\r\n     * [_counter description]\r\n     *\r\n     * @todo Description\r\n     */\n    Object.defineProperty(this, "_counter", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n  }\n  /**\r\n   * [increment description]\r\n   *\r\n   * @todo Description\r\n   */\n  increment() {\n    // TODO throw an error if it is disposed\n    ++this._counter;\n    // TODO make this more efficient\n    return new Disposer(() => {\n      --this._counter;\n      if (this._counter === 0) {\n        this.dispose();\n      }\n    });\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js\n\n\n\n\n/**\r\n * ============================================================================\r\n * DOM FUNCTIONS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Execute a function when DOM is ready.\r\n *\r\n * @since 5.0.2\r\n * @param  f  Callback\r\n */\nfunction ready(f) {\n  if (document.readyState !== "loading") {\n    f();\n  } else {\n    const listener = () => {\n      if (document.readyState !== "loading") {\n        document.removeEventListener("readystatechange", listener);\n        f();\n      }\n    };\n    document.addEventListener("readystatechange", listener);\n  }\n}\n/**\r\n * Removes a DOM element.\r\n * @param  el  Target element\r\n */\nfunction removeElement(el) {\n  if (el.parentNode) {\n    el.parentNode.removeChild(el);\n  }\n}\n/**\r\n * Function that adds a disposable event listener directly to a DOM element.\r\n *\r\n * @ignore Exclude from docs\r\n * @param dom       A DOM element to add event to\r\n * @param type      Event type\r\n * @param listener  Event listener\r\n * @returns Disposable event\r\n */\nfunction Utils_addEventListener(dom, type, listener, options) {\n  //@todo proper type check for options: EventListenerOptions | boolean (TS for some reason gives error on passive parameter)\n  dom.addEventListener(type, listener, options || false);\n  return new Disposer(() => {\n    dom.removeEventListener(type, listener, options || false);\n  });\n}\n/**\r\n * Function that adds an event listener which is triggered when the browser\'s zoom changes.\r\n *\r\n * @param listener  Event listener\r\n * @returns Disposable event\r\n */\nfunction onZoom(listener) {\n  // TODO use matchMedia instead ?\n  return Utils_addEventListener(window, "resize", _ev => {\n    listener();\n  });\n}\n/**\r\n * @ignore\r\n */\nfunction supports(cap) {\n  switch (cap) {\n    case "touchevents":\n      //return "ontouchstart" in document.documentElement;\n      return window.hasOwnProperty("TouchEvent");\n    case "pointerevents":\n      return window.hasOwnProperty("PointerEvent");\n    case "mouseevents":\n      return window.hasOwnProperty("MouseEvent");\n    case "wheelevents":\n      return window.hasOwnProperty("WheelEvent");\n    case "keyboardevents":\n      return window.hasOwnProperty("KeyboardEvent");\n  }\n  return false;\n}\n/**\r\n * @ignore\r\n */\nfunction getPointerId(event) {\n  let id = event.pointerId || 0;\n  return id;\n}\n/**\r\n * Removes focus from any element by shifting focus to body.\r\n *\r\n * @ignore\r\n */\nfunction Utils_blur() {\n  if (document.activeElement && document.activeElement != document.body) {\n    if (document.activeElement.blur) {\n      document.activeElement.blur();\n    } else {\n      let input = document.createElement("button");\n      input.style.position = "fixed";\n      input.style.top = "0px";\n      input.style.left = "-10000px";\n      document.body.appendChild(input);\n      input.focus();\n      input.blur();\n      document.body.removeChild(input);\n    }\n  }\n}\n/**\r\n * Focuses element.\r\n *\r\n * @ignore\r\n */\nfunction Utils_focus(el) {\n  if (el) {\n    el.focus();\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction getRendererEvent(key) {\n  if (supports("pointerevents")) {\n    return key;\n  } else if (supports("touchevents")) {\n    switch (key) {\n      case "pointerover":\n        return "touchstart";\n      case "pointerout":\n        return "touchend";\n      case "pointerleave":\n        return "touchend";\n      case "pointerdown":\n        return "touchstart";\n      case "pointermove":\n        return "touchmove";\n      case "pointerup":\n        return "touchend";\n      case "click":\n        return "click";\n      case "dblclick":\n        return "dblclick";\n    }\n  } else if (supports("mouseevents")) {\n    switch (key) {\n      case "pointerover":\n        return "mouseover";\n      case "pointerout":\n        return "mouseout";\n      case "pointerleave":\n        return "mouseleave";\n      case "pointerdown":\n        return "mousedown";\n      case "pointermove":\n        return "mousemove";\n      case "pointerup":\n        return "mouseup";\n      case "click":\n        return "click";\n      case "dblclick":\n        return "dblclick";\n    }\n  }\n  return key;\n}\n/**\r\n * Determines if pointer event originated from a touch pointer or mouse.\r\n *\r\n * @param ev  Original event\r\n * @return Touch pointer?\r\n */\nfunction isTouchEvent(ev) {\n  if (typeof Touch !== "undefined" && ev instanceof Touch) {\n    return true;\n  } else if (typeof PointerEvent !== "undefined" && ev instanceof PointerEvent && ev.pointerType != null) {\n    switch (ev.pointerType) {\n      case "touch":\n      case "pen":\n      case 2:\n        return true;\n      case "mouse":\n      case 4:\n        return false;\n      default:\n        return !(ev instanceof MouseEvent);\n    }\n  } else if (ev.type != null) {\n    if (ev.type.match(/^mouse/)) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\r\n * Sets style property on DOM element.\r\n *\r\n * @ignore Exclude from docs\r\n */\nfunction Utils_setStyle(dom, property, value) {\n  dom.style[property] = value;\n}\nfunction getStyle(dom, property) {\n  return dom.style[property];\n}\n/**\r\n * Gets the target of the event, works for shadow DOM too.\r\n */\nfunction getEventTarget(event) {\n  if (event.composedPath) {\n    const path = event.composedPath();\n    if (path.length === 0) {\n      return null;\n    } else {\n      return path[0];\n    }\n  } else {\n    return event.target;\n  }\n}\n/**\r\n * Checks of element `a` contains element `b`.\r\n *\r\n * @param a  Aleged ascendant\r\n * @param b  Aleged descendant\r\n * @return Contains?\r\n */\nfunction contains(a, b) {\n  let cursor = b;\n  while (true) {\n    if (a === cursor) {\n      return true;\n    } else if (cursor.parentNode === null) {\n      // TODO better ShadowRoot detection\n      if (cursor.host == null) {\n        return false;\n      } else {\n        cursor = cursor.host;\n      }\n    } else {\n      cursor = cursor.parentNode;\n    }\n  }\n}\n/**\r\n * Returns `true` if pointer event originated on an element within Root.\r\n *\r\n * @since 5.2.8\r\n * @param  event   Event\r\n * @param  target  Target element\r\n */\nfunction isLocalEvent(event, target) {\n  return event.target && contains(target.root.dom, event.target);\n}\n/**\r\n * Disables or enables interactivity of a DOM element.\r\n *\r\n * @param  target       Target element\r\n * @param  interactive  Interactive?\r\n */\nfunction setInteractive(target, interactive) {\n  if (interactive) {\n    target.style.pointerEvents = "auto";\n  } else {\n    target.style.pointerEvents = "none";\n  }\n}\nfunction getEventKey(event) {\n  if (event.key !== undefined) {\n    return event.key;\n  }\n  switch (event.keyCode) {\n    case 9:\n      return "Tab";\n    case 13:\n      return "Enter";\n    case 16:\n      return "Shift";\n    case 17:\n      return "Control";\n    case 27:\n      return "Escape";\n    case 32:\n      return " ";\n    case 37:\n      return "ArrowLeft";\n    case 38:\n      return "ArrowUp";\n    case 39:\n      return "ArrowRight";\n    case 40:\n      return "ArrowDown";\n    case 46:\n      return "Delete";\n  }\n  return "" + event.keyCode;\n}\n/**\r\n * Returns the shadow root of the element or null\r\n *\r\n * @param a  Node\r\n * @return Root\r\n */\nfunction getShadowRoot(a) {\n  let cursor = a;\n  while (true) {\n    if (cursor.parentNode === null) {\n      // TODO better ShadowRoot detection\n      if (cursor.host != null) {\n        return cursor;\n      } else {\n        return null;\n      }\n    } else {\n      cursor = cursor.parentNode;\n    }\n  }\n}\n/**\r\n * [rootStylesheet description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\nlet rootStylesheet;\n/**\r\n * @ignore Exclude from docs\r\n */\nfunction createStylesheet(element, text, nonce = "") {\n  // TODO use createElementNS ?\n  const e = document.createElement("style");\n  e.type = "text/css";\n  if (nonce != "") {\n    e.setAttribute("nonce", nonce);\n  }\n  e.textContent = text;\n  if (element === null) {\n    document.head.appendChild(e);\n  } else {\n    element.appendChild(e);\n  }\n  return e;\n}\n/**\r\n * [getStylesheet description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @return [description]\r\n */\nfunction getStylesheet(element, nonce = "") {\n  if (element === null) {\n    if (rootStylesheet == null) {\n      // TODO use createElementNS ?\n      const e = document.createElement("style");\n      e.type = "text/css";\n      if (nonce != "") {\n        e.setAttribute("nonce", nonce);\n      }\n      document.head.appendChild(e);\n      rootStylesheet = e.sheet;\n    }\n    return rootStylesheet;\n  } else {\n    // TODO use createElementNS ?\n    const e = document.createElement("style");\n    e.type = "text/css";\n    if (nonce != "") {\n      e.setAttribute("nonce", nonce);\n    }\n    element.appendChild(e);\n    return e.sheet;\n  }\n}\n/**\r\n * [makeStylesheet description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param selector  [description]\r\n * @return [description]\r\n */\nfunction appendStylesheet(root, selector) {\n  const index = root.cssRules.length;\n  root.insertRule(selector + "{}", index);\n  return root.cssRules[index];\n}\n/**\r\n * Defines a class for a CSS rule.\r\n *\r\n * Can be used to dynamically add CSS to the document.\r\n */\nclass StyleRule extends (/* unused pure expression or super */ null && (DisposerClass)) {\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param selector  CSS selector\r\n   * @param styles    An object of style attribute - value pairs\r\n   */\n  constructor(element, selector, styles, nonce = "") {\n    super();\n    Object.defineProperty(this, "_root", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * CSS rule.\r\n     */\n    Object.defineProperty(this, "_rule", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._root = getStylesheet(element, nonce);\n    try {\n      this._rule = appendStylesheet(this._root, selector);\n    } catch (err) {\n      // Create an empty rule on failed selectors\n      this._rule = appendStylesheet(this._root, ":not(*)");\n    }\n    $object.each(styles, (key, value) => {\n      this.setStyle(key, value);\n    });\n  }\n  /**\r\n   * A CSS selector text.\r\n   *\r\n   * E.g.: `.myClass p`\r\n   *\r\n   * @param selector  CSS selector\r\n   */\n  set selector(selector) {\n    this._rule.selectorText = selector;\n  }\n  /**\r\n   * @return CSS selector\r\n   */\n  get selector() {\n    return this._rule.selectorText;\n  }\n  // TODO test this\n  _dispose() {\n    // TODO a bit hacky\n    const index = $array.indexOf(this._root.cssRules, this._rule);\n    if (index === -1) {\n      throw new Error("Could not dispose StyleRule");\n    } else {\n      // TODO if it\'s empty remove it from the DOM ?\n      this._root.deleteRule(index);\n    }\n  }\n  /**\r\n   * Sets the same style properties with browser-specific prefixes.\r\n   *\r\n   * @param name   Attribute name\r\n   * @param value  Attribute value\r\n   */\n  _setVendorPrefixName(name, value) {\n    const style = this._rule.style;\n    style.setProperty("-webkit-" + name, value, "");\n    style.setProperty("-moz-" + name, value, "");\n    style.setProperty("-ms-" + name, value, "");\n    style.setProperty("-o-" + name, value, "");\n    style.setProperty(name, value, "");\n  }\n  /**\r\n   * Sets a value for specific style attribute.\r\n   *\r\n   * @param name   Attribute\r\n   * @param value  Value\r\n   */\n  setStyle(name, value) {\n    if (name === "transition") {\n      this._setVendorPrefixName(name, value);\n    } else {\n      this._rule.style.setProperty(name, value, "");\n    }\n  }\n}\n/**\r\n * Defines a class for an entire CSS style sheet.\r\n *\r\n * Can be used to dynamically add CSS to the document.\r\n */\nclass StyleSheet extends (/* unused pure expression or super */ null && (DisposerClass)) {\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param text  CSS stylesheet\r\n   */\n  constructor(element, text, nonce = "") {\n    super();\n    Object.defineProperty(this, "_element", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._element = createStylesheet(element, text, nonce);\n  }\n  _dispose() {\n    if (this._element.parentNode) {\n      this._element.parentNode.removeChild(this._element);\n    }\n  }\n}\n/**\r\n * Adds a class name to an HTML or SVG element.\r\n *\r\n * @ignore Exclude from docs\r\n * @param element    Element\r\n * @param className  Class name to add\r\n */\nfunction addClass(element, className) {\n  if (!element) {\n    return;\n  }\n  if (element.classList) {\n    const classes = className.split(" ");\n    $array.each(classes, name => {\n      element.classList.add(name);\n    });\n  } else {\n    let currentClassName = element.getAttribute("class");\n    if (currentClassName) {\n      element.setAttribute("class", currentClassName.split(" ").filter(item => {\n        return item !== className;\n      }).join(" ") + " " + className);\n    } else {\n      element.setAttribute("class", className);\n    }\n  }\n}\n/**\r\n * Removes a class name from an HTML or SVG element.\r\n *\r\n * @ignore Exclude from docs\r\n * @param element    Element\r\n * @param className  Class name to add\r\n */\nfunction removeClass(element, className) {\n  if (!element) {\n    return;\n  }\n  if (element.classList) {\n    element.classList.remove(className);\n  } else {\n    let currentClassName = element.getAttribute("class");\n    if (currentClassName) {\n      element.setAttribute("class", currentClassName.split(" ").filter(item => {\n        return item !== className;\n      }).join(" "));\n    }\n  }\n}\n// /**\n//  * Applies a set of styles to an element. Stores the original styles so they\n//  * can be restored later.\n//  *\n//  * @ignore\n//  * @param io      Element\n//   */\n// export function prepElementForDrag(dom: HTMLElement): void {\n// \t// @todo: save current values\n// \t// Define possible props\n// \tlet props = [\n// \t\t"touchAction", "webkitTouchAction", "MozTouchAction", "MSTouchAction", "msTouchAction", "oTouchAction",\n// \t\t"userSelect", "webkitUserSelect", "MozUserSelect", "MSUserSelect", "msUserSelect", "oUserSelect",\n// \t\t"touchSelect", "webkitTouchSelect", "MozTouchSelect", "MSTouchSelect", "msTouchSelect", "oTouchSelect",\n// \t\t"touchCallout", "webkitTouchCallout", "MozTouchCallout", "MSTouchCallout", "msTouchCallout", "oTouchCallout",\n// \t\t"contentZooming", "webkitContentZooming", "MozContentZooming", "MSContentZooming", "msContentZooming", "oContentZooming",\n// \t\t"userDrag", "webkitUserDrag", "MozUserDrag", "MSUserDrag", "msUserDrag", "oUserDrag"\n// \t];\n// \tfor (let i = 0; i < props.length; i++) {\n// \t\tif (props[i] in dom.style) {\n// \t\t\tsetStyle(dom, props[i], "none");\n// \t\t}\n// \t}\n// \t// Remove iOS-specific selection;\n// \tsetStyle(dom, "tapHighlightColor", "rgba(0, 0, 0, 0)");\n// }\n// /**\n//  * Restores replaced styles\n//  *\n//  * @ignore\n//  * @param  io  Element\n//  */\n// export function unprepElementForDrag(dom: HTMLElement): void {\n// \t// Define possible props\n// \tlet props = [\n// \t\t"touchAction", "webkitTouchAction", "MozTouchAction", "MSTouchAction", "msTouchAction", "oTouchAction",\n// \t\t"userSelect", "webkitUserSelect", "MozUserSelect", "MSUserSelect", "msUserSelect", "oUserSelect",\n// \t\t"touchSelect", "webkitTouchSelect", "MozTouchSelect", "MSTouchSelect", "msTouchSelect", "oTouchSelect",\n// \t\t"touchCallout", "webkitTouchCallout", "MozTouchCallout", "MSTouchCallout", "msTouchCallout", "oTouchCallout",\n// \t\t"contentZooming", "webkitContentZooming", "MozContentZooming", "MSContentZooming", "msContentZooming", "oContentZooming",\n// \t\t"userDrag", "webkitUserDrag", "MozUserDrag", "MSUserDrag", "msUserDrag", "oUserDrag"\n// \t];\n// \tfor (let i = 0; i < props.length; i++) {\n// \t\tif (props[i] in dom.style) {\n// \t\t\tsetStyle(dom, props[i], "");\n// \t\t}\n// \t}\n// \t// Remove iOS-specific selection;\n// \tsetStyle(dom, "tapHighlightColor", "");\n// }\nfunction iOS() {\n  return /apple/i.test(navigator.vendor) && "ontouchend" in document;\n}\nfunction getSafeResolution() {\n  return iOS() ? 1 : undefined;\n}\nfunction relativeToValue(percent, full) {\n  if (Type_isNumber(percent)) {\n    return percent;\n  } else if (percent != null && Type_isNumber(percent.value) && Type_isNumber(full)) {\n    return full * percent.value;\n  } else {\n    return 0;\n  }\n}\n/**\r\n * Returns number of decimals\r\n *\r\n * @ignore Exclude from docs\r\n * @param number  Input number\r\n * @return Number of decimals\r\n */\nfunction decimalPlaces(number) {\n  let match = (\'\' + number).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n  if (!match) {\n    return 0;\n  }\n  return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? +match[2] : 0));\n}\n/**\r\n * ============================================================================\r\n * STRING FORMATTING FUNCTIONS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Pads a string with additional characters to certain length.\r\n *\r\n * @param value  A numeric value\r\n * @param len    Result string length in characters\r\n * @param char   A character to use for padding\r\n * @return Padded value as string\r\n */\nfunction padString(value, len = 0, char = "0") {\n  if (typeof value !== "string") {\n    value = value.toString();\n  }\n  return len > value.length ? Array(len - value.length + 1).join(char) + value : value;\n}\nfunction trimLeft(text) {\n  return text.replace(/^[\\s]*/, "");\n}\nfunction trimRight(text) {\n  return text.replace(/[\\s]*$/, "");\n}\nfunction Utils_trim(text) {\n  return trimLeft(trimRight(text));\n}\nfunction truncateTextWithEllipsis(text, maxLength, breakWords = false, ellipsis = "...") {\n  if (text.length > maxLength) {\n    // Find the last non-alphanumeric character before maxLength\n    let lastNonAlphanumericIndex = maxLength - 1;\n    while (lastNonAlphanumericIndex >= 0 && text.charAt(lastNonAlphanumericIndex).match(/\\w/)) {\n      lastNonAlphanumericIndex--;\n    }\n    if (lastNonAlphanumericIndex >= 0 && breakWords == false) {\n      return text.substring(0, lastNonAlphanumericIndex + 1) + \'...\';\n    } else {\n      // If no non-alphanumeric character found, truncate without breaking words\n      return text.substring(0, maxLength) + ellipsis;\n    }\n  } else {\n    return text;\n  }\n}\n/**\r\n * Tries to determine format type.\r\n *\r\n * @ignore Exclude from docs\r\n * @param format  Format string\r\n * @return Format type ("string" | "number" | "date" | "duration")\r\n */\nfunction getFormat(format) {\n  // Undefined?\n  if (typeof format === "undefined") {\n    return "string";\n  }\n  // Cleanup and lowercase format\n  format = format.toLowerCase().replace(/^\\[[^\\]]*\\]/, "");\n  // Remove style tags\n  format = format.replace(/\\[[^\\]]+\\]/, "");\n  // Trim\n  format = format.trim();\n  // Check for any explicit format hints (i.e. /Date)\n  let hints = format.match(/\\/(date|number|duration)$/);\n  if (hints) {\n    return hints[1];\n  }\n  // Check for explicit hints\n  if (format === "number") {\n    return "number";\n  }\n  if (format === "date") {\n    return "date";\n  }\n  if (format === "duration") {\n    return "duration";\n  }\n  // Detect number formatting symbols\n  if (format.match(/[#0]/)) {\n    return "number";\n  }\n  // Detect date formatting symbols\n  if (format.match(/[ymwdhnsqaxkzgtei]/)) {\n    return "date";\n  }\n  // Nothing? Let\'s display as string\n  return "string";\n}\n/**\r\n * Cleans up format:\r\n * * Strips out formatter hints\r\n *\r\n * @ignore Exclude from docs\r\n * @param format  Format\r\n * @return Cleaned format\r\n */\nfunction cleanFormat(format) {\n  return format.replace(/\\/(date|number|duration)$/i, "");\n}\n/**\r\n * Strips all tags from the string.\r\n *\r\n * @param text  Source string\r\n * @return String without tags\r\n */\nfunction stripTags(text) {\n  return text ? text.replace(/<[^>]*>/g, "") : text;\n}\n/**\r\n * Removes new lines and tags from a string.\r\n *\r\n * @param text  String to conver\r\n * @return Converted string\r\n */\nfunction plainText(text) {\n  return text ? stripTags(("" + text).replace(/[\\n\\r]+/g, ". ")) : text;\n}\n/**\r\n * Escapes string so it can safely be used in a Regex.\r\n *\r\n * @param value  Unsescaped string\r\n * @return Escaped string\r\n */\nfunction escapeForRgex(value) {\n  return value.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \'\\\\$&\');\n}\n/**\r\n * Adds space before each uppercase letter.\r\n *\r\n * @param   str Input string\r\n * @return      Output string\r\n */\nfunction addSpacing(str) {\n  let result = "";\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charAt(i);\n    if (char.toUpperCase() == char && i != 0) {\n      result += " ";\n    }\n    result += char;\n  }\n  return result;\n}\n/**\r\n * Splits the string into separate characters. Keeps RTL words non-split.\r\n *\r\n * @param   source  Input\r\n * @return          Split text\r\n */\nfunction splitString(source) {\n  // Regular expression to identify RTL characters\n  const rtlChar = /[\\u0590-\\u05FF\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\uFB50-\\uFDFF\\uFE70-\\uFEFF]/;\n  // Regular expression to capture segments ending with specific Arabic characters\n  const splitPattern = /([^اأدذرزو]*[اأدذرزو])/gi;\n  // Split input string into array of words or characters, including whitespace\n  let segments = source.split(/(\\s+)/); // Split by whitespace, capturing it\n  let result = [];\n  segments.forEach(segment => {\n    if (segment.match(/^\\s+$/)) {\n      // If the segment is purely whitespace\n      if (segment = " ") {\n        segment = "  ";\n      }\n      result.push(segment);\n    } else if (rtlChar.test(segment)) {\n      // If the segment contains RTL characters, handle special splits\n      let parts = segment.split(splitPattern).filter(part => part !== \'\');\n      // Concatenate parts processed by the split pattern directly to result\n      result = result.concat(parts);\n    } else {\n      // Treat this segment as LTR: split into characters\n      result = result.concat([...segment]);\n    }\n  });\n  return result;\n}\n/**\r\n * ============================================================================\r\n * DATE-RELATED FUNCTIONS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Returns a year day.\r\n *\r\n * @param date  Date\r\n * @param utc   Assume UTC dates?\r\n * @return Year day\r\n * @todo Account for UTC\r\n */\nfunction getYearDay(date, utc = false) {\n  // TODO: utc needed?\n  utc;\n  const start = new Date(date.getFullYear(), 0, 0);\n  const diff = date.getTime() - start.getTime() + (start.getTimezoneOffset() - date.getTimezoneOffset()) * 60 * 1000;\n  const oneDay = 1000 * 60 * 60 * 24;\n  return Math.floor(diff / oneDay);\n}\n/**\r\n * Returns week number for a given date.\r\n *\r\n * @param date  Date\r\n * @param utc   Assume UTC dates?\r\n * @return Week number\r\n * @todo Account for UTC\r\n */\nfunction getWeek(date, _utc = false) {\n  const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));\n  const day = d.getUTCDay() || 7;\n  d.setUTCDate(d.getUTCDate() + 4 - day);\n  const firstDay = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));\n  return Math.ceil(((d.getTime() - firstDay.getTime()) / 86400000 + 1) / 7);\n}\n/**\r\n * Returns a "week year" of the given date.\r\n *\r\n * @param date  Date\r\n * @param utc   Assume UTC dates?\r\n * @return Year of week\r\n * @since 5.3.0\r\n * @todo Account for UTC\r\n */\nfunction getWeekYear(date, _utc = false) {\n  const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));\n  const day = d.getUTCDay() || 7;\n  d.setUTCDate(d.getUTCDate() + 4 - day);\n  const firstDay = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));\n  return firstDay.getFullYear();\n}\n/**\r\n * Returns a week number in the month.\r\n *\r\n * @param date  Source Date\r\n * @param utc   Assume UTC dates?\r\n * @return Week number in month\r\n */\nfunction getMonthWeek(date, utc = false) {\n  const firstWeek = getWeek(new Date(date.getFullYear(), date.getMonth(), 1), utc);\n  let currentWeek = getWeek(date, utc);\n  if (currentWeek == 1) {\n    currentWeek = 53;\n  }\n  return currentWeek - firstWeek + 1;\n}\n/**\r\n * Returns a year day out of the given week number.\r\n *\r\n * @param week     Week\r\n * @param year     Year\r\n * @param weekday  Weekday\r\n * @param utc      Assume UTC dates\r\n * @return Day in a year\r\n */\nfunction getDayFromWeek(week, year, weekday = 1, utc = false) {\n  let date = new Date(year, 0, 4, 0, 0, 0, 0);\n  if (utc) {\n    date.setUTCFullYear(year);\n  }\n  let day = week * 7 + weekday - ((date.getDay() || 7) + 3);\n  return day;\n}\n/**\r\n * Returns 12-hour representation out of the 24-hour hours.\r\n *\r\n * @param hours  24-hour number\r\n * @return 12-hour number\r\n */\nfunction get12Hours(hours, base) {\n  if (hours > 12) {\n    hours -= 12;\n  } else if (hours === 0) {\n    hours = 12;\n  }\n  return base != null ? hours + (base - 1) : hours;\n}\n/**\r\n * Returns a string name of the time zone.\r\n *\r\n * @param date     Date object\r\n * @param long     Should return long ("Pacific Standard Time") or short abbreviation ("PST")\r\n * @param savings  Include information if it\'s in daylight savings mode\r\n * @param utc      Assume UTC dates\r\n * @return Time zone name\r\n */\nfunction getTimeZone(date, long = false, savings = false, utc = false, timezone) {\n  if (utc) {\n    return long ? "Coordinated Universal Time" : "UTC";\n  } else if (timezone) {\n    const d1 = date.toLocaleString("en-US", {\n      timeZone: timezone\n    });\n    const d2 = date.toLocaleString("en-US", {\n      timeZone: timezone,\n      timeZoneName: long ? "long" : "short"\n    });\n    return Utils_trim(d2.substr(d1.length));\n  }\n  let wotz = date.toLocaleString("UTC");\n  let wtz = date.toLocaleString("UTC", {\n    timeZoneName: long ? "long" : "short"\n  }).substr(wotz.length);\n  //wtz = wtz.replace(/[+-]+[0-9]+$/, "");\n  if (savings === false) {\n    wtz = wtz.replace(/ (standard|daylight|summer|winter) /i, " ");\n  }\n  return Utils_trim(wtz);\n}\nfunction getTimezoneOffset(timezone) {\n  const date = new Date(Date.UTC(2012, 0, 1, 0, 0, 0, 0));\n  const utcDate = new Date(date.toLocaleString("en-US", {\n    timeZone: "UTC"\n  }));\n  const tzDate = new Date(date.toLocaleString("en-US", {\n    timeZone: timezone\n  }));\n  return (tzDate.getTime() - utcDate.getTime()) / 6e4 * -1;\n}\nfunction capitalizeFirst(text) {\n  return text.charAt(0).toUpperCase() + text.slice(1);\n}\n/**\r\n * The functions below are taken and adapted from Garry Tan\'s blog post:\r\n * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c\r\n *\r\n * The further attributions go mjijackson.com, which now seems to be defunct.\r\n */\n/**\r\n * Converts an HSL color value to RGB. Conversion formula\r\n * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\r\n * Assumes h, s, and l are contained in the set [0, 1] and\r\n * returns r, g, and b in the set [0, 255].\r\n *\r\n * Function adapted from:\r\n * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c\r\n *\r\n * @param h       The hue\r\n * @param s       The saturation\r\n * @param l       The lightness\r\n * @return The RGB representation\r\n */\nfunction hslToRgb(color) {\n  let r, g, b;\n  let h = color.h;\n  let s = color.s;\n  let l = color.l;\n  if (s == 0) {\n    r = g = b = l; // achromatic\n  } else {\n    let hue2rgb = function hue2rgb(p, q, t) {\n      if (t < 0) {\n        t += 1;\n      }\n      if (t > 1) {\n        t -= 1;\n      }\n      if (t < 1 / 6) {\n        return p + (q - p) * 6 * t;\n      }\n      if (t < 1 / 2) {\n        return q;\n      }\n      if (t < 2 / 3) {\n        return p + (q - p) * (2 / 3 - t) * 6;\n      }\n      return p;\n    };\n    let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    let p = 2 * l - q;\n    r = hue2rgb(p, q, h + 1 / 3);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1 / 3);\n  }\n  return {\n    r: Math.round(r * 255),\n    g: Math.round(g * 255),\n    b: Math.round(b * 255)\n  };\n}\n/**\r\n * Converts an RGB color value to HSL. Conversion formula\r\n * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\r\n * Assumes r, g, and b are contained in the set [0, 255] and\r\n * returns h, s, and l in the set [0, 1].\r\n *\r\n * Function adapted from:\r\n * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c\r\n *\r\n * @param r       The red color value\r\n * @param g       The green color value\r\n * @param b       The blue color value\r\n * @return The HSL representation\r\n */\nfunction rgbToHsl(color) {\n  let r = color.r / 255;\n  let g = color.g / 255;\n  let b = color.b / 255;\n  let max = Math.max(r, g, b);\n  let min = Math.min(r, g, b);\n  let h = 0;\n  let s = 0;\n  let l = (max + min) / 2;\n  if (max === min) {\n    h = s = 0; // achromatic\n  } else {\n    let d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0);\n        break;\n      case g:\n        h = (b - r) / d + 2;\n        break;\n      case b:\n        h = (r - g) / d + 4;\n        break;\n    }\n    h /= 6;\n  }\n  return {\n    h: h,\n    s: s,\n    l: l\n  };\n}\n/**\r\n * Converts HSV to HSL.\r\n *\r\n * https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL\r\n */\nfunction hsvToHsl(hsv) {\n  const l = hsv.v * (1 - hsv.s / 2);\n  const s = l === 0 || l === 1 ? 0 : (hsv.v - l) / Math.min(l, 1 - l);\n  return {\n    h: hsv.h,\n    s,\n    l,\n    a: hsv.a\n  };\n}\n/**\r\n * Converts HSL to HSV.\r\n *\r\n * https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV\r\n */\nfunction hslToHsv(hsl) {\n  const v = hsl.l + hsl.s * Math.min(hsl.l, 1 - hsl.l);\n  const s = v === 0 ? 0 : 2 * (1 - hsl.l / v);\n  return {\n    h: hsl.h,\n    s,\n    v,\n    a: hsl.a\n  };\n}\n/**\r\n * Returns a color that is `percent` brighter than the reference color.\r\n *\r\n * @param color    Reference color\r\n * @param percent  Brightness percent\r\n * @return Hex code of the new color\r\n */\nfunction lighten(rgb, percent) {\n  if (rgb) {\n    return {\n      r: Math.max(0, Math.min(255, rgb.r + getLightnessStep(rgb.r, percent))),\n      g: Math.max(0, Math.min(255, rgb.g + getLightnessStep(rgb.g, percent))),\n      b: Math.max(0, Math.min(255, rgb.b + getLightnessStep(rgb.b, percent))),\n      a: rgb.a\n    };\n  } else {\n    // TODO is this correct ?\n    return rgb;\n  }\n}\n;\n/**\r\n * Gets lightness step.\r\n *\r\n * @param value    Value\r\n * @param percent  Percent\r\n * @return Step\r\n */\nfunction getLightnessStep(value, percent) {\n  let base = percent > 0 ? 255 - value : value;\n  return Math.round(base * percent);\n}\n/**\r\n * Returns a color that is `percent` brighter than the source `color`.\r\n *\r\n * @param color    Source color\r\n * @param percent  Brightness percent\r\n * @return New color\r\n */\nfunction brighten(rgb, percent) {\n  if (rgb) {\n    let base = Math.min(Math.max(rgb.r, rgb.g, rgb.b), 230);\n    //let base = Math.max(rgb.r, rgb.g, rgb.b);\n    let step = getLightnessStep(base, percent);\n    return {\n      r: Math.max(0, Math.min(255, Math.round(rgb.r + step))),\n      g: Math.max(0, Math.min(255, Math.round(rgb.g + step))),\n      b: Math.max(0, Math.min(255, Math.round(rgb.b + step))),\n      a: rgb.a\n    };\n  } else {\n    // TODO is this correct ?\n    return rgb;\n  }\n}\n;\n/**\r\n * Returns brightness step.\r\n *\r\n * @ignore Exclude from docs\r\n * @param value    Value\r\n * @param percent  Percent\r\n * @return Step\r\n */\nfunction getBrightnessStep(_value, percent) {\n  let base = 255; //percent > 0 ? 255 - value : value;\n  return Math.round(base * percent);\n}\n/**\r\n * Returns `true` if color is "light". Useful indetermining which contrasting\r\n * color to use for elements over this color. E.g.: you would want to use\r\n * black text over light background, and vice versa.\r\n *\r\n * @param color  Source color\r\n * @return Light?\r\n */\nfunction isLight(color) {\n  return (color.r * 299 + color.g * 587 + color.b * 114) / 1000 >= 128;\n}\n/**\r\n * Returns a new [[iRGB]] object based on `rgb` parameter with specific\r\n * saturation applied.\r\n *\r\n * `saturation` can be in the range of 0 (fully desaturated) to 1 (fully\r\n * saturated).\r\n *\r\n * @param color       Base color\r\n * @param saturation  Saturation (0-1)\r\n * @return New color\r\n */\nfunction saturate(rgb, saturation) {\n  if (rgb === undefined || saturation == 1) {\n    return rgb;\n  }\n  let hsl = rgbToHsl(rgb);\n  hsl.s = saturation;\n  return hslToRgb(hsl);\n}\n/**\r\n * Returns a color which contrasts more with the source `color`.\r\n *\r\n * @param  color             Base color\r\n * @param  lightAlternative  Light option\r\n * @param  darkAlternative   Dark option\r\n * @return New color\r\n */\nfunction alternativeColor(color, lightAlternative = {\n  r: 255,\n  g: 255,\n  b: 255\n}, darkAlternative = {\n  r: 255,\n  g: 255,\n  b: 255\n}) {\n  let light = lightAlternative;\n  let dark = darkAlternative;\n  if (isLight(darkAlternative)) {\n    light = darkAlternative;\n    dark = lightAlternative;\n  }\n  return isLight(color) ? dark : light;\n}\n/**\r\n * @ignore\r\n */\nfunction mergeTags(tags1, tags2) {\n  if (!tags1) {\n    tags1 = [];\n  }\n  return [...tags1, ...tags2].filter((value, index, self) => {\n    return self.indexOf(value) === index;\n  });\n}\n/**\r\n * @ignore\r\n */\nfunction sameBounds(a, b) {\n  if (!b) {\n    return false;\n  }\n  if (a.left != b.left) {\n    return false;\n  }\n  if (a.right != b.right) {\n    return false;\n  }\n  if (a.top != b.top) {\n    return false;\n  }\n  if (a.bottom != b.bottom) {\n    return false;\n  }\n  return true;\n}\n;// CONCATENATED MODULE: ./node_modules/tslib/tslib.es6.mjs\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== "function" && b !== null)\n      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === "function")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nfunction __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }\n  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";\n  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === "accessor") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== "object") throw new TypeError("Object expected");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === "field") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nfunction __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nfunction __propKey(x) {\n  return typeof x === "symbol" ? x : "".concat(x);\n};\n\nfunction __setFunctionName(f, name, prefix) {\n  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";\n  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });\n};\n\nfunction __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError("Generator is already executing.");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nfunction __exportStar(m, o) {\n  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nfunction __values(o) {\n  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === "number") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === "function" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i["return"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume("next", value); }\n  function reject(value) { resume("throw", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nfunction __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n  o["default"] = v;\n};\n\nfunction __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nfunction __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");\n  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");\n  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === "m") throw new TypeError("Private method is not writable");\n  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");\n  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");\n  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nfunction __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use \'in\' operator on non-object");\n  return typeof state === "function" ? receiver === state : state.has(receiver);\n}\n\nfunction __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");\n    var dispose;\n    if (async) {\n        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");\n        dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");\n        dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;\n};\n\nfunction __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;\n    env.hasError = true;\n  }\n  function next() {\n    while (env.stack.length) {\n      var rec = env.stack.pop();\n      try {\n        var result = rec.dispose && rec.dispose.call(rec.value);\n        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n      }\n      catch (e) {\n          fail(e);\n      }\n    }\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\n/* harmony default export */ const tslib_es6 = ({\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n});\n\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Represents a relative value (percent).\r\n *\r\n * The Percent object, can be instantiated using two ways:\r\n *\r\n * * Via `new Percent(X)`.\r\n * * Via `am5.percent(X)`.\r\n *\r\n * You can also use shortcut functions for `0%`, `50%`, and `100%`:\r\n * * `am5.p0`\r\n * * `am5.p50`\r\n * * `am5.p100`\r\n */\nclass Percent {\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param percent  Percent value\r\n   */\n  constructor(percent) {\n    /**\r\n     * Value in percent.\r\n     */\n    Object.defineProperty(this, "_value", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._value = percent;\n  }\n  /**\r\n   * Relative value.\r\n   *\r\n   * E.g. 100% is 1, 50% is 0.5, etc.\r\n   *\r\n   * This is useful to apply transformations to other values. E.g.:\r\n   *\r\n   * ```TypeScript\r\n   * let value = 256;\r\n   * let percent = new am5.p50;\r\n   * console.log(value * percent.value); // outputs 128\r\n   * ```\r\n   * ```JavaScript\r\n   * var value = 256;\r\n   * var percent = new am5.p50;\r\n   * console.log(value * percent.value); // outputs 128\r\n   * ```\r\n   *\r\n   * Alternatively, you can use `am5.percent()` helper function:\r\n   *\r\n   * ```TypeScript\r\n   * let value = 256;\r\n   * let percent = am5.p50;\r\n   * console.log(value * percent.value); // outputs 128\r\n   * ```\r\n   * ```JavaScript\r\n   * var value = 256;\r\n   * var percent = am5.p50;\r\n   * console.log(value * percent.value); // outputs 128\r\n   * ```\r\n   *\r\n   * @readonly\r\n   * @return Relative value\r\n   */\n  get value() {\n    return this._value / 100;\n  }\n  /**\r\n   * Value in percent.\r\n   *\r\n   * @readonly\r\n   * @return Percent\r\n   */\n  get percent() {\n    return this._value;\n  }\n  toString() {\n    return "" + this._value + "%";\n  }\n  interpolate(min, max) {\n    return min + this.value * (max - min);\n  }\n  static normalize(percent, min, max) {\n    if (percent instanceof Percent) {\n      return percent;\n    } else {\n      if (min === max) {\n        return new Percent(0);\n      } else {\n        return new Percent(Math.min(Math.max((percent - min) * (1 / (max - min)), 0), 1) * 100);\n      }\n    }\n  }\n}\n/**\r\n * Converts numeric percent value to a proper [[Percent]] object.\r\n *\r\n * ```TypeScript\r\n * pieSeries.set("radius", am5.percent(80));\r\n * ```\r\n * ```JavaScript\r\n * pieSeries.set("radius", am5.percent(80));\r\n * ```\r\n *\r\n * @param value  Percent\r\n * @return Percent object\r\n */\nfunction percent(value) {\n  return new Percent(value);\n}\n/**\r\n * A shortcut function to `am5.percent(0)`.\r\n */\nconst p0 = percent(0);\n/**\r\n * A shortcut function to `am5.percent(100)`.\r\n */\nconst p100 = percent(100);\n/**\r\n * A shortcut function to `am5.percent(50)`.\r\n */\nconst p50 = percent(50);\n/**\r\n * Checks if value is a [[Percent]] object.\r\n *\r\n * @ignore Exclude from docs\r\n * @param value  Input value\r\n * @return Is percent?\r\n */\nfunction isPercent(value) {\n  return value instanceof Percent;\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js\n\n\n\n/**\r\n * @ignore\r\n */\nfunction string2hex(string) {\n  //string = cssColorNames[string.toLowerCase()] || string;\n  if (string[0] === "#") {\n    string = string.substr(1);\n  }\n  if (string.length == 3) {\n    string = string[0].repeat(2) + string[1].repeat(2) + string[2].repeat(2);\n  }\n  return parseInt(string, 16);\n}\n/**\r\n * @ignore\r\n */\nfunction rgba2hex(color) {\n  color = color.replace(/[ ]/g, "");\n  // Init\n  let matches = color.match(/^rgb\\(([0-9]*),([0-9]*),([0-9]*)\\)/i);\n  // Try rgb() format\n  if (matches) {\n    matches.push("1");\n  } else {\n    matches = color.match(/^rgba\\(([0-9]*),([0-9]*),([0-9]*),([.0-9]*)\\)/i);\n    if (!matches) {\n      return 0x000000;\n    }\n  }\n  let hex = "";\n  for (let i = 1; i <= 3; i++) {\n    let val = parseInt(matches[i]).toString(16);\n    if (val.length == 1) {\n      val = "0" + val;\n    }\n    hex += val;\n  }\n  return string2hex(hex);\n}\n/**\r\n * Returns a new [[Color]] object base on input.\r\n *\r\n * Accepts parameters in CSS hex or rgb/rtba strings, or hex numbers.\r\n *\r\n * * `"#f00"`\r\n * * `"#ff0000"`\r\n * * `"rgb(255, 0, 0)"`\r\n * * `"rgba(255, 0, 0, 1)"`\r\n * * `0xff0000`\r\n *\r\n * @param   input  Input color\r\n * @return         Color\r\n */\nfunction color(input) {\n  return Color.fromAny(input);\n}\n/**\r\n * Wherever color needs to be specified in amCharts 5, `Color` object needs to\r\n * be used.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/} for more info\r\n * @important\r\n */\nclass Color {\n  constructor(hex) {\n    Object.defineProperty(this, "_hex", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._hex = hex | 0;\n  }\n  /**\r\n   * Color numeric value.\r\n   */\n  get hex() {\n    return this._hex;\n  }\n  /**\r\n   * Value of color\'s R channel.\r\n   * @return R value\r\n   */\n  get r() {\n    return this._hex >>> 16;\n  }\n  /**\r\n   * Value of color\'s G channel.\r\n   * @return G value\r\n   */\n  get g() {\n    return this._hex >> 8 & 0xFF;\n  }\n  /**\r\n   * Value of color\'s B channel.\r\n   * @return B value\r\n   */\n  get b() {\n    return this._hex & 0xFF;\n  }\n  /**\r\n   * Returns color CSS representation in form of `rgba(r, g, b, a)` string.\r\n   *\r\n   * @param   alpha  Opacity\r\n   * @return         CSS string\r\n   */\n  toCSS(alpha = 1) {\n    return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + alpha + ")";\n  }\n  /**\r\n   * Returns color CSS representation in form of `#rgb` string.\r\n   *\r\n   * @return         CSS string\r\n   */\n  toCSSHex() {\n    return "#" + padString(this.r.toString(16), 2) + padString(this.g.toString(16), 2) + padString(this.b.toString(16), 2);\n  }\n  /**\r\n   * Returns color\'s HSL info.\r\n   * @param   alpha Opacity\r\n   * @return        HSL info\r\n   */\n  toHSL(alpha = 1) {\n    return rgbToHsl({\n      r: this.r,\n      g: this.g,\n      b: this.b,\n      a: alpha\n    });\n  }\n  /**\r\n   * Converts HSL values into a new [[Color]] object.\r\n   *\r\n   * @param   h H value\r\n   * @param   s S value\r\n   * @param   l L value\r\n   * @return    Color object\r\n   */\n  static fromHSL(h, s, l) {\n    const rgb = hslToRgb({\n      h: h,\n      s: s,\n      l: l\n    });\n    return this.fromRGB(rgb.r, rgb.g, rgb.b);\n  }\n  toString() {\n    return this.toCSSHex();\n  }\n  /**\r\n   * Converts hex number into a new [[Color]] object.\r\n   *\r\n   * ```TypeScript\r\n   * Color.fromHex(0xff0000) // red\r\n   * ```\r\n   * ```JavaScript\r\n   * Color.fromHex(0xff0000) // red\r\n   * ```\r\n   *\r\n   * @param   hex  Hex color\r\n   * @return       Color\r\n   */\n  static fromHex(hex) {\n    return new Color(hex);\n  }\n  /**\r\n   * Converts RGB values to a new [[Color]] object.\r\n   *\r\n   * @param   r  R value\r\n   * @param   g  G value\r\n   * @param   b  B value\r\n   * @return     Color\r\n   */\n  static fromRGB(r, g, b) {\n    return new Color((b | 0) + (g << 8) + (r << 16));\n  }\n  /**\r\n   * Converts RGB string to a new [[Color]] object.\r\n   *\r\n   * ```TypeScript\r\n   * Color.fromString("#ff0000") // red\r\n   * ```\r\n   * ```JavaScript\r\n   * Color.fromString("#ff0000") // red\r\n   * ```\r\n   *\r\n   * @param   s  RGB string\r\n   * @return     Color\r\n   */\n  static fromString(s) {\n    return new Color(string2hex(s));\n  }\n  /**\r\n   * Converts CSS rgba() syntax to a new [[Color]] object.\r\n   *\r\n   * ```TypeScript\r\n   * Color.fromCSS("rgba(255, 0, 0, 1)") // red\r\n   * ```\r\n   * ```JavaScript\r\n   * Color.fromCSS("rgba(255, 0, 0, 1)") // red\r\n   * ```\r\n   *\r\n   * @param  {string} s [description]\r\n   * @return {Color}    [description]\r\n   */\n  static fromCSS(s) {\n    return new Color(rgba2hex(s));\n  }\n  /**\r\n   * Convert to color from virtually anything.\r\n   *\r\n   * Will throw an exception if unable to resolve the color.\r\n   *\r\n   * @param   s  Source\r\n   * @return     Color\r\n   */\n  static fromAny(s) {\n    if (Type_isString(s)) {\n      if (s[0] == "#") {\n        return Color.fromString(s);\n      } else if (s.substr(0, 3) == "rgb") {\n        return Color.fromCSS(s);\n      }\n    } else if (Type_isNumber(s)) {\n      return Color.fromHex(s);\n    } else if (s instanceof Color) {\n      return Color.fromHex(s.hex);\n    }\n    throw new Error("Unknown color syntax: " + s);\n  }\n  /**\r\n   * Returns a new [[Color]] object based on either `lightAlternative` or\r\n   * `darkAlternative` depending on which one is more contrasting with\r\n   * the `color`.\r\n   *\r\n   * @param   color             Reference color\r\n   * @param   lightAlternative  Light color\r\n   * @param   darkAlternative   Dark color\r\n   * @return                    Alternative color\r\n   */\n  static alternative(color, lightAlternative, darkAlternative) {\n    const rgb = alternativeColor({\n      r: color.r,\n      g: color.g,\n      b: color.b\n    }, lightAlternative ? {\n      r: lightAlternative.r,\n      g: lightAlternative.g,\n      b: lightAlternative.b\n    } : undefined, darkAlternative ? {\n      r: darkAlternative.r,\n      g: darkAlternative.g,\n      b: darkAlternative.b\n    } : undefined);\n    return this.fromRGB(rgb.r, rgb.g, rgb.b);\n  }\n  /**\r\n   * Returns an intermediate Color between two reference colors depending on\r\n   * the progress (`diff`) between the two.\r\n   *\r\n   * @param   diff  Progress\r\n   * @param   from  Source color\r\n   * @param   to    Target color\r\n   * @param   mode  Interpolation mode\r\n   * @return        Color\r\n   */\n  static interpolate(diff, from, to, mode = "rgb") {\n    if (mode == "hsl") {\n      const fromHSL = from.toHSL();\n      const toHSL = to.toHSL();\n      return Color.fromHSL(Animation_range(diff, fromHSL.h, toHSL.h), Animation_range(diff, fromHSL.s, toHSL.s), Animation_range(diff, fromHSL.l, toHSL.l));\n    } else {\n      return Color.fromRGB(Animation_range(diff, from.r, to.r), Animation_range(diff, from.g, to.g), Animation_range(diff, from.b, to.b));\n    }\n  }\n  /**\r\n   * Returns a new [[Color]] lightened by `percent` value.\r\n   *\r\n   * Use negative value to darken the color.\r\n   *\r\n   * @param   color    Source color\r\n   * @param   percent  Percent\r\n   * @return           New color\r\n   */\n  static lighten(color, percent) {\n    const rgb = lighten({\n      r: color.r,\n      g: color.g,\n      b: color.b\n    }, percent);\n    return Color.fromRGB(rgb.r, rgb.g, rgb.b);\n  }\n  /**\r\n   * Returns a new [[Color]] brightened by `percent` value.\r\n   *\r\n   * Use negative value to dim the color.\r\n   *\r\n   * @param   color    Source color\r\n   * @param   percent  Percent\r\n   * @return           New color\r\n   */\n  static brighten(color, percent) {\n    const rgb = brighten({\n      r: color.r,\n      g: color.g,\n      b: color.b\n    }, percent);\n    return Color.fromRGB(rgb.r, rgb.g, rgb.b);\n  }\n  /**\r\n   * Returns a new [[Color]] saturated by `percent` value.\r\n   *\r\n   * Value range is between `0` (fully desaturated), to `1` (full color).\r\n   *\r\n   * @param   color    Source color\r\n   * @param   percent  Percent\r\n   * @return           New color\r\n   */\n  static saturate(color, percent) {\n    const rgb = saturate({\n      r: color.r,\n      g: color.g,\n      b: color.b\n    }, percent);\n    return Color.fromRGB(rgb.r, rgb.g, rgb.b);\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js\n\nfunction keys(object) {\n  return Object.keys(object);\n}\n/**\r\n * Returns an array of object\'s property names ordered using specific ordering\r\n * function.\r\n *\r\n * @param object  Source object\r\n * @param order   Ordering function\r\n * @returns Object property names\r\n */\nfunction keysOrdered(object, order) {\n  return keys(object).sort(order);\n}\nfunction Object_copy(object) {\n  return Object.assign({}, object);\n}\nfunction Object_each(object, f) {\n  keys(object).forEach(key => {\n    f(key, object[key]);\n  });\n}\n/**\r\n * Iterates through all properties of the object calling `fn` for each of them.\r\n *\r\n * If return value of the function evaluates to `false` further iteration is\r\n * cancelled.\r\n *\r\n * @param object  Source object\r\n * @param fn      Callback function\r\n */\nfunction Object_eachContinue(object, fn) {\n  for (let key in object) {\n    if (hasKey(object, key)) {\n      if (!fn(key, object[key])) {\n        break;\n      }\n    }\n  }\n}\n/**\r\n * Orders object properties using custom `ord` function and iterates through\r\n * them calling `fn` for each of them.\r\n *\r\n * @param object  Source object\r\n * @param fn      Callback function\r\n * @param order   Ordering function\r\n */\nfunction eachOrdered(object, fn, ord) {\n  $array.each(keysOrdered(object, ord), key => {\n    fn(key, object[key]);\n  });\n}\n/**\r\n * Checks if `object` has a specific `key`.\r\n *\r\n * @param object  Source object\r\n * @param key     Property name\r\n * @returns Has key?\r\n */\nfunction hasKey(object, key) {\n  return {}.hasOwnProperty.call(object, key);\n}\n/**\r\n * Copies all properties of one object to the other, omitting undefined, but only if property in target object doesn\'t have a value set.\r\n *\r\n * @param fromObject  Source object\r\n * @param toObject    Target object\r\n * @return Updated target object\r\n * @todo Maybe consolidate with utils.copy?\r\n */\nfunction softCopyProperties(source, target) {\n  Object_each(source, (key, value) => {\n    // only if value is set\n    //if ($type.hasValue(value) && !($type.hasValue((<any>target)[key]))) {\n    if (value != null && target[key] == null) {\n      target[key] = value;\n    }\n  });\n  return target;\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js\n\n\n\n\n\n/**\r\n * @ignore\r\n */\nfunction waitForAnimations(animations) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (animations !== undefined) {\n      const promises = [];\n      Object_each(animations, (_, animation) => {\n        promises.push(animation.waitForStop());\n      });\n      yield Promise.all(promises);\n    }\n  });\n}\n/**\r\n * @ignore\r\n */\nfunction normalize(value, min, max) {\n  if (min === max) {\n    return 0;\n  } else {\n    return Math.min(Math.max((value - min) * (1 / (max - min)), 0), 1);\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction Animation_range(diff, from, to) {\n  return from + diff * (to - from);\n}\n/**\r\n * @ignore\r\n */\nfunction defaultInterpolate(diff, from, to) {\n  if (diff >= 1) {\n    return to;\n  } else {\n    return from;\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction percentInterpolate(diff, from, to) {\n  return new Percent(Animation_range(diff, from.percent, to.percent));\n}\n/**\r\n * @ignore\r\n */\nfunction colorInterpolate(diff, from, to) {\n  return Color.interpolate(diff, from, to);\n}\n/**\r\n * @ignore\r\n */\nfunction getInterpolate(from, to) {\n  if (typeof from === "number" && typeof to === "number") {\n    return Animation_range;\n  }\n  if (from instanceof Percent && to instanceof Percent) {\n    return percentInterpolate;\n  }\n  if (from instanceof Color && to instanceof Color) {\n    return colorInterpolate;\n  }\n  return defaultInterpolate;\n}\nvar AnimationState;\n(function (AnimationState) {\n  AnimationState[AnimationState["Stopped"] = 0] = "Stopped";\n  AnimationState[AnimationState["Playing"] = 1] = "Playing";\n  AnimationState[AnimationState["Paused"] = 2] = "Paused";\n})(AnimationState || (AnimationState = {}));\n/**\r\n * @ignore\r\n */\nclass AnimationTime {\n  constructor(entity, duration) {\n    Object.defineProperty(this, "_entity", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_duration", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_playingDuration", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, "_startingTime", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, "_current", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_from", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_to", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "events", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new EventDispatcher()\n    });\n    Object.defineProperty(this, "easing", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._entity = entity;\n    this._duration = duration;\n  }\n  _stopEvent() {\n    const type = "stopped";\n    if (this.events.isEnabled(type)) {\n      this.events.dispatch(type, {\n        type: type,\n        target: this\n      });\n    }\n  }\n  _runAnimation(currentTime) {\n    if (this._playingDuration !== null) {\n      if (this._startingTime === null) {\n        this._startingTime = currentTime;\n        return AnimationState.Playing;\n      } else {\n        const diff = (currentTime - this._startingTime) / this._playingDuration;\n        if (diff >= 1) {\n          this._playingDuration = null;\n          this._startingTime = null;\n          this._from = this._to;\n          this._current = this._to;\n          this._entity.markDirty();\n          this._stopEvent();\n          const type = "ended";\n          if (this.events.isEnabled(type)) {\n            this.events.dispatch(type, {\n              type: type,\n              target: this\n            });\n          }\n          return AnimationState.Stopped;\n        } else {\n          this._current = Animation_range(diff, this._from, this._to);\n          this._entity.markDirty();\n          const type = "progress";\n          if (this.events.isEnabled(type)) {\n            this.events.dispatch(type, {\n              type: type,\n              target: this,\n              progress: diff\n            });\n          }\n          return AnimationState.Playing;\n        }\n      }\n    } else {\n      return AnimationState.Stopped;\n    }\n  }\n  _play() {\n    this._from = this._current;\n    if (this._playingDuration === null) {\n      this._entity._root._addAnimation(this);\n      const type = "started";\n      if (this.events.isEnabled(type)) {\n        this.events.dispatch(type, {\n          type: type,\n          target: this\n        });\n      }\n    } else {\n      this._startingTime = null;\n    }\n    this._playingDuration = Math.abs(this._to - this._from) * this._duration;\n  }\n  get duration() {\n    return this._duration;\n  }\n  set duration(value) {\n    if (this._duration !== value) {\n      this._duration = value;\n      if (value === 0) {\n        this.jumpTo(this._to);\n      } else if (this._current !== this._to) {\n        this._play();\n      }\n    }\n  }\n  get current() {\n    if (this.easing) {\n      return this.easing(this._current);\n    } else {\n      return this._current;\n    }\n  }\n  stop() {\n    this.jumpTo(this._current);\n  }\n  jumpTo(value) {\n    if (this._current !== value) {\n      this._entity.markDirty();\n    }\n    if (this._playingDuration !== null) {\n      this._stopEvent();\n    }\n    this._playingDuration = null;\n    this._startingTime = null;\n    this._current = value;\n    this._from = value;\n    this._to = value;\n  }\n  tweenTo(value) {\n    if (this._current === value || this._duration === 0) {\n      this.jumpTo(value);\n    } else {\n      if (this._to !== value) {\n        this._to = value;\n        this._play();\n      }\n    }\n  }\n}\n/*export class AnimationValue extends AnimationTime {\r\n    public _min: number;\r\n    public _max: number;\r\n\r\n    constructor(entity: Entity, duration: number, min: number, max: number) {\r\n        super(entity, duration);\r\n        this._min = min;\r\n        this._max = max;\r\n    }\r\n\r\n    public get min(): number {\r\n        return this._min;\r\n    }\r\n\r\n    public set min(value: number) {\r\n        if (this._min !== value) {\r\n            this._min = value;\r\n            this._entity.markDirty();\r\n        }\r\n    }\r\n\r\n    public get max(): number {\r\n        return this._max;\r\n    }\r\n\r\n    public set max(value: number) {\r\n        if (this._max !== value) {\r\n            this._max = value;\r\n            this._entity.markDirty();\r\n        }\r\n    }\r\n\r\n    public currentValue(): number {\r\n        return range(super.currentTime(), this._min, this._max);\r\n    }\r\n\r\n    public jumpToValue(value: number) {\r\n        super.jumpToTime(normalize(value, this._min, this._max));\r\n    }\r\n\r\n    public tweenToValue(value: number) {\r\n        super.tweenToTime(normalize(value, this._min, this._max));\r\n    }\r\n}\r\n*/\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js\n/**\r\n * Event Dispatcher module is used for registering listeners and dispatching\r\n * events across amCharts system.\r\n */\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n\n\n/**\r\n * Universal Event Dispatcher.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info\r\n */\nclass EventDispatcher_EventDispatcher {\n  /**\r\n   * Constructor\r\n   */\n  constructor() {\n    Object.defineProperty(this, "_listeners", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_killed", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_disabled", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_iterating", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_enabled", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_disposed", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._listeners = [];\n    this._killed = [];\n    this._disabled = {};\n    this._iterating = 0;\n    this._enabled = true;\n    this._disposed = false;\n  }\n  /**\r\n   * Returns if this object has been already disposed.\r\n   *\r\n   * @return Disposed?\r\n   */\n  isDisposed() {\n    return this._disposed;\n  }\n  /**\r\n   * Dispose (destroy) this object.\r\n   */\n  dispose() {\n    if (!this._disposed) {\n      this._disposed = true;\n      const a = this._listeners;\n      this._iterating = 1;\n      this._listeners = null;\n      this._disabled = null;\n      try {\n        each(a, x => {\n          x.disposer.dispose();\n        });\n      } finally {\n        this._killed = null;\n        this._iterating = null;\n      }\n    }\n  }\n  /**\r\n   * Checks if this particular event dispatcher has any listeners set.\r\n   *\r\n   * @return Has listeners?\r\n   */\n  hasListeners() {\n    return this._listeners.length !== 0;\n  }\n  /**\r\n   * Checks if this particular event dispatcher has any particular listeners set.\r\n   *\r\n   * @return Has particular event listeners?\r\n   */\n  hasListenersByType(type) {\n    return any(this._listeners, x => (x.type === null || x.type === type) && !x.killed);\n  }\n  /**\r\n   * Enable dispatching of events if they were previously disabled by\r\n   * `disable()`.\r\n   */\n  enable() {\n    this._enabled = true;\n  }\n  /**\r\n   * Disable dispatching of events until re-enabled by `enable()`.\r\n   */\n  disable() {\n    this._enabled = false;\n  }\n  /**\r\n   * Enable dispatching particular event, if it was disabled before by\r\n   * `disableType()`.\r\n   *\r\n   * @param type Event type\r\n   */\n  enableType(type) {\n    delete this._disabled[type];\n  }\n  /**\r\n   * Disable dispatching of events for a certain event type.\r\n   *\r\n   * Optionally, can set how many dispatches to skip before automatically\r\n   * re-enabling the dispatching.\r\n   *\r\n   * @param type    Event type\r\n   * @param amount  Number of event dispatches to skip\r\n   */\n  disableType(type, amount = Infinity) {\n    this._disabled[type] = amount;\n  }\n  /**\r\n   * Removes listener from dispatcher.\r\n   *\r\n   * Will throw an exception if such listener does not exists.\r\n   *\r\n   * @param listener Listener to remove\r\n   */\n  _removeListener(listener) {\n    if (this._iterating === 0) {\n      const index = this._listeners.indexOf(listener);\n      if (index === -1) {\n        throw new Error("Invalid state: could not remove listener");\n      }\n      this._listeners.splice(index, 1);\n    } else {\n      this._killed.push(listener);\n    }\n  }\n  /**\r\n   * Removes existing listener by certain parameters.\r\n   *\r\n   * @param once         Listener\'s once setting\r\n   * @param type         Listener\'s type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   */\n  _removeExistingListener(once, type, callback, context) {\n    if (this._disposed) {\n      throw new Error("EventDispatcher is disposed");\n    }\n    this._eachListener(info => {\n      if (info.once === once &&\n      // TODO is this correct ?\n      info.type === type && (callback === undefined || info.callback === callback) && info.context === context) {\n        info.disposer.dispose();\n      }\n    });\n  }\n  /**\r\n   * Checks if dispatching for particular event type is enabled.\r\n   *\r\n   * @param type  Event type\r\n   * @return Enabled?\r\n   */\n  isEnabled(type) {\n    if (this._disposed) {\n      throw new Error("EventDispatcher is disposed");\n    }\n    // TODO is this check correct ?\n    return this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] === undefined;\n  }\n  /**\r\n   * Removes all listeners of a particular event type\r\n   *\r\n   * @param type  Listener\'s type\r\n   */\n  removeType(type) {\n    if (this._disposed) {\n      throw new Error("EventDispatcher is disposed");\n    }\n    this._eachListener(info => {\n      if (info.type === type) {\n        info.disposer.dispose();\n      }\n    });\n  }\n  /**\r\n   * Checks if there\'s already a listener with specific parameters.\r\n   *\r\n   * @param type      Listener\'s type\r\n   * @param callback  Callback function\r\n   * @param context   Callback context\r\n   * @return Has listener?\r\n   */\n  has(type, callback, context) {\n    const index = findIndex(this._listeners, info => {\n      return info.once !== true &&\n      // Ignoring "once" listeners\n      info.type === type && (callback === undefined || info.callback === callback) && info.context === context;\n    });\n    return index !== -1;\n  }\n  /**\r\n   * Checks whether event of the particular type should be dispatched.\r\n   *\r\n   * @param type  Event type\r\n   * @return Dispatch?\r\n   */\n  _shouldDispatch(type) {\n    if (this._disposed) {\n      throw new Error("EventDispatcher is disposed");\n    }\n    const count = this._disabled[type];\n    if (!Type_isNumber(count)) {\n      return this._enabled;\n    } else {\n      if (count <= 1) {\n        delete this._disabled[type];\n      } else {\n        --this._disabled[type];\n      }\n      return false;\n    }\n  }\n  /**\r\n   * [_eachListener description]\r\n   *\r\n   * All of this extra code is needed when a listener is removed while iterating\r\n   *\r\n   * @todo Description\r\n   * @param fn [description]\r\n   */\n  _eachListener(fn) {\n    ++this._iterating;\n    try {\n      each(this._listeners, fn);\n    } finally {\n      --this._iterating;\n      // TODO should this be inside or outside the finally ?\n      if (this._iterating === 0 && this._killed.length !== 0) {\n        // Remove killed listeners\n        each(this._killed, killed => {\n          this._removeListener(killed);\n        });\n        this._killed.length = 0;\n      }\n    }\n  }\n  /**\r\n   * Dispatches an event immediately without waiting for next cycle.\r\n   *\r\n   * @param type   Event type\r\n   * @param event  Event object\r\n   * @todo automatically add in type and target properties if they are missing\r\n   */\n  dispatch(type, event) {\n    if (this._shouldDispatch(type)) {\n      // TODO check if it\'s faster to use an object of listeners rather than a single big array\n      // TODO if the function throws, maybe it should keep going ?\n      this._eachListener(listener => {\n        if (!listener.killed && (listener.type === null || listener.type === type)) {\n          listener.dispatch(type, event);\n        }\n      });\n    }\n  }\n  /**\r\n   * Shelves the event to be dispatched within next update cycle.\r\n   *\r\n   * @param type   Event type\r\n   * @param event  Event object\r\n   * @todo automatically add in type and target properties if they are missing\r\n   */\n  /*public dispatchLater<Key extends keyof T>(type: Key, event: T[Key]): void {\r\n      if (this._shouldDispatch(type)) {\r\n          this._eachListener((listener) => {\r\n              // TODO check if it\'s faster to use an object of listeners rather than a single big array\r\n              if (!listener.killed && (listener.type === null || listener.type === type)) {\r\n                  // TODO if the function throws, maybe it should keep going ?\r\n                  // TODO dispatch during the update cycle, rather than using whenIdle\r\n                  $async.whenIdle(() => {\r\n                      if (!listener.killed) {\r\n                          listener.dispatch(type, event);\r\n                      }\r\n                  });\r\n              }\r\n          });\r\n      }\r\n  }*/\n  /**\r\n   * Creates, catalogs and returns an [[EventListener]].\r\n   *\r\n   * Event listener can be disposed.\r\n   *\r\n   * @param once         Listener\'s once setting\r\n   * @param type         Listener\'s type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @param dispatch\r\n   * @returns An event listener\r\n   */\n  _on(once, type, callback, context, shouldClone, dispatch) {\n    if (this._disposed) {\n      throw new Error("EventDispatcher is disposed");\n    }\n    this._removeExistingListener(once, type, callback, context);\n    const info = {\n      type: type,\n      callback: callback,\n      context: context,\n      shouldClone: shouldClone,\n      dispatch: dispatch,\n      killed: false,\n      once: once,\n      disposer: new Disposer(() => {\n        info.killed = true;\n        this._removeListener(info);\n      })\n    };\n    this._listeners.push(info);\n    return info;\n  }\n  /**\r\n   * Creates an event listener to be invoked on **any** event.\r\n   *\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   */\n  onAll(callback, context, shouldClone = true) {\n    return this._on(false, null, callback, context, shouldClone, (_type, event) => callback.call(context, event)).disposer;\n  }\n  /**\r\n   * Creates an event listener to be invoked on a specific event type.\r\n   *\r\n   * ```TypeScript\r\n   * button.events.once("click", (ev) => {\r\n   *   console.log("Button clicked");\r\n   * }, this);\r\n   * ```\r\n   * ```JavaScript\r\n   * button.events.once("click", (ev) => {\r\n   *   console.log("Button clicked");\r\n   * }, this);\r\n   * ```\r\n   *\r\n   * The above will invoke our custom event handler whenever series we put\r\n   * event on is hidden.\r\n   *\r\n   * @param type         Listener\'s type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   */\n  on(type, callback, context, shouldClone = true) {\n    return this._on(false, type, callback, context, shouldClone, (_type, event) => callback.call(context, event)).disposer;\n  }\n  /**\r\n   * Creates an event listener to be invoked on a specific event type once.\r\n   *\r\n   * Once the event listener is invoked, it is automatically disposed.\r\n   *\r\n   * ```TypeScript\r\n   * button.events.once("click", (ev) => {\r\n   *   console.log("Button clicked");\r\n   * }, this);\r\n   * ```\r\n   * ```JavaScript\r\n   * button.events.once("click", (ev) => {\r\n   *   console.log("Button clicked");\r\n   * }, this);\r\n   * ```\r\n   *\r\n   * The above will invoke our custom event handler the first time series we\r\n   * put event on is hidden.\r\n   *\r\n   * @param type         Listener\'s type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   */\n  once(type, callback, context, shouldClone = true) {\n    const x = this._on(true, type, callback, context, shouldClone, (_type, event) => {\n      x.disposer.dispose();\n      callback.call(context, event);\n    });\n    // TODO maybe this should return a different Disposer ?\n    return x.disposer;\n  }\n  /**\r\n   * Removes the event listener with specific parameters.\r\n   *\r\n   * @param type         Listener\'s type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   */\n  off(type, callback, context) {\n    this._removeExistingListener(false, type, callback, context);\n  }\n  /**\r\n   * Copies all dispatcher parameters, including listeners, from another event\r\n   * dispatcher.\r\n   *\r\n   * @param source Source event dispatcher\r\n   * @ignore\r\n   */\n  copyFrom(source) {\n    if (this._disposed) {\n      throw new Error("EventDispatcher is disposed");\n    }\n    if (source === this) {\n      throw new Error("Cannot copyFrom the same TargetedEventDispatcher");\n    }\n    const disposers = [];\n    each(source._listeners, x => {\n      // TODO is this correct ?\n      if (!x.killed && x.shouldClone) {\n        if (x.type === null) {\n          disposers.push(this.onAll(x.callback, x.context));\n        } else if (x.once) {\n          disposers.push(this.once(x.type, x.callback, x.context));\n        } else {\n          disposers.push(this.on(x.type, x.callback, x.context));\n        }\n      }\n    });\n    return new Disposer_MultiDisposer(disposers);\n  }\n}\n/**\r\n * A version of the [[EventDispatcher]] that dispatches events for a specific\r\n * target object.\r\n *\r\n * @ignore\r\n */\nclass TargetedEventDispatcher extends (/* unused pure expression or super */ null && (EventDispatcher_EventDispatcher)) {\n  /**\r\n   * Constructor\r\n   *\r\n   * @param target Event dispatcher target\r\n   */\n  constructor(target) {\n    super();\n    /**\r\n     * A target object which is originating events using this dispatcher.\r\n     */\n    Object.defineProperty(this, "target", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.target = target;\n  }\n  /**\r\n   * Copies all dispatcher parameters, including listeners, from another event\r\n   * dispatcher.\r\n   *\r\n   * @param source Source event dispatcher\r\n   * @ignore\r\n   */\n  copyFrom(source) {\n    if (this._disposed) {\n      throw new Error("EventDispatcher is disposed");\n    }\n    if (source === this) {\n      throw new Error("Cannot copyFrom the same TargetedEventDispatcher");\n    }\n    const disposers = [];\n    $array.each(source._listeners, x => {\n      // TODO very hacky\n      if (x.context === source.target) {\n        return;\n      }\n      // TODO is this correct ?\n      if (!x.killed && x.shouldClone) {\n        if (x.type === null) {\n          disposers.push(this.onAll(x.callback, x.context));\n        } else if (x.once) {\n          disposers.push(this.once(x.type, x.callback, x.context));\n        } else {\n          disposers.push(this.on(x.type, x.callback, x.context));\n        }\n      }\n    });\n    return new MultiDisposer(disposers);\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/List.js\n\n\n/**\r\n * Checks if specific index fits into length.\r\n *\r\n * @param index  Index\r\n * @param len    Length\r\n * @ignore\r\n */\nfunction checkBounds(index, len) {\n  if (!(index >= 0 && index < len)) {\n    throw new Error("Index out of bounds: " + index);\n  }\n}\n/**\r\n * A List class is used to hold a number of indexed items of the same type.\r\n */\nclass List {\n  /**\r\n   * Constructor\r\n   *\r\n   * @param initial  Inital list of values to add to list\r\n   */\n  constructor(initial = []) {\n    /**\r\n     * List values.\r\n     */\n    Object.defineProperty(this, "_values", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "events", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new EventDispatcher_EventDispatcher()\n    });\n    this._values = initial;\n  }\n  /**\r\n   * An array of values in the list.\r\n   *\r\n   * Do not use this property to add values. Rather use dedicated methods, like\r\n   * `push()`, `removeIndex()`, etc.\r\n   *\r\n   * @readonly\r\n   * @return List values\r\n   */\n  get values() {\n    return this._values;\n  }\n  /**\r\n   * Checks if list contains specific item reference.\r\n   *\r\n   * @param item  Item to search for\r\n   * @return `true` if found, `false` if not found\r\n   */\n  contains(value) {\n    return this._values.indexOf(value) !== -1;\n  }\n  /**\r\n   * Removes specific item from the list.\r\n   *\r\n   * @param item An item to remove\r\n   */\n  removeValue(value) {\n    let i = 0;\n    let length = this._values.length;\n    while (i < length) {\n      // TODO handle NaN\n      if (this._values[i] === value) {\n        this.removeIndex(i);\n        --length;\n      } else {\n        ++i;\n      }\n    }\n  }\n  /**\r\n   * Searches the list for specific item and returns its index.\r\n   *\r\n   * @param item  An item to search for\r\n   * @return Index or -1 if not found\r\n   */\n  indexOf(value) {\n    return indexOf(this._values, value);\n  }\n  /**\r\n   * Number of items in list.\r\n   *\r\n   * @readonly\r\n   * @return Number of items\r\n   */\n  get length() {\n    return this._values.length;\n  }\n  /**\r\n   * Checks if there\'s a value at specific index.\r\n   *\r\n   * @param index  Index\r\n   * @return Value exists?\r\n   */\n  hasIndex(index) {\n    return index >= 0 && index < this._values.length;\n  }\n  /**\r\n   * Returns an item at specified index.\r\n   *\r\n   * @param index  Index\r\n   * @return List item\r\n   */\n  getIndex(index) {\n    return this._values[index];\n  }\n  _onPush(newValue) {\n    if (this.events.isEnabled("push")) {\n      this.events.dispatch("push", {\n        type: "push",\n        target: this,\n        newValue\n      });\n    }\n  }\n  _onInsertIndex(index, newValue) {\n    if (this.events.isEnabled("insertIndex")) {\n      this.events.dispatch("insertIndex", {\n        type: "insertIndex",\n        target: this,\n        index,\n        newValue\n      });\n    }\n  }\n  _onSetIndex(index, oldValue, newValue) {\n    if (this.events.isEnabled("setIndex")) {\n      this.events.dispatch("setIndex", {\n        type: "setIndex",\n        target: this,\n        index,\n        oldValue,\n        newValue\n      });\n    }\n  }\n  _onRemoveIndex(index, oldValue) {\n    if (this.events.isEnabled("removeIndex")) {\n      this.events.dispatch("removeIndex", {\n        type: "removeIndex",\n        target: this,\n        index,\n        oldValue\n      });\n    }\n  }\n  _onMoveIndex(oldIndex, newIndex, value) {\n    if (this.events.isEnabled("moveIndex")) {\n      this.events.dispatch("moveIndex", {\n        type: "moveIndex",\n        target: this,\n        oldIndex,\n        newIndex,\n        value\n      });\n    }\n  }\n  _onClear(oldValues) {\n    if (this.events.isEnabled("clear")) {\n      this.events.dispatch("clear", {\n        type: "clear",\n        target: this,\n        oldValues\n      });\n    }\n  }\n  /**\r\n   * Sets value at specific index.\r\n   *\r\n   * If there\'s already a value at the index, it is overwritten.\r\n   *\r\n   * @param index  Index\r\n   * @param value  New value\r\n   * @return New value\r\n   */\n  setIndex(index, value) {\n    checkBounds(index, this._values.length);\n    const oldValue = this._values[index];\n    // Do nothing if the old value and the new value are the same\n    if (oldValue !== value) {\n      this._values[index] = value;\n      this._onSetIndex(index, oldValue, value);\n    }\n    return oldValue;\n  }\n  /**\r\n   * Adds an item to the list at a specific index, which pushes all the other\r\n   * items further down the list.\r\n   *\r\n   * @param index Index\r\n   * @param item  An item to add\r\n   */\n  insertIndex(index, value) {\n    checkBounds(index, this._values.length + 1);\n    insertIndex(this._values, index, value);\n    this._onInsertIndex(index, value);\n    return value;\n  }\n  /**\r\n   * Swaps indexes of two items in the list.\r\n   *\r\n   * @param a  Item 1\r\n   * @param b  Item 2\r\n   */\n  swap(a, b) {\n    const len = this._values.length;\n    checkBounds(a, len);\n    checkBounds(b, len);\n    if (a !== b) {\n      const value_a = this._values[a];\n      const value_b = this._values[b];\n      this._values[a] = value_b;\n      this._onSetIndex(a, value_a, value_b);\n      this._values[b] = value_a;\n      this._onSetIndex(b, value_b, value_a);\n    }\n  }\n  /**\r\n   * Removes a value at specific index.\r\n   *\r\n   * @param index  Index of value to remove\r\n   * @return Removed value\r\n   */\n  removeIndex(index) {\n    checkBounds(index, this._values.length);\n    const oldValue = this._values[index];\n    removeIndex(this._values, index);\n    this._onRemoveIndex(index, oldValue);\n    return oldValue;\n  }\n  /**\r\n   * Moves an item to a specific index within the list.\r\n   *\r\n   * If the index is not specified it will move the item to the end of the\r\n   * list.\r\n   *\r\n   * @param value  Item to move\r\n   * @param index  Index to place item at\r\n   */\n  moveValue(value, toIndex) {\n    // TODO don\'t do anything if the desired index is the same as the current index\n    let index = this.indexOf(value);\n    // TODO remove all old values rather than only the first ?\n    if (index !== -1) {\n      removeIndex(this._values, index);\n      if (toIndex == null) {\n        const toIndex = this._values.length;\n        this._values.push(value);\n        this._onMoveIndex(index, toIndex, value);\n      } else {\n        insertIndex(this._values, toIndex, value);\n        this._onMoveIndex(index, toIndex, value);\n      }\n    } else if (toIndex == null) {\n      this._values.push(value);\n      this._onPush(value);\n    } else {\n      insertIndex(this._values, toIndex, value);\n      this._onInsertIndex(toIndex, value);\n    }\n    return value;\n  }\n  /**\r\n   * Adds an item to the end of the list.\r\n   *\r\n   * @param item  An item to add\r\n   */\n  push(value) {\n    this._values.push(value);\n    this._onPush(value);\n    return value;\n  }\n  /**\r\n   * Adds an item as a first item in the list.\r\n   *\r\n   * @param item  An item to add\r\n   */\n  unshift(value) {\n    this.insertIndex(0, value);\n    return value;\n  }\n  /**\r\n   * Adds multiple items to the list.\r\n   *\r\n   * @param items  An Array of items to add\r\n   */\n  pushAll(values) {\n    each(values, value => {\n      this.push(value);\n    });\n  }\n  /**\r\n   * Copies and adds items from abother list.\r\n   *\r\n   * @param source  A list top copy items from\r\n   */\n  copyFrom(source) {\n    this.pushAll(source._values);\n  }\n  /**\r\n   * Returns the last item from the list, and removes it.\r\n   *\r\n   * @return Item\r\n   */\n  pop() {\n    let index = this._values.length - 1;\n    return index < 0 ? undefined : this.removeIndex(this._values.length - 1);\n  }\n  /**\r\n   * Returns the first item from the list, and removes it.\r\n   *\r\n   * @return Item\r\n   */\n  shift() {\n    return this._values.length ? this.removeIndex(0) : undefined;\n  }\n  /**\r\n   * Sets multiple items to the list.\r\n   *\r\n   * All current items are removed.\r\n   *\r\n   * @param newArray  New items\r\n   */\n  setAll(newArray) {\n    const old = this._values;\n    this._values = [];\n    this._onClear(old);\n    each(newArray, value => {\n      this._values.push(value);\n      this._onPush(value);\n    });\n  }\n  /**\r\n   * Removes all items from the list.\r\n   */\n  clear() {\n    this.setAll([]);\n  }\n  /**\r\n   * Returns an ES6 iterator for the list.\r\n   */\n  *[Symbol.iterator]() {\n    const length = this._values.length;\n    for (let i = 0; i < length; ++i) {\n      yield this._values[i];\n    }\n  }\n  /**\r\n   * Calls `f` for each element in the list.\r\n   *\r\n   * `f` should have at least one parameter defined which will get a current\r\n   * item, with optional second argument - index.\r\n   */\n  each(f) {\n    each(this._values, f);\n  }\n  /**\r\n   * Calls `f` for each element in the list, from right to left.\r\n   *\r\n   * `f` should have at least one parameter defined which will get a current\r\n   * item, with optional second argument - index.\r\n   */\n  eachReverse(f) {\n    eachReverse(this._values, f);\n  }\n}\n/**\r\n * A version of a [[List]] where the elements are disposed automatically when\r\n * removed from the list, unless `autoDispose` is set to `false`.\r\n */\nclass ListAutoDispose extends List {\n  constructor() {\n    super(...arguments);\n    /**\r\n     * Automatically disposes elements that are removed from the list.\r\n     *\r\n     * @default true\r\n     */\n    Object.defineProperty(this, "autoDispose", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, "_disposed", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n  }\n  _onSetIndex(index, oldValue, newValue) {\n    if (this.autoDispose) {\n      oldValue.dispose();\n    }\n    super._onSetIndex(index, oldValue, newValue);\n  }\n  _onRemoveIndex(index, oldValue) {\n    if (this.autoDispose) {\n      oldValue.dispose();\n    }\n    super._onRemoveIndex(index, oldValue);\n  }\n  _onClear(oldValues) {\n    if (this.autoDispose) {\n      each(oldValues, x => {\n        x.dispose();\n      });\n    }\n    super._onClear(oldValues);\n  }\n  isDisposed() {\n    return this._disposed;\n  }\n  dispose() {\n    if (!this._disposed) {\n      this._disposed = true;\n      if (this.autoDispose) {\n        each(this._values, x => {\n          x.dispose();\n        });\n      }\n    }\n  }\n}\n/**\r\n * A version of a [[List]] that is able to create new elements as well as\r\n * apply additional settings to newly created items.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/list-templates/} for more info\r\n */\nclass ListTemplate extends ListAutoDispose {\n  constructor(template, make) {\n    super();\n    Object.defineProperty(this, "template", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "make", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.template = template;\n    this.make = make;\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Children.js\n\n\n/**\r\n * A version of [[List]] to hold children of the [[Container]].\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/} for more info\r\n */\nclass Children extends List {\n  constructor(container) {\n    super();\n    Object.defineProperty(this, "_disposed", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_container", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_events", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._container = container;\n    this._events = this.events.onAll(change => {\n      if (change.type === "clear") {\n        each(change.oldValues, x => {\n          this._onRemoved(x);\n        });\n      } else if (change.type === "push") {\n        this._onInserted(change.newValue);\n      } else if (change.type === "setIndex") {\n        this._onRemoved(change.oldValue);\n        this._onInserted(change.newValue, change.index);\n      } else if (change.type === "insertIndex") {\n        this._onInserted(change.newValue, change.index);\n      } else if (change.type === "removeIndex") {\n        this._onRemoved(change.oldValue);\n      } else if (change.type === "moveIndex") {\n        this._onRemoved(change.value);\n        this._onInserted(change.value, change.newIndex);\n      } else {\n        throw new Error("Unknown IListEvent type");\n      }\n    });\n  }\n  _onInserted(child, index) {\n    child._setParent(this._container, true);\n    const childrenDisplay = this._container._childrenDisplay;\n    if (index === undefined) {\n      childrenDisplay.addChild(child._display);\n    } else {\n      childrenDisplay.addChildAt(child._display, index);\n    }\n  }\n  _onRemoved(child) {\n    this._container._childrenDisplay.removeChild(child._display);\n    this._container.markDirtyBounds();\n    this._container.markDirty();\n  }\n  /**\r\n   * Returns `true` if obejct is disposed.\r\n   */\n  isDisposed() {\n    return this._disposed;\n  }\n  /**\r\n   * Permanently dispose this object.\r\n   */\n  dispose() {\n    if (!this._disposed) {\n      this._disposed = true;\n      this._events.dispose();\n      each(this.values, child => {\n        child.dispose();\n      });\n    }\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Ease.js\n/**\r\n * A collection of easing functions\r\n *\r\n * Parts of this collection are taken from D3.js library (https://d3js.org/)\r\n */\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * The functions below are from D3.js library (https://d3js.org/)\r\n *\r\n * ----------------------------------------------------------------------------\r\n * Copyright 2017 Mike Bostock\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n *\tthis list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n *\tthis list of conditions and the following disclaimer in the documentation\r\n *\tand/or other materials provided with the distribution.\r\n *\r\n * 3. Neither the name of the copyright holder nor the names of its\r\n *\tcontributors may be used to endorse or promote products derived from this\r\n *\tsoftware without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n * ----------------------------------------------------------------------------\r\n * @hidden\r\n */\n/**\r\n */\nfunction linear(t) {\n  return t;\n}\nfunction quad(t) {\n  return t * t;\n}\nfunction cubic(t) {\n  return t * t * t;\n}\nfunction pow(t, e) {\n  return Math.pow(t, e);\n}\nfunction exp(t) {\n  return Math.pow(2, 10 * t - 10);\n}\nfunction sine(t) {\n  return 1 - Math.cos(t * $math.HALFPI);\n}\nfunction circle(t) {\n  return 1 - Math.sqrt(1 - t * t);\n}\n/**\r\n * ============================================================================\r\n * TRANSFORMERS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n */\nfunction yoyo(ease) {\n  return function (t) {\n    if (t < 0.5) {\n      return ease(t * 2.0);\n    } else {\n      return ease((1.0 - t) * 2.0);\n    }\n  };\n}\nfunction out(ease) {\n  return function (t) {\n    return 1.0 - ease(1.0 - t);\n  };\n}\nfunction inOut(ease) {\n  return function (t) {\n    if (t <= 0.5) {\n      return ease(t * 2.0) / 2.0;\n    } else {\n      return 1.0 - ease((1.0 - t) * 2.0) / 2.0;\n    }\n  };\n}\n/**\r\n * ============================================================================\r\n * BOUNCE\r\n * ============================================================================\r\n * @hidden\r\n */\nlet b1 = 4 / 11,\n  b2 = (/* unused pure expression or super */ null && (6 / 11)),\n  b3 = (/* unused pure expression or super */ null && (8 / 11)),\n  b4 = (/* unused pure expression or super */ null && (3 / 4)),\n  b5 = (/* unused pure expression or super */ null && (9 / 11)),\n  b6 = (/* unused pure expression or super */ null && (10 / 11)),\n  b7 = (/* unused pure expression or super */ null && (15 / 16)),\n  b8 = (/* unused pure expression or super */ null && (21 / 22)),\n  b9 = (/* unused pure expression or super */ null && (63 / 64)),\n  b0 = 1 / b1 / b1;\nfunction bounce(t) {\n  return 1 - bounceOut(1 - t);\n}\n/**\r\n * @ignore\r\n */\nfunction bounceOut(t) {\n  t = t;\n  if (t < b1) {\n    return b0 * t * t;\n  } else if (t < b3) {\n    return b0 * (t -= b2) * t + b4;\n  } else if (t < b6) {\n    return b0 * (t -= b5) * t + b7;\n  } else {\n    return b0 * (t -= b8) * t + b9;\n  }\n}\n/**\r\n * ============================================================================\r\n * ELASTIC\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * @ignore\r\n */\nlet tau = 2 * Math.PI;\n/**\r\n * @ignore\r\n */\nlet amplitude = 1;\n/**\r\n * @ignore\r\n */\nlet period = 0.3 / tau;\n/**\r\n * @ignore\r\n */\nlet s = Math.asin(1 / amplitude) * period;\nfunction elastic(t) {\n  let v = t;\n  return amplitude * Math.pow(2, 10 * --v) * Math.sin((s - v) / period);\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/States.js\n\n\n/**\r\n * An object representing a collection of setting values to apply as required.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/states/} for more info\r\n */\nclass State {\n  constructor(entity, settings) {\n    Object.defineProperty(this, "_entity", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_settings", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_userSettings", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    this._entity = entity;\n    this._settings = settings;\n    Object_each(settings, key => {\n      this._userSettings[key] = true;\n    });\n  }\n  get(key, fallback) {\n    const value = this._settings[key];\n    if (value !== undefined) {\n      return value;\n    } else {\n      return fallback;\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  setRaw(key, value) {\n    this._settings[key] = value;\n  }\n  /**\r\n   * Sets a setting `value` for the specified `key` to be set when the state\r\n   * is applied.\r\n   *\r\n   * @param   key       Setting key\r\n   * @param   value     Setting value\r\n   * @return            Setting value\r\n   */\n  set(key, value) {\n    this._userSettings[key] = true;\n    this.setRaw(key, value);\n  }\n  /**\r\n   * Removes a setting value for the specified `key`.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info\r\n   * @param   key       Setting key\r\n   */\n  remove(key) {\n    delete this._userSettings[key];\n    delete this._settings[key];\n  }\n  /**\r\n   * Sets multiple settings at once.\r\n   *\r\n   * `settings` must be an object with key: value pairs.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info\r\n   * @param settings Settings\r\n   */\n  setAll(settings) {\n    keys(settings).forEach(key => {\n      this.set(key, settings[key]);\n    });\n  }\n  _eachSetting(f) {\n    Object_each(this._settings, f);\n  }\n  /**\r\n   * Applies the state to the target element.\r\n   *\r\n   * All setting values are set immediately.\r\n   */\n  apply() {\n    const seen = {};\n    seen["stateAnimationEasing"] = true;\n    seen["stateAnimationDuration"] = true;\n    const defaultState = this._entity.states.lookup("default");\n    this._eachSetting((key, value) => {\n      if (!seen[key]) {\n        seen[key] = true;\n        // save values to default state\n        if (this !== defaultState) {\n          if (!(key in defaultState._settings)) {\n            defaultState._settings[key] = this._entity.get(key);\n          }\n        }\n        this._entity.set(key, value);\n      }\n    });\n  }\n  /**\r\n   * Applies the state to the target element.\r\n   *\r\n   * Returns an object representing all [[Animation]] objects created for\r\n   * each setting key transition.\r\n   *\r\n   * @return           Animations\r\n   */\n  applyAnimate(duration) {\n    if (duration == null) {\n      duration = this._settings.stateAnimationDuration;\n    }\n    if (duration == null) {\n      duration = this.get("stateAnimationDuration", this._entity.get("stateAnimationDuration", 0));\n    }\n    let easing = this._settings.stateAnimationEasing;\n    if (easing == null) {\n      easing = this.get("stateAnimationEasing", this._entity.get("stateAnimationEasing", cubic));\n    }\n    const defaultState = this._entity.states.lookup("default");\n    const seen = {};\n    seen["stateAnimationEasing"] = true;\n    seen["stateAnimationDuration"] = true;\n    const animations = {};\n    this._eachSetting((key, value) => {\n      if (!seen[key]) {\n        seen[key] = true;\n        // save values to default state\n        if (this != defaultState) {\n          if (!(key in defaultState._settings)) {\n            defaultState._settings[key] = this._entity.get(key);\n          }\n        }\n        const animation = this._entity.animate({\n          key: key,\n          to: value,\n          duration: duration,\n          easing: easing\n        });\n        if (animation) {\n          animations[key] = animation;\n        }\n      }\n    });\n    return animations;\n  }\n}\n/**\r\n * Collection of [[State]] objects for an element.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/states/} for more info\r\n */\nclass States {\n  constructor(entity) {\n    Object.defineProperty(this, "_states", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_entity", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._entity = entity;\n  }\n  /**\r\n   * Checks if a state by `name` exists. Returns it there is one.\r\n   *\r\n   * @param  name  State name\r\n   * @return       State\r\n   */\n  lookup(name) {\n    return this._states[name];\n  }\n  /**\r\n   * Sets supplied `settings` on a state by the `name`.\r\n   *\r\n   * If such state does not yet exists, it is created.\r\n   *\r\n   * @param   name      State name\r\n   * @param   settings  Settings\r\n   * @return            New State\r\n   */\n  create(name, settings) {\n    const state = this._states[name];\n    if (state) {\n      state.setAll(settings);\n      return state;\n    } else {\n      const state = new State(this._entity, settings);\n      this._states[name] = state;\n      return state;\n    }\n  }\n  /**\r\n   * Removes the state called `name`.\r\n   *\r\n   * @param   name      State name\r\n   */\n  remove(name) {\n    delete this._states[name];\n  }\n  /**\r\n   * Applies a named state to the target element.\r\n   *\r\n   * @param  newState  State name\r\n   */\n  apply(newState) {\n    const state = this._states[newState];\n    if (state) {\n      state.apply();\n    }\n    this._entity._applyState(newState);\n  }\n  /**\r\n   * Applies a named state to the element.\r\n   *\r\n   * Returns an object representing all [[Animation]] objects created for\r\n   * each setting key transition.\r\n   *\r\n   * @param   newState  State name\r\n   * @return            Animations\r\n   */\n  applyAnimate(newState, duration) {\n    let animations;\n    const state = this._states[newState];\n    if (state) {\n      animations = state.applyAnimate(duration);\n    }\n    this._entity._applyStateAnimated(newState, duration);\n    return animations;\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/Registry.js\n/**\r\n * @ignore\r\n */\nclass Registry {\n  constructor() {\n    /**\r\n     * Currently running version of amCharts.\r\n     */\n    Object.defineProperty(this, "version", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: "5.9.8"\n    });\n    /**\r\n     * List of applied licenses.\r\n     * @ignore\r\n     */\n    Object.defineProperty(this, "licenses", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    /**\r\n     * Entities that have their `id` setting set.\r\n     */\n    Object.defineProperty(this, "entitiesById", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    /**\r\n     * All created [[Root]] elements.\r\n     */\n    Object.defineProperty(this, "rootElements", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n  }\n}\n/**\r\n    * @ignore\r\n */\nconst registry = new Registry();\n/**\r\n * Adds a license, e.g.:\r\n *\r\n * ```TypeScript\r\n * am5.addLicense("xxxxxxxx");\r\n * ```\r\n * ```JavaScript\r\n * am5.addLicense("xxxxxxxx");\r\n * ```\r\n *\r\n * Multiple licenses can be added to cover for multiple products.\r\n *\r\n * @param  license  License key\r\n */\nfunction addLicense(license) {\n  registry.licenses.push(license);\n}\n/**\r\n * Disposes all [[Root]] elements.\r\n */\nfunction disposeAllRootElements() {\n  let root;\n  while (root = registry.rootElements.pop()) {\n    root.dispose();\n  }\n}\n/**\r\n * Finds and returns a `Root` element assigned to a container with `id`.\r\n *\r\n * @param   id  Container ID\r\n * @return      Root\r\n * @since 5.9.2\r\n */\nfunction getRootById(id) {\n  let found;\n  registry.rootElements.forEach(item => {\n    if (item.dom.id == id) {\n      found = item;\n    }\n  });\n  return found;\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js\n/**\r\n * @ignore\r\n */\nfunction compare(left, right) {\n  if (left === right) {\n    return 0;\n  } else if (left < right) {\n    return -1;\n  } else {\n    return 1;\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction compareArray(left, right, f) {\n  const leftLength = left.length;\n  const rightLength = right.length;\n  const length = Math.min(leftLength, rightLength);\n  for (let i = 0; i < length; ++i) {\n    const order = f(left[i], right[i]);\n    if (order !== 0) {\n      return order;\n    }\n  }\n  return compare(leftLength, rightLength);\n}\n/**\r\n * @ignore\r\n */\nfunction reverse(order) {\n  if (order < 0) {\n    return 1;\n  } else if (order > 0) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction compareNumber(a, b) {\n  if (a === b) {\n    return 0;\n  } else if (a < b) {\n    return -1;\n  } else {\n    return 1;\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js\n\n\n\n\n\n\n\n\n\n/**\r\n * Allows to dynamically modify setting value of its target element.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/adapters/} for more info\r\n */\nclass Adapters {\n  constructor(entity) {\n    Object.defineProperty(this, "_entity", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_callbacks", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_disabled", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    this._entity = entity;\n  }\n  /**\r\n   * Add a function (`callback`) that will modify value for setting `key`.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/adapters/} for more info\r\n   */\n  add(key, callback) {\n    let callbacks = this._callbacks[key];\n    if (callbacks === undefined) {\n      callbacks = this._callbacks[key] = [];\n    }\n    callbacks.push(callback);\n    this._entity._markDirtyKey(key);\n    return new Disposer(() => {\n      if (removeFirst(callbacks, callback)) {\n        this._entity._markDirtyKey(key);\n      }\n    });\n  }\n  /**\r\n   * Removes all adapters for the specific key.\r\n   *\r\n   * @since 5.1.0\r\n   */\n  remove(key) {\n    const callbacks = this._callbacks[key];\n    if (callbacks !== undefined) {\n      delete this._callbacks[key];\n      if (callbacks.length !== 0) {\n        this._entity._markDirtyKey(key);\n      }\n    }\n  }\n  /**\r\n   * Enables (previously disabled) adapters for specific key.\r\n   *\r\n   * @since 5.1.0\r\n   */\n  enable(key) {\n    if (this._disabled[key]) {\n      delete this._disabled[key];\n      this._entity._markDirtyKey(key);\n    }\n  }\n  /**\r\n   * Disables all adapters for specific key.\r\n   *\r\n   * @since 5.1.0\r\n   */\n  disable(key) {\n    if (!this._disabled[key]) {\n      this._disabled[key] = true;\n      this._entity._markDirtyKey(key);\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  fold(key, value) {\n    if (!this._disabled[key]) {\n      const callbacks = this._callbacks[key];\n      if (callbacks !== undefined) {\n        for (let i = 0, len = callbacks.length; i < len; ++i) {\n          value = callbacks[i](value, this._entity, key);\n        }\n      }\n    }\n    return value;\n  }\n}\n/**\r\n * Animation object.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/animations/} for more info\r\n */\nclass Animation {\n  constructor(animation, from, to, duration, easing, loops, startingTime) {\n    Object.defineProperty(this, "_animation", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_from", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_to", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_duration", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_easing", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_loops", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_interpolate", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_oldTime", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_time", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_stopped", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_playing", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, "events", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new EventDispatcher_EventDispatcher()\n    });\n    this._animation = animation;\n    this._from = from;\n    this._to = to;\n    this._duration = duration;\n    this._easing = easing;\n    this._loops = loops;\n    this._interpolate = getInterpolate(from, to);\n    this._oldTime = startingTime;\n  }\n  get to() {\n    return this._to;\n  }\n  get from() {\n    return this._from;\n  }\n  get playing() {\n    return this._playing;\n  }\n  get stopped() {\n    return this._stopped;\n  }\n  stop() {\n    if (!this._stopped) {\n      this._stopped = true;\n      this._playing = false;\n      if (this.events.isEnabled("stopped")) {\n        this.events.dispatch("stopped", {\n          type: "stopped",\n          target: this\n        });\n      }\n    }\n  }\n  pause() {\n    this._playing = false;\n    this._oldTime = null;\n  }\n  play() {\n    if (!this._stopped && !this._playing) {\n      this._playing = true;\n      this._animation._startAnimation();\n    }\n  }\n  get percentage() {\n    return this._time / this._duration;\n  }\n  waitForStop() {\n    return new Promise((resolve, _reject) => {\n      if (this._stopped) {\n        resolve();\n      } else {\n        const listener = () => {\n          stopped.dispose();\n          resolve();\n        };\n        const stopped = this.events.on("stopped", listener);\n      }\n    });\n  }\n  _checkEnded() {\n    if (this._loops > 1) {\n      --this._loops;\n      return false;\n    } else {\n      return true;\n    }\n  }\n  _run(currentTime) {\n    if (this._oldTime !== null) {\n      this._time += currentTime - this._oldTime;\n      if (this._time > this._duration) {\n        this._time = this._duration;\n      }\n    }\n    this._oldTime = currentTime;\n  }\n  _reset(currentTime) {\n    this._oldTime = currentTime;\n    this._time = 0;\n  }\n  _value(diff) {\n    return this._interpolate(this._easing(diff), this._from, this._to);\n  }\n}\n/**\r\n * @ignore\r\n */\nlet counter = 0;\n/**\r\n * Base class for [[Entity]] objects that support Settings.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info\r\n */\nclass Settings {\n  constructor(settings) {\n    /**\r\n     * Unique ID.\r\n     */\n    Object.defineProperty(this, "uid", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: ++counter\n    });\n    Object.defineProperty(this, "_settings", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_privateSettings", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_settingEvents", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_privateSettingEvents", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_prevSettings", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_prevPrivateSettings", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_animatingSettings", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_animatingPrivateSettings", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_disposed", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    // TODO move this into Entity\n    Object.defineProperty(this, "_userProperties", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    this._settings = settings;\n  }\n  _checkDirty() {\n    keys(this._settings).forEach(key => {\n      this._userProperties[key] = true;\n      this._markDirtyKey(key);\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  resetUserSettings() {\n    this._userProperties = {};\n  }\n  _runAnimation(currentTime) {\n    let state = AnimationState.Stopped;\n    if (!this.isDisposed()) {\n      let playing = false;\n      let paused = false;\n      Object_each(this._animatingSettings, (key, animation) => {\n        if (animation.stopped) {\n          this._stopAnimation(key);\n        } else if (animation.playing) {\n          animation._run(currentTime);\n          const diff = animation.percentage;\n          if (diff >= 1) {\n            if (animation._checkEnded()) {\n              this.set(key, animation._value(1));\n            } else {\n              playing = true;\n              animation._reset(currentTime);\n              this._set(key, animation._value(1));\n            }\n          } else {\n            playing = true;\n            this._set(key, animation._value(diff));\n          }\n        } else {\n          paused = true;\n        }\n      });\n      Object_each(this._animatingPrivateSettings, (key, animation) => {\n        if (animation.stopped) {\n          this._stopAnimationPrivate(key);\n        } else if (animation.playing) {\n          animation._run(currentTime);\n          const diff = animation.percentage;\n          if (diff >= 1) {\n            if (animation._checkEnded()) {\n              this.setPrivate(key, animation._value(1));\n            } else {\n              playing = true;\n              animation._reset(currentTime);\n              this._setPrivate(key, animation._value(1));\n            }\n          } else {\n            playing = true;\n            this._setPrivate(key, animation._value(diff));\n          }\n        } else {\n          paused = true;\n        }\n      });\n      if (playing) {\n        state = AnimationState.Playing;\n      } else if (paused) {\n        state = AnimationState.Paused;\n      }\n    }\n    return state;\n  }\n  _markDirtyKey(_key) {\n    this.markDirty();\n  }\n  _markDirtyPrivateKey(_key) {\n    this.markDirty();\n  }\n  /**\r\n   * Sets a callback function to invoke when specific key of settings changes\r\n   * or is set.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info\r\n   * @param   key       Settings key\r\n   * @param   callback  Callback\r\n   * @return            Disposer for event\r\n   */\n  on(key, callback) {\n    let events = this._settingEvents[key];\n    if (events === undefined) {\n      events = this._settingEvents[key] = [];\n    }\n    events.push(callback);\n    return new Disposer(() => {\n      removeFirst(events, callback);\n      if (events.length === 0) {\n        delete this._settingEvents[key];\n      }\n    });\n  }\n  /**\r\n   * Removes a callback for when value of a setting changes.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info\r\n   * @param   key       Private settings key\r\n   * @param   callback  Callback\r\n   * @since 5.9.2\r\n   */\n  off(key, callback) {\n    let events = this._settingEvents[key];\n    if (events !== undefined && callback !== undefined) {\n      removeFirst(events, callback);\n    } else {\n      delete this._settingEvents[key];\n    }\n  }\n  /**\r\n   * Sets a callback function to invoke when specific key of private settings\r\n   * changes or is set.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info\r\n   * @param   key       Private settings key\r\n   * @param   callback  Callback\r\n   * @return            Disposer for event\r\n   */\n  onPrivate(key, callback) {\n    let events = this._privateSettingEvents[key];\n    if (events === undefined) {\n      events = this._privateSettingEvents[key] = [];\n    }\n    events.push(callback);\n    return new Disposer(() => {\n      removeFirst(events, callback);\n      if (events.length === 0) {\n        delete this._privateSettingEvents[key];\n      }\n    });\n  }\n  /**\r\n   * Removes a callback for when value of a private setting changes.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info\r\n   * @param   key       Private settings key\r\n   * @param   callback  Callback\r\n   * @since 5.9.2\r\n   */\n  offPrivate(key, callback) {\n    let events = this._privateSettingEvents[key];\n    if (events !== undefined && callback !== undefined) {\n      removeFirst(events, callback);\n    } else {\n      delete this._privateSettingEvents[key];\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  getRaw(key, fallback) {\n    const value = this._settings[key];\n    if (value !== undefined) {\n      return value;\n    } else {\n      return fallback;\n    }\n  }\n  /**\r\n   * Returns `true` if the setting exists.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info\r\n   * @param   key        Settings key\r\n   * @return  {boolean}  Key exists\r\n   */\n  has(key) {\n    return key in this._settings;\n  }\n  get(key, fallback) {\n    return this.getRaw(key, fallback);\n  }\n  _sendKeyEvent(key, value) {\n    const events = this._settingEvents[key];\n    if (events !== undefined) {\n      each(events, callback => {\n        callback(value, this, key);\n      });\n    }\n  }\n  _sendPrivateKeyEvent(key, value) {\n    const events = this._privateSettingEvents[key];\n    if (events !== undefined) {\n      each(events, callback => {\n        callback(value, this, key);\n      });\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  _setRaw(key, old, value) {\n    this._prevSettings[key] = old;\n    this._sendKeyEvent(key, value);\n  }\n  /**\r\n   * @ignore\r\n   */\n  setRaw(key, value) {\n    const old = this._settings[key];\n    this._settings[key] = value;\n    if (old !== value) {\n      this._setRaw(key, old, value);\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  _set(key, value) {\n    const old = this._settings[key];\n    this._settings[key] = value;\n    if (old !== value) {\n      this._setRaw(key, old, value);\n      this._markDirtyKey(key);\n    }\n  }\n  _stopAnimation(key) {\n    const animation = this._animatingSettings[key];\n    if (animation) {\n      delete this._animatingSettings[key];\n      animation.stop();\n    }\n  }\n  /**\r\n   * Sets a setting `value` for the specified `key`, and returns the same `value`.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info\r\n   * @param   key       Setting key\r\n   * @param   value     Setting value\r\n   * @return            Setting value\r\n   */\n  set(key, value) {\n    this._set(key, value);\n    this._stopAnimation(key);\n    return value;\n  }\n  /**\r\n   * Removes a setting value for the specified `key`;\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info\r\n   * @param   key       Setting key\r\n   */\n  remove(key) {\n    if (key in this._settings) {\n      this._prevSettings[key] = this._settings[key];\n      delete this._settings[key];\n      this._sendKeyEvent(key, undefined);\n      this._markDirtyKey(key);\n    }\n    this._stopAnimation(key);\n  }\n  /**\r\n   * Removes all keys;\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info\r\n   */\n  removeAll() {\n    each(keys(this._settings), key => {\n      this.remove(key);\n    });\n  }\n  /**\r\n   * Returns a value of a private setting.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/#Private_settings} for more info\r\n   */\n  getPrivate(key, fallback) {\n    const value = this._privateSettings[key];\n    if (value !== undefined) {\n      return value;\n    } else {\n      return fallback;\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  _setPrivateRaw(key, old, value) {\n    this._prevPrivateSettings[key] = old;\n    this._sendPrivateKeyEvent(key, value);\n  }\n  /**\r\n   * @ignore\r\n   */\n  setPrivateRaw(key, value) {\n    const old = this._privateSettings[key];\n    this._privateSettings[key] = value;\n    if (old !== value) {\n      this._setPrivateRaw(key, old, value);\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  _setPrivate(key, value) {\n    const old = this._privateSettings[key];\n    this._privateSettings[key] = value;\n    if (old !== value) {\n      this._setPrivateRaw(key, old, value);\n      this._markDirtyPrivateKey(key);\n    }\n  }\n  _stopAnimationPrivate(key) {\n    const animation = this._animatingPrivateSettings[key];\n    if (animation) {\n      animation.stop();\n      delete this._animatingPrivateSettings[key];\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  setPrivate(key, value) {\n    this._setPrivate(key, value);\n    this._stopAnimationPrivate(key);\n    return value;\n  }\n  /**\r\n   * @ignore\r\n   */\n  removePrivate(key) {\n    if (key in this._privateSettings) {\n      this._prevPrivateSettings[key] = this._privateSettings[key];\n      delete this._privateSettings[key];\n      this._markDirtyPrivateKey(key);\n    }\n    this._stopAnimationPrivate(key);\n  }\n  /**\r\n   * Sets multiple settings at once.\r\n   *\r\n   * `settings` must be an object with key: value pairs.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info\r\n   * @param settings Settings\r\n   */\n  setAll(settings) {\n    Object_each(settings, (key, value) => {\n      this.set(key, value);\n    });\n  }\n  /**\r\n   * Animates setting values from current/start values to new ones.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/animations/#Animating_settings} for more info\r\n   * @param   options  Animation options\r\n   * @return           Animation object\r\n   */\n  animate(options) {\n    const key = options.key;\n    const to = options.to;\n    const duration = options.duration || 0;\n    const loops = options.loops || 1;\n    const from = options.from === undefined ? this.get(key) : options.from;\n    const easing = options.easing === undefined ? linear : options.easing;\n    if (duration === 0) {\n      this.set(key, to);\n    } else {\n      if (from === undefined || from === to) {\n        this.set(key, to);\n      } else {\n        this.set(key, from);\n        const animation = this._animatingSettings[key] = new Animation(this, from, to, duration, easing, loops, this._animationTime());\n        this._startAnimation();\n        return animation;\n      }\n    }\n    const animation = new Animation(this, from, to, duration, easing, loops, null);\n    animation.stop();\n    return animation;\n  }\n  /**\r\n   * @ignore\r\n   */\n  animatePrivate(options) {\n    const key = options.key;\n    const to = options.to;\n    const duration = options.duration || 0;\n    const loops = options.loops || 1;\n    const from = options.from === undefined ? this.getPrivate(key) : options.from;\n    const easing = options.easing === undefined ? linear : options.easing;\n    if (duration === 0) {\n      this.setPrivate(key, to);\n    } else {\n      if (from === undefined || from === to) {\n        this.setPrivate(key, to);\n      } else {\n        this.setPrivate(key, from);\n        const animation = this._animatingPrivateSettings[key] = new Animation(this, from, to, duration, easing, loops, this._animationTime());\n        this._startAnimation();\n        return animation;\n      }\n    }\n    const animation = new Animation(this, from, to, duration, easing, loops, null);\n    animation.stop();\n    return animation;\n  }\n  _dispose() {}\n  /**\r\n   * Returns `true` if this element is disposed.\r\n   *\r\n   * @return Disposed\r\n   */\n  isDisposed() {\n    return this._disposed;\n  }\n  /**\r\n   * Disposes this object.\r\n   */\n  dispose() {\n    if (!this._disposed) {\n      this._disposed = true;\n      this._dispose();\n    }\n  }\n}\n/**\r\n * Base class.\r\n *\r\n * @important\r\n */\nclass Entity extends Settings {\n  /**\r\n   * IMPORTANT! Do not instantiate this class via `new Class()` syntax.\r\n   *\r\n   * Use static method `Class.new()` instead.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info\r\n   * @ignore\r\n   */\n  constructor(root, settings, isReal, templates = []) {\n    super(settings);\n    Object.defineProperty(this, "_root", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_user_id", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    }); // for testing purposes\n    Object.defineProperty(this, "states", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new States(this)\n    });\n    Object.defineProperty(this, "adapters", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Adapters(this)\n    });\n    Object.defineProperty(this, "events", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._createEvents()\n    });\n    Object.defineProperty(this, "_userPrivateProperties", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_dirty", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_dirtyPrivate", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_template", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    // Templates for the themes\n    Object.defineProperty(this, "_templates", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    // Internal templates which can be overridden by the user\'s templates\n    Object.defineProperty(this, "_internalTemplates", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    // Default themes which can be overridden by the user\'s themes\n    Object.defineProperty(this, "_defaultThemes", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    // Disposers for all of the templates\n    Object.defineProperty(this, "_templateDisposers", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "_disposers", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    // Whether the template setup function should be run\n    Object.defineProperty(this, "_runSetup", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, "_disposerProperties", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    if (!isReal) {\n      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");\n    }\n    this._root = root;\n    this._internalTemplates = templates;\n    if (settings.id) {\n      this._registerId(settings.id);\n    }\n  }\n  /**\r\n   * Use this method to create an instance of this class.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info\r\n   * @param   root      Root element\r\n   * @param   settings  Settings\r\n   * @param   template  Template\r\n   * @return            Instantiated object\r\n   */\n  static new(root, settings, template) {\n    const x = new this(root, settings, true);\n    x._template = template;\n    x._afterNew();\n    return x;\n  }\n  static _new(root, settings, templates = []) {\n    const x = new this(root, settings, true, templates);\n    x._afterNew();\n    return x;\n  }\n  _afterNew() {\n    this._checkDirty();\n    let shouldApply = false;\n    const template = this._template;\n    if (template) {\n      shouldApply = true;\n      template._setObjectTemplate(this);\n    }\n    each(this._internalTemplates, template => {\n      shouldApply = true;\n      template._setObjectTemplate(this);\n    });\n    if (shouldApply) {\n      this._applyTemplates(false);\n    }\n    this.states.create("default", {});\n    this._setDefaults();\n  }\n  // This is the same as _afterNew, except it also applies the themes.\n  // This should only be used for classes which don\'t have a parent (because they extend from Entity and not Sprite).\n  _afterNewApplyThemes() {\n    this._checkDirty();\n    const template = this._template;\n    if (template) {\n      template._setObjectTemplate(this);\n    }\n    each(this._internalTemplates, template => {\n      template._setObjectTemplate(this);\n    });\n    this.states.create("default", {});\n    this._setDefaults();\n    this._applyThemes();\n  }\n  _createEvents() {\n    return new EventDispatcher_EventDispatcher();\n  }\n  /**\r\n   * @ignore\r\n   */\n  get classNames() {\n    return this.constructor.classNames;\n  }\n  /**\r\n   * @ignore\r\n   */\n  get className() {\n    return this.constructor.className;\n  }\n  _setDefaults() {}\n  _setDefaultFn(key, f) {\n    const value = this.get(key);\n    if (value) {\n      return value;\n    } else {\n      const value = f();\n      this.set(key, value);\n      return value;\n    }\n  }\n  _setDefault(key, value) {\n    if (!this.has(key)) {\n      super.set(key, value);\n    }\n  }\n  _setRawDefault(key, value) {\n    if (!this.has(key)) {\n      super.setRaw(key, value);\n    }\n  }\n  _clearDirty() {\n    keys(this._dirty).forEach(key => {\n      this._dirty[key] = false;\n    });\n    keys(this._dirtyPrivate).forEach(key => {\n      this._dirtyPrivate[key] = false;\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  isDirty(key) {\n    return !!this._dirty[key];\n  }\n  /**\r\n   * @ignore\r\n   */\n  isPrivateDirty(key) {\n    return !!this._dirtyPrivate[key];\n  }\n  _markDirtyKey(key) {\n    this._dirty[key] = true;\n    super._markDirtyKey(key);\n  }\n  _markDirtyPrivateKey(key) {\n    this._dirtyPrivate[key] = true;\n    super._markDirtyKey(key);\n  }\n  /**\r\n   * Checks if element is of certain class (or inherits one).\r\n   *\r\n   * @param   type  Class name to check\r\n   * @return {boolean} Is of class?\r\n   */\n  isType(type) {\n    return this.classNames.indexOf(type) !== -1;\n  }\n  _pushPropertyDisposer(key, disposer) {\n    let disposers = this._disposerProperties[key];\n    if (disposers === undefined) {\n      disposers = this._disposerProperties[key] = [];\n    }\n    disposers.push(disposer);\n    return disposer;\n  }\n  _disposeProperty(key) {\n    const disposers = this._disposerProperties[key];\n    if (disposers !== undefined) {\n      each(disposers, disposer => {\n        disposer.dispose();\n      });\n      delete this._disposerProperties[key];\n    }\n  }\n  /**\r\n   * @todo needs description\r\n   * @param  value  Template\r\n   */\n  set template(value) {\n    const template = this._template;\n    if (template !== value) {\n      this._template = value;\n      if (template) {\n        template._removeObjectTemplate(this);\n      }\n      if (value) {\n        value._setObjectTemplate(this);\n      }\n      this._applyTemplates();\n    }\n  }\n  get template() {\n    return this._template;\n  }\n  /**\r\n   * @ignore\r\n   */\n  markDirty() {\n    this._root._addDirtyEntity(this);\n  }\n  _startAnimation() {\n    this._root._addAnimation(this);\n  }\n  _animationTime() {\n    return this._root.animationTime;\n  }\n  _applyState(_name) {}\n  _applyStateAnimated(_name, _duration) {}\n  get(key, fallback) {\n    const value = this.adapters.fold(key, this._settings[key]);\n    if (value !== undefined) {\n      return value;\n    } else {\n      return fallback;\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  isUserSetting(key) {\n    return this._userProperties[key] || false;\n  }\n  /**\r\n   * Sets a setting `value` for the specified `key`, and returns the same `value`.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info\r\n   * @param   key       Setting key\r\n   * @param   value     Setting value\r\n   * @return            Setting value\r\n   */\n  set(key, value) {\n    this._userProperties[key] = true;\n    return super.set(key, value);\n  }\n  /**\r\n   * @ignore\r\n   */\n  setRaw(key, value) {\n    this._userProperties[key] = true;\n    super.setRaw(key, value);\n  }\n  /**\r\n   * Sets a setting `value` for the specified `key` only if the value for this key was not set previously using set method, and returns the same `value`.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info\r\n   * @param   key       Setting key\r\n   * @param   value     Setting value\r\n   * @return            Setting value\r\n   */\n  _setSoft(key, value) {\n    if (!this._userProperties[key]) {\n      return super.set(key, value);\n    }\n    return value;\n  }\n  /**\r\n   * Removes a setting value for the specified `key`.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info\r\n   * @param   key       Setting key\r\n   */\n  remove(key) {\n    delete this._userProperties[key];\n    this._removeTemplateProperty(key);\n  }\n  /**\r\n   * @ignore\r\n   */\n  setPrivate(key, value) {\n    this._userPrivateProperties[key] = true;\n    return super.setPrivate(key, value);\n  }\n  /**\r\n   * @ignore\r\n   */\n  setPrivateRaw(key, value) {\n    this._userPrivateProperties[key] = true;\n    super.setPrivateRaw(key, value);\n  }\n  /**\r\n   * @ignore\r\n   */\n  removePrivate(key) {\n    delete this._userPrivateProperties[key];\n    this._removeTemplatePrivateProperty(key);\n  }\n  _setTemplateProperty(template, key, value) {\n    if (!this._userProperties[key]) {\n      const match = this._findTemplateByKey(key);\n      if (template === match) {\n        super.set(key, value);\n      }\n    }\n  }\n  _setTemplatePrivateProperty(template, key, value) {\n    if (!this._userPrivateProperties[key]) {\n      const match = this._findTemplateByPrivateKey(key);\n      if (template === match) {\n        super.setPrivate(key, value);\n      }\n    }\n  }\n  _removeTemplateProperty(key) {\n    if (!this._userProperties[key]) {\n      const match = this._findTemplateByKey(key);\n      if (match) {\n        // TODO don\'t stop the animation if the property didn\'t change\n        super.set(key, match._settings[key]);\n      } else {\n        super.remove(key);\n      }\n    }\n  }\n  _removeTemplatePrivateProperty(key) {\n    if (!this._userPrivateProperties[key]) {\n      const match = this._findTemplateByPrivateKey(key);\n      if (match) {\n        // TODO don\'t stop the animation if the property didn\'t change\n        super.setPrivate(key, match._privateSettings[key]);\n      } else {\n        super.removePrivate(key);\n      }\n    }\n  }\n  _walkParents(f) {\n    f(this._root._rootContainer);\n    f(this);\n  }\n  // TODO faster version of this method which is specialized to just 1 key\n  _applyStateByKey(name) {\n    const other = this.states.create(name, {});\n    const seen = {};\n    this._eachTemplate(template => {\n      const state = template.states.lookup(name);\n      if (state) {\n        state._apply(other, seen);\n      }\n    });\n    Object_each(other._settings, key => {\n      if (!seen[key] && !other._userSettings[key]) {\n        other.remove(key);\n      }\n    });\n  }\n  _applyTemplate(template, state) {\n    this._templateDisposers.push(template._apply(this, state));\n    Object_each(template._settings, (key, value) => {\n      if (!state.settings[key] && !this._userProperties[key]) {\n        state.settings[key] = true;\n        super.set(key, value);\n      }\n    });\n    Object_each(template._privateSettings, (key, value) => {\n      if (!state.privateSettings[key] && !this._userPrivateProperties[key]) {\n        state.privateSettings[key] = true;\n        super.setPrivate(key, value);\n      }\n    });\n    if (this._runSetup && template.setup) {\n      this._runSetup = false;\n      template.setup(this);\n    }\n  }\n  /**\r\n   * Calls the closure with each template and returns the first template which is true\r\n   */\n  _findStaticTemplate(f) {\n    if (this._template) {\n      if (f(this._template)) {\n        return this._template;\n      }\n    }\n  }\n  _eachTemplate(f) {\n    this._findStaticTemplate(template => {\n      f(template);\n      return false;\n    });\n    // _internalTemplates is sorted with most specific to the right\n    eachReverse(this._internalTemplates, f);\n    // _templates is sorted with most specific to the left\n    each(this._templates, f);\n  }\n  _applyTemplates(remove = true) {\n    if (remove) {\n      this._disposeTemplates();\n    }\n    const state = {\n      settings: {},\n      privateSettings: {},\n      states: {}\n    };\n    this._eachTemplate(template => {\n      this._applyTemplate(template, state);\n    });\n    if (remove) {\n      Object_each(this._settings, key => {\n        if (!this._userProperties[key] && !state.settings[key]) {\n          super.remove(key);\n        }\n      });\n      Object_each(this._privateSettings, key => {\n        if (!this._userPrivateProperties[key] && !state.privateSettings[key]) {\n          super.removePrivate(key);\n        }\n      });\n    }\n  }\n  _findTemplate(f) {\n    const value = this._findStaticTemplate(f);\n    if (value === undefined) {\n      // _internalTemplates is sorted with most specific to the right\n      const value = findReverse(this._internalTemplates, f);\n      if (value === undefined) {\n        // _templates is sorted with most specific to the left\n        return find(this._templates, f);\n      } else {\n        return value;\n      }\n    } else {\n      return value;\n    }\n  }\n  _findTemplateByKey(key) {\n    return this._findTemplate(template => {\n      return key in template._settings;\n    });\n  }\n  _findTemplateByPrivateKey(key) {\n    return this._findTemplate(template => {\n      return key in template._privateSettings;\n    });\n  }\n  _disposeTemplates() {\n    each(this._templateDisposers, disposer => {\n      disposer.dispose();\n    });\n    this._templateDisposers.length = 0;\n  }\n  _removeTemplates() {\n    each(this._templates, template => {\n      template._removeObjectTemplate(this);\n    });\n    this._templates.length = 0;\n  }\n  _applyThemes(force = false) {\n    let isConnected = false;\n    const defaults = [];\n    let themes = [];\n    const themeTags = new Set();\n    const tags = this.get("themeTagsSelf");\n    if (tags) {\n      each(tags, tag => {\n        themeTags.add(tag);\n      });\n    }\n    this._walkParents(entity => {\n      if (entity === this._root._rootContainer) {\n        isConnected = true;\n      }\n      if (entity._defaultThemes.length > 0) {\n        defaults.push(entity._defaultThemes);\n      }\n      const theme = entity.get("themes");\n      if (theme) {\n        themes.push(theme);\n      }\n      const tags = entity.get("themeTags");\n      if (tags) {\n        each(tags, tag => {\n          themeTags.add(tag);\n        });\n      }\n    });\n    themes = defaults.concat(themes);\n    this._removeTemplates();\n    if (isConnected || force) {\n      eachReverse(this.classNames, name => {\n        const allRules = [];\n        each(themes, themes => {\n          each(themes, theme => {\n            const rules = theme._lookupRules(name);\n            if (rules) {\n              eachReverse(rules, rule => {\n                const matches = rule.tags.every(tag => {\n                  return themeTags.has(tag);\n                });\n                if (matches) {\n                  const result = getFirstSortedIndex(allRules, x => {\n                    const order = compare(rule.tags.length, x.tags.length);\n                    if (order === 0) {\n                      return compareArray(rule.tags, x.tags, compare);\n                    } else {\n                      return order;\n                    }\n                  });\n                  allRules.splice(result.index, 0, rule);\n                }\n              });\n            }\n          });\n        });\n        each(allRules, rule => {\n          this._templates.push(rule.template);\n          rule.template._setObjectTemplate(this);\n        });\n      });\n    }\n    this._applyTemplates();\n    if (isConnected || force) {\n      // This causes it to only run the setup function the first time that the themes are applied\n      this._runSetup = false;\n    }\n    return isConnected || force;\n  }\n  _changed() {}\n  _beforeChanged() {\n    if (this.isDirty("id")) {\n      const id = this.get("id");\n      if (id) {\n        this._registerId(id);\n      }\n      const prevId = this._prevSettings.id;\n      if (prevId) {\n        delete registry.entitiesById[prevId];\n      }\n    }\n  }\n  _registerId(id) {\n    if (registry.entitiesById[id] && registry.entitiesById[id] !== this) {\n      throw new Error("An entity with id \\"" + id + "\\" already exists.");\n    }\n    registry.entitiesById[id] = this;\n  }\n  _afterChanged() {}\n  /**\r\n   * @ignore\r\n   */\n  addDisposer(disposer) {\n    this._disposers.push(disposer);\n    return disposer;\n  }\n  _dispose() {\n    super._dispose();\n    const template = this._template;\n    if (template) {\n      template._removeObjectTemplate(this);\n    }\n    each(this._internalTemplates, template => {\n      template._removeObjectTemplate(this);\n    });\n    this._removeTemplates();\n    this._disposeTemplates();\n    this.events.dispose();\n    this._disposers.forEach(x => {\n      x.dispose();\n    });\n    Object_each(this._disposerProperties, (_, disposers) => {\n      each(disposers, disposer => {\n        disposer.dispose();\n      });\n    });\n    const id = this.get("id");\n    if (id) {\n      delete registry.entitiesById[id];\n    }\n  }\n  /**\r\n   * Creates and returns a "disposable" timeout.\r\n   *\r\n   * @param   fn     Callback\r\n   * @param   delay  Delay in milliseconds\r\n   * @return         Timeout disposer\r\n   */\n  setTimeout(fn, delay) {\n    const id = setTimeout(() => {\n      this.removeDispose(disposer);\n      fn();\n    }, delay);\n    const disposer = new Disposer(() => {\n      clearTimeout(id);\n    });\n    this._disposers.push(disposer);\n    return disposer;\n  }\n  /**\r\n   * @ignore\r\n   */\n  removeDispose(target) {\n    if (!this.isDisposed()) {\n      let index = indexOf(this._disposers, target);\n      if (index > -1) {\n        this._disposers.splice(index, 1);\n      }\n    }\n    target.dispose();\n  }\n  /**\r\n   * @ignore\r\n   */\n  hasTag(tag) {\n    return indexOf(this.get("themeTags", []), tag) !== -1;\n  }\n  /**\r\n   * @ignore\r\n   */\n  addTag(tag) {\n    if (!this.hasTag(tag)) {\n      const tags = this.get("themeTags", []);\n      tags.push(tag);\n      this.set("themeTags", tags);\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  removeTag(tag) {\n    if (this.hasTag(tag)) {\n      const tags = this.get("themeTags", []);\n      Array_remove(tags, tag);\n      this.set("themeTags", tags);\n    }\n  }\n  _t(text, locale, ...rest) {\n    return this._root.language.translate(text, locale, ...rest);\n  }\n  /**\r\n   * An instance of [[Root]] object.\r\n   *\r\n   * @readonly\r\n   * @since 5.0.6\r\n   * @return Root object\r\n   */\n  get root() {\n    return this._root;\n  }\n}\nObject.defineProperty(Entity, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Entity"\n});\nObject.defineProperty(Entity, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: ["Entity"]\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js\n\n\n\n\nclass TemplateState {\n  constructor(name, template, settings) {\n    Object.defineProperty(this, "_settings", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_name", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_template", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._name = name;\n    this._template = template;\n    this._settings = settings;\n  }\n  get(key, fallback) {\n    const value = this._settings[key];\n    if (value !== undefined) {\n      return value;\n    } else {\n      return fallback;\n    }\n  }\n  set(key, value) {\n    this._settings[key] = value;\n    // TODO maybe only do this if the value changed ?\n    this._template._stateChanged(this._name);\n  }\n  remove(key) {\n    delete this._settings[key];\n    // TODO maybe only do this if the value changed ?\n    this._template._stateChanged(this._name);\n  }\n  setAll(settings) {\n    keys(settings).forEach(key => {\n      this._settings[key] = settings[key];\n    });\n    this._template._stateChanged(this._name);\n  }\n  _apply(other, seen) {\n    Object_each(this._settings, (key, value) => {\n      if (!seen[key] && !other._userSettings[key]) {\n        seen[key] = true;\n        other.setRaw(key, value);\n      }\n    });\n  }\n}\nclass TemplateStates {\n  constructor(template) {\n    Object.defineProperty(this, "_template", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_states", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    this._template = template;\n  }\n  lookup(name) {\n    return this._states[name];\n  }\n  create(name, settings) {\n    const state = this._states[name];\n    if (state) {\n      state.setAll(settings);\n      return state;\n    } else {\n      const state = new TemplateState(name, this._template, settings);\n      this._states[name] = state;\n      this._template._stateChanged(name);\n      return state;\n    }\n  }\n  remove(name) {\n    delete this._states[name];\n    this._template._stateChanged(name);\n  }\n  _apply(entity, state) {\n    Object_each(this._states, (key, value) => {\n      let seen = state.states[key];\n      if (seen == null) {\n        seen = state.states[key] = {};\n      }\n      const other = entity.states.create(key, {});\n      value._apply(other, seen);\n    });\n  }\n}\nclass TemplateAdapters {\n  constructor() {\n    Object.defineProperty(this, "_callbacks", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n  }\n  add(key, callback) {\n    let callbacks = this._callbacks[key];\n    if (callbacks === undefined) {\n      callbacks = this._callbacks[key] = [];\n    }\n    callbacks.push(callback);\n    return new Disposer(() => {\n      removeFirst(callbacks, callback);\n      if (callbacks.length === 0) {\n        delete this._callbacks[key];\n      }\n    });\n  }\n  remove(key) {\n    const callbacks = this._callbacks[key];\n    if (callbacks !== undefined) {\n      delete this._callbacks[key];\n    }\n  }\n  _apply(entity) {\n    const disposers = [];\n    Object_each(this._callbacks, (key, callbacks) => {\n      each(callbacks, callback => {\n        disposers.push(entity.adapters.add(key, callback));\n      });\n    });\n    return new Disposer_MultiDisposer(disposers);\n  }\n}\n// TODO maybe extend from Properties ?\nclass Template {\n  constructor(settings, isReal) {\n    Object.defineProperty(this, "_settings", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_privateSettings", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    // TODO code duplication with Properties\n    Object.defineProperty(this, "_settingEvents", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_privateSettingEvents", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_entities", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "states", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new TemplateStates(this)\n    });\n    Object.defineProperty(this, "adapters", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new TemplateAdapters()\n    });\n    Object.defineProperty(this, "events", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new EventDispatcher_EventDispatcher()\n    });\n    Object.defineProperty(this, "setup", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    if (!isReal) {\n      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");\n    }\n    this._settings = settings;\n  }\n  /**\r\n   * Use this method to create an instance of this class.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info\r\n   * @param   root      Root element\r\n   * @param   settings  Settings\r\n   * @param   template  Template\r\n   * @return            Instantiated object\r\n   */\n  static new(settings) {\n    return new Template(settings, true);\n  }\n  /**\r\n   * Array of all entities using this template.\r\n   */\n  get entities() {\n    return this._entities;\n  }\n  get(key, fallback) {\n    const value = this._settings[key];\n    if (value !== undefined) {\n      return value;\n    } else {\n      return fallback;\n    }\n  }\n  setRaw(key, value) {\n    this._settings[key] = value;\n  }\n  set(key, value) {\n    if (this._settings[key] !== value) {\n      this.setRaw(key, value);\n      this._entities.forEach(entity => {\n        entity._setTemplateProperty(this, key, value);\n      });\n    }\n  }\n  remove(key) {\n    if (key in this._settings) {\n      delete this._settings[key];\n      this._entities.forEach(entity => {\n        entity._removeTemplateProperty(key);\n      });\n    }\n  }\n  removeAll() {\n    Object_each(this._settings, (key, _value) => {\n      this.remove(key);\n    });\n  }\n  getPrivate(key, fallback) {\n    const value = this._privateSettings[key];\n    if (value !== undefined) {\n      return value;\n    } else {\n      return fallback;\n    }\n  }\n  setPrivateRaw(key, value) {\n    this._privateSettings[key] = value;\n    return value;\n  }\n  setPrivate(key, value) {\n    if (this._privateSettings[key] !== value) {\n      this.setPrivateRaw(key, value);\n      this._entities.forEach(entity => {\n        entity._setTemplatePrivateProperty(this, key, value);\n      });\n    }\n    return value;\n  }\n  removePrivate(key) {\n    if (key in this._privateSettings) {\n      delete this._privateSettings[key];\n      this._entities.forEach(entity => {\n        entity._removeTemplatePrivateProperty(key);\n      });\n    }\n  }\n  setAll(value) {\n    Object_each(value, (key, value) => {\n      this.set(key, value);\n    });\n  }\n  // TODO code duplication with Properties\n  on(key, callback) {\n    let events = this._settingEvents[key];\n    if (events === undefined) {\n      events = this._settingEvents[key] = [];\n    }\n    events.push(callback);\n    return new Disposer(() => {\n      removeFirst(events, callback);\n      if (events.length === 0) {\n        delete this._settingEvents[key];\n      }\n    });\n  }\n  // TODO code duplication with Properties\n  onPrivate(key, callback) {\n    let events = this._privateSettingEvents[key];\n    if (events === undefined) {\n      events = this._privateSettingEvents[key] = [];\n    }\n    events.push(callback);\n    return new Disposer(() => {\n      removeFirst(events, callback);\n      if (events.length === 0) {\n        delete this._privateSettingEvents[key];\n      }\n    });\n  }\n  _apply(entity, state) {\n    const disposers = [];\n    Object_each(this._settingEvents, (key, events) => {\n      each(events, event => {\n        disposers.push(entity.on(key, event));\n      });\n    });\n    Object_each(this._privateSettingEvents, (key, events) => {\n      each(events, event => {\n        disposers.push(entity.onPrivate(key, event));\n      });\n    });\n    this.states._apply(entity, state);\n    disposers.push(this.adapters._apply(entity));\n    disposers.push(entity.events.copyFrom(this.events));\n    return new Disposer_MultiDisposer(disposers);\n  }\n  _setObjectTemplate(entity) {\n    this._entities.push(entity);\n  }\n  _removeObjectTemplate(entity) {\n    Array_remove(this._entities, entity);\n  }\n  _stateChanged(name) {\n    this._entities.forEach(entity => {\n      entity._applyStateByKey(name);\n    });\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js\n\n/**\r\n * ============================================================================\r\n * CONSTANTS\r\n * ============================================================================\r\n * @hidden\r\n */\nconst PI = Math.PI;\nconst HALFPI = PI / 2;\nconst RADIANS = PI / 180;\nconst DEGREES = 180 / PI;\n/**\r\n * Rounds the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.\r\n * @return Rounded value\r\n */\nfunction round(value, precision, floor) {\n  if (!Type_isNumber(precision) || precision <= 0) {\n    let rounded = Math.round(value);\n    if (floor) {\n      if (rounded - value == 0.5) {\n        rounded--;\n      }\n    }\n    return rounded;\n  } else {\n    let d = Math.pow(10, precision);\n    return Math.round(value * d) / d;\n  }\n}\n/**\r\n * Ceils the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @return Rounded value\r\n */\nfunction ceil(value, precision) {\n  if (!Type_isNumber(precision) || precision <= 0) {\n    return Math.ceil(value);\n  } else {\n    let d = Math.pow(10, precision);\n    return Math.ceil(value * d) / d;\n  }\n}\n/**\r\n * [getCubicControlPointA description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\nfunction getCubicControlPointA(p0, p1, p2, tensionX, tensionY) {\n  return {\n    x: (-p0.x + p1.x / tensionX + p2.x) * tensionX,\n    y: (-p0.y + p1.y / tensionY + p2.y) * tensionY\n  };\n}\n/**\r\n * [getCubicControlPointB description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\nfunction getCubicControlPointB(p1, p2, p3, tensionX, tensionY) {\n  return {\n    x: (p1.x + p2.x / tensionX - p3.x) * tensionX,\n    y: (p1.y + p2.y / tensionY - p3.y) * tensionY\n  };\n}\nfunction fitToRange(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n/**\r\n * Returns sine of an angle specified in degrees.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\nfunction Math_sin(angle) {\n  return Math.sin(RADIANS * angle);\n}\n/**\r\n * Returns tan of an angle specified in degrees.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\nfunction tan(angle) {\n  return Math.tan(RADIANS * angle);\n}\n/**\r\n * Returns cosine of an angle specified in degrees.\r\n *\r\n * @param value  Value\r\n * @return Cosine\r\n */\nfunction Math_cos(angle) {\n  return Math.cos(RADIANS * angle);\n}\n// 0 to 360\nfunction normalizeAngle(value) {\n  value = value % 360;\n  if (value < 0) {\n    value += 360;\n  }\n  return value;\n}\n// TODO this doesn\'t work properly for skewing, and it\'s probably broken for rotation too\nfunction getArcBounds(cx, cy, startAngle, endAngle, radius) {\n  let minX = Number.MAX_VALUE;\n  let minY = Number.MAX_VALUE;\n  let maxX = -Number.MAX_VALUE;\n  let maxY = -Number.MAX_VALUE;\n  let bpoints = [];\n  bpoints.push(getArcPoint(radius, startAngle));\n  bpoints.push(getArcPoint(radius, endAngle));\n  let fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);\n  let toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);\n  for (let angle = fromAngle; angle <= toAngle; angle += 90) {\n    if (angle >= startAngle && angle <= endAngle) {\n      bpoints.push(getArcPoint(radius, angle));\n    }\n  }\n  for (let i = 0; i < bpoints.length; i++) {\n    let pt = bpoints[i];\n    if (pt.x < minX) {\n      minX = pt.x;\n    }\n    if (pt.y < minY) {\n      minY = pt.y;\n    }\n    if (pt.x > maxX) {\n      maxX = pt.x;\n    }\n    if (pt.y > maxY) {\n      maxY = pt.y;\n    }\n  }\n  return {\n    left: cx + minX,\n    top: cy + minY,\n    right: cx + maxX,\n    bottom: cy + maxY\n  };\n}\n/**\r\n * Returns point on arc\r\n *\r\n * @param center point\r\n * @param radius\r\n * @param arc\r\n * @return {boolean}\r\n */\nfunction getArcPoint(radius, arc) {\n  return {\n    x: radius * Math_cos(arc),\n    y: radius * Math_sin(arc)\n  };\n}\nfunction mergeBounds(bounds) {\n  const len = bounds.length;\n  if (len > 0) {\n    let bound = bounds[0];\n    let left = bound.left;\n    let top = bound.top;\n    let right = bound.right;\n    let bottom = bound.bottom;\n    if (len > 1) {\n      for (let i = 1; i < len; i++) {\n        bound = bounds[i];\n        left = Math.min(bound.left, left);\n        right = Math.max(bound.right, right);\n        top = Math.min(bound.top, top);\n        bottom = Math.max(bound.bottom, bottom);\n      }\n    }\n    return {\n      left,\n      right,\n      top,\n      bottom\n    };\n  }\n  return {\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0\n  };\n}\nfunction fitAngleToRange(value, startAngle, endAngle) {\n  if (startAngle > endAngle) {\n    let temp = startAngle;\n    startAngle = endAngle;\n    endAngle = temp;\n  }\n  value = normalizeAngle(value);\n  let count = (startAngle - normalizeAngle(startAngle)) / 360;\n  if (value < startAngle) {\n    value += 360 * (count + 1);\n  }\n  let maxEnd = startAngle + (endAngle - startAngle) / 2 + 180;\n  let maxStart = startAngle + (endAngle - startAngle) / 2 - 180;\n  if (value > endAngle) {\n    if (value - 360 > startAngle) {\n      value -= 360;\n    } else {\n      if (value < maxEnd) {\n        value = endAngle;\n      } else {\n        value = startAngle;\n      }\n    }\n  }\n  if (value < startAngle) {\n    if (value > maxStart) {\n      value = startAngle;\n    } else {\n      value = endAngle;\n    }\n  }\n  return value;\n}\nfunction inBounds(point, bounds) {\n  if (point.x >= bounds.left && point.y >= bounds.top && point.x <= bounds.right && point.y <= bounds.bottom) {\n    return true;\n  }\n  return false;\n}\nfunction getAngle(point1, point2) {\n  if (!point2) {\n    point2 = {\n      x: point1.x * 2,\n      y: point1.y * 2\n    };\n  }\n  let diffX = point2.x - point1.x;\n  let diffY = point2.y - point1.y;\n  let angle = Math.atan2(diffY, diffX) * DEGREES;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return normalizeAngle(angle);\n}\n/**\r\n * [getPointOnQuadraticCurve description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param pointA        [description]\r\n * @param pointB        [description]\r\n * @param controlPoint  [description]\r\n * @param position      [description]\r\n * @return [description]\r\n */\nfunction getPointOnQuadraticCurve(pointA, pointB, controlPoint, position) {\n  let x = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;\n  let y = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;\n  return {\n    x: x,\n    y: y\n  };\n}\nfunction getPointOnLine(pointA, pointB, position) {\n  return {\n    x: pointA.x + (pointB.x - pointA.x) * position,\n    y: pointA.y + (pointB.y - pointA.y) * position\n  };\n}\n/**\r\n * Returns the closest value from the array of values to the reference value.\r\n *\r\n * @param values  Array of values\r\n * @param value   Reference value\r\n * @return Closes value from the array\r\n */\nfunction closest(values, referenceValue) {\n  return values.reduce(function (prev, curr) {\n    return Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev;\n  });\n}\n/**\r\n * Returns true if bounds overlap\r\n * @param bounds1 IBounds\r\n * @param bounds2 IBounds\r\n * @returns boolean\r\n */\nfunction boundsOverlap(bounds1, bounds2) {\n  const horizontalOverlap = bounds1.left < bounds2.right && bounds1.right > bounds2.left;\n  const verticalOverlap = bounds1.top < bounds2.bottom && bounds1.bottom > bounds2.top;\n  return horizontalOverlap && verticalOverlap;\n}\n/**\r\n * Generates points of a spiral\r\n * @param cx\r\n * @param cy\r\n * @param radius\r\n * @param radiusY\r\n * @param innerRadius\r\n * @param step\r\n * @param radiusStep\r\n * @param startAngle\r\n * @param endAngle\r\n * @returns IPoint[]\r\n */\nfunction spiralPoints(cx, cy, radius, radiusY, innerRadius, step, radiusStep, startAngle, endAngle) {\n  let r = innerRadius + 0.01;\n  let angle = startAngle * RADIANS;\n  let points = [];\n  while (r < radius + radiusStep) {\n    let stepSize = step;\n    if (stepSize / 2 > r) {\n      stepSize = 2 * r;\n    }\n    angle += 2 * Math.asin(stepSize / 2 / r);\n    if (angle * DEGREES > endAngle + (radius - innerRadius) / radiusStep * 360) {\n      break;\n    }\n    let degrees = angle * DEGREES;\n    let point = {\n      x: cx + r * Math.cos(angle),\n      y: cy + r * radiusY / radius * Math.sin(angle)\n    };\n    points.push(point);\n    r = innerRadius + degrees / 360 * radiusStep;\n  }\n  points.shift();\n  return points;\n}\n/**\r\n * Returns true if circles overlap\r\n * @param circle1\r\n * @param circle2\r\n * @returns boolean\r\n */\nfunction circlesOverlap(circle1, circle2) {\n  return Math.hypot(circle1.x - circle2.x, circle1.y - circle2.y) <= circle1.radius + circle2.radius;\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js\n\n\n\n\n\n\n\n\n\n\n\n\n//import { populateString } from "../util/PopulateString";\n/**\r\n * An [[EventDispatcher]] for [[Sprite]].\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info\r\n */\nclass SpriteEventDispatcher extends EventDispatcher_EventDispatcher {\n  constructor(sprite) {\n    super();\n    Object.defineProperty(this, "_sprite", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_rendererDisposers", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_dispatchParents", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    this._sprite = sprite;\n  }\n  _makePointerEvent(key, event) {\n    return {\n      type: key,\n      originalEvent: event.event,\n      point: event.point,\n      simulated: event.simulated,\n      native: event.native,\n      target: this._sprite\n    };\n  }\n  _onRenderer(key, dispatch) {\n    // TODO: is this OK? it\'d be good not to require to set this on each individual element\n    this._sprite.set("interactive", true);\n    this._sprite._display.interactive = true;\n    let events = this._rendererDisposers[key];\n    if (events === undefined) {\n      const disposer = this._sprite._display.on(key, e => {\n        dispatch.call(this, e);\n      });\n      events = this._rendererDisposers[key] = new CounterDisposer(() => {\n        delete this._rendererDisposers[key];\n        disposer.dispose();\n      });\n    }\n    return events.increment();\n  }\n  _on(once, type, callback, context, shouldClone, dispatch) {\n    const info = super._on(once, type, callback, context, shouldClone, dispatch);\n    const rendererEvent = SpriteEventDispatcher.RENDERER_EVENTS[type];\n    if (rendererEvent !== undefined) {\n      info.disposer = new Disposer_MultiDisposer([info.disposer, this._onRenderer(type, rendererEvent)]);\n    }\n    return info;\n  }\n  /**\r\n   * Will stop any bubbling up of the event to element\'s parents.\r\n   *\r\n   * Should be called in an event handler, e.g.:\r\n   *\r\n   * ```TypeScript\r\n   * element.events.on("pointerdown", function(ev) {\r\n   *   // Do something here and prevent from "pointerdown" bubbling up\r\n   *   // ...\r\n   *   ev.target.events.stopParentDispatch();\r\n   * });\r\n   * ```\r\n   * ```JavaScript\r\n   * element.events.on("pointerdown", function(ev) {\r\n   *   // Do something here and prevent from "pointerdown" bubbling up\r\n   *   // ...\r\n   *   ev.target.events.stopParentDispatch();\r\n   * });\r\n   * ```\r\n   */\n  stopParentDispatch() {\n    this._dispatchParents = false;\n  }\n  /**\r\n   * @ignore\r\n   */\n  dispatchParents(type, event) {\n    const old = this._dispatchParents;\n    this._dispatchParents = true;\n    try {\n      this.dispatch(type, event);\n      if (this._dispatchParents && this._sprite.parent) {\n        this._sprite.parent.events.dispatchParents(type, event);\n      }\n    } finally {\n      this._dispatchParents = old;\n    }\n  }\n}\nObject.defineProperty(SpriteEventDispatcher, "RENDERER_EVENTS", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: {\n    "click": function (event) {\n      if (this.isEnabled("click") && !this._sprite.isDragging() && this._sprite._hasDown() && !this._sprite._hasMoved(this._makePointerEvent("click", event))) {\n        this.dispatch("click", this._makePointerEvent("click", event));\n      }\n    },\n    "rightclick": function (event) {\n      if (this.isEnabled("rightclick")) {\n        this.dispatch("rightclick", this._makePointerEvent("rightclick", event));\n      }\n    },\n    "middleclick": function (event) {\n      if (this.isEnabled("middleclick")) {\n        this.dispatch("middleclick", this._makePointerEvent("middleclick", event));\n      }\n    },\n    "dblclick": function (event) {\n      this.dispatchParents("dblclick", this._makePointerEvent("dblclick", event));\n    },\n    "pointerover": function (event) {\n      const sprite = this._sprite;\n      let dispatch = true;\n      if (sprite.getPrivate("trustBounds")) {\n        sprite._getBounds();\n        const bounds = sprite.globalBounds();\n        if (sprite.isType("Graphics")) {\n          const strokeWidth = sprite.get("strokeWidth", 1) / 2;\n          if (strokeWidth >= 1) {\n            bounds.left -= strokeWidth;\n            bounds.right += strokeWidth;\n            bounds.top -= strokeWidth;\n            bounds.bottom += strokeWidth;\n          }\n        }\n        if (!inBounds(event.point, bounds)) {\n          dispatch = false;\n          sprite._root._renderer.removeHovering(sprite._display);\n        }\n      }\n      if (dispatch && this.isEnabled("pointerover")) {\n        this.dispatch("pointerover", this._makePointerEvent("pointerover", event));\n      }\n    },\n    "pointerout": function (event) {\n      if (this.isEnabled("pointerout")) {\n        this.dispatch("pointerout", this._makePointerEvent("pointerout", event));\n      }\n    },\n    "pointerdown": function (event) {\n      this.dispatchParents("pointerdown", this._makePointerEvent("pointerdown", event));\n    },\n    "pointerup": function (event) {\n      if (this.isEnabled("pointerup")) {\n        this.dispatch("pointerup", this._makePointerEvent("pointerup", event));\n      }\n    },\n    "globalpointerup": function (event) {\n      if (this.isEnabled("globalpointerup")) {\n        this.dispatch("globalpointerup", this._makePointerEvent("globalpointerup", event));\n      }\n    },\n    "globalpointermove": function (event) {\n      if (this.isEnabled("globalpointermove")) {\n        this.dispatch("globalpointermove", this._makePointerEvent("globalpointermove", event));\n      }\n    },\n    "wheel": function (event) {\n      this.dispatchParents("wheel", {\n        type: "wheel",\n        target: this._sprite,\n        originalEvent: event.event,\n        point: event.point\n      });\n    }\n  }\n});\n/**\r\n * A base class for all visual elements.\r\n *\r\n * @important\r\n */\nclass Sprite extends Entity {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_adjustedLocalBounds", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }\n    });\n    Object.defineProperty(this, "_localBounds", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }\n    });\n    Object.defineProperty(this, "_parent", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_dataItem", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_templateField", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_sizeDirty", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    // Will be true only when dragging\n    Object.defineProperty(this, "_isDragging", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    // The event when the dragging starts\n    Object.defineProperty(this, "_dragEvent", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    // The position when dragging starts\n    Object.defineProperty(this, "_dragPoint", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_isHidden", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_isShowing", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_isHiding", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_isDown", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_downPoint", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_downPoints", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_toggleDp", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_dragDp", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_tooltipDp", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_hoverDp", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_focusDp", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_tooltipMoveDp", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_tooltipPointerDp", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_statesHandled", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n  }\n  _afterNew() {\n    this.setPrivateRaw("visible", true);\n    super._afterNew();\n  }\n  /**\r\n   * Marks some setting as dirty. Could be used to trigger adapter.\r\n   * @param key\r\n   */\n  markDirtyKey(key) {\n    this._markDirtyKey(key);\n  }\n  _markDirtyKey(key) {\n    super._markDirtyKey(key);\n    if (key == "x" || key == "y" || key == "dx" || key == "dy") {\n      this.markDirtyBounds();\n      this._addPercentagePositionChildren();\n      this.markDirtyPosition();\n    }\n  }\n  _markDirtyPrivateKey(key) {\n    super._markDirtyPrivateKey(key);\n    if (key == "x" || key == "y") {\n      this.markDirtyPosition();\n    }\n  }\n  _removeTemplateField() {\n    if (this._templateField) {\n      this._templateField._removeObjectTemplate(this);\n    }\n  }\n  _createEvents() {\n    return new SpriteEventDispatcher(this);\n  }\n  _processTemplateField() {\n    let template;\n    const field = this.get("templateField");\n    if (field) {\n      const dataItem = this.dataItem;\n      if (dataItem) {\n        const context = dataItem.dataContext;\n        if (context) {\n          template = context[field];\n          if (!(template instanceof Template) && template) {\n            template = Template.new(template);\n          }\n        }\n      }\n    }\n    if (this._templateField !== template) {\n      this._removeTemplateField();\n      this._templateField = template;\n      if (template) {\n        template._setObjectTemplate(this);\n      }\n      this._applyTemplates();\n    }\n  }\n  // TODO change this to run before the element is added to the parent, so that way\n  //      it doesn\'t need to apply the themes twice\n  _setDataItem(dataItem) {\n    const oldDataItem = this._dataItem;\n    this._dataItem = dataItem;\n    this._processTemplateField();\n    const eventType = "dataitemchanged";\n    if (dataItem != oldDataItem) {\n      if (this.events.isEnabled(eventType)) {\n        this.events.dispatch(eventType, {\n          type: eventType,\n          target: this,\n          oldDataItem: oldDataItem,\n          newDataItem: dataItem\n        });\n      }\n    }\n  }\n  /**\r\n   * A [[DataItem]] used for this element.\r\n   *\r\n   * NOTE: data item is being assigned automatically in most cases where it\r\n   * matters. Use this accessor to set data item only if you know what you\'re\r\n   * doing.\r\n   *\r\n   * @param  value  Data item\r\n   */\n  set dataItem(value) {\n    this._setDataItem(value);\n  }\n  /**\r\n   * @return DataItem\r\n   */\n  get dataItem() {\n    if (this._dataItem) {\n      return this._dataItem;\n    } else {\n      let parent = this._parent;\n      while (parent) {\n        if (parent._dataItem) {\n          return parent._dataItem;\n        } else {\n          parent = parent._parent;\n        }\n      }\n    }\n  }\n  _addPercentageSizeChildren() {\n    let parent = this.parent;\n    if (parent) {\n      if (this.get("width") instanceof Percent || this.get("height") instanceof Percent) {\n        pushOne(parent._percentageSizeChildren, this);\n      } else {\n        removeFirst(parent._percentageSizeChildren, this);\n      }\n    }\n  }\n  _addPercentagePositionChildren() {\n    let parent = this.parent;\n    if (parent) {\n      if (this.get("x") instanceof Percent || this.get("y") instanceof Percent) {\n        pushOne(parent._percentagePositionChildren, this);\n      } else {\n        removeFirst(parent._percentagePositionChildren, this);\n      }\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  markDirtyPosition() {\n    this._root._addDirtyPosition(this);\n  }\n  updatePivotPoint() {\n    const bounds = this._localBounds;\n    if (bounds) {\n      const centerX = this.get("centerX");\n      if (centerX != null) {\n        this._display.pivot.x = bounds.left + relativeToValue(centerX, bounds.right - bounds.left);\n      }\n      const centerY = this.get("centerY");\n      if (centerY != null) {\n        this._display.pivot.y = bounds.top + relativeToValue(centerY, bounds.bottom - bounds.top);\n      }\n    }\n  }\n  _beforeChanged() {\n    super._beforeChanged();\n    // handling states in beforeChanged, otherwise states is not applied without animated theme\n    this._handleStates();\n    if (this.isDirty("tooltip")) {\n      const previous = this._prevSettings.tooltip;\n      if (previous) {\n        previous.dispose();\n      }\n    }\n    if (this.isDirty("layer") || this.isDirty("layerMargin")) {\n      this._display.setLayer(this.get("layer"), this.get("layerMargin"));\n      this.markDirtyLayer();\n    }\n    if (this.isDirty("tooltipPosition")) {\n      const tooltipMoveDp = this._tooltipMoveDp;\n      if (tooltipMoveDp) {\n        tooltipMoveDp.dispose();\n        this._tooltipMoveDp = undefined;\n      }\n      const tooltipPointerDp = this._tooltipPointerDp;\n      if (tooltipPointerDp) {\n        tooltipPointerDp.dispose();\n        this._tooltipPointerDp = undefined;\n      }\n      if (this.get("tooltipPosition") == "pointer") {\n        if (this.isHover()) {\n          this._tooltipMoveDp = this.events.on("globalpointermove", e => {\n            this.showTooltip(e.point);\n          });\n        }\n        this._tooltipPointerDp = new Disposer_MultiDisposer([this.events.on("pointerover", () => {\n          this._tooltipMoveDp = this.events.on("globalpointermove", e => {\n            this.showTooltip(e.point);\n          });\n        }), this.events.on("pointerout", () => {\n          const tooltipMoveDp = this._tooltipMoveDp;\n          if (tooltipMoveDp) {\n            tooltipMoveDp.dispose();\n            this._tooltipMoveDp = undefined;\n          }\n        })]);\n      }\n    }\n  }\n  _handleStates() {\n    if (!this._statesHandled) {\n      if (this.isDirty("active")) {\n        if (this.get("active")) {\n          this.states.applyAnimate("active");\n          this.set("ariaChecked", true);\n        } else {\n          if (!this.isHidden()) {\n            this.states.applyAnimate("default");\n          }\n          this.set("ariaChecked", false);\n        }\n        this.markDirtyAccessibility();\n      }\n      if (this.isDirty("disabled")) {\n        if (this.get("disabled")) {\n          this.states.applyAnimate("disabled");\n          this.set("ariaChecked", false);\n        } else {\n          if (!this.isHidden()) {\n            this.states.applyAnimate("default");\n          }\n          this.set("ariaChecked", true);\n        }\n        this.markDirtyAccessibility();\n      }\n      this._statesHandled = true;\n    }\n  }\n  _changed() {\n    super._changed();\n    const display = this._display;\n    const events = this.events;\n    if (this.isDirty("draggable")) {\n      const draggable = this.get("draggable");\n      if (draggable) {\n        this.set("interactive", true);\n        this._dragDp = new Disposer_MultiDisposer([events.on("pointerdown", ev => {\n          this.dragStart(ev);\n        }), events.on("globalpointermove", ev => {\n          this.dragMove(ev);\n        }), events.on("globalpointerup", ev => {\n          this.dragStop(ev);\n        })]);\n      } else {\n        if (this._dragDp) {\n          this._dragDp.dispose();\n          this._dragDp = undefined;\n        }\n      }\n      display.cancelTouch = draggable ? true : false;\n    }\n    if (this.isDirty("tooltipText") || this.isDirty("tooltipHTML") || this.isDirty("showTooltipOn")) {\n      const tooltipText = this.get("tooltipText");\n      const tooltipHTML = this.get("tooltipHTML");\n      const showTooltipOn = this.get("showTooltipOn", "hover");\n      if (this._tooltipDp) {\n        this._tooltipDp.dispose();\n        this._tooltipDp = undefined;\n      }\n      if (tooltipText || tooltipHTML) {\n        if (showTooltipOn == "click") {\n          this._tooltipDp = new Disposer_MultiDisposer([events.on("click", () => {\n            this.setTimeout(() => this.showTooltip(), 10);\n          }), Utils_addEventListener(document, "click", _ev => {\n            this.hideTooltip();\n          })]);\n          this._disposers.push(this._tooltipDp);\n        } else if (showTooltipOn == "always") {\n          // nothing\n        } else {\n          this._tooltipDp = new Disposer_MultiDisposer([events.on("pointerover", () => {\n            this.showTooltip();\n          }), events.on("pointerout", () => {\n            this.hideTooltip();\n          })]);\n          this._disposers.push(this._tooltipDp);\n        }\n      }\n    }\n    if (this.isDirty("toggleKey")) {\n      let toggleKey = this.get("toggleKey");\n      if (toggleKey && toggleKey != "none") {\n        this._toggleDp = events.on("click", () => {\n          if (!this._isDragging) {\n            this.set(toggleKey, !this.get(toggleKey));\n          }\n        });\n      } else {\n        if (this._toggleDp) {\n          this._toggleDp.dispose();\n          this._toggleDp = undefined;\n        }\n      }\n    }\n    if (this.isDirty("opacity")) {\n      display.alpha = Math.max(0, this.get("opacity", 1));\n      if (this.get("focusable")) {\n        this.markDirtyAccessibility();\n      }\n    }\n    if (this.isDirty("rotation")) {\n      this.markDirtyBounds();\n      display.angle = this.get("rotation", 0);\n    }\n    if (this.isDirty("scale")) {\n      this.markDirtyBounds();\n      display.scale = this.get("scale", 0);\n    }\n    if (this.isDirty("centerX") || this.isDirty("centerY")) {\n      this.markDirtyBounds();\n      this.updatePivotPoint();\n    }\n    if (this.isDirty("visible") || this.isPrivateDirty("visible") || this.isDirty("forceHidden")) {\n      if (!this.get("visible") || !this.getPrivate("visible") || this.get("forceHidden")) {\n        display.visible = false;\n        this.hideTooltip();\n      } else {\n        display.visible = true;\n      }\n      this.markDirtyBounds();\n      if (this.get("focusable")) {\n        this.markDirtyAccessibility();\n      }\n    }\n    if (this.isDirty("width") || this.isDirty("height")) {\n      this.markDirtyBounds();\n      this._addPercentageSizeChildren();\n      const parent = this.parent;\n      if (parent) {\n        if (this.isDirty("width") && this.get("width") instanceof Percent || this.isDirty("height") && this.get("height") instanceof Percent) {\n          parent.markDirty();\n          parent._prevWidth = 0;\n        }\n      }\n      this._sizeDirty = true;\n    }\n    if (this.isDirty("maxWidth") || this.isDirty("maxHeight") || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("minWidth") || this.isDirty("minHeight") || this.isPrivateDirty("maxWidth") || this.isPrivateDirty("maxHeight") || this.isPrivateDirty("minWidth") || this.isPrivateDirty("minHeight") || this.isDirty("marginLeft") || this.isDirty("marginTop") || this.isDirty("marginRight") || this.isDirty("marginBottom")) {\n      this.markDirtyBounds();\n      this._sizeDirty = true;\n    }\n    if (this._sizeDirty) {\n      this._updateSize();\n    }\n    if (this.isDirty("wheelable")) {\n      const wheelable = this.get("wheelable");\n      if (wheelable) {\n        this.set("interactive", true);\n      }\n      display.wheelable = wheelable ? true : false;\n    }\n    // Accessibility\n    if (this.isDirty("tabindexOrder") || this.isDirty("focusableGroup")) {\n      if (this.get("focusable")) {\n        this._root._registerTabindexOrder(this);\n      } else {\n        this._root._unregisterTabindexOrder(this);\n      }\n    }\n    if (this.isDirty("filter")) {\n      //this.markDirtyBounds();\n      display.filter = this.get("filter");\n    }\n    let filter = this.get("filter", "");\n    if (this.isDirty("blur")) {\n      const blur = this.get("blur", 0);\n      if (blur != 0) {\n        filter += " blur(" + blur + "px)";\n      }\n    }\n    if (this.isDirty("saturate")) {\n      const saturate = this.get("saturate", 1);\n      if (saturate != 1) {\n        filter += " saturate(" + saturate + ")";\n      }\n    }\n    if (this.isDirty("brightness")) {\n      const brightness = this.get("brightness", 1);\n      if (brightness != 1) {\n        filter += " brightness(" + brightness + ")";\n      }\n    }\n    if (this.isDirty("contrast")) {\n      const contrast = this.get("contrast", 1);\n      if (contrast != 1) {\n        filter += " contrast(" + contrast + ")";\n      }\n    }\n    if (this.isDirty("sepia")) {\n      const sepia = this.get("sepia", 0);\n      if (sepia != 0) {\n        filter += " sepia(" + sepia + ")";\n      }\n    }\n    if (this.isDirty("hue")) {\n      const hue = this.get("hue", 0);\n      if (hue != 0) {\n        filter += " hue-rotate(" + hue + "deg)";\n      }\n    }\n    if (this.isDirty("invert")) {\n      const invert = this.get("invert", 0);\n      if (invert != 0) {\n        filter += " invert(" + invert + ")";\n      }\n    }\n    if (filter) {\n      display.filter = filter;\n    }\n    if (this.isDirty("cursorOverStyle")) {\n      display.cursorOverStyle = this.get("cursorOverStyle");\n    }\n    if (this.isDirty("hoverOnFocus")) {\n      if (this.get("hoverOnFocus")) {\n        this._focusDp = new Disposer_MultiDisposer([events.on("focus", () => {\n          // TODO: proper hover, not just tooltip\n          this.showTooltip();\n        }), events.on("blur", () => {\n          // TODO: proper hover, not just tooltip\n          this.hideTooltip();\n        })]);\n      } else {\n        if (this._focusDp) {\n          this._focusDp.dispose();\n          this._focusDp = undefined;\n        }\n      }\n    }\n    if (this.isDirty("focusable")) {\n      if (this.get("focusable")) {\n        this._root._registerTabindexOrder(this);\n      } else {\n        this._root._unregisterTabindexOrder(this);\n      }\n      this.markDirtyAccessibility();\n    }\n    if (this.isPrivateDirty("focusable")) {\n      this.markDirtyAccessibility();\n    }\n    if (this.isDirty("role") || this.isDirty("ariaLive") || this.isDirty("ariaChecked") || this.isDirty("ariaHidden") || this.isDirty("ariaOrientation") || this.isDirty("ariaValueNow") || this.isDirty("ariaValueMin") || this.isDirty("ariaValueMax") || this.isDirty("ariaValueText") || this.isDirty("ariaLabel") || this.isDirty("ariaControls")) {\n      // display.accessibility.ariaLabel = populateString(this, this.get("ariaLabel", ""));\n      // @todo make sure ariaLabel gets populated in Root\n      this.markDirtyAccessibility();\n    }\n    if (this.isDirty("exportable")) {\n      display.exportable = this.get("exportable");\n    }\n    if (this.isDirty("interactive")) {\n      const events = this.events;\n      if (this.get("interactive") && !events.isDisposed()) {\n        this._hoverDp = new Disposer_MultiDisposer([events.on("click", ev => {\n          if (isTouchEvent(ev.originalEvent)) {\n            if (!this.getPrivate("touchHovering")) {\n              this.setTimeout(() => {\n                this._handleOver();\n                if (this.get("tooltipText") || this.get("tooltipHTML")) {\n                  this.showTooltip();\n                }\n                this.setPrivateRaw("touchHovering", true);\n                this.events.dispatch("pointerover", {\n                  type: "pointerover",\n                  target: ev.target,\n                  originalEvent: ev.originalEvent,\n                  point: ev.point,\n                  simulated: ev.simulated\n                });\n              }, 10);\n            }\n          }\n        }), events.on("globalpointerup", ev => {\n          if (isTouchEvent(ev.originalEvent)) {\n            if (this.getPrivate("touchHovering")) {\n              this._handleOut();\n              if (this.get("tooltipText") || this.get("tooltipHTML")) {\n                this.hideTooltip();\n              }\n              this.setPrivateRaw("touchHovering", false);\n              this.events.dispatch("pointerout", {\n                type: "pointerout",\n                target: ev.target,\n                originalEvent: ev.originalEvent,\n                point: ev.point,\n                simulated: ev.simulated\n              });\n            }\n          }\n          if (this._isDown) {\n            this._handleUp(ev);\n          }\n          //this._isDown = false;\n        }), events.on("pointerover", () => {\n          this._handleOver();\n        }), events.on("pointerout", () => {\n          this._handleOut();\n        }), events.on("pointerdown", e => {\n          this._handleDown(e);\n        })]);\n      } else {\n        this._display.interactive = false;\n        if (this._hoverDp) {\n          this._hoverDp.dispose();\n          this._hoverDp = undefined;\n        }\n      }\n    }\n    if (this.isDirty("forceInactive")) {\n      this._display.inactive = this.get("forceInactive", null);\n    }\n    if (this.get("showTooltipOn") == "always" && this._display.visible) {\n      this.showTooltip();\n    }\n  }\n  /**\r\n   * @ignore\r\n   * @todo should this be user-accessible?\r\n   */\n  dragStart(e) {\n    this._dragEvent = e;\n    this.events.stopParentDispatch();\n  }\n  /**\r\n   * @ignore\r\n   * @todo should this be user-accessible?\r\n   */\n  dragStop(e) {\n    this._dragEvent = undefined;\n    this._dragPoint = undefined;\n    this.events.stopParentDispatch();\n    if (this._isDragging) {\n      this._isDragging = false;\n      const type = "dragstop";\n      if (this.events.isEnabled(type)) {\n        this.events.dispatch(type, {\n          type: type,\n          target: this,\n          originalEvent: e.originalEvent,\n          point: e.point,\n          simulated: e.simulated\n        });\n      }\n    }\n  }\n  _handleOver() {\n    if (!this.isHidden()) {\n      if (this.get("active") && this.states.lookup("hoverActive")) {\n        this.states.applyAnimate("hoverActive");\n      } else if (this.get("disabled") && this.states.lookup("hoverDisabled")) {\n        this.states.applyAnimate("hoverDisabled");\n      } else {\n        this.states.applyAnimate("hover");\n      }\n      if (this.get("draggable") && this._isDown && this.states.lookup("down")) {\n        this.states.applyAnimate("down");\n      }\n    }\n  }\n  _handleOut() {\n    if (!this.isHidden()) {\n      if (this.get("active") && this.states.lookup("active")) {\n        this.states.applyAnimate("active");\n      } else if (this.get("disabled") && this.states.lookup("disabled")) {\n        this.states.applyAnimate("disabled");\n      } else {\n        if (this.states.lookup("hover") || this.states.lookup("hoverActive")) {\n          this.states.applyAnimate("default");\n        }\n      }\n      if (this.get("draggable") && this._isDown && this.states.lookup("down")) {\n        this.states.applyAnimate("down");\n      }\n    }\n  }\n  _handleUp(e) {\n    if (!this.isHidden()) {\n      if (this.get("active") && this.states.lookup("active")) {\n        this.states.applyAnimate("active");\n      } else if (this.get("disabled") && this.states.lookup("disabled")) {\n        this.states.applyAnimate("disabled");\n      } else if (this.states.lookup("down")) {\n        if (this.isHover()) {\n          this.states.applyAnimate("hover");\n        } else {\n          this.states.applyAnimate("default");\n        }\n      }\n      // @todo remove this once migrated to _downPoints\n      this._downPoint = undefined;\n      const pointerId = getPointerId(e.originalEvent);\n      delete this._downPoints[pointerId];\n      if (keys(this._downPoints).length == 0) {\n        this._isDown = false;\n      }\n    }\n  }\n  _hasMoved(e) {\n    // @todo remove this once migrated to _downPoints\n    // if (this._downPoint) {\n    // \tconst x = Math.abs(this._downPoint.x - e.point.x);\n    // \tconst y = Math.abs(this._downPoint.y - e.point.y);\n    // \treturn (x > 5) || (y > 5);\n    // }\n    const pointerId = getPointerId(e.originalEvent);\n    const downPoint = this._downPoints[pointerId];\n    if (downPoint) {\n      const x = Math.abs(downPoint.x - e.point.x);\n      const y = Math.abs(downPoint.y - e.point.y);\n      return x > 5 || y > 5;\n    }\n    return false;\n  }\n  _hasDown() {\n    return keys(this._downPoints).length > 0;\n  }\n  _handleDown(e) {\n    const parent = this.parent;\n    if (parent && !this.get("draggable")) {\n      parent._handleDown(e);\n    }\n    if (this.get("interactive") && !this.isHidden()) {\n      if (this.states.lookup("down")) {\n        this.states.applyAnimate("down");\n      }\n      this._downPoint = {\n        x: e.point.x,\n        y: e.point.y\n      };\n      // @todo remove this once migrated to _downPoints\n      this._isDown = true;\n      const pointerId = getPointerId(e.originalEvent);\n      this._downPoints[pointerId] = {\n        x: e.point.x,\n        y: e.point.y\n      };\n    }\n  }\n  /**\r\n   * @ignore\r\n   * @todo should this be user-accessible?\r\n   */\n  dragMove(e) {\n    let dragEvent = this._dragEvent;\n    if (dragEvent) {\n      if (dragEvent.simulated && !e.simulated) {\n        return true;\n      }\n      let angle = 0;\n      let parent = this.parent;\n      let scale = 1;\n      while (parent != null) {\n        angle += parent.get("rotation", 0);\n        parent = parent.parent;\n        if (parent) {\n          scale *= parent.get("scale", 1);\n        }\n      }\n      let x = (e.point.x - dragEvent.point.x) / scale;\n      let y = (e.point.y - dragEvent.point.y) / scale;\n      const events = this.events;\n      if (dragEvent.simulated && !this._isDragging) {\n        this._isDragging = true;\n        this._dragEvent = e;\n        this._dragPoint = {\n          x: this.x(),\n          y: this.y()\n        };\n        const type = "dragstart";\n        if (events.isEnabled(type)) {\n          events.dispatch(type, {\n            type: type,\n            target: this,\n            originalEvent: e.originalEvent,\n            point: e.point,\n            simulated: e.simulated\n          });\n        }\n      }\n      if (this._isDragging) {\n        let dragPoint = this._dragPoint;\n        this.set("x", dragPoint.x + x * Math_cos(angle) + y * Math_sin(angle));\n        this.set("y", dragPoint.y + y * Math_cos(angle) - x * Math_sin(angle));\n        const type = "dragged";\n        if (events.isEnabled(type)) {\n          events.dispatch(type, {\n            type: type,\n            target: this,\n            originalEvent: e.originalEvent,\n            point: e.point,\n            simulated: e.simulated\n          });\n        }\n      } else {\n        if (Math.hypot(x, y) > 5) {\n          this._isDragging = true;\n          this._dragEvent = e;\n          this._dragPoint = {\n            x: this.x(),\n            y: this.y()\n          };\n          const type = "dragstart";\n          if (events.isEnabled(type)) {\n            events.dispatch(type, {\n              type: type,\n              target: this,\n              originalEvent: e.originalEvent,\n              point: e.point,\n              simulated: e.simulated\n            });\n          }\n        }\n      }\n    }\n  }\n  _updateSize() {}\n  _getBounds() {\n    this._localBounds = this._display.getLocalBounds();\n  }\n  /**\r\n   * Returns depth (how deep in the hierachy of the content tree) of this\r\n   * element.\r\n   *\r\n   * @return Depth\r\n   */\n  depth() {\n    let self = this.parent;\n    let depth = 0;\n    while (true) {\n      if (self) {\n        ++depth;\n        self = self.parent;\n      } else {\n        return depth;\n      }\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  markDirtySize() {\n    this._sizeDirty = true;\n    this.markDirty();\n  }\n  /**\r\n   * @ignore\r\n   */\n  markDirtyBounds() {\n    const display = this._display;\n    if (this.get("isMeasured")) {\n      this._root._addDirtyBounds(this);\n      display.isMeasured = true;\n      display.invalidateBounds();\n      const parent = this.parent;\n      if (parent && this.get("position") != "absolute") {\n        if (parent.get("width") == null || parent.get("height") == null || parent.get("layout")) {\n          parent.markDirtyBounds();\n        }\n      }\n      if (this.get("focusable") && this.isFocus()) {\n        this.markDirtyAccessibility();\n      }\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  markDirtyAccessibility() {\n    //if (this._root.focused(this)) {\n    this._root._invalidateAccessibility(this);\n    //}\n  }\n  /**\r\n   * @ignore\r\n   */\n  markDirtyLayer() {\n    //this._display.markDirtyLayer(this.isDirty("opacity") || this.isDirty("visible")); https://codepen.io/team/amcharts/pen/gOWZPmP <- problems\n    this._display.markDirtyLayer(true);\n  }\n  /**\r\n   * @ignore\r\n   */\n  markDirty() {\n    super.markDirty();\n    this.markDirtyLayer();\n  }\n  _updateBounds() {\n    const oldBounds = this._adjustedLocalBounds;\n    let newBounds;\n    // if display.visible == false, it still returns bounds\n    if (!this.get("visible") || !this.getPrivate("visible") || this.get("forceHidden")) {\n      newBounds = {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      };\n      this._localBounds = newBounds;\n      this._adjustedLocalBounds = newBounds;\n    } else {\n      this._getBounds();\n      this._fixMinBounds(this._localBounds);\n      this.updatePivotPoint();\n      this._adjustedLocalBounds = this._display.getAdjustedBounds(this._localBounds);\n      newBounds = this._adjustedLocalBounds;\n    }\n    if (!oldBounds || oldBounds.left !== newBounds.left || oldBounds.top !== newBounds.top || oldBounds.right !== newBounds.right || oldBounds.bottom !== newBounds.bottom) {\n      const eventType = "boundschanged";\n      if (this.events.isEnabled(eventType)) {\n        this.events.dispatch(eventType, {\n          type: eventType,\n          target: this\n        });\n      }\n      if (this.parent) {\n        this.parent.markDirty();\n        this.parent.markDirtyBounds();\n      }\n      // Update tooltip position together with the Sprite\n      if (this.getPrivate("showingTooltip")) {\n        this.showTooltip();\n      }\n    }\n  }\n  _fixMinBounds(bounds) {\n    let minWidth = this.get("minWidth", this.getPrivate("minWidth"));\n    let minHeight = this.get("minHeight", this.getPrivate("minHeight"));\n    if (Type_isNumber(minWidth)) {\n      if (bounds.right - bounds.left < minWidth) {\n        bounds.right = bounds.left + minWidth;\n      }\n    }\n    if (Type_isNumber(minHeight)) {\n      if (bounds.bottom - bounds.top < minHeight) {\n        bounds.bottom = bounds.top + minHeight;\n      }\n    }\n    let privateWidth = this.getPrivate("width");\n    let privateHeight = this.getPrivate("height");\n    if (Type_isNumber(privateWidth)) {\n      if (privateWidth > 0) {\n        bounds.right = bounds.left + privateWidth;\n      } else {\n        bounds.left = bounds.right + privateWidth;\n      }\n    }\n    if (Type_isNumber(privateHeight)) {\n      if (privateHeight > 0) {\n        bounds.bottom = bounds.top + privateHeight;\n      } else {\n        bounds.top = bounds.bottom + privateHeight;\n      }\n    }\n  }\n  _removeParent(parent) {\n    if (parent) {\n      parent.children.removeValue(this);\n      removeFirst(parent._percentageSizeChildren, this);\n      removeFirst(parent._percentagePositionChildren, this);\n    }\n  }\n  _clearDirty() {\n    super._clearDirty();\n    this._sizeDirty = false;\n    this._statesHandled = false;\n  }\n  /**\r\n   * Simulate hover over element.\r\n   */\n  hover() {\n    this.showTooltip();\n    this._handleOver();\n  }\n  /**\r\n   * Simulate unhover over element.\r\n   */\n  unhover() {\n    this.hideTooltip();\n    this._handleOut();\n  }\n  /**\r\n   * Shows element\'s [[Tooltip]].\r\n   */\n  showTooltip(point) {\n    const tooltip = this.getTooltip();\n    const tooltipText = this.get("tooltipText");\n    const tooltipHTML = this.get("tooltipHTML");\n    if ((tooltipText || tooltipHTML) && tooltip) {\n      const tooltipPosition = this.get("tooltipPosition");\n      const tooltipTarget = this.getPrivate("tooltipTarget", this);\n      if (tooltipPosition == "fixed" || !point) {\n        this._display._setMatrix();\n        point = this.toGlobal(tooltipTarget._getTooltipPoint());\n      }\n      tooltip.set("pointTo", point);\n      tooltip.set("tooltipTarget", tooltipTarget);\n      if (!tooltip.get("x")) {\n        tooltip.set("x", point.x);\n      }\n      if (!tooltip.get("y")) {\n        tooltip.set("y", point.y);\n      }\n      if (tooltipText) {\n        tooltip.label.set("text", tooltipText);\n      }\n      if (tooltipHTML) {\n        tooltip.label.set("html", tooltipHTML);\n      }\n      const dataItem = this.dataItem;\n      if (dataItem) {\n        tooltip.label._setDataItem(dataItem);\n      }\n      if (this.get("showTooltipOn") == "always" && (point.x < 0 || point.x > this._root.width() || point.y < 0 || point.y > this._root.height())) {\n        this.hideTooltip();\n        return;\n      }\n      tooltip.label.text.markDirtyText();\n      const promise = tooltip.show();\n      this.setPrivateRaw("showingTooltip", true);\n      return promise;\n    }\n  }\n  /**\r\n   * Hides element\'s [[Tooltip]].\r\n   */\n  hideTooltip() {\n    const tooltip = this.getTooltip();\n    if (tooltip) {\n      if (tooltip.get("tooltipTarget") == this.getPrivate("tooltipTarget", this) || this.get("tooltip") == tooltip) {\n        let timeout = tooltip.get("keepTargetHover") && tooltip.get("stateAnimationDuration", 0) == 0 ? 400 : undefined;\n        const promise = tooltip.hide(timeout);\n        this.setPrivateRaw("showingTooltip", false);\n        return promise;\n      }\n    }\n  }\n  _getTooltipPoint() {\n    const bounds = this._localBounds;\n    if (bounds) {\n      let x = 0;\n      let y = 0;\n      if (!this.get("isMeasured")) {\n        x = relativeToValue(this.get("tooltipX", 0), this.width());\n        y = relativeToValue(this.get("tooltipY", 0), this.height());\n      } else {\n        x = bounds.left + relativeToValue(this.get("tooltipX", 0), bounds.right - bounds.left);\n        y = bounds.top + relativeToValue(this.get("tooltipY", 0), bounds.bottom - bounds.top);\n      }\n      return {\n        x,\n        y\n      };\n    }\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  /**\r\n   * Returns [[Tooltip]] used for this element.\r\n   *\r\n   * @return Tooltip\r\n   */\n  getTooltip() {\n    let tooltip = this.get("tooltip");\n    if (!tooltip) {\n      let parent = this.parent;\n      if (parent) {\n        return parent.getTooltip();\n      }\n    } else {\n      return tooltip;\n    }\n  }\n  _updatePosition() {\n    const parent = this.parent;\n    let dx = this.get("dx", 0);\n    let dy = this.get("dy", 0);\n    let x = this.get("x");\n    let _x = this.getPrivate("x");\n    let xx = 0;\n    let yy = 0;\n    const position = this.get("position");\n    if (x instanceof Percent) {\n      if (parent) {\n        x = parent.innerWidth() * x.value + parent.get("paddingLeft", 0);\n      } else {\n        x = 0;\n      }\n    }\n    if (Type_isNumber(x)) {\n      xx = x + dx;\n    } else {\n      if (_x != null) {\n        xx = _x;\n      } else if (parent) {\n        if (position == "relative") {\n          xx = parent.get("paddingLeft", 0) + dx;\n        }\n      }\n    }\n    let y = this.get("y");\n    let _y = this.getPrivate("y");\n    if (y instanceof Percent) {\n      if (parent) {\n        y = parent.innerHeight() * y.value + parent.get("paddingTop", 0);\n      } else {\n        y = 0;\n      }\n    }\n    if (Type_isNumber(y)) {\n      yy = y + dy;\n    } else {\n      if (_y != null) {\n        yy = _y;\n      } else if (parent) {\n        if (position == "relative") {\n          yy = parent.get("paddingTop", 0) + dy;\n        }\n      }\n    }\n    const display = this._display;\n    if (display.x != xx || display.y != yy) {\n      display.invalidateBounds();\n      display.x = xx;\n      display.y = yy;\n      const eventType = "positionchanged";\n      if (this.events.isEnabled(eventType)) {\n        this.events.dispatch(eventType, {\n          type: eventType,\n          target: this\n        });\n      }\n    }\n    // Update tooltip position together with the Sprite\n    if (this.getPrivate("showingTooltip")) {\n      this.showTooltip();\n    }\n  }\n  /**\r\n   * Returns element\'s actual X position in pixels.\r\n   *\r\n   * @return X (px)\r\n   */\n  x() {\n    let x = this.get("x");\n    let _x = this.getPrivate("x");\n    const parent = this.parent;\n    if (parent) {\n      if (x instanceof Percent) {\n        return relativeToValue(x, parent.innerWidth()) + parent.get("paddingLeft", 0);\n      } else {\n        if (!Type_isNumber(x)) {\n          if (_x != null) {\n            return _x;\n          } else {\n            return parent.get("paddingLeft", this._display.x);\n          }\n        } else {\n          return x;\n        }\n      }\n    }\n    return this._display.x;\n  }\n  /**\r\n   * Returns element\'s actual Y position in pixels.\r\n   *\r\n   * @return Y (px)\r\n   */\n  y() {\n    let _y = this.getPrivate("y");\n    if (_y != null) {\n      return _y;\n    }\n    let y = this.get("y");\n    const parent = this.parent;\n    if (parent) {\n      if (y instanceof Percent) {\n        return relativeToValue(y, parent.innerHeight()) + parent.get("paddingTop", 0);\n      } else {\n        if (!Type_isNumber(y)) {\n          if (_y != null) {\n            return _y;\n          } else {\n            return parent.get("paddingTop", this._display.y);\n          }\n        } else {\n          return y;\n        }\n      }\n    }\n    return this._display.y;\n  }\n  _dispose() {\n    super._dispose();\n    this._display.dispose();\n    this._removeTemplateField();\n    this._removeParent(this.parent);\n    this._root._removeFocusElement(this);\n    const tooltip = this.get("tooltip");\n    if (tooltip) {\n      tooltip.dispose();\n    }\n    this.markDirty();\n  }\n  /**\r\n   * @ignore\r\n   */\n  adjustedLocalBounds() {\n    this._fixMinBounds(this._adjustedLocalBounds);\n    return this._adjustedLocalBounds;\n  }\n  /**\r\n   * Returns local coordinates of the element\'s bounds.\r\n   *\r\n   * @ignore\r\n   * @return Global bounds\r\n   */\n  localBounds() {\n    return this._localBounds;\n  }\n  /**\r\n   * Returns adjusted local coordinates of the element\'s bounds.\r\n   *\r\n   * @ignore\r\n   * @return Global bounds\r\n   */\n  bounds() {\n    const bounds = this._adjustedLocalBounds;\n    const x = this.x();\n    const y = this.y();\n    return {\n      left: bounds.left + x,\n      right: bounds.right + x,\n      top: bounds.top + y,\n      bottom: bounds.bottom + y\n    };\n  }\n  /**\r\n   * Returns global coordinates of the element\'s bounds.\r\n   *\r\n   * @ignore\r\n   * @return Global bounds\r\n   */\n  globalBounds() {\n    const bounds = this.localBounds();\n    const p0 = this.toGlobal({\n      x: bounds.left,\n      y: bounds.top\n    });\n    const p1 = this.toGlobal({\n      x: bounds.right,\n      y: bounds.top\n    });\n    const p2 = this.toGlobal({\n      x: bounds.right,\n      y: bounds.bottom\n    });\n    const p3 = this.toGlobal({\n      x: bounds.left,\n      y: bounds.bottom\n    });\n    return {\n      left: Math.min(p0.x, p1.x, p2.x, p3.x),\n      top: Math.min(p0.y, p1.y, p2.y, p3.y),\n      right: Math.max(p0.x, p1.x, p2.x, p3.x),\n      bottom: Math.max(p0.y, p1.y, p2.y, p3.y)\n    };\n  }\n  _onShow(_duration) {}\n  _onHide(_duration) {}\n  /**\r\n   * Plays initial reveal animation regardless if element is currently hidden\r\n   * or visible.\r\n   *\r\n   * @param   duration  Duration of the animation in milliseconds\r\n   * @param   delay     Delay showing of the element by X milliseconds\r\n   * @return            Promise\r\n   */\n  appear(duration, delay) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.hide(0);\n      if (delay) {\n        return new Promise((success, _error) => {\n          this.setTimeout(() => {\n            success(this.show(duration));\n          }, delay);\n        });\n      } else {\n        return this.show(duration);\n      }\n    });\n  }\n  /**\r\n   * Shows currently hidden element and returns a `Promise` which completes\r\n   * when all showing animations are finished.\r\n   *\r\n   * ```TypeScript\r\n   * series.show().then(function(ev) {\r\n   *   console.log("Series is now fully visible");\r\n   * })\r\n   * ```\r\n   * ```JavaScript\r\n   * series.show().then(function(ev) {\r\n   *   console.log("Series is now fully visible");\r\n   * })\r\n   * ```\r\n   *\r\n   * @return Promise\r\n   */\n  show(duration) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._isShowing) {\n        this._isHidden = false;\n        this._isShowing = true;\n        this._isHiding = false;\n        if (this.states.lookup("default").get("visible")) {\n          this.set("visible", true);\n        }\n        this._onShow(duration);\n        const animations = this.states.applyAnimate("default", duration);\n        yield waitForAnimations(animations);\n        this._isShowing = false;\n      }\n    });\n  }\n  /**\r\n   * Hides the element and returns a `Promise` which completes when all hiding\r\n   * animations are finished.\r\n   *\r\n   * ```TypeScript\r\n   * series.hide().then(function(ev) {\r\n   *   console.log("Series finished hiding");\r\n   * })\r\n   * ```\r\n   * ```JavaScript\r\n   * series.hide().then(function(ev) {\r\n   *   console.log("Series finished hiding");\r\n   * })\r\n   * ```\r\n   *\r\n   * @return Promise\r\n   */\n  hide(duration) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._isHiding && !this._isHidden) {\n        this._isHiding = true;\n        this._isShowing = false;\n        let state = this.states.lookup("hidden");\n        if (!state) {\n          state = this.states.create("hidden", {\n            "opacity": 0,\n            "visible": false\n          });\n        }\n        this._isHidden = true;\n        this._onHide(duration);\n        const animations = this.states.applyAnimate("hidden", duration);\n        yield waitForAnimations(animations);\n        this._isHiding = false;\n      }\n    });\n  }\n  /**\r\n   * Returns `true` if this element is currently hidden.\r\n   *\r\n   * @return Is hidden?\r\n   */\n  isHidden() {\n    return this._isHidden;\n  }\n  /**\r\n   * Returns `true` if this element is currently animating to a default state.\r\n   *\r\n   * @return Is showing?\r\n   */\n  isShowing() {\n    return this._isShowing;\n  }\n  /**\r\n   * Returns `true` if this element is currently animating to a hidden state.\r\n   *\r\n   * @return Is hiding?\r\n   */\n  isHiding() {\n    return this._isHiding;\n  }\n  /**\r\n   * Returns `true` if this element is currently hovered by a pointer.\r\n   *\r\n   * @return Is hovered?\r\n   */\n  isHover() {\n    return this._display.hovering();\n  }\n  /**\r\n   * Returns `true` if this element does currently have focus.\r\n   *\r\n   * @return Is focused?\r\n   */\n  isFocus() {\n    return this._root.focused(this);\n  }\n  /**\r\n   * Returns `true` if this element is currently being dragged.\r\n   *\r\n   * @return Is dragged?\r\n   */\n  isDragging() {\n    return this._isDragging;\n  }\n  /**\r\n   * Returns `false` if if either public or private setting `visible` is set\r\n   * to `false`, or `forceHidden` is set to `true`.\r\n   *\r\n   * @return Visible?\r\n   */\n  isVisible() {\n    if (this.get("visible") && this.getPrivate("visible") && !this.get("forceHidden")) {\n      return true;\n    }\n    return false;\n  }\n  /**\r\n   * Same as `isVisible()`, except it checks all ascendants, too.\r\n   *\r\n   * @since 5.2.7\r\n   * @return Visible?\r\n   */\n  isVisibleDeep() {\n    return this._parent ? this._parent.isVisibleDeep() && this.isVisible() : this.isVisible();\n  }\n  /**\r\n   * Returns an actual opacity of the element, taking into account all parents.\r\n   *\r\n   * @return Opacity\r\n   * @since 5.2.11\r\n   */\n  compositeOpacity() {\n    const opacity = this.get("opacity", 1);\n    return this._parent ? this._parent.compositeOpacity() * opacity : opacity;\n  }\n  /**\r\n   * Returns an actual scale of the element, taking into account all parents.\r\n   *\r\n   * @return Opacity\r\n   * @since 5.9.2\r\n   */\n  compositeScale() {\n    const scale = this.get("scale", 1);\n    return this._parent ? this._parent.compositeScale() * scale : scale;\n  }\n  /**\r\n   * Returns an actual roation of the element, taking into account all parents.\r\n   *\r\n   * @return Opacity\r\n   * @since 5.9.2\r\n   */\n  compositeRotation() {\n    const rotation = this.get("rotation", 0);\n    return this._parent ? this._parent.compositeRotation() + rotation : rotation;\n  }\n  /**\r\n   * Returns width of this element in pixels.\r\n   *\r\n   * @return Width (px)\r\n   */\n  width() {\n    let width = this.get("width");\n    let maxWidth = this.get("maxWidth", this.getPrivate("maxWidth"));\n    let minWidth = this.get("minWidth", this.getPrivate("minWidth"));\n    let privateWidth = this.getPrivate("width");\n    let w = 0;\n    if (Type_isNumber(privateWidth)) {\n      w = privateWidth;\n    } else {\n      if (width == null) {\n        if (this._adjustedLocalBounds) {\n          w = this._adjustedLocalBounds.right - this._adjustedLocalBounds.left;\n        }\n      } else {\n        if (width instanceof Percent) {\n          const parent = this.parent;\n          if (parent) {\n            w = parent.innerWidth() * width.value;\n          } else {\n            w = this._root.width() * width.value;\n          }\n        } else if (Type_isNumber(width)) {\n          w = width;\n        }\n      }\n    }\n    if (Type_isNumber(minWidth)) {\n      w = Math.max(minWidth, w);\n    }\n    if (Type_isNumber(maxWidth)) {\n      w = Math.min(maxWidth, w);\n    }\n    return w;\n  }\n  /**\r\n   * Returns maximum allowed width of this element in pixels.\r\n   *\r\n   * @return Maximum width (px)\r\n   */\n  maxWidth() {\n    let maxWidth = this.get("maxWidth", this.getPrivate("maxWidth"));\n    if (Type_isNumber(maxWidth)) {\n      return maxWidth;\n    } else {\n      let width = this.get("width");\n      if (Type_isNumber(width)) {\n        return width;\n      }\n    }\n    const parent = this.parent;\n    if (parent) {\n      return parent.innerWidth();\n    }\n    return this._root.width();\n  }\n  /**\r\n   * Returns maximum allowed height of this element in pixels.\r\n   *\r\n   * @return Maximum height (px)\r\n   */\n  maxHeight() {\n    let maxHeight = this.get("maxHeight", this.getPrivate("maxHeight"));\n    if (Type_isNumber(maxHeight)) {\n      return maxHeight;\n    } else {\n      let height = this.get("height");\n      if (Type_isNumber(height)) {\n        return height;\n      }\n    }\n    const parent = this.parent;\n    if (parent) {\n      return parent.innerHeight();\n    }\n    return this._root.height();\n  }\n  /**\r\n   * Returns height of this element in pixels.\r\n   *\r\n   * @return Height (px)\r\n   */\n  height() {\n    let height = this.get("height");\n    let maxHeight = this.get("maxHeight", this.getPrivate("maxHeight"));\n    let minHeight = this.get("minHeight", this.getPrivate("minHeight"));\n    let privateHeight = this.getPrivate("height");\n    let h = 0;\n    if (Type_isNumber(privateHeight)) {\n      h = privateHeight;\n    } else {\n      if (height == null) {\n        if (this._adjustedLocalBounds) {\n          h = this._adjustedLocalBounds.bottom - this._adjustedLocalBounds.top;\n        }\n      } else {\n        if (height instanceof Percent) {\n          const parent = this.parent;\n          if (parent) {\n            h = parent.innerHeight() * height.value;\n          } else {\n            h = this._root.height() * height.value;\n          }\n        } else if (Type_isNumber(height)) {\n          h = height;\n        }\n      }\n    }\n    if (Type_isNumber(minHeight)) {\n      h = Math.max(minHeight, h);\n    }\n    if (Type_isNumber(maxHeight)) {\n      h = Math.min(maxHeight, h);\n    }\n    return h;\n  }\n  _findStaticTemplate(f) {\n    // templateField overrides template\n    if (this._templateField && f(this._templateField)) {\n      return this._templateField;\n    }\n    return super._findStaticTemplate(f);\n  }\n  _walkParents(f) {\n    if (this._parent) {\n      this._walkParent(f);\n    }\n  }\n  _walkParent(f) {\n    if (this._parent) {\n      this._parent._walkParent(f);\n    }\n    f(this);\n  }\n  /**\r\n   * Parent [[Container]] of this element.\r\n   *\r\n   * @return Parent container\r\n   */\n  get parent() {\n    return this._parent;\n  }\n  _setParent(parent, updateChildren = false) {\n    const prevParent = this._parent;\n    if (parent !== prevParent) {\n      this.markDirtyBounds();\n      parent.markDirty();\n      this._parent = parent;\n      if (updateChildren) {\n        this._removeParent(prevParent);\n        if (parent) {\n          this._addPercentageSizeChildren();\n          this._addPercentagePositionChildren();\n        }\n      }\n      this.markDirtyPosition();\n      this._applyThemes();\n    }\n  }\n  /**\r\n   * Returns an instance of [[NumberFormatter]] used in this element.\r\n   *\r\n   * If this element does not have it set, global one form [[Root]] is used.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info\r\n   * @return NumberFormatter instace\r\n   */\n  getNumberFormatter() {\n    return this.get("numberFormatter", this._root.numberFormatter);\n  }\n  /**\r\n   * Returns an instance of [[DateFormatter]] used in this element.\r\n   *\r\n   * If this element does not have it set, global one form [[Root]] is used.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info\r\n   * @return DateFormatter instace\r\n   */\n  getDateFormatter() {\n    return this.get("dateFormatter", this._root.dateFormatter);\n  }\n  /**\r\n   * Returns an instance of [[DurationFormatter]] used in this element.\r\n   *\r\n   * If this element does not have it set, global one form [[Root]] is used.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info\r\n   * @return DurationFormatter instace\r\n   */\n  getDurationFormatter() {\n    return this.get("durationFormatter", this._root.durationFormatter);\n  }\n  /**\r\n   * Converts X/Y coordinate within this element to a global coordinate.\r\n   *\r\n   * @param  point  Local coordinate\r\n   * @return        Global coordinate\r\n   */\n  toGlobal(point) {\n    return this._display.toGlobal(point);\n  }\n  /**\r\n   * Converts global X/Y coordinate to a coordinate within this element.\r\n   *\r\n   * @param  point  Global coordinate\r\n   * @return        Local coordinate\r\n   */\n  toLocal(point) {\n    return this._display.toLocal(point);\n  }\n  _getDownPoint() {\n    const id = this._getDownPointId();\n    if (id) {\n      return this._downPoints[id];\n    }\n  }\n  _getDownPointId() {\n    if (this._downPoints) {\n      return keysOrdered(this._downPoints, (a, b) => {\n        if (a > b) {\n          return 1;\n        }\n        if (a < b) {\n          return -1;\n        }\n        return 0;\n      })[0];\n    }\n  }\n  /**\r\n   * Moves sprite to the end of the parent\'s children array.\r\n   *\r\n   * Depending on `layout` setting of the parten container, it may effect the\r\n   * positioning or overlapping order of the elements.\r\n   */\n  toFront() {\n    const parent = this.parent;\n    if (parent) {\n      parent.children.moveValue(this, parent.children.length - 1);\n    }\n  }\n  /**\r\n   * Moves sprite to the beginning of the parent\'s children array.\r\n   *\r\n   * Depending on `layout` setting of the parten container, it may effect the\r\n   * positioning or overlapping order of the elements.\r\n   */\n  toBack() {\n    const parent = this.parent;\n    if (parent) {\n      parent.children.moveValue(this, 0);\n    }\n  }\n}\nObject.defineProperty(Sprite, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Sprite"\n});\nObject.defineProperty(Sprite, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Entity.classNames.concat([Sprite.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/Pattern.js\n\n/**\r\n * Base class for patterns.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info\r\n */\nclass Pattern extends Entity {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_display", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._root._renderer.makeGraphics()\n    });\n    Object.defineProperty(this, "_backgroundDisplay", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._root._renderer.makeGraphics()\n    });\n    Object.defineProperty(this, "_clear", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_pattern", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  _afterNew() {\n    // Applying themes because pattern will not have parent\n    super._afterNewApplyThemes();\n  }\n  get pattern() {\n    return this._pattern;\n  }\n  _draw() {}\n  _beforeChanged() {\n    super._beforeChanged();\n    if (this.isDirty("repetition") || this.isDirty("width") || this.isDirty("height") || this.isDirty("rotation") || this.isDirty("strokeWidth") || this.isDirty("strokeDasharray") || this.isDirty("strokeDashoffset") || this.isDirty("colorOpacity") || this.isDirty("fillOpacity")) {\n      this._clear = true;\n    }\n    this._checkDirtyFill();\n  }\n  _checkDirtyFill() {\n    if (this.isDirty("color") || this.isDirty("fill")) {\n      this._clear = true;\n    }\n  }\n  _changed() {\n    super._changed();\n    if (this._clear) {\n      const repetition = this.get("repetition", "");\n      const width = this.get("width", 100);\n      const height = this.get("height", 100);\n      const fill = this.get("fill");\n      const fillOpacity = this.get("fillOpacity", 1);\n      const backgroundDisplay = this._backgroundDisplay;\n      const display = this._display;\n      display.clear();\n      backgroundDisplay.clear();\n      if (fill && fillOpacity > 0) {\n        backgroundDisplay.beginFill(fill, fillOpacity);\n        backgroundDisplay.drawRect(0, 0, width, height);\n        backgroundDisplay.endFill();\n      }\n      display.angle = this.get("rotation", 0);\n      //display.pivot = { x: width / 2, y: height / 2 };\n      this._draw();\n      this._pattern = this._root._renderer.createPattern(display, backgroundDisplay, repetition, width, height);\n    }\n    this._clear = false;\n  }\n}\nObject.defineProperty(Pattern, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Pattern"\n});\nObject.defineProperty(Pattern, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Entity.classNames.concat([Pattern.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/PicturePattern.js\n\n/**\r\n * Picture pattern.\r\n *\r\n * @since 5.2.15\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info\r\n */\nclass PicturePattern extends Pattern {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_image", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  _beforeChanged() {\n    super._beforeChanged();\n    this._clear = true;\n    if (this.isDirty("src")) {\n      this._load();\n    }\n    const canvas = this.get("canvas");\n    if (canvas) {\n      this.set("width", canvas.width);\n      this.set("height", canvas.height);\n    }\n  }\n  _draw() {\n    super._draw();\n    const image = this._image;\n    if (image) {\n      const patternWidth = this.get("width", 100);\n      const patternHeight = this.get("height", 100);\n      // Fit\n      const fit = this.get("fit", "image");\n      let width = 0;\n      let height = 0;\n      if (fit == "pattern") {\n        width = patternWidth;\n        height = patternHeight;\n      } else {\n        width = image.width;\n        height = image.height;\n        if (fit == "image") {\n          this.set("width", width);\n          this.set("height", height);\n        }\n      }\n      // Position\n      const centered = this.get("centered", true);\n      let x = 0;\n      let y = 0;\n      if (centered) {\n        x = patternWidth / 2 - width / 2;\n        y = patternHeight / 2 - height / 2;\n      }\n      this._display.image(image, width, height, x, y);\n    }\n    const canvas = this.get("canvas");\n    if (canvas) {\n      this._display.image(canvas, canvas.width, canvas.height, 0, 0);\n    }\n  }\n  _load() {\n    const src = this.get("src");\n    if (src) {\n      const image = new Image();\n      //image.crossOrigin = "Anonymous";\n      image.src = src;\n      image.decode().then(() => {\n        this._image = image;\n        this._draw();\n        if (this.events.isEnabled("loaded")) {\n          this.events.dispatch("loaded", {\n            type: "loaded",\n            target: this\n          });\n        }\n      }).catch(_error => {\n        // TODO: maybe raise error?\n      });\n    }\n  }\n}\nObject.defineProperty(PicturePattern, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "PicturePattern"\n});\nObject.defineProperty(PicturePattern, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Pattern.classNames.concat([PicturePattern.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/backend/Renderer.js\n/**\r\n * From https://github.com/pixijs/pixi.js/blob/3dd0ff9a935f0bc13a09aefff9eb2872f02c51b9/packages/canvas/canvas-renderer/src/utils/mapCanvasBlendModesToPixi.ts#L13\r\n */\nvar BlendMode;\n(function (BlendMode) {\n  BlendMode["ADD"] = "lighter";\n  BlendMode["COLOR"] = "color";\n  BlendMode["COLOR_BURN"] = "color-burn";\n  BlendMode["COLOR_DODGE"] = "color-dodge";\n  BlendMode["DARKEN"] = "darken";\n  BlendMode["DIFFERENCE"] = "difference";\n  BlendMode["DST_OVER"] = "destination-over";\n  BlendMode["EXCLUSION"] = "exclusion";\n  BlendMode["HARD_LIGHT"] = "hard-light";\n  BlendMode["HUE"] = "hue";\n  BlendMode["LIGHTEN"] = "lighten";\n  BlendMode["LUMINOSITY"] = "luminosity";\n  BlendMode["MULTIPLY"] = "multiply";\n  BlendMode["NORMAL"] = "source-over";\n  BlendMode["OVERLAY"] = "overlay";\n  BlendMode["SATURATION"] = "saturation";\n  BlendMode["SCREEN"] = "screen";\n  BlendMode["SOFT_LIGHT"] = "soft-light";\n  BlendMode["SRC_ATOP"] = "source-atop";\n  BlendMode["XOR"] = "xor";\n})(BlendMode || (BlendMode = {}));\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js\n\n\n\n\n\nconst visualSettings = ["fill", "fillOpacity", "stroke", "strokeWidth", "strokeOpacity", "fillPattern", "strokePattern", "fillGradient", "strokeGradient", "strokeDasharray", "strokeDashoffset", "shadowBlur", "shadowColor", "shadowOpacity", "shadowOffsetX", "shadowOffsetY", "blur", "sepia", "invert", "brightness", "hue", "contrast", "saturate"];\n/**\r\n * Base class used for drawing shapes.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info\r\n * @important\r\n */\nclass Graphics extends Sprite {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_display", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._root._renderer.makeGraphics()\n    });\n    Object.defineProperty(this, "_clear", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n  }\n  _beforeChanged() {\n    super._beforeChanged();\n    if (this.isDirty("draw") || this.isDirty("svgPath")) {\n      this.markDirtyBounds();\n    }\n    if (this.isDirty("fill") || this.isDirty("stroke") || this.isDirty("visible") || this.isDirty("forceHidden") || this.isDirty("scale") || this.isDirty("fillGradient") || this.isDirty("strokeGradient") || this.isDirty("fillPattern") || this.isDirty("strokePattern") || this.isDirty("fillOpacity") || this.isDirty("strokeOpacity") || this.isDirty("strokeWidth") || this.isDirty("draw") || this.isDirty("blendMode") || this.isDirty("strokeDasharray") || this.isDirty("strokeDashoffset") || this.isDirty("svgPath") || this.isDirty("lineJoin") || this.isDirty("shadowColor") || this.isDirty("shadowBlur") || this.isDirty("shadowOffsetX") || this.isDirty("shadowOffsetY")) {\n      this._clear = true;\n    }\n    this._display.crisp = this.get("crisp", false);\n    if (this.isDirty("fillGradient")) {\n      const gradient = this.get("fillGradient");\n      if (gradient) {\n        this._display.isMeasured = true;\n        const gradientTarget = gradient.get("target");\n        if (gradientTarget) {\n          this._disposers.push(gradientTarget.events.on("boundschanged", () => {\n            this._markDirtyKey("fill");\n          }));\n          this._disposers.push(gradientTarget.events.on("positionchanged", () => {\n            this._markDirtyKey("fill");\n          }));\n        }\n      }\n    }\n    if (this.isDirty("strokeGradient")) {\n      const gradient = this.get("strokeGradient");\n      if (gradient) {\n        this._display.isMeasured = true;\n        const gradientTarget = gradient.get("target");\n        if (gradientTarget) {\n          this._disposers.push(gradientTarget.events.on("boundschanged", () => {\n            this._markDirtyKey("stroke");\n          }));\n          this._disposers.push(gradientTarget.events.on("positionchanged", () => {\n            this._markDirtyKey("stroke");\n          }));\n        }\n      }\n    }\n  }\n  _changed() {\n    super._changed();\n    if (this._clear) {\n      this.markDirtyBounds();\n      this.markDirtyLayer();\n      this._display.clear();\n      let strokeDasharray = this.get("strokeDasharray");\n      if (Type_isNumber(strokeDasharray)) {\n        if (strokeDasharray < 0.5) {\n          strokeDasharray = [0];\n        } else {\n          strokeDasharray = [strokeDasharray];\n        }\n      }\n      this._display.setLineDash(strokeDasharray);\n      const strokeDashoffset = this.get("strokeDashoffset");\n      if (strokeDashoffset) {\n        this._display.setLineDashOffset(strokeDashoffset);\n      }\n      const blendMode = this.get("blendMode", BlendMode.NORMAL);\n      this._display.blendMode = blendMode;\n      const draw = this.get("draw");\n      if (draw && typeof draw === "function") {\n        draw(this._display, this);\n      }\n      const svgPath = this.get("svgPath");\n      if (svgPath != null) {\n        this._display.svgPath(svgPath);\n      }\n    }\n  }\n  _afterChanged() {\n    super._afterChanged();\n    if (this._clear) {\n      const fill = this.get("fill");\n      const fillGradient = this.get("fillGradient");\n      const fillPattern = this.get("fillPattern");\n      const fillOpacity = this.get("fillOpacity");\n      const stroke = this.get("stroke");\n      const strokeGradient = this.get("strokeGradient");\n      const strokePattern = this.get("strokePattern");\n      const shadowColor = this.get("shadowColor");\n      const shadowBlur = this.get("shadowBlur");\n      const shadowOffsetX = this.get("shadowOffsetX");\n      const shadowOffsetY = this.get("shadowOffsetY");\n      const shadowOpacity = this.get("shadowOpacity");\n      if (shadowColor && (shadowBlur || shadowOffsetX || shadowOffsetY)) {\n        this._display.shadow(shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY, shadowOpacity);\n      }\n      if (fill && !fillGradient) {\n        this._display.beginFill(fill, fillOpacity);\n        this._display.endFill();\n      }\n      if (fillGradient) {\n        if (fill) {\n          const stops = fillGradient.get("stops", []);\n          if (stops.length) {\n            each(stops, stop => {\n              if ((!stop.color || stop.colorInherited) && fill) {\n                stop.color = fill;\n                stop.colorInherited = true;\n              }\n              if (stop.opacity == null || stop.opacityInherited) {\n                stop.opacity = fillOpacity;\n                stop.opacityInherited = true;\n              }\n            });\n          }\n        }\n        const gradient = fillGradient.getFill(this);\n        if (gradient) {\n          this._display.beginFill(gradient, fillOpacity);\n          this._display.endFill();\n        }\n      }\n      if (fillPattern) {\n        const pattern = fillPattern.pattern;\n        if (pattern) {\n          this._display.beginFill(pattern, fillOpacity);\n          this._display.endFill();\n          if (fillPattern instanceof PicturePattern) {\n            fillPattern.events.once("loaded", () => {\n              this._clear = true;\n              this.markDirty();\n            });\n          }\n        }\n      }\n      if (stroke || strokeGradient || strokePattern) {\n        const strokeOpacity = this.get("strokeOpacity");\n        let strokeWidth = this.get("strokeWidth", 1);\n        if (this.get("nonScalingStroke")) {\n          strokeWidth = strokeWidth / this.get("scale", 1);\n        }\n        if (this.get("crisp")) {\n          strokeWidth /= this._root._renderer.resolution;\n        }\n        const lineJoin = this.get("lineJoin");\n        if (stroke && !strokeGradient) {\n          this._display.lineStyle(strokeWidth, stroke, strokeOpacity, lineJoin);\n          this._display.endStroke();\n        }\n        if (strokeGradient) {\n          const stops = strokeGradient.get("stops", []);\n          if (stops.length) {\n            each(stops, stop => {\n              if ((!stop.color || stop.colorInherited) && stroke) {\n                stop.color = stroke;\n                stop.colorInherited = true;\n              }\n              if (stop.opacity == null || stop.opacityInherited) {\n                stop.opacity = strokeOpacity;\n                stop.opacityInherited = true;\n              }\n            });\n          }\n          const gradient = strokeGradient.getFill(this);\n          if (gradient) {\n            this._display.lineStyle(strokeWidth, gradient, strokeOpacity, lineJoin);\n            this._display.endStroke();\n          }\n        }\n        if (strokePattern) {\n          /*\r\n          let changed = false;\r\n          \r\n          if (stroke && (!strokePattern.get("color") || strokePattern.get("colorInherited"))) {\r\n              strokePattern.set("color", stroke);\r\n              strokePattern.set("colorInherited", true);\r\n              changed = true;\r\n          }\r\n          if (changed) {\r\n              // @todo: is this OK?\r\n              strokePattern._changed();\r\n          }\r\n          */\n          let pattern = strokePattern.pattern;\n          if (pattern) {\n            this._display.lineStyle(strokeWidth, pattern, strokeOpacity, lineJoin);\n            this._display.endStroke();\n            if (strokePattern instanceof PicturePattern) {\n              strokePattern.events.once("loaded", () => {\n                this._clear = true;\n                this.markDirty();\n              });\n            }\n          }\n        }\n      }\n      if (this.getPrivate("showingTooltip")) {\n        this.showTooltip();\n      }\n    }\n    this._clear = false;\n  }\n}\nObject.defineProperty(Graphics, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Graphics"\n});\nObject.defineProperty(Graphics, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Sprite.classNames.concat([Graphics.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js\n\n/**\r\n * Draws a rectangle.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info\r\n * @important\r\n */\nclass Rectangle extends Graphics {\n  _afterNew() {\n    super._afterNew();\n    this._display.isMeasured = true;\n    this.setPrivateRaw("trustBounds", true);\n  }\n  _beforeChanged() {\n    super._beforeChanged();\n    if (this.isDirty("width") || this.isDirty("height") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) {\n      this._clear = true;\n    }\n  }\n  _changed() {\n    super._changed();\n    if (this._clear && !this.get("draw")) {\n      this._draw();\n    }\n  }\n  _draw() {\n    this._display.drawRect(0, 0, this.width(), this.height());\n  }\n  _updateSize() {\n    this.markDirty();\n    this._clear = true;\n  }\n}\nObject.defineProperty(Rectangle, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Rectangle"\n});\nObject.defineProperty(Rectangle, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Graphics.classNames.concat([Rectangle.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Layout.js\n\nfunction eachChildren(container, f) {\n  if (container.get("reverseChildren", false)) {\n    container.children.eachReverse(f);\n  } else {\n    container.children.each(f);\n  }\n}\n/**\r\n * Base class for [[Container]] layouts.\r\n */\nclass Layout extends Entity {}\nObject.defineProperty(Layout, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Layout"\n});\nObject.defineProperty(Layout, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Entity.classNames.concat([Layout.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/HorizontalLayout.js\n\n\n\n/**\r\n * A horizontal children layout for [[Container]].\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info\r\n */\nclass HorizontalLayout extends Layout {\n  /**\r\n   * @ignore\r\n   */\n  updateContainer(container) {\n    let paddingLeft = container.get("paddingLeft", 0);\n    let availableWidth = container.innerWidth();\n    let totalPercent = 0;\n    eachChildren(container, child => {\n      if (child.isVisible()) {\n        if (child.get("position") == "relative") {\n          let childWidth = child.get("width");\n          if (childWidth instanceof Percent) {\n            totalPercent += childWidth.value;\n            let w = availableWidth * childWidth.value;\n            let minWidth = child.get("minWidth", child.getPrivate("minWidth", -Infinity));\n            if (minWidth > w) {\n              availableWidth -= minWidth;\n              totalPercent -= childWidth.value;\n            }\n            let maxWidth = child.get("maxWidth", child.getPrivate("maxWidth", Infinity));\n            if (w > maxWidth) {\n              availableWidth -= maxWidth;\n              totalPercent -= childWidth.value;\n            }\n          } else {\n            if (!Type_isNumber(childWidth)) {\n              childWidth = child.width();\n            }\n            availableWidth -= childWidth + child.get("marginLeft", 0) + child.get("marginRight", 0);\n          }\n        }\n      }\n    });\n    if (availableWidth <= 0 || availableWidth == Infinity) {\n      availableWidth = .1;\n    }\n    //if (availableWidth > 0) {\n    eachChildren(container, child => {\n      if (child.isVisible()) {\n        if (child.get("position") == "relative") {\n          let childWidth = child.get("width");\n          if (childWidth instanceof Percent) {\n            let privateWidth = availableWidth * childWidth.value / totalPercent - child.get("marginLeft", 0) - child.get("marginRight", 0);\n            let minWidth = child.get("minWidth", child.getPrivate("minWidth", -Infinity));\n            let maxWidth = child.get("maxWidth", child.getPrivate("maxWidth", Infinity));\n            privateWidth = Math.min(Math.max(minWidth, privateWidth), maxWidth);\n            child.setPrivate("width", privateWidth);\n          } else {\n            if (child._prevSettings.width instanceof Percent) {\n              child.setPrivate("width", undefined);\n            }\n          }\n        }\n      }\n    });\n    //}\n    let prevX = paddingLeft;\n    eachChildren(container, child => {\n      if (child.get("position") == "relative") {\n        if (child.isVisible()) {\n          let bounds = child.adjustedLocalBounds();\n          let marginLeft = child.get("marginLeft", 0);\n          let marginRight = child.get("marginRight", 0);\n          let maxWidth = child.get("maxWidth");\n          let left = bounds.left;\n          let right = bounds.right;\n          if (maxWidth) {\n            if (right - left > maxWidth) {\n              right = left + maxWidth;\n            }\n          }\n          let x = prevX + marginLeft - left;\n          child.setPrivate("x", x);\n          prevX = x + right + marginRight;\n        } else {\n          child.setPrivate("x", undefined);\n        }\n      }\n    });\n  }\n}\nObject.defineProperty(HorizontalLayout, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "HorizontalLayout"\n});\nObject.defineProperty(HorizontalLayout, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Layout.classNames.concat([HorizontalLayout.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/VerticalLayout.js\n\n\n\n/**\r\n * A vertical children layout for [[Container]].\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info\r\n */\nclass VerticalLayout extends Layout {\n  /**\r\n   * @ignore\r\n   */\n  updateContainer(container) {\n    let paddingTop = container.get("paddingTop", 0);\n    let availableHeight = container.innerHeight();\n    let totalPercent = 0;\n    eachChildren(container, child => {\n      if (child.isVisible()) {\n        if (child.get("position") == "relative") {\n          let childHeight = child.get("height");\n          if (childHeight instanceof Percent) {\n            totalPercent += childHeight.value;\n            let h = availableHeight * childHeight.value;\n            let minHeight = child.get("minHeight", child.getPrivate("minHeight", -Infinity));\n            if (minHeight > h) {\n              availableHeight -= minHeight;\n              totalPercent -= childHeight.value;\n            }\n            let maxHeight = child.get("maxHeight", child.getPrivate("maxHeight", Infinity));\n            if (h > maxHeight) {\n              availableHeight -= maxHeight;\n              totalPercent -= childHeight.value;\n            }\n          } else {\n            if (!Type_isNumber(childHeight)) {\n              childHeight = child.height();\n            }\n            availableHeight -= childHeight + child.get("marginTop", 0) + child.get("marginBottom", 0);\n          }\n        }\n      }\n    });\n    if (availableHeight <= 0 || availableHeight == Infinity) {\n      availableHeight = .1;\n    }\n    //if (availableHeight > 0) {\n    eachChildren(container, child => {\n      if (child.isVisible()) {\n        if (child.get("position") == "relative") {\n          let childHeight = child.get("height");\n          if (childHeight instanceof Percent) {\n            let privateHeight = availableHeight * childHeight.value / totalPercent - child.get("marginTop", 0) - child.get("marginBottom", 0);\n            let minHeight = child.get("minHeight", child.getPrivate("minHeight", -Infinity));\n            let maxHeight = child.get("maxHeight", child.getPrivate("maxHeight", Infinity));\n            privateHeight = Math.min(Math.max(minHeight, privateHeight), maxHeight);\n            child.setPrivate("height", privateHeight);\n          } else {\n            if (child._prevSettings.height instanceof Percent) {\n              child.setPrivate("height", undefined);\n            }\n          }\n        }\n      }\n    });\n    //}\n    let prevY = paddingTop;\n    eachChildren(container, child => {\n      if (child.get("position") == "relative") {\n        if (child.isVisible()) {\n          let bounds = child.adjustedLocalBounds();\n          let marginTop = child.get("marginTop", 0);\n          let top = bounds.top;\n          let bottom = bounds.bottom;\n          let maxHeight = child.get("maxHeight");\n          if (maxHeight) {\n            if (bottom - top > maxHeight) {\n              bottom = top + maxHeight;\n            }\n          }\n          let marginBottom = child.get("marginBottom", 0);\n          let y = prevY + marginTop - top;\n          child.setPrivate("y", y);\n          prevY = y + bottom + marginBottom;\n        } else {\n          child.setPrivate("y", undefined);\n        }\n      }\n    });\n  }\n}\nObject.defineProperty(VerticalLayout, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "VerticalLayout"\n});\nObject.defineProperty(VerticalLayout, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Layout.classNames.concat([VerticalLayout.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/GridLayout.js\n\n\n\n/**\r\n * A grid children layout for [[Container]].\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info\r\n */\nclass GridLayout extends Layout {\n  _afterNew() {\n    this._setRawDefault("maxColumns", Number.MAX_VALUE);\n    super._afterNew();\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateContainer(container) {\n    let paddingLeft = container.get("paddingLeft", 0);\n    let paddingRight = container.get("paddingRight", 0);\n    let paddingTop = container.get("paddingTop", 0);\n    let availableWidth = container.maxWidth() - paddingLeft - paddingRight;\n    let minCellWidth = availableWidth;\n    let maxCellWidth = 1;\n    eachChildren(container, child => {\n      if (child.get("visible") && child.getPrivate("visible") && !child.get("forceHidden")) {\n        if (child.get("position") != "absolute") {\n          let childWidth = child.width();\n          if (childWidth < minCellWidth) {\n            minCellWidth = childWidth;\n          }\n          if (childWidth > maxCellWidth) {\n            maxCellWidth = childWidth;\n          }\n        }\n      }\n    });\n    minCellWidth = fitToRange(minCellWidth, 1, availableWidth);\n    maxCellWidth = fitToRange(maxCellWidth, 1, availableWidth);\n    let columnCount = 1;\n    if (this.get("fixedWidthGrid")) {\n      columnCount = availableWidth / maxCellWidth;\n    } else {\n      columnCount = availableWidth / minCellWidth;\n    }\n    columnCount = Math.max(1, Math.floor(columnCount));\n    columnCount = Math.min(this.get("maxColumns", Number.MAX_VALUE), columnCount);\n    let columnWidths = this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);\n    let prevY = paddingTop;\n    let column = 0;\n    let maxColumnHeight = 0;\n    columnCount = columnWidths.length;\n    let prevX = paddingLeft;\n    eachChildren(container, child => {\n      if (child.get("position") == "relative" && child.isVisible()) {\n        const marginTop = child.get("marginTop", 0);\n        const marginBottom = child.get("marginBottom", 0);\n        let bounds = child.adjustedLocalBounds();\n        let marginLeft = child.get("marginLeft", 0);\n        let marginRight = child.get("marginRight", 0);\n        let x = prevX + marginLeft - bounds.left;\n        let y = prevY + marginTop - bounds.top;\n        child.setPrivate("x", x);\n        child.setPrivate("y", y);\n        prevX += columnWidths[column] + marginRight;\n        maxColumnHeight = Math.max(maxColumnHeight, child.height() + marginTop + marginBottom);\n        column++;\n        if (column >= columnCount) {\n          column = 0;\n          prevX = paddingLeft;\n          prevY += maxColumnHeight;\n        }\n      }\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  getColumnWidths(container, columnCount, maxCellWidth, availableWidth) {\n    let totalWidth = 0;\n    let columnWidths = [];\n    let column = 0;\n    eachChildren(container, child => {\n      let bounds = child.adjustedLocalBounds();\n      if (child.get("position") != "absolute" && child.isVisible()) {\n        if (this.get("fixedWidthGrid")) {\n          columnWidths[column] = maxCellWidth;\n        } else {\n          columnWidths[column] = Math.max(columnWidths[column] | 0, bounds.right - bounds.left + child.get("marginLeft", 0) + child.get("marginRight", 0));\n        }\n        if (column < container.children.length - 1) {\n          column++;\n          if (column == columnCount) {\n            column = 0;\n          }\n        }\n      }\n    });\n    each(columnWidths, w => {\n      totalWidth += w;\n    });\n    if (totalWidth > availableWidth) {\n      if (columnCount > 2) {\n        columnCount -= 1;\n        return this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);\n      } else {\n        return [availableWidth];\n      }\n    }\n    return columnWidths;\n  }\n}\nObject.defineProperty(GridLayout, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "GridLayout"\n});\nObject.defineProperty(GridLayout, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Layout.classNames.concat([GridLayout.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js\n\n\nclass TextFormatter {\n  /**\r\n   * Replaces brackets with temporary placeholders.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Escaped text\r\n   */\n  static escape(text) {\n    return text.replace(/\\[\\[/g, this.prefix + "1").replace(/([^\\/\\]]{1})\\]\\]/g, "$1" + this.prefix + "2").replace(/\\]\\]/g, this.prefix + "2").replace(/\\{\\{/g, this.prefix + "3").replace(/\\}\\}/g, this.prefix + "4").replace(/\\\'\\\'/g, this.prefix + "5");\n  }\n  /**\r\n   * Replaces placeholders back to brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Escaped text\r\n   * @return Unescaped text\r\n   */\n  static unescape(text) {\n    return text.replace(new RegExp(this.prefix + "1", "g"), "[[").replace(new RegExp(this.prefix + "2", "g"), "]]").replace(new RegExp(this.prefix + "3", "g"), "{{").replace(new RegExp(this.prefix + "4", "g"), "}}").replace(new RegExp(this.prefix + "5", "g"), "\'\'");\n  }\n  /**\r\n   * Cleans up the text text for leftover double square brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Cleaned up text\r\n   */\n  static cleanUp(text) {\n    return text.replace(/\\[\\[/g, "[").replace(/\\]\\]/g, "]").replace(/\\{\\{/g, "{").replace(/\\}\\}/g, "}").replace(/\\\'\\\'/g, "\'");\n  }\n  /**\r\n   * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\r\n   *\r\n   * If the second parameter `quotedBlocks` is set to `true` this method will\r\n   * also single out text blocks enclosed within single quotes that no\r\n   * formatting should be applied to, and they should be displayed as is.\r\n   *\r\n   * Default for the above is `false`, so that you can use single quote in text\r\n   * without escaping it.\r\n   *\r\n   * If enabled, single quotes can be escaped by doubling it - adding two\r\n   * single quotes, which will be replaced by a one single quote in the final\r\n   * output.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text          Text to chunk\r\n   * @param quotedBlocks  Use quoted blocks\r\n   * @param noFormatting  Formatting blocks will be treated as regular text\r\n   * @return Array of string chunks\r\n   */\n  static chunk(text, quotedBlocks = false, noFormatting = false) {\n    // Init result\n    let res = [];\n    // Replace double (escaped) square spaces and quotes with temporary codes\n    text = this.escape(text);\n    // Deal with style blocks\n    let chunks = quotedBlocks ? text.split("\'") : [text];\n    for (let i = 0; i < chunks.length; i++) {\n      let chunk = chunks[i];\n      // Empty?\n      if (chunk === "") {\n        continue;\n      }\n      if (i % 2 === 0) {\n        // Text outside quotes\n        // Parse for style blocks which are "text" chunks, the rest chunks are\n        // "value"\n        chunk = chunk.replace(/\\]\\[/g, "]" + PLACEHOLDER + "[");\n        chunk = chunk.replace(/\\[\\]/g, "[ ]");\n        let chunks2 = chunk.split(/[\\[\\]]+/);\n        for (let i2 = 0; i2 < chunks2.length; i2++) {\n          let chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n          // Placeholder?\n          if (chunk2 === PLACEHOLDER) {\n            continue;\n          }\n          // Empty?\n          if (chunk2 === "") {\n            continue;\n          }\n          // Block or value\n          if (i2 % 2 === 0) {\n            res.push({\n              "type": "value",\n              "text": chunk2\n            });\n          } else {\n            res.push({\n              "type": noFormatting ? "value" : "format",\n              "text": "[" + chunk2 + "]"\n            });\n          }\n        }\n      } else {\n        // A text within doublequotes\n        // All chunks are "text"\n        let chunks2 = chunk.split(/[\\[\\]]+/);\n        for (let i2 = 0; i2 < chunks2.length; i2++) {\n          let chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n          // Empty?\n          if (chunk2 === "") {\n            continue;\n          }\n          // Block or text\n          if (i2 % 2 === 0) {\n            res.push({\n              "type": "text",\n              "text": chunk2\n            });\n          } else if (this.isImage(chunk2)) {\n            res.push({\n              "type": "image",\n              "text": "[" + chunk2 + "]"\n            });\n          } else {\n            res.push({\n              "type": "format",\n              "text": "[" + chunk2 + "]"\n            });\n          }\n        }\n      }\n    }\n    return res;\n  }\n  /**\r\n   * Checks if supplied format contains image information and should be\r\n   * formatted as such.\r\n   * I.e.: `[img: myImage.png]`\r\n   *\r\n   * @ignore\r\n   * @param  text  Format\r\n   * @return true if it is an image\r\n   */\n  static isImage(text) {\n    return text.match(/img[ ]?:/) ? true : false;\n  }\n  static getTextStyle(style) {\n    // let textStyle: string[] = [];\n    // let textFill: string | undefined;\n    let format = {};\n    if (style == "" || style == "[ ]") {\n      return {};\n    }\n    // Pre-process quoted text\n    const q = style.match(/(\'[^\']*\')|("[^"]*")/gi);\n    if (q) {\n      for (let i = 0; i < q.length; i++) {\n        style = style.replace(q[i], q[i].replace(/[\'"]*/g, "").replace(/[ ]+/g, "+"));\n      }\n    }\n    // Get style parts\n    let b = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w\\-]+)|(\\/)/gi);\n    // Empty?\n    if (!b) {\n      return {};\n    }\n    // Check each part\n    for (let i = 0; i < b.length; i++) {\n      if (b[i].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i)) {\n        format.fontWeight = b[i];\n      } else if (b[i].match(/^(underline|line-through)$/i)) {\n        format.textDecoration = b[i];\n      } else if (b[i] == "/") {\n        // Just closing tag\n        // Do nothing\n      } else if (!b[i].match(/:/)) {\n        // Color\n        format.fill = Color.fromString(b[i]);\n      } else {\n        const p = b[i].replace("+", " ").split(/:[ ]*/);\n        format[p[0]] = p[1];\n        //textStyle.push(b[i].replace(/^[a-zA-Z]:[ ]*/, ""));\n        //b[i] = b[i].replace(/\\+/g, " ");\n      }\n    }\n\n    return format;\n  }\n}\nObject.defineProperty(TextFormatter, "prefix", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "__amcharts__"\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/PopulateString.js\n/** @ignore */ /** */\n\n\n\n\n/**\r\n * @ignore\r\n */\nfunction populateString(target, string) {\n  if (string != null) {\n    string = "" + string;\n    string = TextFormatter.escape(string);\n    let tags = string.match(/\\{([^}]+)\\}/g);\n    let i;\n    if (tags) {\n      for (i = 0; i < tags.length; i++) {\n        let tag = tags[i].replace(/\\{([^}]+)\\}/, "$1");\n        let value = getTagValue(target, tag, "");\n        if (value == null) {\n          value = "";\n        }\n        string = string.split(tags[i]).join(value);\n      }\n    }\n    string = TextFormatter.unescape(string);\n  } else {\n    string = "";\n  }\n  // TODO: apply adapter?\n  return string;\n}\n/**\r\n * @ignore\r\n */\nfunction getTagValue(target, tagName, format) {\n  let value;\n  const dataItem = target.dataItem;\n  // Parse parts\n  let parts = [];\n  let reg = /(format[a-zA-Z]*)\\((.*)\\)|([^.]+)/g;\n  let matches;\n  while (true) {\n    matches = reg.exec(tagName);\n    if (matches === null) {\n      break;\n    }\n    if (matches[3]) {\n      // Simple property\n      parts.push({\n        prop: matches[3]\n      });\n      // Check if maybe we should force a formatter on this value\n      const dateFields = target.getDateFormatter().get("dateFields", []);\n      const numericFields = target.getNumberFormatter().get("numericFields", []);\n      const durationFields = target.getDurationFormatter().get("durationFields", []);\n      if (dateFields.indexOf(matches[3]) !== -1) {\n        parts.push({\n          method: "formatDate",\n          params: []\n        });\n      } else if (numericFields.indexOf(matches[3]) !== -1) {\n        parts.push({\n          method: "formatNumber",\n          params: []\n        });\n      } else if (durationFields.indexOf(matches[3]) !== -1) {\n        parts.push({\n          method: "formatDuration",\n          params: []\n        });\n      }\n    } else {\n      // Method\n      // Parse parameters\n      let params = [];\n      if (Utils_trim(matches[2]) != "") {\n        let reg2 = /\'([^\']*)\'|"([^"]*)"|([0-9\\-]+)/g;\n        let matches2;\n        while (true) {\n          matches2 = reg2.exec(matches[2]);\n          if (matches2 === null) {\n            break;\n          }\n          params.push(matches2[1] || matches2[2] || matches2[3]);\n        }\n      }\n      parts.push({\n        method: matches[1],\n        params: params\n      });\n    }\n  }\n  // Check if we can retrieve the value from data item\n  if (dataItem) {\n    // Check values\n    value = getTagValueFromObject(target, parts, dataItem._settings);\n    // Check properties\n    if (value == null || Type_isObject(value)) {\n      // isObject helps to solve problem with date axis, as for example dateX will get dateX from values object and won\'t get to the dateX date.\n      value = getTagValueFromObject(target, parts, dataItem);\n    }\n    // Check data context\n    let dataContext = dataItem.dataContext;\n    if (value == null && dataContext) {\n      value = getTagValueFromObject(target, parts, dataContext);\n      // Maybe it\'s a literal dot-separated name of the key in dataContext?\n      if (value == null) {\n        value = getTagValueFromObject(target, [{\n          prop: tagName\n        }], dataContext);\n      }\n      // scond data context level sometimes exist (tree map)\n      if (value == null && dataContext.dataContext) {\n        value = getTagValueFromObject(target, parts, dataContext.dataContext);\n      }\n    }\n    // Check component\'s data item\n    if (value == null && dataItem.component && dataItem.component.dataItem !== dataItem) {\n      value = getTagValue(dataItem.component, tagName, format);\n    }\n  }\n  // Check sprite\'s properties\n  if (value == null) {\n    value = getTagValueFromObject(target, parts, target);\n  }\n  // Finally, check the parent\n  if (value == null && target.parent) {\n    value = getTagValue(target.parent, tagName, format);\n  }\n  return value;\n}\n/**\r\n * @ignore\r\n */\nfunction getCustomDataValue(target, prop) {\n  const customData = target.getPrivate("customData");\n  if (Type_isObject(customData)) {\n    return customData[prop];\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction getTagValueFromObject(target, parts, object, format) {\n  let current = object;\n  let formatApplied = false;\n  for (let i = 0, len = parts.length; i < len; i++) {\n    let part = parts[i];\n    if (part.prop) {\n      // Regular property\n      if (current instanceof Sprite) {\n        let tmp = current.get(part.prop);\n        if (tmp == null) tmp = current.getPrivate(part.prop);\n        if (tmp == null) tmp = getCustomDataValue(current, part.prop);\n        if (tmp == null) tmp = current[part.prop];\n        current = tmp;\n      } else if (current.get) {\n        let tmp = current.get(part.prop);\n        if (tmp == null) tmp = current[part.prop];\n        current = tmp;\n      } else {\n        current = current[part.prop];\n      }\n      if (current == null) {\n        // Not set, return undefined\n        return;\n      }\n    } else {\n      // Method\n      switch (part.method) {\n        case "formatNumber":\n          let numberValue = Type_toNumber(current);\n          if (numberValue != null) {\n            current = target.getNumberFormatter().format(numberValue, format || part.params[0] || undefined);\n            formatApplied = true;\n          }\n          break;\n        case "formatDate":\n          let dateValue = toDate(current);\n          if (!Type_isDate(dateValue) || Type_isNaN(dateValue.getTime())) {\n            // Was not able to get date out of value, quitting and letting\n            // calling method try another value\n            return;\n          }\n          if (dateValue != null) {\n            current = target.getDateFormatter().format(dateValue, format || part.params[0] || undefined);\n            formatApplied = true;\n          }\n          break;\n        case "formatDuration":\n          let durationValue = Type_toNumber(current);\n          if (durationValue != null) {\n            current = target.getDurationFormatter().format(durationValue, format || part.params[0] || undefined, part.params[1] || undefined);\n            formatApplied = true;\n          }\n          break;\n        case "urlEncode":\n        case "encodeURIComponent":\n          current = encodeURIComponent(current);\n          break;\n        default:\n          if (current[part.method]) {\n            current[part.method].apply(object, part.params);\n          }\n          break;\n      }\n    }\n  }\n  // Apply default format if it wasn\'t applied explicitly\n  if (!formatApplied) {\n    let formatParts = [{\n      method: "",\n      params: format\n    }];\n    if (format == null) {\n      // Format is not set\n      // Determine from the type of the value\n      if (Type_isNumber(current)) {\n        formatParts[0].method = "formatNumber";\n        formatParts[0].params = "";\n      } else if (Type_isDate(current)) {\n        formatParts[0].method = "formatDate";\n        formatParts[0].params = "";\n      }\n    } else {\n      // Format set\n      // Try to determine formatter based on the format\n      let formatterType = getFormat(format);\n      // format\n      if (formatterType === "number") {\n        formatParts[0].method = "formatNumber";\n      } else if (formatterType === "date") {\n        formatParts[0].method = "formatDate";\n      } else if (formatterType === "duration") {\n        formatParts[0].method = "formatDuration";\n      }\n    }\n    // Apply format\n    if (formatParts[0].method) {\n      current = getTagValueFromObject(target, formatParts, current);\n    }\n  }\n  return current;\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * A basic element that can have child elements, maintain their layout, and\r\n * have a background.\r\n *\r\n * It can have any [[Sprite]] element as a child, from very basic shapes, to\r\n * full-fledged charts.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/} for more info\r\n * @important\r\n */\nclass Container extends Sprite {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_display", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._root._renderer.makeContainer()\n    });\n    Object.defineProperty(this, "_childrenDisplay", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._root._renderer.makeContainer()\n    });\n    /**\r\n     * List of Container\'s child elements.\r\n     */\n    Object.defineProperty(this, "children", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Children(this)\n    });\n    Object.defineProperty(this, "_percentageSizeChildren", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "_percentagePositionChildren", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "_prevWidth", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_prevHeight", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_contentWidth", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_contentHeight", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_contentMask", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_vsbd0", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_vsbd1", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  _afterNew() {\n    super._afterNew();\n    this._display.addChild(this._childrenDisplay);\n  }\n  _dispose() {\n    eachReverse(this.allChildren(), child => {\n      child.dispose();\n    });\n    if (this.getPrivate("htmlElement")) {\n      this._root._removeHTMLContent(this);\n    }\n    super._dispose();\n  }\n  _changed() {\n    super._changed();\n    if (this.isDirty("interactiveChildren")) {\n      this._display.interactiveChildren = this.get("interactiveChildren", false);\n    }\n    if (this.isDirty("layout")) {\n      this._prevWidth = 0;\n      this._prevHeight = 0;\n      this.markDirtyBounds();\n      if (this._prevSettings.layout) {\n        this.children.each(child => {\n          child.removePrivate("x");\n          child.removePrivate("y");\n        });\n      }\n    }\n    if (this.isDirty("paddingTop") || this.isDirty("paddingBottom") || this.isDirty("paddingLeft") || this.isDirty("paddingRight")) {\n      this.children.each(child => {\n        child.markDirtyPosition();\n      });\n    }\n    if (this.isDirty("maskContent")) {\n      const childrenDisplay = this._childrenDisplay;\n      let contentMask = this._contentMask;\n      if (this.get("maskContent")) {\n        if (!contentMask) {\n          contentMask = Rectangle.new(this._root, {\n            x: -.5,\n            y: -.5,\n            width: this.width() + 1,\n            height: this.height() + 1\n          });\n          this._contentMask = contentMask;\n          childrenDisplay.addChildAt(contentMask._display, 0);\n          childrenDisplay.mask = contentMask._display;\n        }\n      } else {\n        if (contentMask) {\n          childrenDisplay.removeChild(contentMask._display);\n          childrenDisplay.mask = null;\n          contentMask.dispose();\n          this._contentMask = undefined;\n        }\n      }\n    }\n  }\n  _updateSize() {\n    super._updateSize();\n    each(this._percentageSizeChildren, child => {\n      child._updateSize();\n    });\n    each(this._percentagePositionChildren, child => {\n      child.markDirtyPosition();\n      child._updateSize();\n    });\n    this.updateBackground();\n  }\n  updateBackground() {\n    const background = this.get("background");\n    let bounds = this._localBounds;\n    if (bounds && !this.isHidden()) {\n      let x = bounds.left;\n      let y = bounds.top;\n      let w = bounds.right - x;\n      let h = bounds.bottom - y;\n      let maxWidth = this.get("maxWidth");\n      let maxHeight = this.get("maxHeight");\n      if (maxHeight) {\n        if (h > maxHeight) {\n          h = maxHeight;\n        }\n      }\n      if (maxWidth) {\n        if (w > maxWidth) {\n          w = maxWidth;\n        }\n      }\n      let width = this.width();\n      let height = this.height();\n      if (background) {\n        background.setAll({\n          width: w,\n          height: h,\n          x: x,\n          y: y\n        });\n        if (this._display.interactive) {\n          background._display.interactive = true;\n        }\n      }\n      const contentMask = this._contentMask;\n      if (contentMask) {\n        contentMask.setAll({\n          width: width + 1,\n          height: height + 1\n        });\n      }\n      const verticalScrollbar = this.get("verticalScrollbar");\n      if (verticalScrollbar) {\n        verticalScrollbar.set("height", height);\n        verticalScrollbar.set("x", width - verticalScrollbar.width() - verticalScrollbar.get("marginRight", 0));\n        verticalScrollbar.set("end", verticalScrollbar.get("start", 0) + height / this._contentHeight);\n        const bg = verticalScrollbar.get("background");\n        if (bg) {\n          bg.setAll({\n            width: verticalScrollbar.width(),\n            height: height\n          });\n        }\n        let visible = true;\n        if (this._contentHeight <= height) {\n          visible = false;\n        }\n        verticalScrollbar.setPrivate("visible", visible);\n      }\n    }\n  }\n  _applyThemes(force = false) {\n    if (super._applyThemes(force)) {\n      this.eachChildren(child => {\n        child._applyThemes(force);\n      });\n      return true;\n    } else {\n      return false;\n    }\n  }\n  _applyState(name) {\n    super._applyState(name);\n    if (this.get("setStateOnChildren")) {\n      this.eachChildren(child => {\n        child.states.apply(name);\n      });\n    }\n  }\n  _applyStateAnimated(name, duration) {\n    super._applyStateAnimated(name, duration);\n    if (this.get("setStateOnChildren")) {\n      this.eachChildren(child => {\n        child.states.applyAnimate(name, duration);\n      });\n    }\n  }\n  /**\r\n   * Returns container\'s inner width (width without padding) in pixels.\r\n   *\r\n   * @return Inner width (px)\r\n   */\n  innerWidth() {\n    return this.width() - this.get("paddingRight", 0) - this.get("paddingLeft", 0);\n  }\n  /**\r\n   * Returns container\'s inner height (height without padding) in pixels.\r\n   *\r\n   * @return Inner height (px)\r\n   */\n  innerHeight() {\n    return this.height() - this.get("paddingTop", 0) - this.get("paddingBottom", 0);\n  }\n  _getBounds() {\n    let width = this.get("width");\n    let height = this.get("height");\n    let pWidth = this.getPrivate("width");\n    let pHeight = this.getPrivate("height");\n    let bounds = {\n      left: 0,\n      top: 0,\n      right: this.width(),\n      bottom: this.height()\n    };\n    let layout = this.get("layout");\n    let horizontal = false;\n    let vertical = false;\n    if (layout instanceof HorizontalLayout || layout instanceof GridLayout) {\n      horizontal = true;\n    }\n    if (layout instanceof VerticalLayout) {\n      vertical = true;\n    }\n    if ((width != null || pWidth != null) && (height != null || pHeight != null) && !this.get("verticalScrollbar")) {\n      // void\n    } else {\n      let m = Number.MAX_VALUE;\n      let l = m;\n      let r = -m;\n      let t = m;\n      let b = -m;\n      const paddingLeft = this.get("paddingLeft", 0);\n      const paddingTop = this.get("paddingTop", 0);\n      const paddingRight = this.get("paddingRight", 0);\n      const paddingBottom = this.get("paddingBottom", 0);\n      this.children.each(child => {\n        if (child.get("position") != "absolute" && child.get("isMeasured")) {\n          let childBounds = child.adjustedLocalBounds();\n          let childX = child.x();\n          let childY = child.y();\n          let cl = childX + childBounds.left;\n          let cr = childX + childBounds.right;\n          let ct = childY + childBounds.top;\n          let cb = childY + childBounds.bottom;\n          if (horizontal) {\n            cl -= child.get("marginLeft", 0);\n            cr += child.get("marginRight", 0);\n          }\n          if (vertical) {\n            ct -= child.get("marginTop", 0);\n            cb += child.get("marginBottom", 0);\n          }\n          if (cl < l) {\n            l = cl;\n          }\n          if (cr > r) {\n            r = cr;\n          }\n          if (ct < t) {\n            t = ct;\n          }\n          if (cb > b) {\n            b = cb;\n          }\n        }\n      });\n      if (l == m) {\n        l = 0;\n      }\n      if (r == -m) {\n        r = 0;\n      }\n      if (t == m) {\n        t = 0;\n      }\n      if (b == -m) {\n        b = 0;\n      }\n      bounds.left = l - paddingLeft;\n      bounds.top = t - paddingTop;\n      bounds.right = r + paddingRight;\n      bounds.bottom = b + paddingBottom;\n      const minWidth = this.get("minWidth");\n      if (Type_isNumber(minWidth) && minWidth > 0) {\n        if (bounds.right - bounds.left < minWidth) {\n          if (bounds.right >= minWidth) {\n            bounds.left = bounds.right - minWidth;\n          } else {\n            bounds.right = bounds.left + minWidth;\n          }\n        }\n      }\n      const minHeight = this.get("minHeight");\n      if (Type_isNumber(minHeight) && minHeight > 0) {\n        if (bounds.bottom - bounds.top < minHeight) {\n          if (bounds.bottom >= minHeight) {\n            bounds.top = bounds.bottom - minHeight;\n          } else {\n            bounds.bottom = bounds.top + minHeight;\n          }\n        }\n      }\n    }\n    this._contentWidth = bounds.right - bounds.left;\n    this._contentHeight = bounds.bottom - bounds.top;\n    if (Type_isNumber(width)) {\n      bounds.left = 0;\n      bounds.right = width;\n    }\n    if (Type_isNumber(pWidth)) {\n      bounds.left = 0;\n      bounds.right = pWidth;\n    }\n    if (Type_isNumber(height)) {\n      bounds.top = 0;\n      bounds.bottom = height;\n    }\n    if (Type_isNumber(pHeight)) {\n      bounds.top = 0;\n      bounds.bottom = pHeight;\n    }\n    this._localBounds = bounds;\n  }\n  _updateBounds() {\n    const layout = this.get("layout");\n    if (layout) {\n      layout.updateContainer(this);\n    }\n    super._updateBounds();\n    this.updateBackground();\n  }\n  /**\r\n   * @ignore\r\n   */\n  markDirty() {\n    super.markDirty();\n    this._root._addDirtyParent(this);\n  }\n  _prepareChildren() {\n    const innerWidth = this.innerWidth();\n    const innerHeight = this.innerHeight();\n    if (innerWidth != this._prevWidth || innerHeight != this._prevHeight) {\n      let layout = this.get("layout");\n      let horizontal = false;\n      let vertical = false;\n      if (layout) {\n        if (layout instanceof HorizontalLayout || layout instanceof GridLayout) {\n          horizontal = true;\n        }\n        if (layout instanceof VerticalLayout) {\n          vertical = true;\n        }\n      }\n      each(this._percentageSizeChildren, child => {\n        if (!horizontal) {\n          let width = child.get("width");\n          if (width instanceof Percent) {\n            child.setPrivate("width", width.value * innerWidth);\n          }\n        }\n        if (!vertical) {\n          let height = child.get("height");\n          if (height instanceof Percent) {\n            child.setPrivate("height", height.value * innerHeight);\n          }\n        }\n      });\n      each(this._percentagePositionChildren, child => {\n        child.markDirtyPosition();\n        child.markDirtyBounds();\n      });\n      this._prevWidth = innerWidth;\n      this._prevHeight = innerHeight;\n      this._sizeDirty = true;\n      this.updateBackground();\n    }\n    this._handleStates();\n  }\n  _updateHTMLContent() {\n    const html = this.get("html");\n    if (html && html !== "") {\n      this._root._setHTMLContent(this, populateString(this, this.get("html", "")));\n    } else {\n      this._root._removeHTMLContent(this);\n    }\n    this._root._positionHTMLElement(this);\n  }\n  _updateChildren() {\n    if (this.isDirty("html")) {\n      this._updateHTMLContent();\n    }\n    if (this.isDirty("verticalScrollbar")) {\n      const verticalScrollbar = this.get("verticalScrollbar");\n      if (verticalScrollbar) {\n        verticalScrollbar._setParent(this);\n        verticalScrollbar.startGrip.setPrivate("visible", false);\n        verticalScrollbar.endGrip.setPrivate("visible", false);\n        this.set("maskContent", true);\n        this.set("paddingRight", verticalScrollbar.width() + verticalScrollbar.get("marginRight", 0) + verticalScrollbar.get("marginLeft", 0));\n        let background = this.get("background");\n        if (!background) {\n          background = this.set("background", Rectangle.new(this._root, {\n            themeTags: ["background"],\n            fillOpacity: 0,\n            fill: this._root.interfaceColors.get("alternativeBackground")\n          }));\n        }\n        this._vsbd0 = this.events.on("wheel", event => {\n          const wheelEvent = event.originalEvent;\n          // Ignore wheel event if it is happening on a non-chart element, e.g. if\n          // some page element is over the chart.\n          if (isLocalEvent(wheelEvent, this)) {\n            wheelEvent.preventDefault();\n          } else {\n            return;\n          }\n          let shiftY = wheelEvent.deltaY / 5000;\n          const start = verticalScrollbar.get("start", 0);\n          const end = verticalScrollbar.get("end", 1);\n          if (start + shiftY <= 0) {\n            shiftY = -start;\n          }\n          if (end + shiftY >= 1) {\n            shiftY = 1 - end;\n          }\n          if (start + shiftY >= 0 && end + shiftY <= 1) {\n            verticalScrollbar.set("start", start + shiftY);\n            verticalScrollbar.set("end", end + shiftY);\n          }\n        });\n        this._disposers.push(this._vsbd0);\n        this._vsbd1 = verticalScrollbar.events.on("rangechanged", () => {\n          let h = this._contentHeight;\n          const childrenDisplay = this._childrenDisplay;\n          const contentMask = this._contentMask;\n          childrenDisplay.y = -verticalScrollbar.get("start", 0) * h;\n          childrenDisplay.markDirtyLayer();\n          if (contentMask) {\n            contentMask._display.y = -childrenDisplay.y;\n            childrenDisplay.mask = contentMask._display;\n          }\n        });\n        this._disposers.push(this._vsbd1);\n        this._display.addChild(verticalScrollbar._display);\n      } else {\n        const previous = this._prevSettings.verticalScrollbar;\n        if (previous) {\n          this._display.removeChild(previous._display);\n          if (this._vsbd0) {\n            this._vsbd0.dispose();\n          }\n          if (this._vsbd1) {\n            this._vsbd1.dispose();\n          }\n          const childrenDisplay = this._childrenDisplay;\n          childrenDisplay.y = 0;\n          this.setPrivate("height", undefined);\n          this.set("maskContent", false);\n          this.set("paddingRight", undefined);\n        }\n      }\n    }\n    if (this.isDirty("background")) {\n      // TODO maybe this should dispose ?\n      const previous = this._prevSettings["background"];\n      if (previous) {\n        this._display.removeChild(previous._display);\n      }\n      const background = this.get("background");\n      if (background instanceof Sprite) {\n        background.set("isMeasured", false);\n        background._setParent(this);\n        this._display.addChildAt(background._display, 0);\n      }\n    }\n    if (this.isDirty("mask")) {\n      const mask = this.get("mask");\n      const previous = this._prevSettings["mask"];\n      if (previous) {\n        this._display.removeChild(previous._display);\n        if (previous != mask) {\n          previous.dispose();\n        }\n      }\n      if (mask) {\n        const parent = mask.parent;\n        if (parent) {\n          parent.children.removeValue(mask);\n        }\n        mask._setParent(this);\n        this._display.addChildAt(mask._display, 0);\n        this._childrenDisplay.mask = mask._display;\n      }\n    }\n  }\n  _processTemplateField() {\n    super._processTemplateField();\n    this.children.each(child => {\n      child._processTemplateField();\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  walkChildren(f) {\n    this.children.each(child => {\n      if (child instanceof Container) {\n        child.walkChildren(f);\n      }\n      f(child);\n    });\n  }\n  eachChildren(f) {\n    const background = this.get("background");\n    if (background) {\n      f(background);\n    }\n    const verticalScrollbar = this.get("verticalScrollbar");\n    if (verticalScrollbar) {\n      f(verticalScrollbar);\n    }\n    const mask = this.get("mask");\n    if (mask) {\n      f(mask);\n    }\n    this.children.values.forEach(child => {\n      f(child);\n    });\n  }\n  allChildren() {\n    const output = [];\n    this.eachChildren(x => {\n      output.push(x);\n    });\n    return output;\n  }\n  _setDataItem(dataItem) {\n    const updated = dataItem !== this._dataItem;\n    super._setDataItem(dataItem);\n    const html = this.get("html", "");\n    if (html && html !== "" && updated) {\n      this._root._setHTMLContent(this, populateString(this, html));\n    }\n  }\n}\nObject.defineProperty(Container, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Container"\n});\nObject.defineProperty(Container, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Sprite.classNames.concat([Container.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Text.js\n\n\n\n\n\n/**\r\n * @ignore Text is an internal class. Use Label instead.\r\n */\nclass Text_Text extends Sprite {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "textStyle", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._root._renderer.makeTextStyle()\n    });\n    Object.defineProperty(this, "_display", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._root._renderer.makeText("", this.textStyle)\n    });\n    Object.defineProperty(this, "_textStyles", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: ["textAlign", "fontFamily", "fontSize", "fontStyle", "fontWeight", "fontStyle", "fontVariant", "textDecoration", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "shadowOpacity",\n      // "leading",\n      // "letterSpacing",\n      "lineHeight", "baselineRatio",\n      //"padding",\n      // "stroke",\n      // "strokeThickness",\n      // "trim",\n      // "wordWrap",\n      "direction", "textBaseline", "oversizedBehavior", "breakWords", "ellipsis", "minScale", "maxChars"]\n    });\n    Object.defineProperty(this, "_originalScale", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  _updateBounds() {\n    if (!this.get("text")) {\n      let newBounds = {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      };\n      this._adjustedLocalBounds = newBounds;\n    } else {\n      super._updateBounds();\n    }\n  }\n  _changed() {\n    super._changed();\n    this._display.clear();\n    let textStyle = this.textStyle;\n    if (this.isDirty("opacity")) {\n      let opacity = this.get("opacity", 1);\n      this._display.alpha = opacity;\n    }\n    if (this.isDirty("text") || this.isDirty("populateText")) {\n      this._display.text = this._getText();\n      this.markDirtyBounds();\n      if (this.get("role") == "tooltip") {\n        this._root.updateTooltip(this);\n      }\n    }\n    if (this.isPrivateDirty("tooltipElement")) {\n      const tooltipElement = this.getPrivate("tooltipElement");\n      if (tooltipElement) {\n        this._disposers.push(new Disposer(() => {\n          this._root._removeTooltipElement(this);\n        }));\n      }\n    }\n    if (this.isDirty("width")) {\n      textStyle.wordWrapWidth = this.width();\n      this.markDirtyBounds();\n    }\n    if (this.isDirty("oversizedBehavior")) {\n      textStyle.oversizedBehavior = this.get("oversizedBehavior", "none");\n      this.markDirtyBounds();\n    }\n    if (this.isDirty("breakWords")) {\n      textStyle.breakWords = this.get("breakWords", false);\n      this.markDirtyBounds();\n    }\n    if (this.isDirty("ellipsis")) {\n      textStyle.ellipsis = this.get("ellipsis");\n      this.markDirtyBounds();\n    }\n    if (this.isDirty("ignoreFormatting")) {\n      textStyle.ignoreFormatting = this.get("ignoreFormatting", false);\n      this.markDirtyBounds();\n    }\n    if (this.isDirty("minScale")) {\n      textStyle.minScale = this.get("minScale", 0);\n      this.markDirtyBounds();\n    }\n    if (this.isDirty("fill")) {\n      let fill = this.get("fill");\n      if (fill) {\n        textStyle.fill = fill;\n      }\n    }\n    if (this.isDirty("fillOpacity")) {\n      let fillOpacity = this.get("fillOpacity", 1);\n      if (fillOpacity) {\n        textStyle.fillOpacity = fillOpacity;\n      }\n    }\n    if (this.isDirty("maxWidth") || this.isPrivateDirty("maxWidth")) {\n      textStyle.maxWidth = this.get("maxWidth", this.getPrivate("maxWidth"));\n      this.markDirtyBounds();\n    }\n    if (this.isDirty("maxHeight") || this.isPrivateDirty("maxHeight")) {\n      textStyle.maxHeight = this.get("maxHeight", this.getPrivate("maxHeight"));\n      this.markDirtyBounds();\n    }\n    each(this._textStyles, styleName => {\n      if (this._dirty[styleName]) {\n        textStyle[styleName] = this.get(styleName);\n        this.markDirtyBounds();\n      }\n    });\n    textStyle["fontSize"] = this.get("fontSize");\n    textStyle["fontFamily"] = this.get("fontFamily");\n    this._display.style = textStyle;\n    if (this.isDirty("role") && this.get("role") == "tooltip") {\n      this._root.updateTooltip(this);\n    }\n  }\n  _getText() {\n    let text = this.get("text", "");\n    if (this.get("maxChars")) {\n      text = truncateTextWithEllipsis(text, this.get("maxChars", 100000000), this.get("breakWords"), this.get("ellipsis"));\n    }\n    return this.get("populateText") ? populateString(this, text) : text;\n  }\n  _getAccessibleText() {\n    const ariaLabel = this.get("ariaLabel");\n    if (ariaLabel !== undefined) {\n      return this.get("populateText") ? populateString(this, ariaLabel) : ariaLabel;\n    }\n    return this._getText();\n  }\n  /**\r\n   * Forces the text to be re-evaluated and re-populated.\r\n   */\n  markDirtyText() {\n    this._display.text = this._getText();\n    if (this.get("role") == "tooltip") {\n      this._root.updateTooltip(this);\n    }\n    this.markDirtyBounds();\n    this.markDirty();\n  }\n  _setDataItem(dataItem) {\n    super._setDataItem(dataItem);\n    if (this.get("populateText")) {\n      this.markDirtyText();\n    }\n  }\n  getNumberFormatter() {\n    if (this.parent) {\n      return this.parent.getNumberFormatter();\n    } else {\n      return super.getNumberFormatter();\n    }\n  }\n  getDateFormatter() {\n    if (this.parent) {\n      return this.parent.getDateFormatter();\n    } else {\n      return super.getDateFormatter();\n    }\n  }\n  getDurationFormatter() {\n    if (this.parent) {\n      return this.parent.getDurationFormatter();\n    } else {\n      return super.getDurationFormatter();\n    }\n  }\n}\nObject.defineProperty(Text_Text, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Text"\n});\nObject.defineProperty(Text_Text, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Sprite.classNames.concat([Text_Text.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/ResizeSensor.js\n/** @ignore */ /** */\n\n\n/**\r\n * @ignore\r\n */\nclass Native {\n  constructor() {\n    Object.defineProperty(this, "_observer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_targets", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    this._observer = new ResizeObserver(entries => {\n      each(entries, entry => {\n        each(this._targets, x => {\n          if (x.target === entry.target) {\n            x.callback();\n          }\n        });\n      });\n    });\n  }\n  addTarget(target, callback) {\n    this._observer.observe(target, {\n      box: "border-box"\n    });\n    this._targets.push({\n      target,\n      callback\n    });\n  }\n  removeTarget(target) {\n    this._observer.unobserve(target);\n    keepIf(this._targets, x => {\n      return x.target !== target;\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass Raf {\n  constructor() {\n    Object.defineProperty(this, "_timer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, "_targets", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n  }\n  addTarget(target, callback) {\n    if (this._timer === null) {\n      let lastTime = null;\n      const loop = () => {\n        const currentTime = Date.now();\n        if (lastTime === null || currentTime > lastTime + Raf.delay) {\n          lastTime = currentTime;\n          each(this._targets, x => {\n            let newSize = x.target.getBoundingClientRect();\n            if (newSize.width !== x.size.width || newSize.height !== x.size.height) {\n              x.size = newSize;\n              x.callback();\n            }\n          });\n        }\n        if (this._targets.length === 0) {\n          this._timer = null;\n        } else {\n          this._timer = requestAnimationFrame(loop);\n        }\n      };\n      this._timer = requestAnimationFrame(loop);\n    }\n    // We start off with fake bounds so that sensor always kicks in\n    let size = {\n      width: 0,\n      height: 0,\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0,\n      x: 0,\n      y: 0\n    };\n    this._targets.push({\n      target,\n      callback,\n      size\n    });\n  }\n  removeTarget(target) {\n    keepIf(this._targets, x => {\n      return x.target !== target;\n    });\n    if (this._targets.length === 0) {\n      if (this._timer !== null) {\n        cancelAnimationFrame(this._timer);\n        this._timer = null;\n      }\n    }\n  }\n}\nObject.defineProperty(Raf, "delay", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: 200\n});\n/**\r\n * @ignore\r\n */\nlet observer = null;\n/**\r\n * @ignore\r\n */\nfunction makeSensor() {\n  if (observer === null) {\n    if (typeof ResizeObserver !== "undefined") {\n      observer = new Native();\n    } else {\n      observer = new Raf();\n    }\n  }\n  return observer;\n}\n/**\r\n * @ignore\r\n */\nclass ResizeSensor {\n  constructor(element, callback) {\n    Object.defineProperty(this, "_sensor", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_element", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_listener", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_disposed", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    this._sensor = makeSensor();\n    this._element = element;\n    // This is needed because we need to know when the window is zoomed\n    this._listener = onZoom(callback);\n    this._sensor.addTarget(element, callback);\n  }\n  isDisposed() {\n    return this._disposed;\n  }\n  dispose() {\n    if (!this._disposed) {\n      this._disposed = true;\n      this._sensor.removeTarget(this._element);\n      this._listener.dispose();\n    }\n  }\n  get sensor() {\n    return this._sensor;\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/InterfaceColors.js\n\n/**\r\n * Presets for common UI elements.\r\n */\nclass InterfaceColors extends Entity {}\nObject.defineProperty(InterfaceColors, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "InterfaceColors"\n});\nObject.defineProperty(InterfaceColors, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Entity.classNames.concat([InterfaceColors.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js\n\n\n\n\n\n/**\r\n * Creates a label with support for in-line styling and data bindings.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/labels/} for more info\r\n */\nclass Label extends Container {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_text", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_textKeys", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: ["text", "fill", "fillOpacity", "textAlign", "fontFamily", "fontSize", "fontStyle", "fontWeight", "fontStyle", "fontVariant", "textDecoration", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "shadowOpacity",\n      // "leading",\n      // "letterSpacing",\n      "lineHeight", "baselineRatio",\n      //"padding",\n      // "stroke",\n      // "strokeThickness",\n      // "trim",\n      // "wordWrap",\n      "direction", "textBaseline", "oversizedBehavior", "breakWords", "ellipsis", "minScale", "populateText", "role", "ignoreFormatting", "maxChars", "ariaLabel"]\n    });\n  }\n  /**\r\n   * @ignore Text is not to be used directly\r\n   */\n  get text() {\n    return this._text;\n  }\n  _afterNew() {\n    super._afterNew();\n    this._makeText();\n    each(this._textKeys, property => {\n      const propValue = this.get(property);\n      if (propValue != undefined) {\n        this._text.set(property, propValue);\n      }\n    });\n    if (this.get("html", "") !== "") {\n      this._text.set("text", "");\n    }\n    this.onPrivate("maxWidth", () => {\n      this._setMaxDimentions();\n    });\n    this.onPrivate("maxHeight", () => {\n      this._setMaxDimentions();\n    });\n  }\n  _makeText() {\n    this._text = this.children.push(Text_Text.new(this._root, {}));\n  }\n  _updateChildren() {\n    super._updateChildren();\n    const text = this._text;\n    each(this._textKeys, property => {\n      this._text.set(property, this.get(property));\n    });\n    if (this.isDirty("maxWidth") || this.isDirty("maxHeight") || this.isDirty("rotation")) {\n      this._setMaxDimentions();\n    }\n    // Do not show regular text if HTML is used\n    if (this.get("html", "") !== "") {\n      text.set("text", "");\n    } else {\n      text.set("text", this.get("text"));\n      this._maybeUpdateHTMLColor();\n    }\n    if (this.isDirty("fill")) {\n      this._maybeUpdateHTMLColor();\n    }\n    if (this.isDirty("textAlign") || this.isDirty("width")) {\n      const textAlign = this.get("textAlign");\n      let x;\n      if (this.get("width") != null) {\n        if (textAlign == "right") {\n          x = p100;\n        } else if (textAlign == "center") {\n          x = p50;\n        } else {\n          x = 0;\n        }\n      } else {\n        if (textAlign == "left" || textAlign == "start") {\n          x = this.get("paddingLeft", 0);\n        } else if (textAlign == "right" || textAlign == "end") {\n          x = -this.get("paddingRight", 0);\n        }\n      }\n      text.set("x", x);\n    }\n    const background = this.get("background");\n    if (background) {\n      background.setPrivate("visible", text._display.textVisible);\n    }\n  }\n  _maybeUpdateHTMLColor() {\n    const htmlElement = this.getPrivate("htmlElement");\n    if (htmlElement && this.get("fill")) {\n      htmlElement.style.color = this.get("fill").toCSSHex();\n    }\n  }\n  _setMaxDimentions() {\n    const rotation = this.get("rotation");\n    const vertical = rotation == 90 || rotation == 270 || rotation == -90;\n    const text = this._text;\n    const maxWidth = this.get("maxWidth", this.getPrivate("maxWidth", Infinity));\n    if (Type_isNumber(maxWidth)) {\n      text.set(vertical ? "maxHeight" : "maxWidth", maxWidth - this.get("paddingLeft", 0) - this.get("paddingRight", 0));\n    } else {\n      text.set(vertical ? "maxHeight" : "maxWidth", undefined);\n    }\n    const maxHeight = this.get("maxHeight", this.getPrivate("maxHeight", Infinity));\n    if (Type_isNumber(maxHeight)) {\n      text.set(vertical ? "maxWidth" : "maxHeight", maxHeight - this.get("paddingTop", 0) - this.get("paddingBottom", 0));\n    } else {\n      text.set(vertical ? "maxWidth" : "maxHeight", undefined);\n    }\n    this.root.events.once("frameended", () => {\n      text.markDirtyBounds();\n    });\n  }\n  _setDataItem(dataItem) {\n    super._setDataItem(dataItem);\n    this._markDirtyKey("text");\n    const text = this._text;\n    if (text.get("populateText")) {\n      text.markDirtyText();\n    }\n    const html = this.get("html");\n    if (html && html !== "") {\n      this._updateHTMLContent();\n    }\n  }\n  /**\r\n   * Returns text with populated placeholders and formatting if `populateText` is\r\n   * set to `true`.\r\n   *\r\n   * @return Populated text\r\n   */\n  getText() {\n    return this._text._getText();\n  }\n  /**\r\n   * Returns "aria-label" text with populated placeholders and formatting\r\n   * if `populateText` is set to `true`.\r\n   *\r\n   * @return Populated text\r\n   */\n  getAccessibleText() {\n    return this._text._getAccessibleText();\n  }\n}\nObject.defineProperty(Label, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Label"\n});\nObject.defineProperty(Label, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Container.classNames.concat([Label.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/PointedRectangle.js\n\n\n/**\r\n * Draws a rectangle with a pointer.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info\r\n * @important\r\n */\nclass PointedRectangle extends Graphics {\n  _beforeChanged() {\n    super._beforeChanged();\n    if (this.isDirty("pointerBaseWidth") || this.isDirty("cornerRadius") || this.isDirty("pointerLength") || this.isDirty("pointerX") || this.isDirty("pointerY") || this.isDirty("width") || this.isDirty("height")) {\n      this._clear = true;\n    }\n  }\n  _changed() {\n    super._changed();\n    if (this._clear) {\n      this.markDirtyBounds();\n      let w = this.width();\n      let h = this.height();\n      if (w > 0 && h > 0) {\n        let cr = this.get("cornerRadius", 8);\n        cr = fitToRange(cr, 0, Math.min(w / 2, h / 2));\n        let x = this.get("pointerX", 0);\n        let y = this.get("pointerY", 0);\n        let bwh = this.get("pointerBaseWidth", 15) / 2;\n        // corner coordinates\n        // top left\n        let xtl = 0;\n        let ytl = 0;\n        // top right\n        let xtr = w;\n        let ytr = 0;\n        // bottom right\n        let xbr = w;\n        let ybr = h;\n        // bottom left\n        let xbl = 0;\n        let ybl = h;\n        // find stem base side: http://$math.stackexchange.com/questions/274712/calculate-on-which-side-of-straign-line-is-dot-located\n        // d=(x−x1)(y2−y1)−(y−y1)(x2−x1)\n        let d1 = (x - xtl) * (ybr - ytl) - (y - ytl) * (xbr - xtl);\n        let d2 = (x - xbl) * (ytr - ybl) - (y - ybl) * (xtr - xbl);\n        const display = this._display;\n        // top\n        display.moveTo(cr, 0);\n        if (d1 > 0 && d2 > 0) {\n          let stemX = Math.round(fitToRange(x, cr + bwh, w - bwh - cr));\n          y = fitToRange(y, -Infinity, 0);\n          display.lineTo(stemX - bwh, 0);\n          display.lineTo(x, y);\n          display.lineTo(stemX + bwh, 0);\n        }\n        display.lineTo(w - cr, 0);\n        display.arcTo(w, 0, w, cr, cr);\n        // right\n        if (d1 > 0 && d2 < 0) {\n          let stemY = Math.round(fitToRange(y, cr + bwh, h - bwh - cr));\n          x = fitToRange(x, w, Infinity);\n          display.lineTo(w, cr);\n          display.lineTo(w, Math.max(stemY - bwh, cr));\n          display.lineTo(x, y);\n          display.lineTo(w, stemY + bwh);\n        }\n        display.lineTo(w, h - cr);\n        display.arcTo(w, h, w - cr, h, cr);\n        // bottom\n        if (d1 < 0 && d2 < 0) {\n          let stemX = Math.round(fitToRange(x, cr + bwh, w - bwh - cr));\n          y = fitToRange(y, h, Infinity);\n          display.lineTo(w - cr, h);\n          display.lineTo(stemX + bwh, h);\n          display.lineTo(x, y);\n          display.lineTo(stemX - bwh, h);\n        }\n        display.lineTo(cr, h);\n        display.arcTo(0, h, 0, h - cr, cr);\n        // left\n        if (d1 < 0 && d2 > 0) {\n          let stemY = Math.round(fitToRange(y, cr + bwh, h - cr - bwh));\n          x = fitToRange(x, -Infinity, 0);\n          display.lineTo(0, h - cr);\n          display.lineTo(0, stemY + bwh);\n          display.lineTo(x, y);\n          display.lineTo(0, Math.max(stemY - bwh, cr));\n        }\n        display.lineTo(0, cr);\n        display.arcTo(0, 0, cr, 0, cr);\n        display.closePath();\n      }\n    }\n  }\n}\nObject.defineProperty(PointedRectangle, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "PointedRectangle"\n});\nObject.defineProperty(PointedRectangle, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Graphics.classNames.concat([PointedRectangle.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Tooltip.js\n\n\n\n\n\n\n\n\n\n/**\r\n * Creates a tooltip.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/} for more info\r\n * @important\r\n */\nclass Tooltip extends Container {\n  constructor(root, settings, isReal, templates = []) {\n    super(root, settings, isReal, templates);\n    Object.defineProperty(this, "_fx", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_fy", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_label", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_fillDp", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_strokeDp", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_labelDp", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_w", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_h", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_keepHoverDp", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_htmlContentHovered", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n  }\n  _afterNew() {\n    this._settings.themeTags = mergeTags(this._settings.themeTags, ["tooltip"]);\n    super._afterNew();\n    const background = this._setDefaultFn("background", () => {\n      return PointedRectangle.new(this._root, {});\n    });\n    background.set("themeTags", ["tooltip", "background"]);\n    this._label = this.children.push(Label.new(this._root, {}));\n    this._disposers.push(this._label.events.on("boundschanged", () => {\n      this._updateBackground();\n    }));\n    this._disposers.push(this.on("bounds", () => {\n      this._updateBackground();\n    }));\n    this._updateTextColor();\n    this._root.tooltipContainer.children.push(this);\n    this.hide(0);\n    this._disposers.push(this.label.onPrivate("htmlElement", htmlElement => {\n      if (htmlElement) {\n        Utils_addEventListener(htmlElement, "pointerover", _ev => {\n          this._htmlContentHovered = true;\n        });\n        Utils_addEventListener(htmlElement, "pointerout", _ev => {\n          this._htmlContentHovered = false;\n        });\n      }\n    }));\n    this.on("visible", _ev => {\n      this._handleReaderAnnouncement();\n    });\n    this.label.events.on("dataitemchanged", _ev => {\n      this._handleReaderAnnouncement();\n    });\n    this._root._tooltips.push(this);\n  }\n  _handleReaderAnnouncement() {\n    if (this.get("readerAnnounce") && this.isVisibleDeep()) {\n      this._root.readerAlert(this.label.getAccessibleText());\n    }\n  }\n  /**\r\n   * A [[Label]] element for the tooltip.\r\n   *\r\n   * @readonly\r\n   * @return Label\r\n   */\n  get label() {\n    return this._label;\n  }\n  /**\r\n   * Permanently disposes the tooltip.\r\n   */\n  dispose() {\n    super.dispose();\n    Array_remove(this._root._tooltips, this);\n  }\n  _updateChildren() {\n    super._updateChildren();\n    if (this.isDirty("pointerOrientation") || this.isPrivateDirty("minWidth") || this.isPrivateDirty("minHeight")) {\n      this.get("background")._markDirtyKey("width");\n    }\n    const labelText = this.get("labelText");\n    if (labelText != null) {\n      this.label.set("text", this.get("labelText"));\n    }\n    const labelHTML = this.get("labelHTML");\n    if (labelHTML != null) {\n      this.label.set("html", this.get("labelHTML"));\n    }\n    const labelAriaLabel = this.get("labelAriaLabel");\n    if (labelAriaLabel != null) {\n      this.label.set("ariaLabel", this.get("labelAriaLabel"));\n    }\n  }\n  _changed() {\n    super._changed();\n    if (this.isDirty("pointTo") || this.isDirty("pointerOrientation")) {\n      // can\'t compare to previous, as sometimes pointTo is set twice (when pointer moves, so the position won\'t be udpated)\n      this._updateBackground();\n    }\n    if (this.isDirty("tooltipTarget")) {\n      this.updateBackgroundColor();\n    }\n    if (this.isDirty("keepTargetHover")) {\n      const keephover = this.get("keepTargetHover");\n      if (keephover) {\n        const bg = this.get("background");\n        this._keepHoverDp = new Disposer_MultiDisposer([bg.events.on("pointerover", _ev => {\n          let target = this.get("tooltipTarget");\n          if (target) {\n            if (target.parent && target.parent.getPrivate("tooltipTarget") == target) {\n              target = target.parent;\n            }\n            target.hover();\n          }\n        }), bg.events.on("pointerout", _ev => {\n          let target = this.get("tooltipTarget");\n          if (target) {\n            if (target.parent && target.parent.getPrivate("tooltipTarget") == target) {\n              target = target.parent;\n            }\n            if (!this._htmlContentHovered) {\n              target.unhover();\n            }\n          }\n        })]);\n        this.label.onPrivate("htmlElement", htmlElement => {\n          if (this._keepHoverDp && htmlElement) {\n            this._keepHoverDp.disposers.push(Utils_addEventListener(htmlElement, "pointerleave", ev => {\n              const outEvent = this.root._renderer.getEvent(ev);\n              bg.events.dispatch("pointerout", {\n                type: "pointerout",\n                originalEvent: outEvent.event,\n                point: outEvent.point,\n                simulated: false,\n                target: bg\n              });\n            }));\n          }\n        });\n      } else {\n        if (this._keepHoverDp) {\n          this._keepHoverDp.dispose();\n          this._keepHoverDp = undefined;\n        }\n      }\n    }\n  }\n  _onShow() {\n    super._onShow();\n    this.updateBackgroundColor();\n  }\n  updateBackgroundColor() {\n    let tooltipTarget = this.get("tooltipTarget");\n    const background = this.get("background");\n    let fill;\n    let stroke;\n    if (tooltipTarget && background) {\n      fill = tooltipTarget.get("fill");\n      stroke = tooltipTarget.get("stroke");\n      if (fill == null) {\n        fill = stroke;\n      }\n      if (this.get("getFillFromSprite")) {\n        if (this._fillDp) {\n          this._fillDp.dispose();\n        }\n        if (fill != null) {\n          background.set("fill", fill);\n        }\n        this._fillDp = tooltipTarget.on("fill", fill => {\n          if (fill != null) {\n            background.set("fill", fill);\n            this._updateTextColor(fill);\n          }\n        });\n        this._disposers.push(this._fillDp);\n      }\n      if (this.get("getStrokeFromSprite")) {\n        if (this._strokeDp) {\n          this._strokeDp.dispose();\n        }\n        if (fill != null) {\n          background.set("stroke", fill);\n        }\n        this._strokeDp = tooltipTarget.on("fill", fill => {\n          if (fill != null) {\n            background.set("stroke", fill);\n          }\n        });\n        this._disposers.push(this._strokeDp);\n      }\n      if (this.get("getLabelFillFromSprite")) {\n        if (this._labelDp) {\n          this._labelDp.dispose();\n        }\n        if (fill != null) {\n          this.label.set("fill", fill);\n        }\n        this._labelDp = tooltipTarget.on("fill", fill => {\n          if (fill != null) {\n            this.label.set("fill", fill);\n          }\n        });\n        this._disposers.push(this._labelDp);\n      }\n    }\n    this._updateTextColor(fill);\n  }\n  _updateTextColor(fill) {\n    if (this.get("autoTextColor")) {\n      if (fill == null) {\n        fill = this.get("background").get("fill");\n      }\n      if (fill == null) {\n        fill = this._root.interfaceColors.get("background");\n      }\n      if (fill instanceof Color) {\n        this.label.set("fill", Color.alternative(fill, this._root.interfaceColors.get("alternativeText"), this._root.interfaceColors.get("text")));\n      }\n    }\n  }\n  _setDataItem(dataItem) {\n    super._setDataItem(dataItem);\n    this.label._setDataItem(dataItem);\n  }\n  _updateBackground() {\n    super.updateBackground();\n    const parent = this._root.container;\n    if (parent) {\n      let cw = 0.5;\n      let ch = 0.5;\n      let centerX = this.get("centerX");\n      if (centerX instanceof Percent) {\n        cw = centerX.value;\n      }\n      let centerY = this.get("centerY");\n      if (centerY instanceof Percent) {\n        ch = centerY.value;\n      }\n      let parentW = parent.width();\n      let parentH = parent.height();\n      let tooltipContainer = this.parent;\n      let xx = 0;\n      let yy = 0;\n      if (tooltipContainer) {\n        xx = tooltipContainer.x();\n        yy = tooltipContainer.y();\n        const layerMargin = tooltipContainer.get("layerMargin");\n        if (layerMargin) {\n          xx += layerMargin.left || 0;\n          yy += layerMargin.top || 0;\n          parentW += (layerMargin.left || 0) + (layerMargin.right || 0);\n          parentH += (layerMargin.top || 0) + (layerMargin.bottom || 0);\n        }\n      }\n      const bounds = this.get("bounds", {\n        left: -xx,\n        top: -yy,\n        right: parentW - xx,\n        bottom: parentH - yy\n      });\n      this._updateBounds();\n      let w = this.width();\n      let h = this.height();\n      // use old w and h,as when tooltip is hidden, these are 0 and unneeded animation happens\n      if (w === 0) {\n        w = this._w;\n      }\n      if (h === 0) {\n        h = this._h;\n      }\n      let pointTo = this.get("pointTo", {\n        x: parentW / 2,\n        y: parentH / 2\n      });\n      let x = pointTo.x;\n      let y = pointTo.y;\n      let pointerOrientation = this.get("pointerOrientation");\n      let background = this.get("background");\n      let pointerLength = 0;\n      let bgStrokeSizeY = 0;\n      let bgStrokeSizeX = 0;\n      if (background instanceof PointedRectangle) {\n        pointerLength = background.get("pointerLength", 0);\n        bgStrokeSizeY = background.get("strokeWidth", 0) / 2;\n        bgStrokeSizeX = bgStrokeSizeY;\n        background.set("width", w);\n        background.set("height", h);\n      }\n      let pointerX = 0;\n      let pointerY = 0;\n      let boundsW = bounds.right - bounds.left;\n      let boundsH = bounds.bottom - bounds.top;\n      // horizontal\n      if (pointerOrientation == "horizontal" || pointerOrientation == "left" || pointerOrientation == "right") {\n        bgStrokeSizeY = 0;\n        if (pointerOrientation == "horizontal") {\n          if (x > bounds.left + boundsW / 2) {\n            x -= w * (1 - cw) + pointerLength;\n            bgStrokeSizeX *= -1;\n          } else {\n            x += w * cw + pointerLength;\n          }\n        } else if (pointerOrientation == "left") {\n          x += w * (1 - cw) + pointerLength;\n        } else {\n          x -= w * cw + pointerLength;\n          bgStrokeSizeX *= -1;\n        }\n      }\n      // vertical pointer\n      else {\n        bgStrokeSizeX = 0;\n        if (pointerOrientation == "vertical") {\n          if (y > bounds.top + h / 2 + pointerLength) {\n            y -= h * (1 - ch) + pointerLength;\n          } else {\n            y += h * ch + pointerLength;\n            bgStrokeSizeY *= -1;\n          }\n        } else if (pointerOrientation == "down") {\n          y -= h * (1 - ch) + pointerLength;\n        } else {\n          y += h * ch + pointerLength;\n          bgStrokeSizeY *= -1;\n        }\n      }\n      x = fitToRange(x, bounds.left + w * cw, bounds.left + boundsW - w * (1 - cw)) + bgStrokeSizeX;\n      y = fitToRange(y, bounds.top + h * ch, bounds.top + boundsH - h * (1 - ch)) - bgStrokeSizeY;\n      pointerX = pointTo.x - x + w * cw + bgStrokeSizeX;\n      pointerY = pointTo.y - y + h * ch - bgStrokeSizeY;\n      this._fx = x;\n      this._fy = y;\n      const animationDuration = this.get("animationDuration", 0);\n      if (animationDuration > 0 && this.get("visible") && this.get("opacity") > 0.1) {\n        const animationEasing = this.get("animationEasing");\n        this.animate({\n          key: "x",\n          to: x,\n          duration: animationDuration,\n          easing: animationEasing\n        });\n        this.animate({\n          key: "y",\n          to: y,\n          duration: animationDuration,\n          easing: animationEasing\n        });\n      } else {\n        this.set("x", x);\n        this.set("y", y);\n      }\n      if (background instanceof PointedRectangle) {\n        background.set("pointerX", pointerX);\n        background.set("pointerY", pointerY);\n      }\n      if (w > 0) {\n        this._w = w;\n      }\n      if (h > 0) {\n        this._h = h;\n      }\n    }\n  }\n}\nObject.defineProperty(Tooltip, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Tooltip"\n});\nObject.defineProperty(Tooltip, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Container.classNames.concat([Tooltip.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/NumberFormatter.js\n\n\n\n\n\n/**\r\n * Number formatter\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-numbers/} for more info\r\n * @important\r\n */\nclass NumberFormatter extends Entity {\n  _setDefaults() {\n    // Defaults\n    this._setDefault("negativeBase", 0);\n    this._setDefault("numberFormat", "#,###.#####");\n    this._setDefault("smallNumberThreshold", 1.00);\n    const bns = "_big_number_suffix_";\n    const sns = "_small_number_suffix_";\n    const bs = "_byte_suffix_";\n    this._setDefault("bigNumberPrefixes", [{\n      "number": 1e+3,\n      "suffix": this._t(bns + "3")\n    }, {\n      "number": 1e+6,\n      "suffix": this._t(bns + "6")\n    }, {\n      "number": 1e+9,\n      "suffix": this._t(bns + "9")\n    }, {\n      "number": 1e+12,\n      "suffix": this._t(bns + "12")\n    }, {\n      "number": 1e+15,\n      "suffix": this._t(bns + "15")\n    }, {\n      "number": 1e+18,\n      "suffix": this._t(bns + "18")\n    }, {\n      "number": 1e+21,\n      "suffix": this._t(bns + "21")\n    }, {\n      "number": 1e+24,\n      "suffix": this._t(bns + "24")\n    }]);\n    this._setDefault("smallNumberPrefixes", [{\n      "number": 1e-24,\n      "suffix": this._t(sns + "24")\n    }, {\n      "number": 1e-21,\n      "suffix": this._t(sns + "21")\n    }, {\n      "number": 1e-18,\n      "suffix": this._t(sns + "18")\n    }, {\n      "number": 1e-15,\n      "suffix": this._t(sns + "15")\n    }, {\n      "number": 1e-12,\n      "suffix": this._t(sns + "12")\n    }, {\n      "number": 1e-9,\n      "suffix": this._t(sns + "9")\n    }, {\n      "number": 1e-6,\n      "suffix": this._t(sns + "6")\n    }, {\n      "number": 1e-3,\n      "suffix": this._t(sns + "3")\n    }]);\n    this._setDefault("bytePrefixes", [{\n      "number": 1,\n      suffix: this._t(bs + "B")\n    }, {\n      "number": 1024,\n      suffix: this._t(bs + "KB")\n    }, {\n      "number": 1048576,\n      suffix: this._t(bs + "MB")\n    }, {\n      "number": 1073741824,\n      suffix: this._t(bs + "GB")\n    }, {\n      "number": 1099511627776,\n      suffix: this._t(bs + "TB")\n    }, {\n      "number": 1125899906842624,\n      suffix: this._t(bs + "PB")\n    }]);\n    super._setDefaults();\n  }\n  _beforeChanged() {\n    super._beforeChanged();\n  }\n  /**\r\n   * Formats the number according to specific format.\r\n   *\r\n   * @param value   Value to format\r\n   * @param format  Format to apply\r\n   * @return Formatted number\r\n   */\n  format(value, format, precision) {\n    // no format passed in or "Number"\n    if (format == null || Type_isString(format) && format.toLowerCase() === "number") {\n      format = this.get("numberFormat", "");\n    }\n    // Init return value\n    let formatted;\n    // Cast to number just in case\n    // TODO: maybe use better casting\n    let source = Number(value);\n    // Is it a built-in format or Intl.NumberFormatOptions\n    if (Type_isObject(format)) {\n      try {\n        if (this.get("intlLocales")) {\n          return new Intl.NumberFormat(this.get("intlLocales"), format).format(source);\n        } else {\n          return new Intl.NumberFormat(undefined, format).format(source);\n        }\n      } catch (e) {\n        return "Invalid";\n      }\n    } else {\n      // Clean format\n      format = cleanFormat(format);\n      // Get format info (it will also deal with parser caching)\n      let info = this.parseFormat(format, this._root.language);\n      // format and replace the number\n      let details;\n      if (source > this.get("negativeBase")) {\n        details = info.positive;\n      } else if (source < this.get("negativeBase")) {\n        details = info.negative;\n      } else {\n        details = info.zero;\n      }\n      // Adjust precision\n      if (precision != null && !details.mod) {\n        details = Object_copy(details);\n        details.decimals.active = source == 0 ? 0 : precision;\n      }\n      // Format\n      formatted = details.template.split(PLACEHOLDER).join(this.applyFormat(source, details));\n    }\n    if (this.get("forceLTR") === true) {\n      formatted = "‎" + formatted;\n    }\n    return formatted;\n  }\n  /**\r\n   * Parses supplied format into structured object which can be used to format\r\n   * the number.\r\n   *\r\n   * @param format Format string, i.e. "#,###.00"\r\n   * @param language Language\r\n   * @ignore\r\n   */\n  parseFormat(format, language) {\n    // Check cache\n    // TODO\n    // let cached = this.getCache(format);\n    // if (cached != null) {\n    // \treturn cached;\n    // }\n    const thousandSeparator = language.translateEmpty("_thousandSeparator");\n    const decimalSeparator = language.translateEmpty("_decimalSeparator");\n    // init format parse info holder\n    let info = {\n      "positive": {\n        "thousands": {\n          "active": -1,\n          "passive": -1,\n          "interval": -1,\n          "separator": thousandSeparator\n        },\n        "decimals": {\n          "active": -1,\n          "passive": -1,\n          "separator": decimalSeparator\n        },\n        "template": "",\n        "source": "",\n        "parsed": false\n      },\n      "negative": {\n        "thousands": {\n          "active": -1,\n          "passive": -1,\n          "interval": -1,\n          "separator": thousandSeparator\n        },\n        "decimals": {\n          "active": -1,\n          "passive": -1,\n          "separator": decimalSeparator\n        },\n        "template": "",\n        "source": "",\n        "parsed": false\n      },\n      "zero": {\n        "thousands": {\n          "active": -1,\n          "passive": -1,\n          "interval": -1,\n          "separator": thousandSeparator\n        },\n        "decimals": {\n          "active": -1,\n          "passive": -1,\n          "separator": decimalSeparator\n        },\n        "template": "",\n        "source": "",\n        "parsed": false\n      }\n    };\n    // Escape double vertical bars (that mean display one vertical bar)\n    format = format.replace("||", PLACEHOLDER2);\n    // Split it up and deal with different formats\n    let parts = format.split("|");\n    info.positive.source = parts[0];\n    if (typeof parts[2] === "undefined") {\n      info.zero = info.positive;\n    } else {\n      info.zero.source = parts[2];\n    }\n    if (typeof parts[1] === "undefined") {\n      info.negative = info.positive;\n    } else {\n      info.negative.source = parts[1];\n    }\n    // Parse each\n    Object_each(info, (_part, item) => {\n      // Already parsed\n      if (item.parsed) {\n        return;\n      }\n      // Check cached\n      // TODO\n      // if (typeof this.getCache(item.source) !== "undefined") {\n      // \tinfo[part] = this.getCache(item.source);\n      // \treturn;\n      // }\n      // Begin parsing\n      let partFormat = item.source;\n      // Just "Number"?\n      if (partFormat.toLowerCase() === "number") {\n        partFormat = this.get("numberFormat", "#,###.#####");\n      }\n      // Let TextFormatter split into chunks\n      let chunks = TextFormatter.chunk(partFormat, true);\n      for (let i = 0; i < chunks.length; i++) {\n        let chunk = chunks[i];\n        // replace back double vertical bar\n        chunk.text = chunk.text.replace(PLACEHOLDER2, "|");\n        if (chunk.type === "value") {\n          // Parse format\n          // Look for codes\n          let matches = chunk.text.match(/[#0.,]+[ ]?[abespABESP%!]?[abespABESP‰!]?/);\n          if (matches) {\n            if (matches === null || matches[0] === "") {\n              // no codes here - assume string\n              // nothing to do here\n              item.template += chunk.text;\n            } else {\n              // look for the format modifiers at the end\n              let mods = matches[0].match(/[abespABESP%‰!]{2}|[abespABESP%‰]{1}$/);\n              if (mods) {\n                item.mod = mods[0].toLowerCase();\n                item.modSpacing = matches[0].match(/[ ]{1}[abespABESP%‰!]{1}$/) ? true : false;\n              }\n              // break the format up\n              let a = matches[0].split(".");\n              // Deal with thousands\n              if (a[0] === "") {\n                // No directives for thousands\n                // Leave default settings (no formatting)\n              } else {\n                // Counts\n                item.thousands.active = (a[0].match(/0/g) || []).length;\n                item.thousands.passive = (a[0].match(/\\#/g) || []).length + item.thousands.active;\n                // Separator interval\n                let b = a[0].split(",");\n                if (b.length === 1) {\n                  // No thousands separators\n                  // Do nothing\n                } else {\n                  // Use length fo the last chunk as thousands length\n                  item.thousands.interval = (b.pop() || "").length;\n                  if (item.thousands.interval === 0) {\n                    item.thousands.interval = -1;\n                  }\n                }\n              }\n              // Deal with decimals\n              if (typeof a[1] === "undefined") {\n                // No directives for decimals\n                // Leave at defaults (no formatting)\n              } else {\n                // Counts\n                item.decimals.active = (a[1].match(/0/g) || []).length;\n                item.decimals.passive = (a[1].match(/\\#/g) || []).length + item.decimals.active;\n              }\n              // Add special code to template\n              item.template += chunk.text.split(matches[0]).join(PLACEHOLDER);\n            }\n          }\n        } else {\n          // Quoted string - take it as it is\n          item.template += chunk.text;\n        }\n      }\n      // Apply style formatting\n      //item.template = getTextFormatter().format(item.template, this.outputFormat);\n      // Save cache\n      // TODO\n      //this.setCache(item.source, item);\n      // Mark this as parsed\n      item.parsed = true;\n    });\n    // Save cache (the whole thing)\n    // TODO\n    //this.setCache(format, info);\n    return info;\n  }\n  /**\r\n   * Applies parsed format to a numeric value.\r\n   *\r\n   * @param value    Value\r\n   * @param details  Parsed format as returned by parseFormat()\r\n   * @return Formatted number\r\n   * @ignore\r\n   */\n  applyFormat(value, details) {\n    // Use absolute values\n    let negative = value < 0;\n    value = Math.abs(value);\n    // Recalculate according to modifier\n    let prefix = "",\n      suffix = "";\n    let mods = details.mod ? details.mod.split("") : [];\n    if (mods.indexOf("b") !== -1) {\n      let a = this.applyPrefix(value, this.get("bytePrefixes"), mods.indexOf("!") !== -1);\n      value = a[0];\n      prefix = a[1];\n      suffix = a[2];\n      if (details.modSpacing) {\n        suffix = " " + suffix;\n      }\n    } else if (mods.indexOf("a") !== -1) {\n      let a = this.applyPrefix(value, value < this.get("smallNumberThreshold") ? this.get("smallNumberPrefixes") : this.get("bigNumberPrefixes"), mods.indexOf("!") !== -1);\n      value = a[0];\n      prefix = a[1];\n      suffix = a[2];\n      if (details.modSpacing) {\n        suffix = " " + suffix;\n      }\n    } else if (mods.indexOf("p") !== -1) {\n      let ol = Math.min(value.toString().length + 2, 21);\n      //value *= 100;\n      value = parseFloat(value.toPrecision(ol));\n      prefix = this._root.language.translate("_percentPrefix");\n      suffix = this._root.language.translate("_percentSuffix");\n      if (prefix == "" && suffix == "") {\n        suffix = "%";\n      }\n    } else if (mods.indexOf("%") !== -1) {\n      let ol = Math.min(value.toString().length + 2, 21);\n      value *= 100;\n      value = parseFloat(value.toPrecision(ol));\n      suffix = "%";\n    } else if (mods.indexOf("‰") !== -1) {\n      let ol = Math.min(value.toString().length + 3, 21);\n      value *= 1000;\n      value = parseFloat(value.toPrecision(ol));\n      suffix = "‰";\n    }\n    // Round to passive\n    if (mods.indexOf("e") !== -1) {\n      // convert the value to exponential\n      let exp;\n      if (details.decimals.passive >= 0) {\n        exp = value.toExponential(details.decimals.passive).split("e");\n      } else {\n        exp = value.toExponential().split("e");\n      }\n      value = Number(exp[0]);\n      suffix = "e" + exp[1];\n      if (details.modSpacing) {\n        suffix = " " + suffix;\n      }\n    } else if (details.decimals.passive === 0) {\n      value = Math.round(value);\n    } else if (details.decimals.passive > 0) {\n      let d = Math.pow(10, details.decimals.passive);\n      value = Math.round(value * d) / d;\n    }\n    // Init return value\n    let res = "";\n    // Calc integer and decimal parts\n    let a = numberToString(value).split(".");\n    // Format integers\n    let ints = a[0];\n    // Pad integers to active length\n    if (ints.length < details.thousands.active) {\n      ints = Array(details.thousands.active - ints.length + 1).join("0") + ints;\n    }\n    // Insert thousands separators\n    if (details.thousands.interval > 0) {\n      let ip = [];\n      let intsr = ints.split("").reverse().join("");\n      for (let i = 0, len = ints.length; i <= len; i += details.thousands.interval) {\n        let c = intsr.substr(i, details.thousands.interval).split("").reverse().join("");\n        if (c !== "") {\n          ip.unshift(c);\n        }\n      }\n      ints = ip.join(details.thousands.separator);\n    }\n    // Add integers\n    res += ints;\n    // Add decimals\n    if (a.length === 1) {\n      a.push("");\n    }\n    let decs = a[1];\n    // Fill zeros?\n    if (decs.length < details.decimals.active) {\n      decs += Array(details.decimals.active - decs.length + 1).join("0");\n    }\n    if (decs !== "") {\n      res += details.decimals.separator + decs;\n    }\n    // Can\'t have empty return value\n    if (res === "") {\n      res = "0";\n    }\n    // Add minus sign back\n    if (value !== 0 && negative && mods.indexOf("s") === -1) {\n      res = "-" + res;\n    }\n    // Add suffixes/prefixes\n    if (prefix) {\n      res = prefix + res;\n    }\n    if (suffix) {\n      res += suffix;\n    }\n    return res;\n  }\n  applyPrefix(value, prefixes, force = false) {\n    let newvalue = value;\n    let prefix = "";\n    let suffix = "";\n    let applied = false;\n    let k = 1;\n    for (let i = 0, len = prefixes.length; i < len; i++) {\n      if (prefixes[i].number <= value) {\n        if (prefixes[i].number === 0) {\n          newvalue = 0;\n        } else {\n          newvalue = value / prefixes[i].number;\n          k = prefixes[i].number;\n        }\n        prefix = prefixes[i].prefix;\n        suffix = prefixes[i].suffix;\n        applied = true;\n      }\n    }\n    if (!applied && force && prefixes.length && value != 0) {\n      // Prefix was not applied. Use the first prefix.\n      newvalue = value / prefixes[0].number;\n      prefix = prefixes[0].prefix;\n      suffix = prefixes[0].suffix;\n      applied = true;\n    }\n    if (applied) {\n      newvalue = parseFloat(newvalue.toPrecision(Math.min(k.toString().length + Math.floor(newvalue).toString().replace(/[^0-9]*/g, "").length, 21)));\n    }\n    return [newvalue, prefix, suffix];\n  }\n  /**\r\n   * Replaces brackets with temporary placeholders.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Escaped text\r\n   */\n  escape(text) {\n    return text.replace("||", PLACEHOLDER2);\n  }\n  /**\r\n   * Replaces placeholders back to brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Escaped text\r\n   * @return Unescaped text\r\n   */\n  unescape(text) {\n    return text.replace(PLACEHOLDER2, "|");\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Timezone.js\nfunction parseDate(timezone, date) {\n  let year = 0;\n  let month = 0;\n  let day = 1;\n  let hour = 0;\n  let minute = 0;\n  let second = 0;\n  let millisecond = 0;\n  let weekday = 0;\n  timezone.formatToParts(date).forEach(x => {\n    switch (x.type) {\n      case "year":\n        year = +x.value;\n        break;\n      case "month":\n        month = +x.value - 1;\n        break;\n      case "day":\n        day = +x.value;\n        break;\n      case "hour":\n        hour = +x.value;\n        break;\n      case "minute":\n        minute = +x.value;\n        break;\n      case "second":\n        second = +x.value;\n        break;\n      case "fractionalSecond":\n        millisecond = +x.value;\n        break;\n      case "weekday":\n        switch (x.value) {\n          case "Sun":\n            weekday = 0;\n            break;\n          case "Mon":\n            weekday = 1;\n            break;\n          case "Tue":\n            weekday = 2;\n            break;\n          case "Wed":\n            weekday = 3;\n            break;\n          case "Thu":\n            weekday = 4;\n            break;\n          case "Fri":\n            weekday = 5;\n            break;\n          case "Sat":\n            weekday = 6;\n            break;\n        }\n    }\n  });\n  if (hour === 24) {\n    hour = 0;\n  }\n  return {\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    weekday\n  };\n}\nfunction toUTCDate(timezone, date) {\n  const {\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond\n  } = parseDate(timezone, date);\n  return Date.UTC(year, month, day, hour, minute, second, millisecond);\n}\nclass Timezone {\n  constructor(timezone, isReal) {\n    Object.defineProperty(this, "_utc", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_dtf", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "name", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    if (!isReal) {\n      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");\n    }\n    this.name = timezone;\n    this._utc = new Intl.DateTimeFormat("UTC", {\n      hour12: false,\n      timeZone: "UTC",\n      year: "numeric",\n      month: "2-digit",\n      day: "2-digit",\n      hour: "2-digit",\n      minute: "2-digit",\n      second: "2-digit",\n      weekday: "short",\n      fractionalSecondDigits: 3\n    });\n    this._dtf = new Intl.DateTimeFormat("UTC", {\n      hour12: false,\n      timeZone: timezone,\n      year: "numeric",\n      month: "2-digit",\n      day: "2-digit",\n      hour: "2-digit",\n      minute: "2-digit",\n      second: "2-digit",\n      weekday: "short",\n      fractionalSecondDigits: 3\n    });\n  }\n  /**\r\n   * Use this method to create an instance of this class.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info\r\n   * @param   timezone  IANA timezone\r\n   * @return            Instantiated object\r\n   */\n  static new(timezone) {\n    return new this(timezone, true);\n  }\n  convertLocal(date) {\n    const offset = this.offsetUTC(date);\n    const userOffset = date.getTimezoneOffset();\n    const output = new Date(date);\n    output.setUTCMinutes(output.getUTCMinutes() - (offset - userOffset));\n    const newUserOffset = output.getTimezoneOffset();\n    if (userOffset != newUserOffset) {\n      output.setUTCMinutes(output.getUTCMinutes() + newUserOffset - userOffset);\n    }\n    return output;\n  }\n  offsetUTC(date) {\n    const utc = toUTCDate(this._utc, date);\n    const dtf = toUTCDate(this._dtf, date);\n    return (utc - dtf) / 60000;\n  }\n  parseDate(date) {\n    return parseDate(this._dtf, date);\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/DateFormatter.js\n\n\n\n\n\n/**\r\n * Date formatter class.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/} for more info\r\n * @important\r\n */\nclass DateFormatter extends Entity {\n  _setDefaults() {\n    // Defaults\n    this._setDefault("capitalize", true);\n    this._setDefault("dateFormat", "yyyy-MM-dd");\n    super._setDefaults();\n  }\n  _beforeChanged() {\n    super._beforeChanged();\n  }\n  /**\r\n   * Formats a source `Date` object into string format\r\n   * @param   source          inpout date\r\n   * @param   format          Output format\r\n   * @param   ignoreTimezone  Ignore timezone?\r\n   * @return                  Formatted date\r\n   */\n  format(source, format, ignoreTimezone = false) {\n    // Locale?\n    // TODO\n    // No format passed in or it\'s empty\n    if (typeof format === "undefined" || format === "") {\n      format = this.get("dateFormat", "yyyy-MM-dd");\n    }\n    // Init return value\n    let formatted;\n    // Cast?\n    // TODO: decide if we need to cast\n    let date = source;\n    // Is it a built-in format or Intl.DateTimeFormat\n    if (Type_isObject(format)) {\n      try {\n        const locales = this.get("intlLocales");\n        if (locales) {\n          return new Intl.DateTimeFormat(locales, format).format(date);\n        } else {\n          return new Intl.DateTimeFormat(undefined, format).format(date);\n        }\n      } catch (e) {\n        return "Invalid";\n      }\n    }\n    // get format info (it will also deal with parser caching)\n    let info = this.parseFormat(format);\n    // Should we apply custom time zone?\n    const timezone = this._root.timezone;\n    if (timezone && !this._root.utc && !ignoreTimezone) {\n      date = timezone.convertLocal(date);\n    }\n    // Check if it\'s a valid date\n    if (!Type_isNumber(date.getTime())) {\n      // TODO translation\n      //return this._t("Invalid date");\n      return "Invalid date";\n    }\n    // Apply format\n    formatted = this.applyFormat(date, info, ignoreTimezone);\n    // Capitalize\n    if (this.get("capitalize")) {\n      formatted = formatted.replace(/^.{1}/, formatted.substr(0, 1).toUpperCase());\n    }\n    // We\'re done\n    return formatted;\n  }\n  /**\r\n   * Applies format to Date.\r\n   *\r\n   * @param date      Date object\r\n   * @param info      Parsed format information\r\n   * @return Formatted date string\r\n   */\n  applyFormat(date, info, ignoreTimezone = false) {\n    // Init return value\n    let res = info.template;\n    // Get values\n    let fullYear,\n      month,\n      weekday,\n      day,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      timestamp = date.getTime();\n    if (this._root.utc && !ignoreTimezone) {\n      fullYear = date.getUTCFullYear();\n      month = date.getUTCMonth();\n      weekday = date.getUTCDay();\n      day = date.getUTCDate();\n      hours = date.getUTCHours();\n      minutes = date.getUTCMinutes();\n      seconds = date.getUTCSeconds();\n      milliseconds = date.getUTCMilliseconds();\n    } else {\n      fullYear = date.getFullYear();\n      month = date.getMonth();\n      weekday = date.getDay();\n      day = date.getDate();\n      hours = date.getHours();\n      minutes = date.getMinutes();\n      seconds = date.getSeconds();\n      milliseconds = date.getMilliseconds();\n    }\n    // Go through each part and format/replace it in template\n    for (let i = 0, len = info.parts.length; i < len; i++) {\n      let value = "";\n      switch (info.parts[i]) {\n        case "G":\n          value = this._t(fullYear < 0 ? "_era_bc" : "_era_ad");\n          break;\n        case "yyyy":\n          value = Math.abs(fullYear).toString();\n          if (fullYear < 0) {\n            value += this._t("_era_bc");\n          }\n          break;\n        case "yyy":\n        case "yy":\n        case "y":\n          value = Math.abs(fullYear).toString().substr(-info.parts[i].length);\n          if (fullYear < 0) {\n            value += this._t("_era_bc");\n          }\n          break;\n        case "YYYY":\n        case "YYY":\n        case "YY":\n        case "Y":\n          let year = getWeekYear(date, this._root.utc);\n          if (info.parts[i] == "YYYY") {\n            value = Math.abs(year).toString();\n          } else {\n            value = Math.abs(year).toString().substr(-info.parts[i].length);\n          }\n          if (year < 0) {\n            value += this._t("_era_bc");\n          }\n          break;\n        case "u":\n          // @todo\n          break;\n        case "q":\n          value = "" + Math.ceil((date.getMonth() + 1) / 3);\n          break;\n        case "MMMMM":\n          value = this._t(this._getMonth(month)).substr(0, 1);\n          break;\n        case "MMMM":\n          value = this._t(this._getMonth(month));\n          break;\n        case "MMM":\n          value = this._t(this._getShortMonth(month));\n          break;\n        case "MM":\n          value = padString(month + 1, 2, "0");\n          break;\n        case "M":\n          value = (month + 1).toString();\n          break;\n        case "ww":\n          value = padString(getWeek(date, this._root.utc), 2, "0");\n          break;\n        case "w":\n          value = getWeek(date, this._root.utc).toString();\n          break;\n        case "W":\n          value = getMonthWeek(date, this._root.utc).toString();\n          break;\n        case "dd":\n          value = padString(day, 2, "0");\n          break;\n        case "d":\n          value = day.toString();\n          break;\n        case "DD":\n        case "DDD":\n          value = padString(getYearDay(date, this._root.utc).toString(), info.parts[i].length, "0");\n          break;\n        case "D":\n          value = getYearDay(date, this._root.utc).toString();\n          break;\n        case "F":\n          // @todo\n          break;\n        case "g":\n          // @todo\n          break;\n        case "t":\n          value = this._root.language.translateFunc("_dateOrd").call(this, day);\n          break;\n        case "E":\n          value = (weekday || 7).toString();\n          break;\n        case "EE":\n          value = padString((weekday || 7).toString(), 2, "0");\n          break;\n        case "EEE":\n        case "eee":\n          value = this._t(this._getShortWeekday(weekday));\n          break;\n        case "EEEE":\n        case "eeee":\n          value = this._t(this._getWeekday(weekday));\n          break;\n        case "EEEEE":\n        case "eeeee":\n          value = this._t(this._getShortWeekday(weekday)).substr(0, 1);\n          break;\n        case "e":\n        case "ee":\n          value = (weekday - (this._root.locale.firstDayOfWeek || 1) + 1).toString();\n          if (info.parts[i] == "ee") {\n            value = padString(value, 2, "0");\n          }\n          break;\n        case "a":\n          if (hours >= 12) {\n            value = this._t("PM");\n          } else {\n            value = this._t("AM");\n          }\n          break;\n        case "aa":\n          if (hours >= 12) {\n            value = this._t("P.M.");\n          } else {\n            value = this._t("A.M.");\n          }\n          break;\n        case "aaa":\n          if (hours >= 12) {\n            value = this._t("P");\n          } else {\n            value = this._t("A");\n          }\n          break;\n        case "h":\n          value = get12Hours(hours).toString();\n          break;\n        case "hh":\n          value = padString(get12Hours(hours), 2, "0");\n          break;\n        case "H":\n          value = hours.toString();\n          break;\n        case "HH":\n          value = padString(hours, 2, "0");\n          break;\n        case "K":\n          value = get12Hours(hours, 0).toString();\n          break;\n        case "KK":\n          value = padString(get12Hours(hours, 0), 2, "0");\n          break;\n        case "k":\n          value = (hours + 1).toString();\n          break;\n        case "kk":\n          value = padString(hours + 1, 2, "0");\n          break;\n        case "m":\n          value = minutes.toString();\n          break;\n        case "mm":\n          value = padString(minutes, 2, "0");\n          break;\n        case "s":\n          value = seconds.toString();\n          break;\n        case "ss":\n          value = padString(seconds, 2, "0");\n          break;\n        case "S":\n        case "SS":\n        case "SSS":\n          value = Math.round(milliseconds / 1000 * Math.pow(10, info.parts[i].length)).toString();\n          break;\n        case "x":\n          value = timestamp.toString();\n          break;\n        case "n":\n        case "nn":\n        case "nnn":\n          value = padString(milliseconds, info.parts[i].length, "0");\n          break;\n        case "z":\n          value = getTimeZone(date, false, false, this._root.utc, this._root.timezone ? this._root.timezone.name : undefined).replace(/[+-]+[0-9]+$/, "");\n          break;\n        case "zz":\n          value = getTimeZone(date, true, false, this._root.utc, this._root.timezone ? this._root.timezone.name : undefined);\n          break;\n        case "zzz":\n          value = getTimeZone(date, false, true, this._root.utc, this._root.timezone ? this._root.timezone.name : undefined).replace(/[+-]+[0-9]+$/, "");\n          break;\n        case "zzzz":\n          value = getTimeZone(date, true, true, this._root.utc, this._root.timezone ? this._root.timezone.name : undefined);\n          break;\n        case "Z":\n        case "ZZ":\n          let timezone = this._root.utc ? "UTC" : this._root.timezone;\n          if (timezone instanceof Timezone) {\n            timezone = timezone.name;\n          }\n          const offset = timezone ? getTimezoneOffset(timezone) : date.getTimezoneOffset();\n          let tz = Math.abs(offset) / 60;\n          let tzh = Math.floor(tz);\n          let tzm = tz * 60 - tzh * 60;\n          if (this._root.utc) {\n            tzh = 0;\n            tzm = 0;\n          }\n          if (info.parts[i] == "Z") {\n            value = "GMT";\n            value += offset > 0 ? "-" : "+";\n            value += padString(tzh, 2) + ":" + padString(tzm, 2);\n          } else {\n            value = offset > 0 ? "-" : "+";\n            value += padString(tzh, 2) + padString(tzm, 2);\n          }\n          break;\n        case "i":\n          value = date.toISOString();\n          break;\n        case "I":\n          value = date.toUTCString();\n          break;\n      }\n      res = res.replace(PLACEHOLDER, value);\n    }\n    return res;\n  }\n  /**\r\n   * Parses format into structured infromation.\r\n   *\r\n   * @param format Format template\r\n   */\n  parseFormat(format) {\n    // Check cache\n    // TODO: implement caching of the parsed format\n    // Init format parse info holder\n    let info = {\n      "template": "",\n      "parts": []\n    };\n    // Let TextFormatter split into chunks\n    let chunks = TextFormatter.chunk(format, true);\n    for (let i = 0; i < chunks.length; i++) {\n      let chunk = chunks[i];\n      if (chunk.type === "value") {\n        // Just "Date"?\n        if (chunk.text.match(/^date$/i)) {\n          let dateFormat = this.get("dateFormat", "yyyy-MM-dd");\n          if (!Type_isString(dateFormat)) {\n            dateFormat = "yyyy-MM-dd";\n          }\n          chunk.text = dateFormat;\n        }\n        // Find all possible parts\n        let matches = chunk.text.match(/G|yyyy|yyy|yy|y|YYYY|YYY|YY|Y|u|q|MMMMM|MMMM|MMM|MM|M|ww|w|W|dd|d|DDD|DD|D|F|g|EEEEE|EEEE|EEE|EE|E|eeeee|eeee|eee|ee|e|aaa|aa|a|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|SSS|SS|S|A|zzzz|zzz|zz|z|ZZ|Z|t|x|nnn|nn|n|i|I/g);\n        // Found?\n        if (matches) {\n          // Populate template\n          for (let x = 0; x < matches.length; x++) {\n            info.parts.push(matches[x]);\n            chunk.text = chunk.text.replace(matches[x], PLACEHOLDER);\n          }\n        }\n      }\n      // Apply to template\n      info.template += chunk.text;\n    }\n    // Save cache\n    // TODO\n    return info;\n  }\n  _months() {\n    return ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];\n  }\n  _getMonth(index) {\n    return this._months()[index];\n  }\n  _shortMonths() {\n    return ["Jan", "Feb", "Mar", "Apr", "May(short)", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];\n  }\n  _getShortMonth(index) {\n    return this._shortMonths()[index];\n  }\n  _weekdays() {\n    return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];\n  }\n  _getWeekday(index) {\n    return this._weekdays()[index];\n  }\n  _shortWeekdays() {\n    return ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];\n  }\n  _getShortWeekday(index) {\n    return this._shortWeekdays()[index];\n  }\n  parse(source, format) {\n    // Is it already a Date\n    if (source instanceof Date) {\n      return source;\n    }\n    // Is it a numeric timestamp\n    if (Type_isNumber(source)) {\n      return new Date(source);\n    }\n    // Are we parsing a timestamp?\n    if (format == "x") {\n      return new Date(parseInt(source));\n    }\n    // No? Let\'s check if it\'s string, and try converting to it if nec\n    if (!Type_isString(source)) {\n      source = source.toString();\n    }\n    // Init return value\n    let res;\n    // Init RegEx for parsing\n    let reg = "";\n    // Clean format\n    format = cleanFormat(format);\n    // Clip format to length of the source string\n    format = format.substr(0, source.length);\n    // Parse format\n    let info = this.parseFormat(format);\n    // Init parsed items holder\n    let parsedIndexes = {\n      "year": -1,\n      "year3": -1,\n      "year2": -1,\n      "year1": -1,\n      "month": -1,\n      "monthShort": -1,\n      "monthLong": -1,\n      "weekdayShort": -1,\n      "weekdayLong": -1,\n      "day": -1,\n      "yearDay": -1,\n      "week": -1,\n      "hourBase0": -1,\n      "hour12Base0": -1,\n      "hourBase1": -1,\n      "hour12Base1": -1,\n      "minute": -1,\n      "second": -1,\n      "millisecond": -1,\n      "millisecondDigits": -1,\n      "am": -1,\n      "zone": -1,\n      "timestamp": -1,\n      "iso": -1\n    };\n    // Init values\n    let resValues = {\n      "year": 1970,\n      "month": 0,\n      "day": 1,\n      "hour": 0,\n      "minute": 0,\n      "second": 0,\n      "millisecond": 0,\n      "timestamp": null,\n      "offset": 0,\n      "utc": this._root.utc\n    };\n    // Index adjuster\n    let indexAdjust = 0;\n    let index = 0;\n    // Iterate through all of the parts\n    for (let i = 0; i < info.parts.length; i++) {\n      // Set current match index\n      index = i + indexAdjust + 1;\n      switch (info.parts[i]) {\n        case "yyyy":\n        case "YYYY":\n          reg += "([0-9]{4})";\n          parsedIndexes.year = index;\n          break;\n        case "yyy":\n        case "YYY":\n          reg += "([0-9]{3})";\n          parsedIndexes.year3 = index;\n          break;\n        case "yy":\n        case "YY":\n          reg += "([0-9]{2})";\n          parsedIndexes.year2 = index;\n          break;\n        case "y":\n        case "Y":\n          reg += "([0-9]{1})";\n          parsedIndexes.year1 = index;\n          break;\n        case "MMMM":\n          reg += "(" + this.getStringList(this._months()).join("|") + ")";\n          parsedIndexes.monthLong = index;\n          break;\n        case "MMM":\n          reg += "(" + this.getStringList(this._shortMonths()).join("|") + ")";\n          parsedIndexes.monthShort = index;\n          break;\n        case "MM":\n        case "M":\n          reg += "([0-9]{2}|[0-9]{1})";\n          parsedIndexes.month = index;\n          break;\n        case "ww":\n        case "w":\n          reg += "([0-9]{2}|[0-9]{1})";\n          parsedIndexes.week = index;\n          break;\n        case "dd":\n        case "d":\n          reg += "([0-9]{2}|[0-9]{1})";\n          parsedIndexes.day = index;\n          break;\n        case "DDD":\n        case "DD":\n        case "D":\n          reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";\n          parsedIndexes.yearDay = index;\n          break;\n        case "dddd":\n          reg += "(" + this.getStringList(this._weekdays()).join("|") + ")";\n          parsedIndexes.weekdayLong = index;\n          break;\n        case "ddd":\n          reg += "(" + this.getStringList(this._shortWeekdays()).join("|") + ")";\n          parsedIndexes.weekdayShort = index;\n          break;\n        case "aaa":\n        case "aa":\n        case "a":\n          // TODO: fix (escape regex)\n          reg += "(" + this.getStringList(["AM", "PM", "A\\.M\\.", "P\\.M\\.", "A", "P"]).join("|") + ")";\n          parsedIndexes.am = index;\n          break;\n        case "hh":\n        case "h":\n          reg += "([0-9]{2}|[0-9]{1})";\n          parsedIndexes.hour12Base1 = index;\n          break;\n        case "HH":\n        case "H":\n          reg += "([0-9]{2}|[0-9]{1})";\n          parsedIndexes.hourBase0 = index;\n          break;\n        case "KK":\n        case "K":\n          reg += "([0-9]{2}|[0-9]{1})";\n          parsedIndexes.hour12Base0 = index;\n          break;\n        case "kk":\n        case "k":\n          reg += "([0-9]{2}|[0-9]{1})";\n          parsedIndexes.hourBase1 = index;\n          break;\n        case "mm":\n        case "m":\n          reg += "([0-9]{2}|[0-9]{1})";\n          parsedIndexes.minute = index;\n          break;\n        case "ss":\n        case "s":\n          reg += "([0-9]{2}|[0-9]{1})";\n          parsedIndexes.second = index;\n          break;\n        case "SSS":\n        case "SS":\n        case "S":\n          reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";\n          parsedIndexes.millisecond = index;\n          parsedIndexes.millisecondDigits = info.parts[i].length;\n          break;\n        case "nnn":\n        case "nn":\n        case "n":\n          reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";\n          parsedIndexes.millisecond = index;\n          break;\n        case "x":\n          reg += "([0-9]{1,})";\n          parsedIndexes.timestamp = index;\n          break;\n        case "Z":\n          reg += "GMT([-+]+[0-9]{2}:[0-9]{2})";\n          parsedIndexes.zone = index;\n          break;\n        case "ZZ":\n          reg += "([\\\\-+]+[0-9]{2}[0-9]{2})";\n          parsedIndexes.zone = index;\n          break;\n        case "i":\n          reg += "([0-9]{4})-?([0-9]{2})-?([0-9]{2})T?([0-9]{2}):?([0-9]{2}):?([0-9]{2})\\\\.?([0-9]{0,3})([zZ]|[+\\\\-][0-9]{2}:?[0-9]{2}|$)";\n          parsedIndexes.iso = index;\n          indexAdjust += 7;\n          break;\n        case "G":\n        case "YYYY":\n        case "YYY":\n        case "YY":\n        case "Y":\n        case "MMMMM":\n        case "W":\n        case "EEEEE":\n        case "EEEE":\n        case "EEE":\n        case "EE":\n        case "E":\n        case "eeeee":\n        case "eeee":\n        case "eee":\n        case "ee":\n        case "e":\n        case "zzzz":\n        case "zzz":\n        case "zz":\n        case "z":\n        case "t":\n          // Ignore\n          indexAdjust--;\n          break;\n      }\n      reg += "[^0-9]*";\n    }\n    // Try matching\n    let regex = new RegExp(reg);\n    let matches = source.match(regex);\n    if (matches) {\n      // Populate the date object\n      // Full year\n      if (parsedIndexes.year > -1) {\n        resValues.year = parseInt(matches[parsedIndexes.year]);\n      }\n      // 3-digit year\n      if (parsedIndexes.year3 > -1) {\n        let val = parseInt(matches[parsedIndexes.year3]);\n        val += 1000;\n        resValues.year = val;\n      }\n      // 2-digit year\n      if (parsedIndexes.year2 > -1) {\n        let val = parseInt(matches[parsedIndexes.year2]);\n        if (val > 50) {\n          val += 1000;\n        } else {\n          val += 2000;\n        }\n        resValues.year = val;\n      }\n      // 1-digit year\n      if (parsedIndexes.year1 > -1) {\n        let val = parseInt(matches[parsedIndexes.year1]);\n        val = Math.floor(new Date().getFullYear() / 10) * 10 + val;\n        resValues.year = val;\n      }\n      // Full month\n      if (parsedIndexes.monthLong > -1) {\n        resValues.month = this.resolveMonth(matches[parsedIndexes.monthLong]);\n      }\n      // Short month\n      if (parsedIndexes.monthShort > -1) {\n        resValues.month = this.resolveShortMonth(matches[parsedIndexes.monthShort]);\n      }\n      // Numeric month\n      if (parsedIndexes.month > -1) {\n        resValues.month = parseInt(matches[parsedIndexes.month]) - 1;\n      }\n      // Weekday\n      // @todo\n      // Week\n      if (parsedIndexes.week > -1 && parsedIndexes.day === -1) {\n        // We parse weeks ONLY if day is not explicitly set\n        // TODO: this needs work\n        // (but maybe later - I can hardly imagine anyone passing their dates in weeks)\n        resValues.month = 0;\n        resValues.day = getDayFromWeek(parseInt(matches[parsedIndexes.week]), resValues.year, 1, this._root.utc);\n      }\n      // Day\n      if (parsedIndexes.day > -1) {\n        resValues.day = parseInt(matches[parsedIndexes.day]);\n      }\n      // Year day\n      if (parsedIndexes.yearDay > -1) {\n        resValues.month = 0;\n        resValues.day = parseInt(matches[parsedIndexes.yearDay]);\n      }\n      // 24 Hour (0-23)\n      if (parsedIndexes.hourBase0 > -1) {\n        resValues.hour = parseInt(matches[parsedIndexes.hourBase0]);\n      }\n      // 24 Hour (1-24)\n      if (parsedIndexes.hourBase1 > -1) {\n        resValues.hour = parseInt(matches[parsedIndexes.hourBase1]) - 1;\n      }\n      // 12 Hour (0-11)\n      if (parsedIndexes.hour12Base0 > -1) {\n        let val = parseInt(matches[parsedIndexes.hour12Base0]);\n        if (val == 11) {\n          val = 0;\n        }\n        if (parsedIndexes.am > -1 && !this.isAm(matches[parsedIndexes.am])) {\n          val += 12;\n        }\n        resValues.hour = val;\n      }\n      // 12 Hour (1-12)\n      if (parsedIndexes.hour12Base1 > -1) {\n        let val = parseInt(matches[parsedIndexes.hour12Base1]);\n        if (val == 12) {\n          val = 0;\n        }\n        if (parsedIndexes.am > -1 && !this.isAm(matches[parsedIndexes.am])) {\n          val += 12;\n        }\n        resValues.hour = val;\n      }\n      // Minute\n      if (parsedIndexes.minute > -1) {\n        resValues.minute = parseInt(matches[parsedIndexes.minute]);\n      }\n      // Second\n      if (parsedIndexes.second > -1) {\n        resValues.second = parseInt(matches[parsedIndexes.second]);\n      }\n      // Millisecond\n      if (parsedIndexes.millisecond > -1) {\n        let val = parseInt(matches[parsedIndexes.millisecond]);\n        if (parsedIndexes.millisecondDigits == 2) {\n          val *= 10;\n        } else if (parsedIndexes.millisecondDigits == 1) {\n          val *= 100;\n        }\n        resValues.millisecond = val;\n      }\n      // Timestamp\n      if (parsedIndexes.timestamp > -1) {\n        resValues.timestamp = parseInt(matches[parsedIndexes.timestamp]);\n        const ts = new Date(resValues.timestamp);\n        resValues.year = ts.getUTCFullYear();\n        resValues.month = ts.getUTCMonth();\n        resValues.day = ts.getUTCDate();\n        resValues.hour = ts.getUTCHours();\n        resValues.minute = ts.getUTCMinutes();\n        resValues.second = ts.getUTCSeconds();\n        resValues.millisecond = ts.getUTCMilliseconds();\n      }\n      // Adjust time zone\n      if (parsedIndexes.zone > -1) {\n        resValues.offset = this.resolveTimezoneOffset(new Date(resValues.year, resValues.month, resValues.day), matches[parsedIndexes.zone]);\n      }\n      // ISO\n      if (parsedIndexes.iso > -1) {\n        resValues.year = Type_toNumber(matches[parsedIndexes.iso + 0]);\n        resValues.month = Type_toNumber(matches[parsedIndexes.iso + 1]) - 1;\n        resValues.day = Type_toNumber(matches[parsedIndexes.iso + 2]);\n        resValues.hour = Type_toNumber(matches[parsedIndexes.iso + 3]);\n        resValues.minute = Type_toNumber(matches[parsedIndexes.iso + 4]);\n        resValues.second = Type_toNumber(matches[parsedIndexes.iso + 5]);\n        resValues.millisecond = Type_toNumber(matches[parsedIndexes.iso + 6]);\n        if (matches[parsedIndexes.iso + 7] == "Z" || matches[parsedIndexes.iso + 7] == "z") {\n          resValues.utc = true;\n        } else if (matches[parsedIndexes.iso + 7] != "") {\n          resValues.offset = this.resolveTimezoneOffset(new Date(resValues.year, resValues.month, resValues.day), matches[parsedIndexes.iso + 7]);\n        }\n      }\n      // Create Date object\n      if (resValues.utc) {\n        res = new Date(Date.UTC(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute, resValues.second, resValues.millisecond));\n      } else {\n        res = new Date(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute + resValues.offset, resValues.second, resValues.millisecond);\n      }\n    } else {\n      // Didn\'t match anything\n      // Let\'s try dropping it into Date constructor and hope for the best\n      res = new Date(source);\n    }\n    return res;\n  }\n  resolveTimezoneOffset(date, zone) {\n    let value = zone.match(/([+\\-]?)([0-9]{2}):?([0-9]{2})/);\n    if (value) {\n      let match = zone.match(/([+\\-]?)([0-9]{2}):?([0-9]{2})/);\n      let dir = match[1];\n      let hour = match[2];\n      let minute = match[3];\n      let offset = parseInt(hour) * 60 + parseInt(minute);\n      // Adjust offset\n      // Making it negative does not seem to make sense, but it\'s right\n      // because of how JavaScript calculates GMT offsets\n      if (dir == "+") {\n        offset *= -1;\n      }\n      // Check the difference in offset\n      let originalOffset = (date || new Date()).getTimezoneOffset();\n      let diff = offset - originalOffset;\n      return diff;\n    }\n    return 0;\n  }\n  /**\r\n   * Resolves month name (i.e. "December") into a month number (11).\r\n   *\r\n   * @param value  Month name\r\n   * @return Month number\r\n   */\n  resolveMonth(value) {\n    // Let\'s try English first\n    let month = this._months().indexOf(value);\n    if (month > -1) {\n      return month;\n    }\n    // Try the translation\n    if (!this._root.language.isDefault()) {\n      month = this._root.language.translateAll(this._months()).indexOf(value);\n      if (month > -1) {\n        return month;\n      }\n    }\n    return 0;\n  }\n  /**\r\n   * Resolves short month name (i.e. "Dec") into a month number.\r\n   *\r\n   * @param value  Short month name\r\n   * @return Month number\r\n   */\n  resolveShortMonth(value) {\n    // Let\'s try English first\n    let month = this._shortMonths().indexOf(value);\n    if (month > -1) {\n      return month;\n    }\n    // Maybe long month (workaround for May)\n    month = this._months().indexOf(value);\n    if (month > -1) {\n      return month;\n    }\n    // Try the translation\n    if (this._root.language && !this._root.language.isDefault()) {\n      month = this._root.language.translateAll(this._shortMonths()).indexOf(value);\n      if (month > -1) {\n        return month;\n      }\n    }\n    return 0;\n  }\n  /**\r\n   * Checks if passed in string represents AM/PM notation in many of its\r\n   * versions.\r\n   *\r\n   * @param value  Source string\r\n   * @return Is it AM/PM?\r\n   */\n  isAm(value) {\n    let list = this.getStringList(["AM", "A.M.", "A"]);\n    return list.indexOf(value.toUpperCase()) > -1;\n  }\n  /**\r\n   * Translates list of strings.\r\n   *\r\n   * @param list  Source strings\r\n   * @return Translated strings\r\n   */\n  getStringList(list) {\n    let res = [];\n    for (let i = 0; i < list.length; i++) {\n      // translate?\n      if (this._root.language) {\n        res.push(escapeForRgex(this._t(list[i])));\n      } else {\n        res.push(escapeForRgex(list[i]));\n      }\n    }\n    return res;\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/DurationFormatter.js\n\n\n\n\n\n/**\r\n * A class used to format numberic values as time duration.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-durations/} for more info\r\n */\nclass DurationFormatter extends Entity {\n  constructor() {\n    super(...arguments);\n    /**\r\n     * Collection of aliases for units.\r\n     */\n    Object.defineProperty(this, "_unitAliases", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {\n        "Y": "y",\n        "D": "d",\n        "H": "h",\n        "K": "h",\n        "k": "h",\n        "n": "S"\n      }\n    });\n  }\n  _setDefaults() {\n    const dmillisecond = "_duration_millisecond";\n    const dsecond = "_duration_second";\n    const dminute = "_duration_minute";\n    const dhour = "_duration_hour";\n    const dday = "_duration_day";\n    const dweek = "_duration_week";\n    const dmonth = "_duration_month";\n    const dyear = "_duration_year";\n    const asecond = "_second";\n    const aminute = "_minute";\n    const ahour = "_hour";\n    const aday = "_day";\n    const aweek = "_week";\n    const amonth = "_week";\n    const ayear = "_year";\n    // Defaults\n    this._setDefault("negativeBase", 0);\n    this._setDefault("baseUnit", "second");\n    this._setDefault("durationFormats", {\n      "millisecond": {\n        "millisecond": this._t(dmillisecond),\n        "second": this._t(dmillisecond + asecond),\n        "minute": this._t(dmillisecond + aminute),\n        "hour": this._t(dmillisecond + ahour),\n        "day": this._t(dmillisecond + aday),\n        "week": this._t(dmillisecond + aweek),\n        "month": this._t(dmillisecond + amonth),\n        "year": this._t(dmillisecond + ayear)\n      },\n      "second": {\n        "second": this._t(dsecond),\n        "minute": this._t(dsecond + aminute),\n        "hour": this._t(dsecond + ahour),\n        "day": this._t(dsecond + aday),\n        "week": this._t(dsecond + aweek),\n        "month": this._t(dsecond + amonth),\n        "year": this._t(dsecond + ayear)\n      },\n      "minute": {\n        "minute": this._t(dminute),\n        "hour": this._t(dminute + ahour),\n        "day": this._t(dminute + aday),\n        "week": this._t(dminute + aweek),\n        "month": this._t(dminute + amonth),\n        "year": this._t(dminute + ayear)\n      },\n      "hour": {\n        "hour": this._t(dhour),\n        "day": this._t(dhour + aday),\n        "week": this._t(dhour + aweek),\n        "month": this._t(dhour + amonth),\n        "year": this._t(dhour + ayear)\n      },\n      "day": {\n        "day": this._t(dday),\n        "week": this._t(dday + aweek),\n        "month": this._t(dday + amonth),\n        "year": this._t(dday + ayear)\n      },\n      "week": {\n        "week": this._t(dweek),\n        "month": this._t(dweek + amonth),\n        "year": this._t(dweek + ayear)\n      },\n      "month": {\n        "month": this._t(dmonth),\n        "year": this._t(dmonth + ayear)\n      },\n      "year": {\n        "year": this._t(dyear)\n      }\n    });\n    super._setDefaults();\n  }\n  _beforeChanged() {\n    super._beforeChanged();\n  }\n  /**\r\n   * Formats the number as duration.\r\n   *\r\n   * For example `1000` (base unit seconds) would be converted to `16:40` as in\r\n   * 16 minutes and 40 seconds.\r\n   *\r\n   * @param value   Value to format\r\n   * @param format  Format to apply\r\n   * @param base    Override base unit\r\n   * @return Formatted number\r\n   */\n  format(value, format, base) {\n    // no base unit?\n    let baseUnit = base || this.get("baseUnit");\n    // no format passed in or empty\n    if (typeof format === "undefined" || format === "") {\n      if (this.get("durationFormat") != null) {\n        format = this.get("durationFormat");\n      } else {\n        format = this.getFormat(Type_toNumber(value), undefined, baseUnit);\n      }\n    }\n    // Clean format\n    format = cleanFormat(format);\n    // get format info (it will also deal with parser caching)\n    let info = this.parseFormat(format, baseUnit);\n    // cast to number just in case\n    // TODO: maybe use better casting\n    let source = Number(value);\n    // format and replace the number\n    let details;\n    if (source > this.get("negativeBase")) {\n      details = info.positive;\n    } else if (source < this.get("negativeBase")) {\n      details = info.negative;\n    } else {\n      details = info.zero;\n    }\n    // Format\n    let formatted = this.applyFormat(source, details);\n    // Apply color?\n    if (details.color !== "") {\n      formatted = "[" + details.color + "]" + formatted + "[/]";\n    }\n    return formatted;\n  }\n  /**\r\n   * Parses supplied format into structured object which can be used to format\r\n   * the number.\r\n   *\r\n   * @param format  Format string, i.e. "#,###.00"\r\n   * @param base    Override base unit\r\n   * @return Parsed information\r\n   */\n  parseFormat(format, base) {\n    // Check cache\n    // TODO\n    // let cached = this.getCache(format);\n    // if (cached != null) {\n    // \treturn cached;\n    // }\n    // no base unit?\n    let baseUnit = base || this.get("baseUnit");\n    // Initialize duration parsing info\n    let info = {\n      "positive": {\n        "color": "",\n        "template": "",\n        "parts": [],\n        "source": "",\n        "baseUnit": baseUnit,\n        "parsed": false,\n        "absolute": false\n      },\n      "negative": {\n        "color": "",\n        "template": "",\n        "parts": [],\n        "source": "",\n        "baseUnit": baseUnit,\n        "parsed": false,\n        "absolute": false\n      },\n      "zero": {\n        "color": "",\n        "template": "",\n        "parts": [],\n        "source": "",\n        "baseUnit": baseUnit,\n        "parsed": false,\n        "absolute": false\n      }\n    };\n    // Escape double vertical bars (that mean display one vertical bar)\n    format = format.replace("||", PLACEHOLDER2);\n    // Split it up and deal with different formats\n    let parts = format.split("|");\n    info.positive.source = parts[0];\n    if (typeof parts[2] === "undefined") {\n      info.zero = info.positive;\n    } else {\n      info.zero.source = parts[2];\n    }\n    if (typeof parts[1] === "undefined") {\n      info.negative = info.positive;\n    } else {\n      info.negative.source = parts[1];\n    }\n    // Parse each\n    Object_each(info, (_part, item) => {\n      // Already parsed\n      if (item.parsed) {\n        return;\n      }\n      // Check cached\n      // TODO\n      // if (typeof this.getCache(item.source) !== "undefined") {\n      // \tinfo[part] = this.getCache(item.source);\n      // \treturn;\n      // }\n      // Begin parsing\n      let partFormat = item.source;\n      // Check for [] directives\n      let dirs = [];\n      dirs = item.source.match(/^\\[([^\\]]*)\\]/);\n      if (dirs && dirs.length && dirs[0] !== "") {\n        partFormat = item.source.substr(dirs[0].length);\n        item.color = dirs[1];\n      }\n      // Let TextFormatter split into chunks\n      let chunks = TextFormatter.chunk(partFormat, true);\n      for (let i = 0; i < chunks.length; i++) {\n        let chunk = chunks[i];\n        // replace back double vertical bar\n        chunk.text = chunk.text.replace(PLACEHOLDER2, "|");\n        if (chunk.type === "value") {\n          // Just "Duration"?\n          // if (chunk.text.toLowerCase() === "duration") {\n          // \tchunk.text = durationFormat;\n          // }\n          // Check for "a" (absolute) modifier\n          if (chunk.text.match(/[yYMdDwhHKkmsSn]+a/)) {\n            item.absolute = true;\n            chunk.text = chunk.text.replace(/([yYMdDwhHKkmsSn]+)a/, "$1");\n          }\n          // Find all possible parts\n          let matches = chunk.text.match(/y+|Y+|M+|d+|D+|w+|h+|H+|K+|k+|m+|s+|S+|n+/g);\n          if (matches) {\n            // Populate template\n            for (let x = 0; x < matches.length; x++) {\n              // Is it an alias?\n              if (matches[x] == null) {\n                matches[x] = this._unitAliases[matches[x]];\n              }\n              item.parts.push(matches[x]);\n              chunk.text = chunk.text.replace(matches[x], PLACEHOLDER);\n            }\n          }\n        }\n        // Apply to template\n        item.template += chunk.text;\n      }\n      // Apply style formatting\n      //item.template = TextFormatter.format(item.template, this.outputFormat);\n      // Save cache\n      // TODO\n      //this.setCache(item.source, item);\n      // Mark this as parsed\n      item.parsed = true;\n    });\n    // Save cache (the whole thing)\n    // TODO\n    //this.setCache(format, info);\n    return info;\n  }\n  /**\r\n   * Applies parsed format to a numeric value.\r\n   *\r\n   * @param value    Value\r\n   * @param details  Parsed format as returned by {parseFormat}\r\n   * @return Formatted duration\r\n   */\n  applyFormat(value, details) {\n    // Use absolute values\n    let negative = !details.absolute && value < this.get("negativeBase");\n    value = Math.abs(value);\n    // Recalculate to milliseconds\n    let tstamp = this.toTimeStamp(value, details.baseUnit);\n    // Init return value\n    let res = details.template;\n    // Iterate through duration parts\n    for (let i = 0, len = details.parts.length; i < len; i++) {\n      // Gather the part\n      let part = details.parts[i];\n      let unit = this._toTimeUnit(part.substr(0, 1));\n      let digits = part.length;\n      // Calculate current unit value\n      let ints = Math.floor(tstamp / this._getUnitValue(unit));\n      res = res.replace(PLACEHOLDER, padString(ints, digits, "0"));\n      // Reduce timestamp\n      tstamp -= ints * this._getUnitValue(unit);\n    }\n    // Reapply negative sign\n    if (negative) {\n      res = "-" + res;\n    }\n    return res;\n  }\n  /**\r\n   * Converts numeric value to timestamp in milliseconds.\r\n   *\r\n   * @param value     A source value\r\n   * @param baseUnit  Base unit the source value is in: "q", "s", "i", "h", "d", "w", "m", "y"\r\n   * @return Value representation as a timestamp in milliseconds\r\n   */\n  toTimeStamp(value, baseUnit) {\n    return value * this._getUnitValue(baseUnit);\n  }\n  _toTimeUnit(code) {\n    switch (code) {\n      case "S":\n        return "millisecond";\n      case "s":\n        return "second";\n      case "m":\n        return "minute";\n      case "h":\n        return "hour";\n      case "d":\n        return "day";\n      case "w":\n        return "week";\n      case "M":\n        return "month";\n      case "y":\n        return "year";\n    }\n    ;\n  }\n  /**\r\n   * Returns appropriate default format for the value.\r\n   *\r\n   * If `maxValue` is sepcified, it will use that value to determine the time\r\n   * unit for the format.\r\n   *\r\n   * For example if your `baseUnit` is `"second"` and you pass in `10`, you\r\n   * will get `"10"`.\r\n   *\r\n   * However, you might want it to be formatted in the context of bigger scale,\r\n   * say 10 minutes (600 seconds). If you pass in `600` as `maxValue`, all\r\n   * values, including small ones will use format with minutes, e.g.:\r\n   * `00:10`, `00:50`, `12: 30`, etc.\r\n   *\r\n   * @param value     Value to format\r\n   * @param maxValue  Maximum value to be used to determine format\r\n   * @param baseUnit  Base unit of the value\r\n   * @return Format\r\n   */\n  getFormat(value, maxValue, baseUnit) {\n    // Is format override set?\n    if (this.get("durationFormat") != null) {\n      return this.get("durationFormat");\n    }\n    // Get base unit\n    if (!baseUnit) {\n      baseUnit = this.get("baseUnit");\n    }\n    if (maxValue != null && value != maxValue) {\n      value = Math.abs(value);\n      maxValue = Math.abs(maxValue);\n      let maxUnit = this.getValueUnit(Math.max(value, maxValue), baseUnit);\n      return this.get("durationFormats")[baseUnit][maxUnit];\n    } else {\n      let unit = this.getValueUnit(value, baseUnit);\n      return this.get("durationFormats")[baseUnit][unit];\n    }\n  }\n  /**\r\n   * Returns value\'s closest denominator time unit, e.g 100 seconds is\r\n   * `"minute"`, while 59 seconds would still be `second`.\r\n   *\r\n   * @param value     Source duration value\r\n   * @param baseUnit  Base unit\r\n   * @return Denominator\r\n   */\n  getValueUnit(value, baseUnit) {\n    // Get base unit\n    if (!baseUnit) {\n      baseUnit = this.get("baseUnit");\n    }\n    // Convert to milliseconds\n    let currentUnit;\n    let ms = this.getMilliseconds(value, baseUnit);\n    Object_eachContinue(this._getUnitValues(), (key, val) => {\n      if (key == baseUnit || currentUnit) {\n        let num = ms / val;\n        if (num <= 1) {\n          if (!currentUnit) {\n            currentUnit = key;\n          }\n          return false;\n        }\n        currentUnit = key;\n      }\n      return true;\n    });\n    return currentUnit;\n  }\n  /**\r\n   * Converts value to milliseconds according to `baseUnit`.\r\n   *\r\n   * @param value     Source duration value\r\n   * @param baseUnit  Base unit\r\n   * @return Value in milliseconds\r\n   */\n  getMilliseconds(value, baseUnit) {\n    // Get base unit\n    if (!baseUnit) {\n      baseUnit = this.get("baseUnit");\n    }\n    return value * this._getUnitValue(baseUnit);\n  }\n  _getUnitValue(timeUnit) {\n    return this._getUnitValues()[timeUnit];\n  }\n  _getUnitValues() {\n    return {\n      "millisecond": 1,\n      "second": 1000,\n      "minute": 60000,\n      "hour": 3600000,\n      "day": 86400000,\n      "week": 604800000,\n      "month": 2592000000,\n      "year": 31536000000\n    };\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/locales/en.js\n/**\r\n * amCharts 5 locale\r\n *\r\n * Locale: en\r\n * Language: International English\r\n * Author: Martynas Majeris\r\n *\r\n * Follow instructions in [on this page](https://www.amcharts.com/docs/v5/tutorials/creating-translations/) to make corrections or add new translations.\r\n *\r\n * ---\r\n * Edit but leave the header section above this line. You can remove any\r\n * subsequent comment sections.\r\n * ---\r\n *\r\n * Use this file as a template to create translations. Leave the key part in\r\n * English intact. Fill the value with a translation.\r\n *\r\n * Empty string means no translation, so default "International English"\r\n * will be used.\r\n *\r\n * If you need the translation to literally be an empty string, use `null`\r\n * instead.\r\n *\r\n * IMPORTANT:\r\n * When translating make good effort to keep the translation length\r\n * at least the same chartcount as the English, especially for short prompts.\r\n *\r\n * Having significantly longer prompts may distort the actual charts.\r\n *\r\n * NOTE:\r\n * Some prompts - like months or weekdays - come in two versions: full and\r\n * shortened.\r\n *\r\n * If there\'s no official shortened version of these in your language, and it\r\n * would not be possible to invent such short versions that don\'t seem weird\r\n * to native speakers of that language, fill those with the same as full\r\n * version.\r\n *\r\n * PLACEHOLDERS:\r\n * Some prompts have placeholders like "%1". Those will be replaced by actual\r\n * values during translation and should be retained in the translated prompts.\r\n *\r\n * Placeholder positions may be changed to better suit structure of the\r\n * sentence.\r\n *\r\n * For example "From %1 to %2", when actually used will replace "%1" with an\r\n * actual value representing range start, and "%2" will be replaced by end\r\n * value.\r\n *\r\n * E.g. in a Scrollbar for Value axis "From %1 to %2" will become\r\n * "From 100 to 200". You may translate "From" and "to", as well as re-arrange\r\n * the order of the prompt itself, but make sure the "%1" and "%2" remain, in\r\n * places where they will make sense.\r\n *\r\n * Save the file as language_LOCALE, i.e. `en_GB.ts`, `fr_FR.ts`, etc.\r\n */\n/* harmony default export */ const en = ({\n  "firstDayOfWeek": 1,\n  // Number formatting options.\n  // \n  // Please check with the local standards which separator is accepted to be\n  // used for separating decimals, and which for thousands.\n  "_decimalSeparator": ".",\n  "_thousandSeparator": ",",\n  // Position of the percent sign in numbers\n  "_percentPrefix": null,\n  "_percentSuffix": "%",\n  // Suffixes for numbers\n  // When formatting numbers, big or small numers might be reformatted to\n  // shorter version, by applying a suffix.\n  // \n  // For example, 1000000 might become "1m".\n  // Or 1024 might become "1KB" if we\'re formatting byte numbers.\n  // \n  // This section defines such suffixes for all such cases.\n  "_big_number_suffix_3": "k",\n  "_big_number_suffix_6": "M",\n  "_big_number_suffix_9": "G",\n  "_big_number_suffix_12": "T",\n  "_big_number_suffix_15": "P",\n  "_big_number_suffix_18": "E",\n  "_big_number_suffix_21": "Z",\n  "_big_number_suffix_24": "Y",\n  "_small_number_suffix_3": "m",\n  "_small_number_suffix_6": "μ",\n  "_small_number_suffix_9": "n",\n  "_small_number_suffix_12": "p",\n  "_small_number_suffix_15": "f",\n  "_small_number_suffix_18": "a",\n  "_small_number_suffix_21": "z",\n  "_small_number_suffix_24": "y",\n  "_byte_suffix_B": "B",\n  "_byte_suffix_KB": "KB",\n  "_byte_suffix_MB": "MB",\n  "_byte_suffix_GB": "GB",\n  "_byte_suffix_TB": "TB",\n  "_byte_suffix_PB": "PB",\n  // Default date formats for various periods.\n  // \n  // This should reflect official or de facto formatting universally accepted\n  // in the country translation is being made for\n  // Available format codes here:\n  // https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/#Format_codes\n  // \n  // This will be used when formatting date/time for particular granularity,\n  // e.g. "_date_hour" will be shown whenever we need to show time as hours.\n  // \n  // "date" is used as in default date format when showing standalone dates.\n  "_date": "yyyy-MM-dd",\n  "_date_millisecond": "mm:ss SSS",\n  "_date_millisecond_full": "HH:mm:ss SSS",\n  "_date_second": "HH:mm:ss",\n  "_date_second_full": "HH:mm:ss",\n  "_date_minute": "HH:mm",\n  "_date_minute_full": "HH:mm - MMM dd, yyyy",\n  "_date_hour": "HH:mm",\n  "_date_hour_full": "HH:mm - MMM dd, yyyy",\n  "_date_day": "MMM dd",\n  "_date_day_full": "MMM dd, yyyy",\n  "_date_week": "ww",\n  "_date_week_full": "MMM dd, yyyy",\n  "_date_month": "MMM",\n  "_date_month_full": "MMM, yyyy",\n  "_date_year": "yyyy",\n  // Default duration formats for various base units.\n  // \n  // This will be used by DurationFormatter to format numeric values into\n  // duration.\n  // \n  // Notice how each duration unit comes in several versions. This is to ensure\n  // that each base unit is shown correctly.\n  // \n  // For example, if we have baseUnit set to "second", meaning our duration is\n  // in seconds.\n  // \n  // If we pass in `50` to formatter, it will know that we have just 50 seconds\n  // (less than a minute) so it will use format in `"_duration_second"` ("ss"),\n  // and the formatted result will be in like `"50"`.\n  // \n  // If we pass in `70`, which is more than a minute, the formatter will switch\n  // to `"_duration_second_minute"` ("mm:ss"), resulting in "01:10" formatted\n  // text.\n  // \n  // Available codes here:\n  // https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/#Available_Codes\n  "_duration_millisecond": "SSS",\n  "_duration_millisecond_second": "ss.SSS",\n  "_duration_millisecond_minute": "mm:ss SSS",\n  "_duration_millisecond_hour": "hh:mm:ss SSS",\n  "_duration_millisecond_day": "d\'d\' mm:ss SSS",\n  "_duration_millisecond_week": "d\'d\' mm:ss SSS",\n  "_duration_millisecond_month": "M\'m\' dd\'d\' mm:ss SSS",\n  "_duration_millisecond_year": "y\'y\' MM\'m\' dd\'d\' mm:ss SSS",\n  "_duration_second": "ss",\n  "_duration_second_minute": "mm:ss",\n  "_duration_second_hour": "hh:mm:ss",\n  "_duration_second_day": "d\'d\' hh:mm:ss",\n  "_duration_second_week": "d\'d\' hh:mm:ss",\n  "_duration_second_month": "M\'m\' dd\'d\' hh:mm:ss",\n  "_duration_second_year": "y\'y\' MM\'m\' dd\'d\' hh:mm:ss",\n  "_duration_minute": "mm",\n  "_duration_minute_hour": "hh:mm",\n  "_duration_minute_day": "d\'d\' hh:mm",\n  "_duration_minute_week": "d\'d\' hh:mm",\n  "_duration_minute_month": "M\'m\' dd\'d\' hh:mm",\n  "_duration_minute_year": "y\'y\' MM\'m\' dd\'d\' hh:mm",\n  "_duration_hour": "hh\'h\'",\n  "_duration_hour_day": "d\'d\' hh\'h\'",\n  "_duration_hour_week": "d\'d\' hh\'h\'",\n  "_duration_hour_month": "M\'m\' dd\'d\' hh\'h\'",\n  "_duration_hour_year": "y\'y\' MM\'m\' dd\'d\' hh\'h\'",\n  "_duration_day": "d\'d\'",\n  "_duration_day_week": "d\'d\'",\n  "_duration_day_month": "M\'m\' dd\'d\'",\n  "_duration_day_year": "y\'y\' MM\'m\' dd\'d\'",\n  "_duration_week": "w\'w\'",\n  "_duration_week_month": "w\'w\'",\n  "_duration_week_year": "w\'w\'",\n  "_duration_month": "M\'m\'",\n  "_duration_month_year": "y\'y\' MM\'m\'",\n  "_duration_year": "y\'y\'",\n  // Era translations\n  "_era_ad": "AD",\n  "_era_bc": "BC",\n  // Day part, used in 12-hour formats, e.g. 5 P.M.\n  // Please note that these come in 3 variants:\n  // * one letter (e.g. "A")\n  // * two letters (e.g. "AM")\n  // * two letters with dots (e.g. "A.M.")\n  // \n  // All three need to to be translated even if they are all the same. Some\n  // users might use one, some the other.\n  "A": "",\n  "P": "",\n  "AM": "",\n  "PM": "",\n  "A.M.": "",\n  "P.M.": "",\n  // Date-related stuff.\n  // \n  // When translating months, if there\'s a difference, use the form which is\n  // best for a full date, e.g. as you would use it in "2018 January 1".\n  // \n  // Note that May is listed twice. This is because in English May is the same\n  // in both long and short forms, while in other languages it may not be the\n  // case. Translate "May" to full word, while "May(short)" to shortened\n  // version.\n  // \n  // Should month names and weekdays be capitalized or not?\n  // \n  // Rule of thumb is this: if the names should always be capitalized,\n  // regardless of name position within date ("January", "21st January 2018",\n  // etc.) use capitalized names. Otherwise enter all lowercase.\n  // \n  // The date formatter will automatically capitalize names if they are the\n  // first (or only) word in resulting date.\n  "January": "",\n  "February": "",\n  "March": "",\n  "April": "",\n  "May": "",\n  "June": "",\n  "July": "",\n  "August": "",\n  "September": "",\n  "October": "",\n  "November": "",\n  "December": "",\n  "Jan": "",\n  "Feb": "",\n  "Mar": "",\n  "Apr": "",\n  "May(short)": "May",\n  "Jun": "",\n  "Jul": "",\n  "Aug": "",\n  "Sep": "",\n  "Oct": "",\n  "Nov": "",\n  "Dec": "",\n  // Weekdays.\n  "Sunday": "",\n  "Monday": "",\n  "Tuesday": "",\n  "Wednesday": "",\n  "Thursday": "",\n  "Friday": "",\n  "Saturday": "",\n  "Sun": "",\n  "Mon": "",\n  "Tue": "",\n  "Wed": "",\n  "Thu": "",\n  "Fri": "",\n  "Sat": "",\n  // Date ordinal function.\n  // \n  // This is used when adding number ordinal when formatting days in dates.\n  // \n  // E.g. "January 1st", "February 2nd".\n  // \n  // The function accepts day number, and returns a string to be added to the\n  // day, like in default English translation, if we pass in 2, we will receive\n  // "nd" back.\n  "_dateOrd": function (day) {\n    let res = "th";\n    if (day < 11 || day > 13) {\n      switch (day % 10) {\n        case 1:\n          res = "st";\n          break;\n        case 2:\n          res = "nd";\n          break;\n        case 3:\n          res = "rd";\n          break;\n      }\n    }\n    return res;\n  },\n  // Various chart controls.\n  // Shown as a tooltip on zoom out button.\n  "Zoom Out": "",\n  // Timeline buttons\n  "Play": "",\n  "Stop": "",\n  // Chart\'s Legend screen reader title.\n  "Legend": "",\n  // Legend\'s item screen reader indicator.\n  "Press ENTER to toggle": "",\n  // Shown when the chart is busy loading something.\n  "Loading": "",\n  // Shown as the first button in the breadcrumb navigation, e.g.:\n  // Home > First level > ...\n  "Home": "",\n  // Chart types.\n  // Those are used as default screen reader titles for the main chart element\n  // unless developer has set some more descriptive title.\n  "Chart": "",\n  "Serial chart": "",\n  "X/Y chart": "",\n  "Pie chart": "",\n  "Gauge chart": "",\n  "Radar chart": "",\n  "Sankey diagram": "",\n  "Flow diagram": "",\n  "Chord diagram": "",\n  "TreeMap chart": "",\n  "Force directed tree": "",\n  "Sliced chart": "",\n  // Series types.\n  // Used to name series by type for screen readers if they do not have their\n  // name set.\n  "Series": "",\n  "Candlestick Series": "",\n  "OHLC Series": "",\n  "Column Series": "",\n  "Line Series": "",\n  "Pie Slice Series": "",\n  "Funnel Series": "",\n  "Pyramid Series": "",\n  "X/Y Series": "",\n  // Map-related stuff.\n  "Map": "",\n  "Press ENTER to zoom in": "",\n  "Press ENTER to zoom out": "",\n  "Use arrow keys to zoom in and out": "",\n  "Use plus and minus keys on your keyboard to zoom in and out": "",\n  // Export-related stuff.\n  // These prompts are used in Export menu labels.\n  // \n  // "Export" is the top-level menu item.\n  // \n  // "Image", "Data", "Print" as second-level indicating type of export\n  // operation.\n  // \n  // Leave actual format untranslated, unless you absolutely know that they\n  // would convey more meaning in some other way.\n  "Export": "",\n  "Image": "",\n  "Data": "",\n  "Print": "",\n  "Press ENTER or use arrow keys to navigate": "",\n  "Press ENTER to open": "",\n  "Press ENTER to print.": "",\n  "Press ENTER to export as %1.": "",\n  "(Press ESC to close this message)": "",\n  "Image Export Complete": "",\n  "Export operation took longer than expected. Something might have gone wrong.": "",\n  "Saved from": "",\n  "PNG": "",\n  "JPG": "",\n  "GIF": "",\n  "SVG": "",\n  "PDF": "",\n  "JSON": "",\n  "CSV": "",\n  "XLSX": "",\n  "HTML": "",\n  // Scrollbar-related stuff.\n  // \n  // Scrollbar is a control which can zoom and pan the axes on the chart.\n  // \n  // Each scrollbar has two grips: left or right (for horizontal scrollbar) or\n  // upper and lower (for vertical one).\n  // \n  // Prompts change in relation to whether Scrollbar is vertical or horizontal.\n  // \n  // The final section is used to indicate the current range of selection.\n  "Use TAB to select grip buttons or left and right arrows to change selection": "",\n  "Use left and right arrows to move selection": "",\n  "Use left and right arrows to move left selection": "",\n  "Use left and right arrows to move right selection": "",\n  "Use TAB select grip buttons or up and down arrows to change selection": "",\n  "Use up and down arrows to move selection": "",\n  "Use up and down arrows to move lower selection": "",\n  "Use up and down arrows to move upper selection": "",\n  "From %1 to %2": "",\n  "From %1": "",\n  "To %1": "",\n  // Data loader-related.\n  "No parser available for file: %1": "",\n  "Error parsing file: %1": "",\n  "Unable to load file: %1": "",\n  "Invalid date": "",\n  // Common actions\n  "Close": "",\n  "Minimize": ""\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Language.js\n\n\n\n\n;\n/**\r\n * Add localization functionality.\r\n */\nclass Language extends Entity {\n  _setDefaults() {\n    this.setPrivate("defaultLocale", en);\n    super._setDefaults();\n  }\n  /**\r\n   * Returns a prompt translation.\r\n   *\r\n   * @param   prompt   Prompt to translate\r\n   * @param   locale   Target locale\r\n   * @param   ...rest  Parameters\r\n   * @return           Translation\r\n   */\n  translate(prompt, locale, ...rest) {\n    // Get langauge\n    if (!locale) {\n      locale = this._root.locale || this.getPrivate("defaultLocale");\n    }\n    // Init translation\n    let translation = prompt;\n    let value = locale[prompt];\n    // Try to look for the translation\n    if (value === null) {\n      translation = "";\n    } else if (value != null) {\n      // It might be an empty string\n      if (value) {\n        translation = value;\n      }\n    } else if (locale !== this.getPrivate("defaultLocale")) {\n      // Try to look in default language\n      return this.translate(prompt, this.getPrivate("defaultLocale"), ...rest);\n    }\n    // Replace %1, %2, etc params\n    if (rest.length) {\n      for (let len = rest.length, i = 0; i < len; ++i) {\n        translation = translation.split("%" + (i + 1)).join(rest[i]);\n      }\n    }\n    // Return the translation\n    return translation;\n  }\n  /**\r\n   * Returns a prompt translation, including custom prompts.\r\n   *\r\n   * @param   prompt   Prompt to translate\r\n   * @param   locale   Target locale\r\n   * @param   ...rest  Parameters\r\n   * @return           Translation\r\n   */\n  translateAny(prompt, locale, ...rest) {\n    return this.translate(prompt, locale, ...rest);\n  }\n  /**\r\n   * Add a custom prompt to locale.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/creating-translations/#Extending_locale_with_custom_prompts}\r\n   * @param  prompt       Source prompt\r\n   * @param  translation  Tanslation\r\n   * @param  locale       Target locale\r\n   */\n  setTranslationAny(prompt, translation, locale) {\n    const localeTarget = locale || this._root.locale;\n    localeTarget[prompt] = translation;\n  }\n  /**\r\n   * Add a batch of custom prompts.\r\n   *\r\n   * @since 5.3.3\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/creating-translations/#Extending_locale_with_custom_prompts}\r\n   * @param  translations  Translations\r\n   * @param  locale        Target locale\r\n   */\n  setTranslationsAny(translations, locale) {\n    Object_each(translations, (key, val) => {\n      this.setTranslationAny(key, val, locale);\n    });\n  }\n  translateEmpty(prompt, locale, ...rest) {\n    let translation = this.translate(prompt, locale, ...rest);\n    return translation == prompt ? "" : translation;\n  }\n  translateFunc(prompt, locale) {\n    if (this._root.locale[prompt]) {\n      return this._root.locale[prompt];\n    }\n    // Try to look in default language\n    if (locale !== this.getPrivate("defaultLocale")) {\n      return this.translateFunc(prompt, this.getPrivate("defaultLocale"));\n    }\n    // Fail - return empty function\n    return () => {\n      return "";\n    };\n  }\n  /**\r\n   * Translates a btach of prompts.\r\n   *\r\n   * @param  list    Array of prompts to translate\r\n   * @param  locale  Target locale\r\n   * @return         Array of translations\r\n   */\n  translateAll(list, locale) {\n    // Translate all items in the list\n    if (!this.isDefault()) {\n      return Array_map(list, x => this.translate(x, locale));\n    } else {\n      return list;\n    }\n  }\n  /**\r\n   * Returns `true` if the currently selected locale is a default locale.\r\n   *\r\n   * @return `true` if locale is default; `false` if it is not.\r\n   */\n  isDefault() {\n    return this.getPrivate("defaultLocale") === this._root.locale;\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/Theme.js\n\n\n\n/**\r\n * A base class for an amCharts theme.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/themes/} for more info\r\n * @important\r\n */\nclass Theme {\n  constructor(root, isReal) {\n    Object.defineProperty(this, "_root", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_rules", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    this._root = root;\n    if (!isReal) {\n      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");\n    }\n  }\n  /**\r\n   * Use this method to create an instance of this class.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info\r\n   * @param   root      Root element\r\n   * @param   settings  Settings\r\n   * @param   template  Template\r\n   * @return            Instantiated object\r\n   */\n  static new(root) {\n    const x = new this(root, true);\n    x.setupDefaultRules();\n    return x;\n  }\n  setupDefaultRules() {}\n  /**\r\n   * Looks up the rules for a specific theme class.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info\r\n   * @param   themeClass Theme class\r\n   * @return             Array<IRule<A>>\r\n   */\n  _lookupRules(themeClass) {\n    return this._rules[themeClass];\n  }\n  /**\r\n   * Creates a [[Template]] for specific theme class and tags.\r\n   *\r\n   * NOTE: the difference from `rule()` is that `ruleRaw()` does not do any\r\n   * type checks.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info\r\n   * @param   themeClass Theme class\r\n   * @param   themeTags  Theme tags\r\n   * @return             Template\r\n   */\n  ruleRaw(themeClass, themeTags = []) {\n    let rules = this._rules[themeClass];\n    if (!rules) {\n      rules = this._rules[themeClass] = [];\n    }\n    themeTags.sort(compare);\n    const {\n      index,\n      found\n    } = getSortedIndex(rules, x => {\n      const order = compare(x.tags.length, themeTags.length);\n      if (order === 0) {\n        return compareArray(x.tags, themeTags, compare);\n      } else {\n        return order;\n      }\n    });\n    if (found) {\n      return rules[index].template;\n    } else {\n      const template = Template.new({});\n      rules.splice(index, 0, {\n        tags: themeTags,\n        template\n      });\n      return template;\n    }\n  }\n  /**\r\n   * Creates a [[Template]] for specific theme class and tags.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info\r\n   * @param   themeClass Theme class\r\n   * @param   themeTags  Theme tags\r\n   * @return             Template\r\n   */\n  rule(themeClass, themeTags = []) {\n    return this.ruleRaw(themeClass, themeTags);\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/themes/DefaultTheme.js\n\n\n\n\n\n/**\r\n * @ignore\r\n */\nfunction setColor(rule, key, ic, name) {\n  // TODO this shouldn\'t use get, figure out a better way\n  rule.set(key, ic.get(name));\n  ic.on(name, value => {\n    rule.set(key, value);\n  });\n}\n/**\r\n * @ignore\r\n */\nclass DefaultTheme extends Theme {\n  setupDefaultRules() {\n    super.setupDefaultRules();\n    const language = this._root.language;\n    const ic = this._root.interfaceColors;\n    const horizontalLayout = this._root.horizontalLayout;\n    const verticalLayout = this._root.verticalLayout;\n    const r = this.rule.bind(this);\n    /**\r\n     * ========================================================================\r\n     * core\r\n     * ========================================================================\r\n     */\n    r("InterfaceColors").setAll({\n      stroke: Color.fromHex(0xe5e5e5),\n      fill: Color.fromHex(0xf3f3f3),\n      primaryButton: Color.fromHex(0x6794dc),\n      primaryButtonHover: Color.fromHex(0x6771dc),\n      primaryButtonDown: Color.fromHex(0x68dc76),\n      primaryButtonActive: Color.fromHex(0x68dc76),\n      primaryButtonText: Color.fromHex(0xffffff),\n      primaryButtonStroke: Color.fromHex(0xffffff),\n      secondaryButton: Color.fromHex(0xd9d9d9),\n      secondaryButtonHover: Color.fromHex(0xa3a3a3),\n      secondaryButtonDown: Color.fromHex(0x8d8d8d),\n      secondaryButtonActive: Color.fromHex(0xe6e6e6),\n      secondaryButtonText: Color.fromHex(0x000000),\n      secondaryButtonStroke: Color.fromHex(0xffffff),\n      grid: Color.fromHex(0x000000),\n      background: Color.fromHex(0xffffff),\n      alternativeBackground: Color.fromHex(0x000000),\n      text: Color.fromHex(0x000000),\n      alternativeText: Color.fromHex(0xffffff),\n      disabled: Color.fromHex(0xadadad),\n      positive: Color.fromHex(0x50b300),\n      negative: Color.fromHex(0xb30000)\n    });\n    {\n      const rule = r("ColorSet");\n      rule.setAll({\n        passOptions: {\n          hue: 0.05,\n          saturation: 0,\n          lightness: 0\n        },\n        colors: [Color.fromHex(0x67b7dc)],\n        step: 1,\n        //baseColor: Color.fromRGB(103, 183, 220),\n        //count: 20,\n        reuse: false,\n        startIndex: 0\n      });\n      rule.setPrivate("currentStep", 0);\n      rule.setPrivate("currentPass", 0);\n    }\n    r("Entity").setAll({\n      stateAnimationDuration: 0,\n      stateAnimationEasing: out(cubic)\n    });\n    r("Component").setAll({\n      interpolationDuration: 0,\n      interpolationEasing: out(cubic)\n    });\n    r("Sprite").setAll({\n      visible: true,\n      scale: 1,\n      opacity: 1,\n      rotation: 0,\n      position: "relative",\n      tooltipX: p50,\n      tooltipY: p50,\n      tooltipPosition: "fixed",\n      isMeasured: true\n    });\n    r("Sprite").states.create("default", {\n      "visible": true,\n      opacity: 1\n    });\n    r("Container").setAll({\n      interactiveChildren: true,\n      setStateOnChildren: false\n    });\n    r("Graphics").setAll({\n      strokeWidth: 1\n    });\n    r("Chart").setAll({\n      width: p100,\n      height: p100,\n      interactiveChildren: false\n    });\n    r("ZoomableContainer").setAll({\n      width: p100,\n      height: p100,\n      wheelable: true,\n      pinchZoom: true,\n      maxZoomLevel: 32,\n      minZoomLevel: 1,\n      zoomStep: 2,\n      animationEasing: out(cubic),\n      animationDuration: 600\n    });\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * core: alignment\r\n     * ------------------------------------------------------------------------\r\n     */\n    r("Sprite", ["horizontal", "center"]).setAll({\n      centerX: p50,\n      x: p50\n    });\n    r("Sprite", ["vertical", "center"]).setAll({\n      centerY: p50,\n      y: p50\n    });\n    r("Container", ["horizontal", "layout"]).setAll({\n      layout: horizontalLayout\n    });\n    r("Container", ["vertical", "layout"]).setAll({\n      layout: verticalLayout\n    });\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * core: patterns\r\n     * ------------------------------------------------------------------------\r\n     */\n    r("Pattern").setAll({\n      repetition: "repeat",\n      width: 50,\n      height: 50,\n      rotation: 0,\n      fillOpacity: 1\n    });\n    r("LinePattern").setAll({\n      gap: 6,\n      colorOpacity: 1,\n      width: 49,\n      height: 49\n    });\n    r("RectanglePattern").setAll({\n      gap: 6,\n      checkered: false,\n      centered: true,\n      maxWidth: 5,\n      maxHeight: 5,\n      width: 48,\n      height: 48,\n      strokeWidth: 0\n    });\n    r("CirclePattern").setAll({\n      gap: 5,\n      checkered: false,\n      centered: false,\n      radius: 3,\n      strokeWidth: 0,\n      width: 45,\n      height: 45\n    });\n    r("GrainPattern").setAll({\n      width: 200,\n      height: 200,\n      colors: [Color.fromHex(0x000000)],\n      size: 1,\n      horizontalGap: 0,\n      verticalGap: 0,\n      density: 1,\n      minOpacity: 0,\n      maxOpacity: 0.2\n    });\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * core: gradients\r\n     * ------------------------------------------------------------------------\r\n     */\n    r("LinearGradient").setAll({\n      rotation: 90\n    });\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * core: Legend\r\n     * ------------------------------------------------------------------------\r\n     */\n    r("Legend").setAll({\n      fillField: "fill",\n      strokeField: "stroke",\n      nameField: "name",\n      layout: GridLayout.new(this._root, {}),\n      layer: 30,\n      clickTarget: "itemContainer"\n    });\n    // Class: Container\n    r("Container", ["legend", "item", "itemcontainer"]).setAll({\n      paddingLeft: 5,\n      paddingRight: 5,\n      paddingBottom: 5,\n      paddingTop: 5,\n      layout: horizontalLayout,\n      setStateOnChildren: true,\n      interactiveChildren: false,\n      ariaChecked: true,\n      focusable: true,\n      ariaLabel: language.translate("Press ENTER to toggle"),\n      role: "checkbox"\n    });\n    {\n      const rule = r("Rectangle", ["legend", "item", "background"]);\n      rule.setAll({\n        fillOpacity: 0\n      });\n      setColor(rule, "fill", ic, "background");\n    }\n    r("Container", ["legend", "marker"]).setAll({\n      setStateOnChildren: true,\n      centerY: p50,\n      paddingLeft: 0,\n      paddingRight: 0,\n      paddingBottom: 0,\n      paddingTop: 0,\n      width: 18,\n      height: 18\n    });\n    r("RoundedRectangle", ["legend", "marker", "rectangle"]).setAll({\n      width: p100,\n      height: p100,\n      cornerRadiusBL: 3,\n      cornerRadiusTL: 3,\n      cornerRadiusBR: 3,\n      cornerRadiusTR: 3\n    });\n    {\n      const rule = r("RoundedRectangle", ["legend", "marker", "rectangle"]).states.create("disabled", {});\n      setColor(rule, "fill", ic, "disabled");\n      setColor(rule, "stroke", ic, "disabled");\n    }\n    r("Label", ["legend", "label"]).setAll({\n      centerY: p50,\n      marginLeft: 5,\n      paddingRight: 0,\n      paddingLeft: 0,\n      paddingTop: 0,\n      paddingBottom: 0,\n      populateText: true\n    });\n    {\n      const rule = r("Label", ["legend", "label"]).states.create("disabled", {});\n      setColor(rule, "fill", ic, "disabled");\n    }\n    r("Label", ["legend", "value", "label"]).setAll({\n      centerY: p50,\n      marginLeft: 5,\n      paddingRight: 0,\n      paddingLeft: 0,\n      paddingTop: 0,\n      paddingBottom: 0,\n      width: 50,\n      centerX: p100,\n      populateText: true\n    });\n    {\n      const rule = r("Label", ["legend", "value", "label"]).states.create("disabled", {});\n      setColor(rule, "fill", ic, "disabled");\n    }\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * core: HeatLegend\r\n     * ------------------------------------------------------------------------\r\n     */\n    r("HeatLegend").setAll({\n      stepCount: 1\n    });\n    r("RoundedRectangle", ["heatlegend", "marker"]).setAll({\n      cornerRadiusTR: 0,\n      cornerRadiusBR: 0,\n      cornerRadiusTL: 0,\n      cornerRadiusBL: 0\n    });\n    r("RoundedRectangle", ["vertical", "heatlegend", "marker"]).setAll({\n      height: p100,\n      width: 15\n    });\n    r("RoundedRectangle", ["horizontal", "heatlegend", "marker"]).setAll({\n      width: p100,\n      height: 15\n    });\n    r("HeatLegend", ["vertical"]).setAll({\n      height: p100\n    });\n    r("HeatLegend", ["horizontal"]).setAll({\n      width: p100\n    });\n    r("Label", ["heatlegend", "start"]).setAll({\n      paddingLeft: 5,\n      paddingRight: 5,\n      paddingTop: 5,\n      paddingBottom: 5\n    });\n    r("Label", ["heatlegend", "end"]).setAll({\n      paddingLeft: 5,\n      paddingRight: 5,\n      paddingTop: 5,\n      paddingBottom: 5\n    });\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * core: Labels\r\n     * ------------------------------------------------------------------------\r\n     */\n    {\n      const rule = r("Label");\n      rule.setAll({\n        paddingTop: 8,\n        paddingBottom: 8,\n        paddingLeft: 10,\n        paddingRight: 10,\n        fontFamily: "-apple-system, BlinkMacSystemFont, \\"Segoe UI\\", Roboto, Helvetica, Arial, sans-serif, \\"Apple Color Emoji\\", \\"Segoe UI Emoji\\", \\"Segoe UI Symbol\\"",\n        fontSize: "1em",\n        populateText: false\n      });\n      setColor(rule, "fill", ic, "text");\n    }\n    r("RadialLabel").setAll({\n      textType: "regular",\n      centerY: p50,\n      centerX: p50,\n      inside: false,\n      radius: 0,\n      baseRadius: p100,\n      orientation: "auto",\n      textAlign: "center"\n    });\n    r("EditableLabel").setAll({\n      editOn: "click",\n      //setStateOnChildren: true,\n      themeTags: ["editablelabel"],\n      multiLine: true\n    });\n    r("RoundedRectangle", ["editablelabel", "background"]).setAll({\n      fillOpacity: 0,\n      fill: Color.fromHex(0x000000),\n      cornerRadiusBL: 3,\n      cornerRadiusBR: 3,\n      cornerRadiusTL: 3,\n      cornerRadiusTR: 3,\n      strokeOpacity: 0,\n      stroke: Color.fromHex(0x000000)\n    });\n    {\n      r("RoundedRectangle", ["editablelabel", "background"]).states.create("active", {\n        strokeOpacity: 0.2\n      });\n    }\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * core: Elements and shapes\r\n     * ------------------------------------------------------------------------\r\n     */\n    r("RoundedRectangle").setAll({\n      cornerRadiusTL: 8,\n      cornerRadiusBL: 8,\n      cornerRadiusTR: 8,\n      cornerRadiusBR: 8\n    });\n    r("PointedRectangle").setAll({\n      pointerBaseWidth: 15,\n      pointerLength: 10,\n      cornerRadius: 8\n    });\n    r("Slice").setAll({\n      shiftRadius: 0,\n      dRadius: 0,\n      dInnerRadius: 0\n    });\n    {\n      const rule = r("Tick");\n      rule.setAll({\n        strokeOpacity: .15,\n        isMeasured: false,\n        length: 4.5,\n        position: "absolute",\n        crisp: true\n      });\n      setColor(rule, "stroke", ic, "grid");\n    }\n    r("Bullet").setAll({\n      locationX: 0.5,\n      locationY: 0.5\n    });\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * core: Tooltip\r\n     * ------------------------------------------------------------------------\r\n     */\n    r("Tooltip").setAll({\n      position: "absolute",\n      getFillFromSprite: true,\n      getStrokeFromSprite: false,\n      autoTextColor: true,\n      paddingTop: 9,\n      paddingBottom: 8,\n      paddingLeft: 10,\n      paddingRight: 10,\n      marginBottom: 5,\n      pointerOrientation: "vertical",\n      centerX: p50,\n      centerY: p50,\n      animationEasing: out(cubic),\n      exportable: false\n      //layer: 100\n    });\n\n    r("Polygon").setAll({\n      animationEasing: out(cubic)\n    });\n    {\n      const rule = r("PointedRectangle", ["tooltip", "background"]);\n      rule.setAll({\n        strokeOpacity: 0.9,\n        cornerRadius: 4,\n        pointerLength: 4,\n        pointerBaseWidth: 8,\n        fillOpacity: 0.9,\n        stroke: Color.fromHex(0xffffff)\n      });\n    }\n    {\n      const rule = r("Label", ["tooltip"]);\n      rule.setAll({\n        role: "tooltip",\n        populateText: true,\n        paddingRight: 0,\n        paddingTop: 0,\n        paddingLeft: 0,\n        paddingBottom: 0\n      });\n      setColor(rule, "fill", ic, "alternativeText");\n    }\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * core: Button\r\n     * ------------------------------------------------------------------------\r\n     */\n    r("Button").setAll({\n      paddingTop: 8,\n      paddingBottom: 8,\n      paddingLeft: 10,\n      paddingRight: 10,\n      interactive: true,\n      layout: horizontalLayout,\n      interactiveChildren: false,\n      setStateOnChildren: true,\n      focusable: true\n    });\n    r("Button").states.create("hover", {});\n    r("Button").states.create("down", {\n      stateAnimationDuration: 0\n    });\n    r("Button").states.create("active", {});\n    {\n      const rule = r("RoundedRectangle", ["button", "background"]);\n      setColor(rule, "fill", ic, "primaryButton");\n      setColor(rule, "stroke", ic, "primaryButtonStroke");\n    }\n    {\n      const rule = r("RoundedRectangle", ["button", "background"]).states.create("hover", {});\n      setColor(rule, "fill", ic, "primaryButtonHover");\n    }\n    {\n      const rule = r("RoundedRectangle", ["button", "background"]).states.create("down", {\n        stateAnimationDuration: 0\n      });\n      setColor(rule, "fill", ic, "primaryButtonDown");\n    }\n    {\n      const rule = r("RoundedRectangle", ["button", "background"]).states.create("active", {});\n      setColor(rule, "fill", ic, "primaryButtonActive");\n    }\n    {\n      const rule = r("Graphics", ["button", "icon"]);\n      setColor(rule, "stroke", ic, "primaryButtonText");\n    }\n    {\n      const rule = r("Label", ["button"]);\n      setColor(rule, "fill", ic, "primaryButtonText");\n    }\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * charts/xy: ZoomOutButton\r\n     * ------------------------------------------------------------------------\r\n     */\n    r("Button", ["zoom"]).setAll({\n      paddingTop: 18,\n      paddingBottom: 18,\n      paddingLeft: 12,\n      paddingRight: 12,\n      centerX: 46,\n      centerY: -10,\n      y: 0,\n      x: p100,\n      role: "button",\n      ariaLabel: language.translate("Zoom Out"),\n      layer: 30\n    });\n    {\n      const rule = r("RoundedRectangle", ["background", "button", "zoom"]);\n      rule.setAll({\n        cornerRadiusBL: 40,\n        cornerRadiusBR: 40,\n        cornerRadiusTL: 40,\n        cornerRadiusTR: 40\n      });\n      setColor(rule, "fill", ic, "primaryButton");\n    }\n    {\n      const rule = r("RoundedRectangle", ["background", "button", "zoom"]).states.create("hover", {});\n      setColor(rule, "fill", ic, "primaryButtonHover");\n    }\n    {\n      const rule = r("RoundedRectangle", ["background", "button", "zoom"]).states.create("down", {\n        stateAnimationDuration: 0\n      });\n      setColor(rule, "fill", ic, "primaryButtonDown");\n    }\n    {\n      const rule = r("Graphics", ["icon", "button", "zoom"]);\n      rule.setAll({\n        crisp: true,\n        strokeOpacity: 0.7,\n        draw: display => {\n          display.moveTo(0, 0);\n          display.lineTo(12, 0);\n        }\n      });\n      setColor(rule, "stroke", ic, "primaryButtonText");\n    }\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * core: ResizeButton\r\n     * ------------------------------------------------------------------------\r\n     */\n    r("Button", ["resize"]).setAll({\n      paddingTop: 9,\n      paddingBottom: 9,\n      paddingLeft: 13,\n      paddingRight: 13,\n      draggable: true,\n      centerX: p50,\n      centerY: p50,\n      position: "absolute",\n      role: "slider",\n      ariaValueMin: "0",\n      ariaValueMax: "100",\n      ariaLabel: language.translate("Use up and down arrows to move selection")\n    });\n    {\n      const rule = r("RoundedRectangle", ["background", "resize", "button"]);\n      rule.setAll({\n        cornerRadiusBL: 40,\n        cornerRadiusBR: 40,\n        cornerRadiusTL: 40,\n        cornerRadiusTR: 40\n      });\n      setColor(rule, "fill", ic, "secondaryButton");\n      setColor(rule, "stroke", ic, "secondaryButtonStroke");\n    }\n    {\n      const rule = r("RoundedRectangle", ["background", "resize", "button"]).states.create("hover", {});\n      setColor(rule, "fill", ic, "secondaryButtonHover");\n    }\n    {\n      const rule = r("RoundedRectangle", ["background", "resize", "button"]).states.create("down", {\n        stateAnimationDuration: 0\n      });\n      setColor(rule, "fill", ic, "secondaryButtonDown");\n    }\n    {\n      const rule = r("Graphics", ["resize", "button", "icon"]);\n      rule.setAll({\n        interactive: false,\n        crisp: true,\n        strokeOpacity: 0.5,\n        draw: display => {\n          display.moveTo(0, 0.5);\n          display.lineTo(0, 12.5);\n          display.moveTo(4, 0.5);\n          display.lineTo(4, 12.5);\n        }\n      });\n      setColor(rule, "stroke", ic, "secondaryButtonText");\n    }\n    r("Button", ["resize", "vertical"]).setAll({\n      rotation: 90,\n      cursorOverStyle: "ns-resize"\n    });\n    r("Button", ["resize", "horizontal"]).setAll({\n      cursorOverStyle: "ew-resize"\n    });\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * core: PlayButton\r\n     * ------------------------------------------------------------------------\r\n     */\n    r("Button", ["play"]).setAll({\n      paddingTop: 13,\n      paddingBottom: 13,\n      paddingLeft: 14,\n      paddingRight: 14,\n      ariaLabel: language.translate("Play"),\n      toggleKey: "active"\n    });\n    {\n      const rule = r("RoundedRectangle", ["play", "background"]);\n      rule.setAll({\n        strokeOpacity: 0.5,\n        cornerRadiusBL: 100,\n        cornerRadiusBR: 100,\n        cornerRadiusTL: 100,\n        cornerRadiusTR: 100\n      });\n      setColor(rule, "fill", ic, "primaryButton");\n    }\n    {\n      const rule = r("Graphics", ["play", "icon"]);\n      rule.setAll({\n        stateAnimationDuration: 0,\n        dx: 1,\n        draw: display => {\n          display.moveTo(0, -5);\n          display.lineTo(8, 0);\n          display.lineTo(0, 5);\n          display.lineTo(0, -5);\n        }\n      });\n      setColor(rule, "fill", ic, "primaryButtonText");\n    }\n    r("Graphics", ["play", "icon"]).states.create("default", {\n      stateAnimationDuration: 0\n    });\n    r("Graphics", ["play", "icon"]).states.create("active", {\n      stateAnimationDuration: 0,\n      draw: display => {\n        display.moveTo(-4, -5);\n        display.lineTo(-1, -5);\n        display.lineTo(-1, 5);\n        display.lineTo(-4, 5);\n        display.lineTo(-4, -5);\n        display.moveTo(4, -5);\n        display.lineTo(1, -5);\n        display.lineTo(1, 5);\n        display.lineTo(4, 5);\n        display.lineTo(4, -5);\n      }\n    });\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * core: SwitchButton\r\n     * ------------------------------------------------------------------------\r\n     */\n    r("Button", ["switch"]).setAll({\n      paddingTop: 4,\n      paddingBottom: 4,\n      paddingLeft: 4,\n      paddingRight: 4,\n      ariaLabel: language.translate("Press ENTER to toggle"),\n      toggleKey: "active",\n      width: 40,\n      height: 24,\n      layout: null\n    });\n    {\n      const rule = r("RoundedRectangle", ["switch", "background"]);\n      rule.setAll({\n        strokeOpacity: 0.5,\n        cornerRadiusBL: 100,\n        cornerRadiusBR: 100,\n        cornerRadiusTL: 100,\n        cornerRadiusTR: 100\n      });\n      setColor(rule, "fill", ic, "primaryButton");\n    }\n    {\n      const rule = r("Circle", ["switch", "icon"]);\n      rule.setAll({\n        radius: 8,\n        centerY: 0,\n        centerX: 0,\n        dx: 0\n      });\n      setColor(rule, "fill", ic, "primaryButtonText");\n    }\n    r("Graphics", ["switch", "icon"]).states.create("active", {\n      dx: 16\n    });\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * core: Scrollbar\r\n     * ------------------------------------------------------------------------\r\n     */\n    r("Scrollbar").setAll({\n      start: 0,\n      end: 1,\n      layer: 30,\n      animationEasing: out(cubic)\n    });\n    r("Scrollbar", ["vertical"]).setAll({\n      marginRight: 13,\n      marginLeft: 13,\n      minWidth: 12,\n      height: p100\n    });\n    r("Scrollbar", ["horizontal"]).setAll({\n      marginTop: 13,\n      marginBottom: 13,\n      minHeight: 12,\n      width: p100\n    });\n    this.rule("Button", ["scrollbar"]).setAll({\n      exportable: false\n    });\n    {\n      const rule = r("RoundedRectangle", ["scrollbar", "main", "background"]);\n      rule.setAll({\n        cornerRadiusTL: 8,\n        cornerRadiusBL: 8,\n        cornerRadiusTR: 8,\n        cornerRadiusBR: 8,\n        fillOpacity: 0.8\n      });\n      setColor(rule, "fill", ic, "fill");\n    }\n    {\n      const rule = r("RoundedRectangle", ["scrollbar", "thumb"]);\n      rule.setAll({\n        role: "slider",\n        ariaLive: "polite",\n        position: "absolute",\n        draggable: true\n      });\n      setColor(rule, "fill", ic, "secondaryButton");\n    }\n    {\n      const rule = r("RoundedRectangle", ["scrollbar", "thumb"]).states.create("hover", {});\n      setColor(rule, "fill", ic, "secondaryButtonHover");\n    }\n    {\n      const rule = r("RoundedRectangle", ["scrollbar", "thumb"]).states.create("down", {\n        stateAnimationDuration: 0\n      });\n      setColor(rule, "fill", ic, "secondaryButtonDown");\n    }\n    r("RoundedRectangle", ["scrollbar", "thumb", "vertical"]).setAll({\n      x: p50,\n      width: p100,\n      centerX: p50,\n      ariaLabel: language.translate("Use up and down arrows to move selection")\n    });\n    r("RoundedRectangle", ["scrollbar", "thumb", "horizontal"]).setAll({\n      y: p50,\n      centerY: p50,\n      height: p100,\n      ariaLabel: language.translate("Use left and right arrows to move selection")\n    });\n    // @todo: is this needed? used to be "ContentScrollbar"\n    // r("Scrollbar", ["content?"]).setAll({\n    // \tmarginRight: 0,\n    // \tmarginLeft: 5,\n    // \tlayer: 5\n    // });\n    /**\r\n     * ========================================================================\r\n     * charts/xy\r\n     * ========================================================================\r\n     *\r\n     * This needs to be in DefaultTheme because it\'s the only theme that is\r\n     * automatically applied to Root, and tooltips different ancestors\r\n     * than actual charts using them.\r\n     */\n    {\n      const rule = r("PointedRectangle", ["axis", "tooltip", "background"]);\n      rule.setAll({\n        cornerRadius: 0\n      });\n      setColor(rule, "fill", ic, "alternativeBackground");\n    }\n    r("Label", ["axis", "tooltip"]).setAll({\n      role: undefined\n    });\n    r("Label", ["axis", "tooltip", "y"]).setAll({\n      textAlign: "right"\n    });\n    r("Label", ["axis", "tooltip", "y", "opposite"]).setAll({\n      textAlign: "left"\n    });\n    r("Label", ["axis", "tooltip", "x"]).setAll({\n      textAlign: "center"\n    });\n    r("Tooltip", ["categoryaxis"]).setAll({\n      labelText: "{category}"\n    });\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * Shapes\r\n     * ------------------------------------------------------------------------\r\n     */\n    // Class: Graphics\n    r("Star").setAll({\n      spikes: 5,\n      innerRadius: 5,\n      radius: 10\n    });\n    // STOCK\n    r("Tooltip", ["stock"]).setAll({\n      paddingTop: 6,\n      paddingBottom: 5,\n      paddingLeft: 7,\n      paddingRight: 7\n    });\n    r("PointedRectangle", ["tooltip", "stock", "axis"]).setAll({\n      pointerLength: 0,\n      pointerBaseWidth: 0,\n      cornerRadius: 3\n    });\n    r("Label", ["tooltip", "stock"]).setAll({\n      fontSize: "0.8em"\n    });\n    // resizer\n    r("SpriteResizer").setAll({\n      rotationStep: 10,\n      isMeasured: false\n    });\n    {\n      const rule = r("Container", ["resizer", "grip"]);\n      rule.states.create("hover", {});\n    }\n    {\n      const rule = r("RoundedRectangle", ["resizer", "grip"]);\n      rule.setAll({\n        strokeOpacity: 0.7,\n        strokeWidth: 1,\n        fillOpacity: 1,\n        width: 12,\n        height: 12\n      });\n      setColor(rule, "fill", ic, "background");\n      setColor(rule, "stroke", ic, "alternativeBackground");\n    }\n    {\n      const rule = r("RoundedRectangle", ["resizer", "grip", "outline"]);\n      rule.setAll({\n        strokeOpacity: 0,\n        fillOpacity: 0,\n        width: 20,\n        height: 20\n      });\n      rule.states.create("hover", {\n        fillOpacity: 0.3\n      });\n      setColor(rule, "fill", ic, "alternativeBackground");\n    }\n    r("RoundedRectangle", ["resizer", "grip", "left"]).setAll({\n      cornerRadiusBL: 0,\n      cornerRadiusBR: 0,\n      cornerRadiusTL: 0,\n      cornerRadiusTR: 0\n    });\n    r("RoundedRectangle", ["resizer", "grip", "right"]).setAll({\n      cornerRadiusBL: 0,\n      cornerRadiusBR: 0,\n      cornerRadiusTL: 0,\n      cornerRadiusTR: 0\n    });\n    {\n      const rule = r("Rectangle", ["resizer", "rectangle"]);\n      rule.setAll({\n        strokeDasharray: [2, 2],\n        strokeOpacity: 0.5,\n        strokeWidth: 1\n      });\n      setColor(rule, "stroke", ic, "alternativeBackground");\n    }\n    r("Graphics", ["button", "plus", "icon"]).setAll({\n      x: p50,\n      y: p50,\n      draw: display => {\n        display.moveTo(-4, 0);\n        display.lineTo(4, 0);\n        display.moveTo(0, -4);\n        display.lineTo(0, 4);\n      }\n    });\n    r("Graphics", ["button", "minus", "icon"]).setAll({\n      x: p50,\n      y: p50,\n      draw: display => {\n        display.moveTo(-4, 0);\n        display.lineTo(4, 0);\n      }\n    });\n    r("Graphics", ["button", "home", "icon"]).setAll({\n      x: p50,\n      y: p50,\n      svgPath: "M 8 -1 L 6 -1 L 6 7 L 2 7 L 2 1 L -2 1 L -2 7 L -6 7 L -6 -1 L -8 -1 L 0 -9 L 8 -1 Z M 8 -1"\n    });\n    r("Button", ["zoomtools"]).setAll({\n      marginTop: 1,\n      marginBottom: 2\n    });\n    r("ZoomTools").setAll({\n      x: p100,\n      centerX: p100,\n      y: p100,\n      centerY: p100,\n      paddingRight: 10,\n      paddingBottom: 10\n    });\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Matrix.js\n/**\r\n * Modified from Pixi:\r\n *\r\n * The MIT License\r\n *\r\n * Copyright (c) 2013-2017 Mathew Groves, Chad Engler\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the "Software"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\n/**\r\n * @ignore\r\n */\nclass Matrix {\n  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    Object.defineProperty(this, "a", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "b", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "c", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "d", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "tx", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "ty", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n  }\n  /**\r\n   * Sets the matrix based on all the available properties\r\n   */\n  setTransform(x, y, pivotX, pivotY, rotation, scale = 1) {\n    this.a = Math.cos(rotation) * scale;\n    this.b = Math.sin(rotation) * scale;\n    this.c = -Math.sin(rotation) * scale;\n    this.d = Math.cos(rotation) * scale;\n    this.tx = x - (pivotX * this.a + pivotY * this.c);\n    this.ty = y - (pivotX * this.b + pivotY * this.d);\n  }\n  /**\r\n   * Get a new position with the current transformation applied.\r\n   * Can be used to go from a child\'s coordinate space to the world coordinate space. (e.g. rendering)\r\n   */\n  apply(origin) {\n    return {\n      x: this.a * origin.x + this.c * origin.y + this.tx,\n      y: this.b * origin.x + this.d * origin.y + this.ty\n    };\n  }\n  /**\r\n   * Get a new position with the inverse of the current transformation applied.\r\n   * Can be used to go from the world coordinate space to a child\'s coordinate space. (e.g. input)\r\n   */\n  applyInverse(origin) {\n    const id = 1 / (this.a * this.d + this.c * -this.b);\n    return {\n      x: this.d * id * origin.x + -this.c * id * origin.y + (this.ty * this.c - this.tx * this.d) * id,\n      y: this.a * id * origin.y + -this.b * id * origin.x + (-this.ty * this.a + this.tx * this.b) * id\n    };\n  }\n  /**\r\n   * Appends the given Matrix to this Matrix.\r\n   */\n  append(matrix) {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    this.a = matrix.a * a1 + matrix.b * c1;\n    this.b = matrix.a * b1 + matrix.b * d1;\n    this.c = matrix.c * a1 + matrix.d * c1;\n    this.d = matrix.c * b1 + matrix.d * d1;\n    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n  }\n  /**\r\n   * Prepends the given Matrix to this Matrix.\r\n   */\n  prepend(matrix) {\n    const tx1 = this.tx;\n    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n      const a1 = this.a;\n      const c1 = this.c;\n      this.a = a1 * matrix.a + this.b * matrix.c;\n      this.b = a1 * matrix.b + this.b * matrix.d;\n      this.c = c1 * matrix.a + this.d * matrix.c;\n      this.d = c1 * matrix.b + this.d * matrix.d;\n    }\n    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n  }\n  /**\r\n   * Copies the other matrix\'s properties into this matrix\r\n   */\n  copyFrom(matrix) {\n    this.a = matrix.a;\n    this.b = matrix.b;\n    this.c = matrix.c;\n    this.d = matrix.d;\n    this.tx = matrix.tx;\n    this.ty = matrix.ty;\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/svg-arc-to-cubic-bezier/modules/index.js\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i["return"]) _i["return"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError("Invalid attempt to destructure non-iterable instance");\n    }\n  };\n}();\nvar TAU = Math.PI * 2;\nvar mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {\n  var x = _ref.x,\n    y = _ref.y;\n  x *= rx;\n  y *= ry;\n  var xp = cosphi * x - sinphi * y;\n  var yp = sinphi * x + cosphi * y;\n  return {\n    x: xp + centerx,\n    y: yp + centery\n  };\n};\nvar approxUnitArc = function approxUnitArc(ang1, ang2) {\n  // If 90 degree circular arc, use a constant\n  // as derived from http://spencermortensen.com/articles/bezier-circle\n  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n  var x1 = Math.cos(ang1);\n  var y1 = Math.sin(ang1);\n  var x2 = Math.cos(ang1 + ang2);\n  var y2 = Math.sin(ang1 + ang2);\n  return [{\n    x: x1 - y1 * a,\n    y: y1 + x1 * a\n  }, {\n    x: x2 + y2 * a,\n    y: y2 - x2 * a\n  }, {\n    x: x2,\n    y: y2\n  }];\n};\nvar vectorAngle = function vectorAngle(ux, uy, vx, vy) {\n  var sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  var dot = ux * vx + uy * vy;\n  if (dot > 1) {\n    dot = 1;\n  }\n  if (dot < -1) {\n    dot = -1;\n  }\n  return sign * Math.acos(dot);\n};\nvar getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {\n  var rxsq = Math.pow(rx, 2);\n  var rysq = Math.pow(ry, 2);\n  var pxpsq = Math.pow(pxp, 2);\n  var pypsq = Math.pow(pyp, 2);\n  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;\n  if (radicant < 0) {\n    radicant = 0;\n  }\n  radicant /= rxsq * pypsq + rysq * pxpsq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n  var centerxp = radicant * rx / ry * pyp;\n  var centeryp = radicant * -ry / rx * pxp;\n  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;\n  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;\n  var vx1 = (pxp - centerxp) / rx;\n  var vy1 = (pyp - centeryp) / ry;\n  var vx2 = (-pxp - centerxp) / rx;\n  var vy2 = (-pyp - centeryp) / ry;\n  var ang1 = vectorAngle(1, 0, vx1, vy1);\n  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n  return [centerx, centery, ang1, ang2];\n};\nvar arcToBezier = function arcToBezier(_ref2) {\n  var px = _ref2.px,\n    py = _ref2.py,\n    cx = _ref2.cx,\n    cy = _ref2.cy,\n    rx = _ref2.rx,\n    ry = _ref2.ry,\n    _ref2$xAxisRotation = _ref2.xAxisRotation,\n    xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation,\n    _ref2$largeArcFlag = _ref2.largeArcFlag,\n    largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag,\n    _ref2$sweepFlag = _ref2.sweepFlag,\n    sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;\n  var curves = [];\n  if (rx === 0 || ry === 0) {\n    return [];\n  }\n  var sinphi = Math.sin(xAxisRotation * TAU / 360);\n  var cosphi = Math.cos(xAxisRotation * TAU / 360);\n  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;\n  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;\n  if (pxp === 0 && pyp === 0) {\n    return [];\n  }\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),\n    _getArcCenter2 = _slicedToArray(_getArcCenter, 4),\n    centerx = _getArcCenter2[0],\n    centery = _getArcCenter2[1],\n    ang1 = _getArcCenter2[2],\n    ang2 = _getArcCenter2[3];\n\n  // If \'ang2\' == 90.0000000001, then `ratio` will evaluate to\n  // 1.0000000001. This causes `segments` to be greater than one, which is an\n  // unecessary split, and adds extra points to the bezier curve. To alleviate\n  // this issue, we round to 1.0 when the ratio is close to 1.0.\n\n  var ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1.0 - ratio) < 0.0000001) {\n    ratio = 1.0;\n  }\n  var segments = Math.max(Math.ceil(ratio), 1);\n  ang2 /= segments;\n  for (var i = 0; i < segments; i++) {\n    curves.push(approxUnitArc(ang1, ang2));\n    ang1 += ang2;\n  }\n  return curves.map(function (curve) {\n    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),\n      x1 = _mapToEllipse.x,\n      y1 = _mapToEllipse.y;\n    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),\n      x2 = _mapToEllipse2.x,\n      y2 = _mapToEllipse2.y;\n    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),\n      x = _mapToEllipse3.x,\n      y = _mapToEllipse3.y;\n    return {\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2,\n      x: x,\n      y: y\n    };\n  });\n};\n/* harmony default export */ const modules = (arcToBezier);\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/backend/CanvasRenderer.js\n/** @ignore */ /** */\n\n\n\n\n//import { Throttler } from "../../util/Throttler";\n\n\n\n\n\n\n\n\n/**\r\n * @ignore\r\n */\nfunction checkArgs(name, actual, expected) {\n  if (actual !== expected) {\n    throw new Error("Required " + expected + " arguments for " + name + " but got " + actual);\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction checkMinArgs(name, actual, expected) {\n  if (actual < expected) {\n    throw new Error("Required at least " + expected + " arguments for " + name + " but got " + actual);\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction checkEvenArgs(name, actual, expected) {\n  checkMinArgs(name, actual, expected);\n  if (actual % expected !== 0) {\n    throw new Error("Arguments for " + name + " must be in pairs of " + expected);\n  }\n}\n/**\r\n * @ignore\r\n * This splits the flag so that way 0017 will be processed as 0 0 17\r\n *\r\n * This is important for weird paths like `M17 5A1 1 0 0017 30 1 1 0 0017 5`\r\n */\nfunction splitArcFlags(args) {\n  for (let i = 0; i < args.length; i += 7) {\n    let index = i + 3;\n    let flag = args[index];\n    if (flag.length > 1) {\n      const a = /^([01])([01])(.*)$/.exec(flag);\n      if (a !== null) {\n        args.splice(index, 0, a[1]);\n        ++index;\n        args.splice(index, 0, a[2]);\n        ++index;\n        if (a[3].length > 0) {\n          args[index] = a[3];\n        } else {\n          args.splice(index, 1);\n        }\n      }\n    }\n    ++index;\n    flag = args[index];\n    if (flag.length > 1) {\n      const a = /^([01])(.+)$/.exec(flag);\n      if (a !== null) {\n        args.splice(index, 0, a[1]);\n        ++index;\n        args[index] = a[2];\n      }\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction assertBinary(value) {\n  if (value === 0 || value === 1) {\n    return value;\n  } else {\n    throw new Error("Flag must be 0 or 1");\n  }\n}\n//  1 -> 0xffffff * (2 / 2)\n//  2 -> 0xffffff * (1 / 2)\n//\n//  3 -> 0xffffff * (3 / 4)\n//  4 -> 0xffffff * (1 / 4)\n//\n//  5 -> 0xffffff * (7 / 8)\n//  6 -> 0xffffff * (5 / 8)\n//  7 -> 0xffffff * (3 / 8)\n//  8 -> 0xffffff * (1 / 8)\n//\n//  9 -> 0xffffff * (15 / 16)\n// 10 -> 0xffffff * (13 / 16)\n// 11 -> 0xffffff * (11 / 16)\n// 12 -> 0xffffff *  (9 / 16)\n// 13 -> 0xffffff *  (7 / 16)\n// 14 -> 0xffffff *  (5 / 16)\n// 15 -> 0xffffff *  (3 / 16)\n// 16 -> 0xffffff *  (1 / 16)\n// @todo remove this old color distribution algo if the new one pans out\n/*function distributeId(id: number): number {\r\n    if (id === 1) {\r\n        return 0x000001;\r\n\r\n    } else {\r\n        // Finds the closest power of 2\r\n        const base = Math.pow(2, Math.ceil(Math.log(id) / Math.log(2)));\r\n\r\n        // Translates the id into an odd fraction index\r\n        const index = ((base - id) * 2) + 1;\r\n\r\n        // TODO is Math.round correct ?\r\n        return Math.round(0xffffff * (index / base));\r\n    }\r\n}*/\n/**\r\n * Function by smeans:\r\n * https://lowcode.life/generating-unique-contrasting-colors-in-javascript/\r\n * @ignore\r\n */\nfunction distributeId(id) {\n  const rgb = [0, 0, 0];\n  for (let i = 0; i < 24; i++) {\n    rgb[i % 3] <<= 1;\n    rgb[i % 3] |= id & 0x01;\n    id >>= 1;\n  }\n  return (rgb[0] | 0) + (rgb[1] << 8) + (rgb[2] << 16);\n}\n/**\r\n * @ignore\r\n */\nfunction eachTargets(hitTarget, f) {\n  for (;;) {\n    if (hitTarget.interactive) {\n      if (!f(hitTarget)) {\n        break;\n      }\n    }\n    if (hitTarget._parent) {\n      hitTarget = hitTarget._parent;\n    } else {\n      break;\n    }\n  }\n}\n// TODO feature detection for mouse/touch/pointer\n/**\r\n * @ignore\r\n */\nfunction onPointerEvent(element, name, f) {\n  return Utils_addEventListener(element, getRendererEvent(name), event => {\n    const target = getEventTarget(event);\n    let touches = event.touches;\n    if (touches) {\n      if (touches.length == 0) {\n        touches = event.changedTouches;\n      }\n      f(copy(touches), target);\n    } else {\n      f([event], target);\n    }\n  });\n}\n/**\r\n * @ignore\r\n */\nfunction isTainted(image) {\n  const canvas = document.createElement("canvas");\n  canvas.width = 1;\n  canvas.height = 1;\n  const context = canvas.getContext("2d", {\n    willReadFrequently: true\n  });\n  context.drawImage(image, 0, 0, 1, 1);\n  try {\n    context.getImageData(0, 0, 1, 1);\n    return false;\n  } catch (err) {\n    console.warn("Image \\"" + image.src + "\\" is loaded from different host and is not covered by CORS policy. For more information about the implications read here: https://www.amcharts.com/docs/v5/concepts/cors");\n    return true;\n  }\n}\n/**\r\n * This is needed to workaround a bug in iOS which causes it to not GC canvas elements.\r\n *\r\n * @ignore\r\n */\nfunction clearCanvas(view) {\n  view.width = 0;\n  view.height = 0;\n  view.style.width = "0px";\n  view.style.height = "0px";\n}\n/**\r\n * Aligns the coordinate to the pixel, so it renders crisp\r\n *\r\n * @ignore\r\n */\nfunction crisp(x) {\n  return Math.floor(x) + .5;\n}\n/**\r\n * @ignore\r\n */\nclass CanvasPivot {\n  constructor() {\n    Object.defineProperty(this, "_x", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_y", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n  }\n  get x() {\n    return this._x;\n  }\n  get y() {\n    return this._y;\n  }\n  set x(value) {\n    this._x = value;\n  }\n  set y(value) {\n    this._y = value;\n  }\n}\n/**\r\n * @ignore\r\n */\nclass CanvasDisplayObject extends Disposer_DisposerClass {\n  constructor(renderer) {\n    super();\n    Object.defineProperty(this, "_layer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "mask", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, "visible", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, "exportable", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, "interactive", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "inactive", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, "wheelable", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "cancelTouch", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "isMeasured", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "buttonMode", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "alpha", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, "compoundAlpha", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, "angle", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "scale", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, "x", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "y", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "crisp", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "pivot", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new CanvasPivot()\n    });\n    Object.defineProperty(this, "filter", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "cursorOverStyle", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_replacedCursorStyle", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_localMatrix", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Matrix()\n    });\n    Object.defineProperty(this, "_matrix", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Matrix()\n    });\n    // TODO can this be replaced with _localMatrix ?\n    Object.defineProperty(this, "_uMatrix", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Matrix()\n    });\n    Object.defineProperty(this, "_renderer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_parent", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_localBounds", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_bounds", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_colorId", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._renderer = renderer;\n  }\n  subStatus(status) {\n    return {\n      inactive: this.inactive == null ? status.inactive : this.inactive,\n      layer: this._layer || status.layer\n    };\n  }\n  _dispose() {\n    this._renderer._removeObject(this);\n    this.getLayer().dirty = true;\n  }\n  getCanvas() {\n    return this.getLayer().view;\n  }\n  getLayer() {\n    let self = this;\n    for (;;) {\n      if (self._layer) {\n        return self._layer;\n      } else if (self._parent) {\n        self = self._parent;\n      } else {\n        return this._renderer.defaultLayer;\n      }\n    }\n  }\n  setLayer(order, margin) {\n    if (order == null) {\n      this._layer = undefined;\n    } else {\n      const visible = true;\n      this._layer = this._renderer.getLayer(order, visible);\n      this._layer.visible = visible;\n      this._layer.margin = margin;\n      if (margin) {\n        setInteractive(this._layer.view, false);\n      }\n      this._renderer._ghostLayer.setMargin(this._renderer.layers);\n      if (this._parent) {\n        this._parent.registerChildLayer(this._layer);\n      }\n      this._layer.dirty = true;\n      this._renderer.resizeLayer(this._layer);\n      this._renderer.resizeGhost();\n    }\n  }\n  markDirtyLayer() {\n    this.getLayer().dirty = true;\n  }\n  clear() {\n    this.invalidateBounds();\n  }\n  invalidateBounds() {\n    this._localBounds = undefined;\n  }\n  _addBounds(_bounds) {}\n  _getColorId() {\n    if (this._colorId === undefined) {\n      this._colorId = this._renderer.paintId(this);\n    }\n    return this._colorId;\n  }\n  _isInteractive(status) {\n    return !status.inactive && (this.interactive || this._renderer._forceInteractive > 0);\n  }\n  _isInteractiveMask(status) {\n    return this._isInteractive(status);\n  }\n  contains(child) {\n    for (;;) {\n      if (child === this) {\n        return true;\n      } else if (child._parent) {\n        child = child._parent;\n      } else {\n        return false;\n      }\n    }\n  }\n  toGlobal(point) {\n    return this._matrix.apply(point);\n  }\n  toLocal(point) {\n    return this._matrix.applyInverse(point);\n  }\n  getLocalMatrix() {\n    this._uMatrix.setTransform(0, 0, this.pivot.x, this.pivot.y, this.angle * Math.PI / 180, this.scale);\n    return this._uMatrix;\n  }\n  getLocalBounds() {\n    if (!this._localBounds) {\n      const bn = 10000000;\n      this._localBounds = {\n        left: bn,\n        top: bn,\n        right: -bn,\n        bottom: -bn\n      };\n      this._addBounds(this._localBounds);\n    }\n    return this._localBounds;\n  }\n  getAdjustedBounds(bounds) {\n    this._setMatrix();\n    const matrix = this.getLocalMatrix();\n    const p0 = matrix.apply({\n      x: bounds.left,\n      y: bounds.top\n    });\n    const p1 = matrix.apply({\n      x: bounds.right,\n      y: bounds.top\n    });\n    const p2 = matrix.apply({\n      x: bounds.right,\n      y: bounds.bottom\n    });\n    const p3 = matrix.apply({\n      x: bounds.left,\n      y: bounds.bottom\n    });\n    return {\n      left: Math.min(p0.x, p1.x, p2.x, p3.x),\n      top: Math.min(p0.y, p1.y, p2.y, p3.y),\n      right: Math.max(p0.x, p1.x, p2.x, p3.x),\n      bottom: Math.max(p0.y, p1.y, p2.y, p3.y)\n    };\n  }\n  on(key, callback, context) {\n    if (this.interactive) {\n      return this._renderer._addEvent(this, key, callback, context);\n    } else {\n      return new Disposer(() => {});\n    }\n  }\n  _setMatrix() {\n    // TODO only calculate this if it has actually changed\n    this._localMatrix.setTransform(this.x, this.y, this.pivot.x, this.pivot.y,\n    // Converts degrees to radians\n    this.angle * Math.PI / 180, this.scale);\n    this._matrix.copyFrom(this._localMatrix);\n    if (this._parent) {\n      // TODO only calculate this if it has actually changed\n      this._matrix.prepend(this._parent._matrix);\n    }\n  }\n  _transform(context, resolution) {\n    const m = this._matrix;\n    let tx = m.tx * resolution;\n    let ty = m.ty * resolution;\n    if (this.crisp) {\n      tx = crisp(tx);\n      ty = crisp(ty);\n    }\n    context.setTransform(m.a * resolution, m.b * resolution, m.c * resolution, m.d * resolution, tx, ty);\n  }\n  _transformMargin(context, resolution, margin) {\n    const m = this._matrix;\n    context.setTransform(m.a * resolution, m.b * resolution, m.c * resolution, m.d * resolution, (m.tx + margin.left) * resolution, (m.ty + margin.top) * resolution);\n  }\n  _transformLayer(context, resolution, layer) {\n    if (layer.margin) {\n      this._transformMargin(context, layer.scale || resolution, layer.margin);\n    } else {\n      this._transform(context, layer.scale || resolution);\n    }\n  }\n  render(status) {\n    if (this.visible && (this.exportable !== false || !this._renderer._omitTainted)) {\n      this._setMatrix();\n      const subStatus = this.subStatus(status);\n      const resolution = this._renderer.resolution;\n      const layers = this._renderer.layers;\n      const ghostLayer = this._renderer._ghostLayer;\n      const ghostContext = ghostLayer.context;\n      const mask = this.mask;\n      if (mask) {\n        mask._setMatrix();\n      }\n      // TODO improve this\n      each(layers, layer => {\n        if (layer) {\n          const context = layer.context;\n          context.save();\n          // We must apply the mask before we transform the element\n          if (mask) {\n            mask._transformLayer(context, resolution, layer);\n            mask._runPath(context);\n            context.clip();\n          }\n          context.globalAlpha = this.compoundAlpha * this.alpha;\n          this._transformLayer(context, resolution, layer);\n          if (this.filter) {\n            context.filter = this.filter;\n          }\n        }\n      });\n      ghostContext.save();\n      // We must apply the mask before we transform the element\n      if (mask && this._isInteractiveMask(subStatus)) {\n        mask._transformMargin(ghostContext, resolution, ghostLayer.margin);\n        mask._runPath(ghostContext);\n        ghostContext.clip();\n      }\n      this._transformMargin(ghostContext, resolution, ghostLayer.margin);\n      this._render(subStatus);\n      ghostContext.restore();\n      each(layers, layer => {\n        if (layer) {\n          layer.context.restore();\n        }\n      });\n    }\n  }\n  _render(status) {\n    if (this.exportable === false) {\n      status.layer.tainted = true;\n    }\n  }\n  hovering() {\n    return this._renderer._hovering.has(this);\n  }\n  dragging() {\n    return this._renderer._dragging.some(x => x.value === this);\n  }\n  shouldCancelTouch() {\n    const renderer = this._renderer;\n    if (renderer.tapToActivate && !renderer._touchActive) {\n      return false;\n    }\n    if (this.cancelTouch) {\n      return true;\n    } else if (this._parent) {\n      return this._parent.shouldCancelTouch();\n    }\n    return false;\n  }\n}\n/**\r\n * @ignore\r\n */\nclass CanvasContainer extends CanvasDisplayObject {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "interactiveChildren", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, "_childLayers", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_children", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n  }\n  _isInteractiveMask(status) {\n    return this.interactiveChildren || super._isInteractiveMask(status);\n  }\n  addChild(child) {\n    child._parent = this;\n    this._children.push(child);\n    if (child._layer) {\n      this.registerChildLayer(child._layer);\n    }\n  }\n  addChildAt(child, index) {\n    child._parent = this;\n    this._children.splice(index, 0, child);\n    if (child._layer) {\n      this.registerChildLayer(child._layer);\n    }\n  }\n  removeChild(child) {\n    child._parent = undefined;\n    removeFirst(this._children, child);\n  }\n  _render(status) {\n    super._render(status);\n    const renderer = this._renderer;\n    if (this.interactive && this.interactiveChildren) {\n      ++renderer._forceInteractive;\n    }\n    each(this._children, child => {\n      child.compoundAlpha = this.compoundAlpha * this.alpha;\n      child.render(status);\n    });\n    if (this.interactive && this.interactiveChildren) {\n      --renderer._forceInteractive;\n    }\n  }\n  registerChildLayer(layer) {\n    if (!this._childLayers) {\n      this._childLayers = [];\n    }\n    pushOne(this._childLayers, layer);\n    if (this._parent) {\n      this._parent.registerChildLayer(layer);\n    }\n  }\n  markDirtyLayer(deep = false) {\n    super.markDirtyLayer();\n    if (deep && this._childLayers) {\n      each(this._childLayers, layer => layer.dirty = true);\n    }\n  }\n  _dispose() {\n    super._dispose();\n    if (this._childLayers) {\n      each(this._childLayers, layer => {\n        layer.dirty = true;\n      });\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction setPoint(bounds, point) {\n  bounds.left = Math.min(bounds.left, point.x);\n  bounds.top = Math.min(bounds.top, point.y);\n  bounds.right = Math.max(bounds.right, point.x);\n  bounds.bottom = Math.max(bounds.bottom, point.y);\n}\n/**\r\n * @ignore\r\n */\nclass Op {\n  colorize(_context, _forceColor) {}\n  colorizeGhost(context, forceColor) {\n    this.colorize(context, forceColor);\n  }\n  path(_context) {}\n  pathGhost(context) {\n    this.path(context);\n  }\n  addBounds(_bounds) {}\n}\n/**\r\n * @ignore\r\n */\nclass BeginPath extends Op {\n  colorize(context, _forceColor) {\n    context.beginPath();\n  }\n}\n/**\r\n * @ignore\r\n */\nclass BeginFill extends Op {\n  constructor(color) {\n    super();\n    Object.defineProperty(this, "color", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: color\n    });\n  }\n  colorize(context, forceColor) {\n    if (forceColor !== undefined) {\n      context.fillStyle = forceColor;\n    } else {\n      context.fillStyle = this.color;\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nclass EndFill extends Op {\n  constructor(clearShadow) {\n    super();\n    Object.defineProperty(this, "clearShadow", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: clearShadow\n    });\n  }\n  colorize(context, _forceColor) {\n    context.fill();\n    if (this.clearShadow) {\n      context.shadowColor = "";\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nclass EndStroke extends Op {\n  colorize(context, _forceColor) {\n    context.stroke();\n  }\n}\n/**\r\n * @ignore\r\n */\nclass LineStyle extends Op {\n  constructor(width, color, lineJoin) {\n    super();\n    Object.defineProperty(this, "width", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: width\n    });\n    Object.defineProperty(this, "color", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: color\n    });\n    Object.defineProperty(this, "lineJoin", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: lineJoin\n    });\n  }\n  colorize(context, forceColor) {\n    if (forceColor !== undefined) {\n      context.strokeStyle = forceColor;\n    } else {\n      context.strokeStyle = this.color;\n    }\n    context.lineWidth = this.width;\n    if (this.lineJoin) {\n      context.lineJoin = this.lineJoin;\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nclass LineDash extends Op {\n  constructor(dash) {\n    super();\n    Object.defineProperty(this, "dash", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: dash\n    });\n  }\n  colorize(context, _forceColor) {\n    context.setLineDash(this.dash);\n  }\n}\n/**\r\n * @ignore\r\n */\nclass LineDashOffset extends Op {\n  constructor(dashOffset) {\n    super();\n    Object.defineProperty(this, "dashOffset", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: dashOffset\n    });\n  }\n  colorize(context, _forceColor) {\n    context.lineDashOffset = this.dashOffset;\n  }\n}\n/**\r\n * @ignore\r\n */\nclass DrawRect extends Op {\n  constructor(x, y, width, height) {\n    super();\n    Object.defineProperty(this, "x", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(this, "y", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n    Object.defineProperty(this, "width", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: width\n    });\n    Object.defineProperty(this, "height", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: height\n    });\n  }\n  path(context) {\n    context.rect(this.x, this.y, this.width, this.height);\n  }\n  addBounds(bounds) {\n    const l = this.x;\n    const t = this.y;\n    const r = l + this.width;\n    const b = t + this.height;\n    setPoint(bounds, {\n      x: l,\n      y: t\n    });\n    setPoint(bounds, {\n      x: r,\n      y: t\n    });\n    setPoint(bounds, {\n      x: l,\n      y: b\n    });\n    setPoint(bounds, {\n      x: r,\n      y: b\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass DrawCircle extends Op {\n  constructor(x, y, radius) {\n    super();\n    Object.defineProperty(this, "x", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(this, "y", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n    Object.defineProperty(this, "radius", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radius\n    });\n  }\n  path(context) {\n    context.moveTo(this.x + this.radius, this.y);\n    context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);\n  }\n  // TODO handle skewing and rotation\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.x - this.radius,\n      y: this.y - this.radius\n    });\n    setPoint(bounds, {\n      x: this.x + this.radius,\n      y: this.y + this.radius\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass DrawEllipse extends Op {\n  constructor(x, y, radiusX, radiusY) {\n    super();\n    Object.defineProperty(this, "x", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(this, "y", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n    Object.defineProperty(this, "radiusX", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radiusX\n    });\n    Object.defineProperty(this, "radiusY", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radiusY\n    });\n  }\n  path(context) {\n    context.ellipse(0, 0, this.radiusX, this.radiusY, 0, 0, Math.PI * 2);\n  }\n  // TODO handle skewing and rotation\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.x - this.radiusX,\n      y: this.y - this.radiusY\n    });\n    setPoint(bounds, {\n      x: this.x + this.radiusX,\n      y: this.y + this.radiusY\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass Arc extends Op {\n  constructor(cx, cy, radius, startAngle, endAngle, anticlockwise) {\n    super();\n    Object.defineProperty(this, "cx", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cx\n    });\n    Object.defineProperty(this, "cy", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cy\n    });\n    Object.defineProperty(this, "radius", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radius\n    });\n    Object.defineProperty(this, "startAngle", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: startAngle\n    });\n    Object.defineProperty(this, "endAngle", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: endAngle\n    });\n    Object.defineProperty(this, "anticlockwise", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: anticlockwise\n    });\n  }\n  path(context) {\n    if (this.radius > 0) {\n      context.arc(this.cx, this.cy, this.radius, this.startAngle, this.endAngle, this.anticlockwise);\n    }\n  }\n  addBounds(bounds) {\n    let arcBounds = getArcBounds(this.cx, this.cy, this.startAngle * DEGREES, this.endAngle * DEGREES, this.radius);\n    setPoint(bounds, {\n      x: arcBounds.left,\n      y: arcBounds.top\n    });\n    setPoint(bounds, {\n      x: arcBounds.right,\n      y: arcBounds.bottom\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass ArcTo extends Op {\n  constructor(x1, y1, x2, y2, radius) {\n    super();\n    Object.defineProperty(this, "x1", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x1\n    });\n    Object.defineProperty(this, "y1", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y1\n    });\n    Object.defineProperty(this, "x2", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x2\n    });\n    Object.defineProperty(this, "y2", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y2\n    });\n    Object.defineProperty(this, "radius", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radius\n    });\n  }\n  path(context) {\n    if (this.radius > 0) {\n      context.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius);\n    }\n  }\n  // TODO: add points\n  addBounds(_bounds) {\n    /*\r\n    // not finished\r\n    https://math.stackexchange.com/questions/1781438/finding-the-center-of-a-circle-given-two-points-and-a-radius-algebraically\r\n      if (prevPoint) {\r\n        let x1 = prevPoint.x;\r\n        let y1 = prevPoint.y;\r\n        let x2 = this.x2;\r\n        let y2 = this.y2;\r\n        let r = this.radius;\r\n          let xa = (x2 - x1) / 2;\r\n        let ya = (y2 - y1) / 2;\r\n          let x0 = x1 + xa;\r\n        let y0 = y1 + ya;\r\n          let a = Math.hypot(xa, ya);\r\n        let b = Math.sqrt(r * r - a * a);\r\n          let cx = x0 + b * ya / a;\r\n        let cy = y0 - b * xa / a;\r\n          console.log(cx, cy);\r\n    }*/\n  }\n}\n/**\r\n * @ignore\r\n */\nclass LineTo extends Op {\n  constructor(x, y) {\n    super();\n    Object.defineProperty(this, "x", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(this, "y", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n  }\n  path(context) {\n    context.lineTo(this.x, this.y);\n  }\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.x,\n      y: this.y\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass MoveTo extends Op {\n  constructor(x, y) {\n    super();\n    Object.defineProperty(this, "x", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(this, "y", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n  }\n  path(context) {\n    context.moveTo(this.x, this.y);\n  }\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.x,\n      y: this.y\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass ClosePath extends Op {\n  path(context) {\n    context.closePath();\n  }\n}\n/**\r\n * @ignore\r\n */\nclass BezierCurveTo extends Op {\n  constructor(cpX, cpY, cpX2, cpY2, toX, toY) {\n    super();\n    Object.defineProperty(this, "cpX", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpX\n    });\n    Object.defineProperty(this, "cpY", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpY\n    });\n    Object.defineProperty(this, "cpX2", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpX2\n    });\n    Object.defineProperty(this, "cpY2", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpY2\n    });\n    Object.defineProperty(this, "toX", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: toX\n    });\n    Object.defineProperty(this, "toY", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: toY\n    });\n  }\n  path(context) {\n    context.bezierCurveTo(this.cpX, this.cpY, this.cpX2, this.cpY2, this.toX, this.toY);\n  }\n  // TODO: OK?\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.cpX,\n      y: this.cpY\n    });\n    setPoint(bounds, {\n      x: this.cpX2,\n      y: this.cpY2\n    });\n    setPoint(bounds, {\n      x: this.toX,\n      y: this.toY\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass QuadraticCurveTo extends Op {\n  constructor(cpX, cpY, toX, toY) {\n    super();\n    Object.defineProperty(this, "cpX", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpX\n    });\n    Object.defineProperty(this, "cpY", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpY\n    });\n    Object.defineProperty(this, "toX", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: toX\n    });\n    Object.defineProperty(this, "toY", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: toY\n    });\n  }\n  path(context) {\n    context.quadraticCurveTo(this.cpX, this.cpY, this.toX, this.toY);\n  }\n  // TODO: OK?\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.cpX,\n      y: this.cpY\n    });\n    setPoint(bounds, {\n      x: this.toX,\n      y: this.toY\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass Shadow extends Op {\n  constructor(color, blur, offsetX, offsetY, opacity) {\n    super();\n    Object.defineProperty(this, "color", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: color\n    });\n    Object.defineProperty(this, "blur", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: blur\n    });\n    Object.defineProperty(this, "offsetX", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: offsetX\n    });\n    Object.defineProperty(this, "offsetY", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: offsetY\n    });\n    Object.defineProperty(this, "opacity", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: opacity\n    });\n  }\n  colorize(context, _forceColor) {\n    if (this.opacity) {\n      context.fillStyle = this.color;\n    }\n    context.shadowColor = this.color;\n    context.shadowBlur = this.blur;\n    context.shadowOffsetX = this.offsetX;\n    context.shadowOffsetY = this.offsetY;\n  }\n  colorizeGhost(_context, _forceColor) {}\n}\n/**\r\n * @ignore\r\n */\nclass GraphicsImage extends Op {\n  constructor(image, width, height, x, y) {\n    super();\n    Object.defineProperty(this, "image", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: image\n    });\n    Object.defineProperty(this, "width", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: width\n    });\n    Object.defineProperty(this, "height", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: height\n    });\n    Object.defineProperty(this, "x", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(this, "y", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n  }\n  path(context) {\n    context.drawImage(this.image, this.x, this.y, this.width, this.height);\n  }\n  // TODO: OK?\n  addBounds(bounds) {\n    setPoint(bounds, {\n      x: this.x,\n      y: this.y\n    });\n    setPoint(bounds, {\n      x: this.width,\n      y: this.height\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass CanvasGraphics extends CanvasDisplayObject {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_operations", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "blendMode", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: BlendMode.NORMAL\n    });\n    Object.defineProperty(this, "_hasShadows", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_fillAlpha", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_strokeAlpha", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  clear() {\n    super.clear();\n    this._operations.length = 0;\n  }\n  _pushOp(op) {\n    this._operations.push(op);\n  }\n  beginFill(color, alpha = 1) {\n    this._fillAlpha = alpha;\n    if (color) {\n      if (color instanceof Color) {\n        this._pushOp(new BeginFill(color.toCSS(alpha)));\n      } else {\n        this.isMeasured = true;\n        this._pushOp(new BeginFill(color));\n      }\n    } else {\n      this._pushOp(new BeginFill("rgba(0, 0, 0, " + alpha + ")"));\n    }\n  }\n  endFill() {\n    this._pushOp(new EndFill(this._hasShadows));\n  }\n  endStroke() {\n    this._pushOp(new EndStroke());\n  }\n  beginPath() {\n    this._pushOp(new BeginPath());\n  }\n  lineStyle(width = 0, color, alpha = 1, lineJoin) {\n    this._strokeAlpha = alpha;\n    if (color) {\n      if (color instanceof Color) {\n        this._pushOp(new LineStyle(width, color.toCSS(alpha), lineJoin));\n      } else {\n        this._pushOp(new LineStyle(width, color, lineJoin));\n      }\n    } else {\n      this._pushOp(new LineStyle(width, "rgba(0, 0, 0, " + alpha + ")", lineJoin));\n    }\n  }\n  setLineDash(dash) {\n    this._pushOp(new LineDash(dash ? dash : []));\n  }\n  setLineDashOffset(dashOffset = 0) {\n    this._pushOp(new LineDashOffset(dashOffset));\n  }\n  drawRect(x, y, width, height) {\n    this._pushOp(new DrawRect(x, y, width, height));\n  }\n  drawCircle(x, y, radius) {\n    this._pushOp(new DrawCircle(x, y, radius));\n  }\n  drawEllipse(x, y, radiusX, radiusY) {\n    this._pushOp(new DrawEllipse(x, y, radiusX, radiusY));\n  }\n  arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {\n    this._pushOp(new Arc(cx, cy, radius, startAngle, endAngle, anticlockwise));\n  }\n  arcTo(x1, y1, x2, y2, radius) {\n    this._pushOp(new ArcTo(x1, y1, x2, y2, radius));\n  }\n  lineTo(x, y) {\n    this._pushOp(new LineTo(x, y));\n  }\n  moveTo(x, y) {\n    this._pushOp(new MoveTo(x, y));\n  }\n  bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {\n    this._pushOp(new BezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY));\n  }\n  quadraticCurveTo(cpX, cpY, toX, toY) {\n    this._pushOp(new QuadraticCurveTo(cpX, cpY, toX, toY));\n  }\n  closePath() {\n    this._pushOp(new ClosePath());\n  }\n  shadow(color, blur = 0, offsetX = 0, offsetY = 0, opacity) {\n    this._hasShadows = true;\n    this._pushOp(new Shadow(opacity ? color.toCSS(opacity) : color.toCSS(this._fillAlpha || this._strokeAlpha), blur, offsetX, offsetY));\n  }\n  image(image, width, height, x, y) {\n    this._pushOp(new GraphicsImage(image, width, height, x, y));\n  }\n  // https://svgwg.org/svg2-draft/paths.html#DProperty\n  // TODO better error checking\n  svgPath(path) {\n    let x = 0;\n    let y = 0;\n    let cpx = null;\n    let cpy = null;\n    let qcpx = null;\n    let qcpy = null;\n    const SEGMENTS_REGEXP = /([MmZzLlHhVvCcSsQqTtAa])([^MmZzLlHhVvCcSsQqTtAa]*)/g;\n    const ARGS_REGEXP = /[\\u0009\\u0020\\u000A\\u000C\\u000D]*([\\+\\-]?[0-9]*\\.?[0-9]+(?:[eE][\\+\\-]?[0-9]+)?)[\\u0009\\u0020\\u000A\\u000C\\u000D]*,?/g;\n    let match;\n    while ((match = SEGMENTS_REGEXP.exec(path)) !== null) {\n      const name = match[1];\n      const rest = match[2];\n      const args = [];\n      while ((match = ARGS_REGEXP.exec(rest)) !== null) {\n        args.push(match[1]);\n      }\n      // Reset control point\n      if (name !== "S" && name !== "s" && name !== "C" && name !== "c") {\n        cpx = null;\n        cpy = null;\n      }\n      // Reset control point\n      if (name !== "Q" && name !== "q" && name !== "T" && name !== "t") {\n        qcpx = null;\n        qcpy = null;\n      }\n      switch (name) {\n        case "M":\n          checkEvenArgs(name, args.length, 2);\n          x = +args[0];\n          y = +args[1];\n          this.moveTo(x, y);\n          for (let i = 2; i < args.length; i += 2) {\n            x = +args[i];\n            y = +args[i + 1];\n            this.lineTo(x, y);\n          }\n          break;\n        case "m":\n          checkEvenArgs(name, args.length, 2);\n          x += +args[0];\n          y += +args[1];\n          this.moveTo(x, y);\n          for (let i = 2; i < args.length; i += 2) {\n            x += +args[i];\n            y += +args[i + 1];\n            this.lineTo(x, y);\n          }\n          break;\n        case "L":\n          checkEvenArgs(name, args.length, 2);\n          for (let i = 0; i < args.length; i += 2) {\n            x = +args[i];\n            y = +args[i + 1];\n            this.lineTo(x, y);\n          }\n          break;\n        case "l":\n          checkEvenArgs(name, args.length, 2);\n          for (let i = 0; i < args.length; i += 2) {\n            x += +args[i];\n            y += +args[i + 1];\n            this.lineTo(x, y);\n          }\n          break;\n        case "H":\n          checkMinArgs(name, args.length, 1);\n          for (let i = 0; i < args.length; ++i) {\n            x = +args[i];\n            this.lineTo(x, y);\n          }\n          break;\n        case "h":\n          checkMinArgs(name, args.length, 1);\n          for (let i = 0; i < args.length; ++i) {\n            x += +args[i];\n            this.lineTo(x, y);\n          }\n          break;\n        case "V":\n          checkMinArgs(name, args.length, 1);\n          for (let i = 0; i < args.length; ++i) {\n            y = +args[i];\n            this.lineTo(x, y);\n          }\n          break;\n        case "v":\n          checkMinArgs(name, args.length, 1);\n          for (let i = 0; i < args.length; ++i) {\n            y += +args[i];\n            this.lineTo(x, y);\n          }\n          break;\n        case "C":\n          checkEvenArgs(name, args.length, 6);\n          for (let i = 0; i < args.length; i += 6) {\n            const x1 = +args[i];\n            const y1 = +args[i + 1];\n            cpx = +args[i + 2];\n            cpy = +args[i + 3];\n            x = +args[i + 4];\n            y = +args[i + 5];\n            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n          }\n          break;\n        case "c":\n          checkEvenArgs(name, args.length, 6);\n          for (let i = 0; i < args.length; i += 6) {\n            const x1 = +args[i] + x;\n            const y1 = +args[i + 1] + y;\n            cpx = +args[i + 2] + x;\n            cpy = +args[i + 3] + y;\n            x += +args[i + 4];\n            y += +args[i + 5];\n            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n          }\n          break;\n        case "S":\n          checkEvenArgs(name, args.length, 4);\n          if (cpx === null || cpy === null) {\n            cpx = x;\n            cpy = y;\n          }\n          for (let i = 0; i < args.length; i += 4) {\n            const x1 = 2 * x - cpx;\n            const y1 = 2 * y - cpy;\n            cpx = +args[i];\n            cpy = +args[i + 1];\n            x = +args[i + 2];\n            y = +args[i + 3];\n            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n          }\n          break;\n        case "s":\n          checkEvenArgs(name, args.length, 4);\n          if (cpx === null || cpy === null) {\n            cpx = x;\n            cpy = y;\n          }\n          for (let i = 0; i < args.length; i += 4) {\n            const x1 = 2 * x - cpx;\n            const y1 = 2 * y - cpy;\n            cpx = +args[i] + x;\n            cpy = +args[i + 1] + y;\n            x += +args[i + 2];\n            y += +args[i + 3];\n            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n          }\n          break;\n        case "Q":\n          checkEvenArgs(name, args.length, 4);\n          for (let i = 0; i < args.length; i += 4) {\n            qcpx = +args[i];\n            qcpy = +args[i + 1];\n            x = +args[i + 2];\n            y = +args[i + 3];\n            this.quadraticCurveTo(qcpx, qcpy, x, y);\n          }\n          break;\n        case "q":\n          checkEvenArgs(name, args.length, 4);\n          for (let i = 0; i < args.length; i += 4) {\n            qcpx = +args[i] + x;\n            qcpy = +args[i + 1] + y;\n            x += +args[i + 2];\n            y += +args[i + 3];\n            this.quadraticCurveTo(qcpx, qcpy, x, y);\n          }\n          break;\n        case "T":\n          checkEvenArgs(name, args.length, 2);\n          if (qcpx === null || qcpy === null) {\n            qcpx = x;\n            qcpy = y;\n          }\n          for (let i = 0; i < args.length; i += 2) {\n            qcpx = 2 * x - qcpx;\n            qcpy = 2 * y - qcpy;\n            x = +args[i];\n            y = +args[i + 1];\n            this.quadraticCurveTo(qcpx, qcpy, x, y);\n          }\n          break;\n        case "t":\n          checkEvenArgs(name, args.length, 2);\n          if (qcpx === null || qcpy === null) {\n            qcpx = x;\n            qcpy = y;\n          }\n          for (let i = 0; i < args.length; i += 2) {\n            qcpx = 2 * x - qcpx;\n            qcpy = 2 * y - qcpy;\n            x += +args[i];\n            y += +args[i + 1];\n            this.quadraticCurveTo(qcpx, qcpy, x, y);\n          }\n          break;\n        case "A":\n        case "a":\n          const relative = name === "a";\n          splitArcFlags(args);\n          checkEvenArgs(name, args.length, 7);\n          for (let i = 0; i < args.length; i += 7) {\n            let cx = +args[i + 5];\n            let cy = +args[i + 6];\n            if (relative) {\n              cx += x;\n              cy += y;\n            }\n            const bs = modules({\n              px: x,\n              py: y,\n              rx: +args[i],\n              ry: +args[i + 1],\n              xAxisRotation: +args[i + 2],\n              largeArcFlag: assertBinary(+args[i + 3]),\n              sweepFlag: assertBinary(+args[i + 4]),\n              cx,\n              cy\n            });\n            each(bs, b => {\n              this.bezierCurveTo(b.x1, b.y1, b.x2, b.y2, b.x, b.y);\n              x = b.x;\n              y = b.y;\n            });\n          }\n          break;\n        case "Z":\n        case "z":\n          checkArgs(name, args.length, 0);\n          this.closePath();\n          break;\n      }\n    }\n  }\n  _runPath(context) {\n    context.beginPath();\n    each(this._operations, op => {\n      op.path(context);\n    });\n  }\n  _render(status) {\n    super._render(status);\n    const layerDirty = status.layer.dirty;\n    const interactive = this._isInteractive(status);\n    if (layerDirty || interactive) {\n      const context = status.layer.context;\n      const ghostContext = this._renderer._ghostLayer.context;\n      if (layerDirty) {\n        context.globalCompositeOperation = this.blendMode;\n        context.beginPath();\n      }\n      let color;\n      if (interactive) {\n        ghostContext.beginPath();\n        color = this._getColorId();\n      }\n      each(this._operations, op => {\n        if (layerDirty) {\n          op.path(context);\n          op.colorize(context, undefined);\n        }\n        if (interactive) {\n          op.pathGhost(ghostContext);\n          op.colorizeGhost(ghostContext, color);\n        }\n      });\n    }\n  }\n  renderDetached(context) {\n    if (this.visible) {\n      this._setMatrix();\n      context.save();\n      // We must apply the mask before we transform the element\n      const mask = this.mask;\n      if (mask) {\n        mask._setMatrix();\n        mask._transform(context, 1);\n        mask._runPath(context);\n        context.clip();\n      }\n      // TODO handle compoundAlpha somehow ?\n      context.globalAlpha = this.compoundAlpha * this.alpha;\n      this._transform(context, 1);\n      if (this.filter) {\n        context.filter = this.filter;\n      }\n      context.globalCompositeOperation = this.blendMode;\n      context.beginPath();\n      each(this._operations, op => {\n        op.path(context);\n        op.colorize(context, undefined);\n      });\n      context.restore();\n    }\n  }\n  _addBounds(bounds) {\n    if (this.visible && this.isMeasured) {\n      each(this._operations, op => {\n        op.addBounds(bounds);\n      });\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nclass CanvasText extends CanvasDisplayObject {\n  constructor(renderer, text, style) {\n    super(renderer);\n    Object.defineProperty(this, "text", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "style", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "resolution", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, "textVisible", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, "_textInfo", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_originalScale", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    this.text = text;\n    this.style = style;\n  }\n  invalidateBounds() {\n    super.invalidateBounds();\n    this._textInfo = undefined;\n  }\n  _shared(context) {\n    if (this.style.textAlign) {\n      context.textAlign = this.style.textAlign;\n    }\n    if (this.style.direction) {\n      context.direction = this.style.direction;\n    }\n    if (this.style.textBaseline) {\n      context.textBaseline = this.style.textBaseline;\n    }\n  }\n  _prerender(status, ignoreGhost = false, ignoreFontWeight = false) {\n    super._render(status);\n    const context = status.layer.context;\n    const ghostContext = this._renderer._ghostLayer.context;\n    // Font style\n    const style = this.style;\n    let fontStyle = this._getFontStyle(undefined, ignoreFontWeight);\n    context.font = fontStyle;\n    if (this._isInteractive(status) && !ignoreGhost) {\n      ghostContext.font = fontStyle;\n    }\n    // Other parameters\n    if (style.fill) {\n      if (style.fill instanceof Color) {\n        context.fillStyle = style.fill.toCSS(style.fillOpacity != undefined ? style.fillOpacity : 1);\n      } else {\n        context.fillStyle = style.fill;\n      }\n    }\n    if (style.shadowColor) {\n      status.layer.context.shadowColor = style.shadowColor.toCSS(style.shadowOpacity || 1);\n    }\n    if (style.shadowBlur) {\n      status.layer.context.shadowBlur = style.shadowBlur;\n    }\n    if (style.shadowOffsetX) {\n      status.layer.context.shadowOffsetX = style.shadowOffsetX;\n    }\n    if (style.shadowOffsetY) {\n      status.layer.context.shadowOffsetY = style.shadowOffsetY;\n    }\n    this._shared(context);\n    if (this._isInteractive(status) && !ignoreGhost) {\n      ghostContext.fillStyle = this._getColorId();\n      this._shared(ghostContext);\n    }\n  }\n  _getFontStyle(style2, ignoreFontWeight = false) {\n    // Process defaults\n    const style = this.style;\n    let fontStyle = [];\n    if (style2 && style2.fontVariant) {\n      fontStyle.push(style2.fontVariant);\n    } else if (style.fontVariant) {\n      fontStyle.push(style.fontVariant);\n    }\n    if (!ignoreFontWeight) {\n      if (style2 && style2.fontWeight) {\n        fontStyle.push(style2.fontWeight);\n      } else if (style.fontWeight) {\n        fontStyle.push(style.fontWeight);\n      }\n    }\n    if (style2 && style2.fontStyle) {\n      fontStyle.push(style2.fontStyle);\n    } else if (style.fontStyle) {\n      fontStyle.push(style.fontStyle);\n    }\n    if (style2 && style2.fontSize) {\n      if (Type_isNumber(style2.fontSize)) {\n        style2.fontSize = style2.fontSize + "px";\n      }\n      fontStyle.push(style2.fontSize);\n    } else if (style.fontSize) {\n      if (Type_isNumber(style.fontSize)) {\n        style.fontSize = style.fontSize + "px";\n      }\n      fontStyle.push(style.fontSize);\n    }\n    if (style2 && style2.fontFamily) {\n      fontStyle.push(style2.fontFamily);\n    } else if (style.fontFamily) {\n      fontStyle.push(style.fontFamily);\n    } else if (fontStyle.length) {\n      fontStyle.push("Arial");\n    }\n    return fontStyle.join(" ");\n  }\n  _render(status) {\n    // We need measurements in order to properly position text for alignment\n    if (!this._textInfo) {\n      this._measure(status);\n    }\n    if (this.textVisible) {\n      const interactive = this._isInteractive(status);\n      const context = status.layer.context;\n      const layerDirty = status.layer.dirty;\n      const ghostContext = this._renderer._ghostLayer.context;\n      context.save();\n      ghostContext.save();\n      this._prerender(status);\n      // const lines = this.text.toString().replace(/\\r/g, "").split(/\\n/);\n      // const x = this._localBounds && (this._localBounds.left < 0) ? Math.abs(this._localBounds.left) : 0;\n      // Process text info produced by _measure()\n      each(this._textInfo, (line, _index) => {\n        each(line.textChunks, (chunk, _index) => {\n          // Set style\n          if (chunk.style) {\n            context.save();\n            ghostContext.save();\n            context.font = chunk.style;\n            if (this._isInteractive(status)) {\n              ghostContext.font = chunk.style;\n            }\n          }\n          if (chunk.fill) {\n            context.save();\n            context.fillStyle = chunk.fill.toCSS();\n            // Color does not affect ghostContext so we not set it\n          }\n          // Draw text\n          if (layerDirty) {\n            context.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);\n          }\n          // Draw underline\n          if (chunk.textDecoration == "underline" || chunk.textDecoration == "line-through") {\n            let thickness = 1;\n            let offset = 1;\n            let fontSize = chunk.height;\n            let offsetX = chunk.offsetX;\n            switch (this.style.textAlign) {\n              case "right":\n              case "end":\n                offsetX -= chunk.width;\n                break;\n              case "center":\n                offsetX -= chunk.width / 2;\n                break;\n            }\n            if (chunk.style) {\n              const format = TextFormatter.getTextStyle(chunk.style);\n              switch (format.fontWeight) {\n                case "bolder":\n                case "bold":\n                case "700":\n                case "800":\n                case "900":\n                  thickness = 2;\n                  break;\n              }\n            }\n            if (fontSize) {\n              offset = fontSize / 20;\n            }\n            let y;\n            if (chunk.textDecoration == "line-through") {\n              y = thickness + line.offsetY + chunk.offsetY - chunk.height / 2;\n            } else {\n              y = thickness + offset * 1.5 + line.offsetY + chunk.offsetY;\n            }\n            context.save();\n            context.beginPath();\n            if (chunk.fill) {\n              context.strokeStyle = chunk.fill.toCSS();\n            } else if (this.style.fill && this.style.fill instanceof Color) {\n              context.strokeStyle = this.style.fill.toCSS();\n            }\n            context.lineWidth = thickness * offset;\n            context.moveTo(offsetX, y);\n            context.lineTo(offsetX + chunk.width, y);\n            context.stroke();\n            context.restore();\n          }\n          if (interactive && this.interactive) {\n            // Draw text in ghost canvas ONLY if it is set as interactive\n            // explicitly. This way we avoid hit test anomalies caused by anti\n            // aliasing of text.\n            ghostContext.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);\n          }\n          if (chunk.fill) {\n            context.restore();\n            // Color does not affect ghostContext so we not set it\n          }\n          // Reset style\n          if (chunk.style) {\n            context.restore();\n            ghostContext.restore();\n          }\n        });\n      });\n      context.restore();\n      ghostContext.restore();\n    }\n  }\n  _addBounds(bounds) {\n    if (this.visible && this.isMeasured) {\n      //if (this._textVisible) {\n      const x = this._measure({\n        inactive: this.inactive,\n        layer: this.getLayer()\n      });\n      setPoint(bounds, {\n        x: x.left,\n        y: x.top\n      });\n      setPoint(bounds, {\n        x: x.right,\n        y: x.bottom\n      });\n      //}\n    }\n  }\n\n  _ignoreFontWeight() {\n    return /apple/i.test(navigator.vendor);\n  }\n  _measure(status) {\n    const context = status.layer.context;\n    const ghostContext = this._renderer._ghostLayer.context;\n    const rtl = this.style.direction == "rtl";\n    // Reset text info\n    this._textInfo = [];\n    // Init\n    const oversizedBehavior = this.style.oversizedBehavior;\n    const maxWidth = this.style.maxWidth;\n    const truncate = Type_isNumber(maxWidth) && oversizedBehavior == "truncate";\n    const wrap = Type_isNumber(maxWidth) && (oversizedBehavior == "wrap" || oversizedBehavior == "wrap-no-break");\n    // Pre-render\n    context.save();\n    ghostContext.save();\n    this._prerender(status, true, this._ignoreFontWeight());\n    // Get default font metrix\n    const refText = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";\n    // Split up text into lines\n    const lines = this.text.toString().replace(/\\r/g, "").split(/\\n/);\n    let styleRestored = true;\n    let minX = 0;\n    let maxX = 0;\n    // Iterate through the lines\n    let offsetY = 0;\n    let currentStyle;\n    each(lines, (line, _index) => {\n      // Split up line into format/value chunks\n      let chunks;\n      if (line == "") {\n        chunks = [{\n          type: "value",\n          text: ""\n        }];\n      } else {\n        chunks = TextFormatter.chunk(line, false, this.style.ignoreFormatting);\n      }\n      while (chunks.length > 0) {\n        // Init line object\n        let lineInfo = {\n          offsetY: offsetY,\n          ascent: 0,\n          width: 0,\n          height: 0,\n          left: 0,\n          right: 0,\n          textChunks: []\n        };\n        // Measure reference text\n        const metrics = this._measureText(refText, context);\n        const height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n        lineInfo.height = height;\n        lineInfo.ascent = metrics.actualBoundingBoxAscent;\n        let currentFormat;\n        let currentDecoration = this.style.textDecoration;\n        let currentFill;\n        let currentChunkWidth;\n        let skipFurtherText = false;\n        let firstTextChunk = true;\n        let leftoverChunks = [];\n        let currentVerticalAlign;\n        //let offsetX = 0;\n        //let chunk;\n        //while(chunk = chunks.shift()) {\n        eachContinue(chunks, (chunk, index) => {\n          // Format chunk\n          if (chunk.type == "format") {\n            if (chunk.text == "[/]") {\n              if (!styleRestored) {\n                context.restore();\n                ghostContext.restore();\n                styleRestored = true;\n              }\n              currentFill = undefined;\n              currentStyle = undefined;\n              currentChunkWidth = undefined;\n              currentDecoration = this.style.textDecoration;\n              currentVerticalAlign = undefined;\n              currentFormat = chunk.text;\n            } else {\n              if (!styleRestored) {\n                context.restore();\n                ghostContext.restore();\n              }\n              let format = TextFormatter.getTextStyle(chunk.text);\n              const fontStyle = this._getFontStyle(format);\n              context.save();\n              ghostContext.save();\n              context.font = fontStyle;\n              currentStyle = fontStyle;\n              currentFormat = chunk.text;\n              if (format.textDecoration) {\n                currentDecoration = format.textDecoration;\n              }\n              if (format.fill) {\n                currentFill = format.fill;\n              }\n              if (format.width) {\n                currentChunkWidth = Type_toNumber(format.width);\n              }\n              if (format.verticalAlign) {\n                currentVerticalAlign = format.verticalAlign;\n              }\n              styleRestored = false;\n              // Measure reference text after change of format\n              const metrics = this._measureText(refText, context);\n              const height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n              if (height > lineInfo.height) {\n                lineInfo.height = height;\n              }\n              if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {\n                lineInfo.ascent = metrics.actualBoundingBoxAscent;\n              }\n            }\n          }\n          // Text chunk\n          else if (chunk.type == "value" && !skipFurtherText) {\n            // Measure\n            const metrics = this._measureText(chunk.text, context);\n            let chunkWidth = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;\n            // Check for fit\n            if (truncate) {\n              // Break words?\n              let breakWords = firstTextChunk || this.style.breakWords || false;\n              // Measure ellipsis and check if it fits\n              const ellipsis = this.style.ellipsis || "";\n              const ellipsisMetrics = this._measureText(ellipsis, context);\n              const ellipsisWidth = ellipsisMetrics.actualBoundingBoxLeft + ellipsisMetrics.actualBoundingBoxRight;\n              // Check fit\n              if (lineInfo.width + chunkWidth > maxWidth) {\n                const excessWidth = maxWidth - lineInfo.width - ellipsisWidth;\n                chunk.text = this._truncateText(context, chunk.text, excessWidth, breakWords);\n                chunk.text += ellipsis;\n                skipFurtherText = true;\n              }\n            } else if (wrap) {\n              // Check fit\n              if (lineInfo.width + chunkWidth > maxWidth) {\n                const excessWidth = maxWidth - lineInfo.width;\n                const tmpText = this._truncateText(context, chunk.text, excessWidth, false, firstTextChunk && this.style.oversizedBehavior != "wrap-no-break");\n                if (tmpText == "") {\n                  // Unable to fit a single letter - hide the whole label\n                  this.textVisible = true;\n                  return false;\n                }\n                //skipFurtherText = true;\n                //Add remaining chunks for the next line\n                leftoverChunks = chunks.slice(index + 1);\n                //Add remaining text of current chunk if it was forced-cut\n                if (Utils_trim(tmpText) != Utils_trim(chunk.text)) {\n                  leftoverChunks.unshift({\n                    type: "value",\n                    text: chunk.text.substr(tmpText.length)\n                  });\n                  if (currentFormat) {\n                    leftoverChunks.unshift({\n                      type: "format",\n                      text: currentFormat\n                    });\n                  }\n                }\n                // Set current chunk (truncated)\n                chunk.text = Utils_trim(tmpText);\n                chunks = [];\n                skipFurtherText = true;\n              }\n            }\n            // Chunk width?\n            let leftBoundMod = 1;\n            let rightBoundMod = 1;\n            if (currentStyle && currentChunkWidth && currentChunkWidth > chunkWidth) {\n              // increase horizontal bounding boxes accordingly\n              const boundsMod = chunkWidth / currentChunkWidth;\n              switch (this.style.textAlign) {\n                case "right":\n                case "end":\n                  leftBoundMod = boundsMod;\n                  break;\n                case "center":\n                  leftBoundMod = boundsMod;\n                  rightBoundMod = boundsMod;\n                  break;\n                default:\n                  rightBoundMod = boundsMod;\n              }\n              chunkWidth = currentChunkWidth;\n            }\n            const chunkHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n            if (chunkHeight > lineInfo.height) {\n              lineInfo.height = chunkHeight;\n            }\n            if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {\n              lineInfo.ascent = metrics.actualBoundingBoxAscent;\n            }\n            lineInfo.width += chunkWidth;\n            lineInfo.left += metrics.actualBoundingBoxLeft / leftBoundMod;\n            lineInfo.right += metrics.actualBoundingBoxRight / rightBoundMod;\n            lineInfo.textChunks.push({\n              style: currentStyle,\n              fill: currentFill,\n              text: chunk.text,\n              width: chunkWidth,\n              height: chunkHeight,\n              left: metrics.actualBoundingBoxLeft,\n              right: metrics.actualBoundingBoxRight,\n              ascent: metrics.actualBoundingBoxAscent,\n              offsetX: 0,\n              offsetY: 0,\n              textDecoration: currentDecoration,\n              verticalAlign: currentVerticalAlign\n            });\n            //offsetX += chunkWidth;\n            firstTextChunk = false;\n          }\n          if (leftoverChunks) {\n            //return false;\n          }\n          return true;\n          //}\n        });\n\n        if (this.style.lineHeight instanceof Percent) {\n          lineInfo.height *= this.style.lineHeight.value;\n          lineInfo.ascent *= this.style.lineHeight.value;\n        } else {\n          lineInfo.height *= this.style.lineHeight || 1.2;\n          lineInfo.ascent *= this.style.lineHeight || 1.2;\n        }\n        if (minX < lineInfo.left) {\n          minX = lineInfo.left;\n        }\n        if (maxX < lineInfo.right) {\n          maxX = lineInfo.right;\n        }\n        this._textInfo.push(lineInfo);\n        //lineInfo.offsetY += lineInfo.ascent;\n        offsetY += lineInfo.height;\n        // Reset chunks so that it can proceed to the next line\n        chunks = leftoverChunks || [];\n      }\n    });\n    if (!styleRestored) {\n      context.restore();\n      ghostContext.restore();\n    }\n    // Adjust chunk internal offsets\n    each(this._textInfo, (lineInfo, _index) => {\n      let currentChunkOffset = 0;\n      each(lineInfo.textChunks, chunk => {\n        chunk.offsetX = currentChunkOffset + chunk.left - lineInfo.left;\n        chunk.offsetY += lineInfo.height - lineInfo.height * (this.style.baselineRatio || 0.19);\n        currentChunkOffset += chunk.width;\n        if (chunk.verticalAlign) {\n          switch (chunk.verticalAlign) {\n            case "super":\n              chunk.offsetY -= lineInfo.height / 2 - chunk.height / 2;\n              break;\n            case "sub":\n              chunk.offsetY += chunk.height / 2;\n              break;\n          }\n        }\n      });\n    });\n    const bounds = {\n      left: rtl ? -maxX : -minX,\n      top: 0,\n      right: rtl ? minX : maxX,\n      bottom: offsetY\n    };\n    // We need to fit?\n    if (oversizedBehavior !== "none") {\n      const ratio = this._fitRatio(bounds);\n      if (ratio < 1) {\n        if (oversizedBehavior == "fit") {\n          if (Type_isNumber(this.style.minScale) && ratio < this.style.minScale) {\n            this.textVisible = false;\n            bounds.left = 0;\n            bounds.top = 0;\n            bounds.right = 0;\n            bounds.bottom = 0;\n          } else {\n            if (!this._originalScale || this._originalScale == 1) {\n              this._originalScale = this.scale;\n            }\n            this.scale = ratio;\n            this.textVisible = true;\n          }\n        } else if (oversizedBehavior == "hide") {\n          this.textVisible = false;\n          bounds.left = 0;\n          bounds.top = 0;\n          bounds.right = 0;\n          bounds.bottom = 0;\n        } else {\n          switch (this.style.textAlign) {\n            case "right":\n            case "end":\n              bounds.left = -maxWidth;\n              bounds.right = 0;\n              break;\n            case "center":\n              bounds.left = -maxWidth / 2;\n              bounds.right = maxWidth / 2;\n              break;\n            default:\n              bounds.left = 0;\n              bounds.right = maxWidth;\n          }\n          this.scale = this._originalScale || 1;\n          this._originalScale = undefined;\n          this.textVisible = true;\n        }\n      } else {\n        this.scale = this._originalScale || 1;\n        this._originalScale = undefined;\n        this.textVisible = true;\n      }\n    }\n    context.restore();\n    ghostContext.restore();\n    return bounds;\n  }\n  _fitRatio(bounds) {\n    const maxW = this.style.maxWidth;\n    const maxH = this.style.maxHeight;\n    if (!Type_isNumber(maxW) && !Type_isNumber(maxH)) {\n      return 1;\n    }\n    const w = bounds.right - bounds.left;\n    const h = bounds.bottom - bounds.top;\n    return Math.min(maxW / w || 1, maxH / h || 1);\n  }\n  _truncateText(context, text, maxWidth, breakWords = false, fallbackBreakWords = true) {\n    let width;\n    do {\n      if (breakWords) {\n        text = text.slice(0, -1);\n      } else {\n        let tmp = text.replace(/[^,;:!?\\\\\\/\\s​]+[,;:!?\\\\\\/\\s​]*$/g, "");\n        if ((tmp == "" || tmp === text) && fallbackBreakWords) {\n          breakWords = true;\n        } else if (tmp == "") {\n          return text;\n        } else {\n          text = tmp;\n        }\n      }\n      const metrics = this._measureText(text, context);\n      width = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;\n    } while (width > maxWidth && text != "");\n    return text;\n  }\n  _measureText(text, context) {\n    let metrics = context.measureText(text);\n    let fakeMetrics = {};\n    if (metrics.actualBoundingBoxAscent == null) {\n      const div = document.createElement("div");\n      div.innerText = text;\n      div.style.visibility = "hidden";\n      div.style.position = "absolute";\n      div.style.top = "-1000000px;";\n      div.style.fontFamily = this.style.fontFamily || "";\n      div.style.fontSize = this.style.fontSize + "";\n      document.body.appendChild(div);\n      const bbox = div.getBoundingClientRect();\n      document.body.removeChild(div);\n      const h = bbox.height;\n      const w = metrics.width;\n      let left = 0;\n      let right = w;\n      fakeMetrics = {\n        actualBoundingBoxAscent: h,\n        actualBoundingBoxDescent: 0,\n        actualBoundingBoxLeft: left,\n        actualBoundingBoxRight: right,\n        fontBoundingBoxAscent: h,\n        fontBoundingBoxDescent: 0,\n        width: w\n      };\n      //return fake;\n    } else {\n      fakeMetrics = {\n        actualBoundingBoxAscent: metrics.actualBoundingBoxAscent,\n        actualBoundingBoxDescent: metrics.actualBoundingBoxDescent,\n        actualBoundingBoxLeft: metrics.actualBoundingBoxLeft,\n        actualBoundingBoxRight: metrics.actualBoundingBoxRight,\n        fontBoundingBoxAscent: metrics.actualBoundingBoxAscent,\n        fontBoundingBoxDescent: metrics.actualBoundingBoxDescent,\n        width: metrics.width\n      };\n    }\n    const w = metrics.width;\n    switch (this.style.textAlign) {\n      case "right":\n      case "end":\n        fakeMetrics.actualBoundingBoxLeft = w;\n        fakeMetrics.actualBoundingBoxRight = 0;\n        break;\n      case "center":\n        fakeMetrics.actualBoundingBoxLeft = w / 2;\n        fakeMetrics.actualBoundingBoxRight = w / 2;\n        break;\n      default:\n        fakeMetrics.actualBoundingBoxLeft = 0;\n        fakeMetrics.actualBoundingBoxRight = w;\n    }\n    return fakeMetrics;\n  }\n}\n/**\r\n * @ignore\r\n */\nclass CanvasTextStyle {\n  constructor() {\n    //public wordWrapWidth: number = 100;\n    Object.defineProperty(this, "fill", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "fillOpacity", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "textAlign", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "fontFamily", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "fontSize", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "fontWeight", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "fontStyle", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "fontVariant", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "textDecoration", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "shadowColor", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "shadowBlur", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "shadowOffsetX", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "shadowOffsetY", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "shadowOpacity", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    // leading?: number;\n    // letterSpacing?: number;\n    Object.defineProperty(this, "lineHeight", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: percent(120)\n    });\n    Object.defineProperty(this, "baselineRatio", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0.19\n    });\n    // padding?: number;\n    // stroke?: number;\n    // strokeThickness?: number;\n    // trim?: number;\n    // wordWrap?: boolean;\n    Object.defineProperty(this, "direction", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "textBaseline", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "oversizedBehavior", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: "none"\n    });\n    Object.defineProperty(this, "breakWords", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "ellipsis", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: "…"\n    });\n    Object.defineProperty(this, "maxWidth", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "maxHeight", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "minScale", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "ignoreFormatting", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n  }\n}\n/**\r\n * @ignore\r\n */\nclass CanvasRadialText extends CanvasText {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "textType", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: "circular"\n    });\n    Object.defineProperty(this, "radius", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "startAngle", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "inside", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "orientation", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: "auto"\n    });\n    Object.defineProperty(this, "kerning", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_textReversed", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n  }\n  _render(status) {\n    switch (this.textType) {\n      case "circular":\n        this._renderCircular(status);\n        break;\n      default:\n        super._render(status);\n        break;\n    }\n  }\n  _renderCircular(status) {\n    if (this.textVisible) {\n      this._prerender(status);\n      const interactive = this._isInteractive(status);\n      const context = status.layer.context;\n      const layerDirty = status.layer.dirty;\n      const ghostContext = this._renderer._ghostLayer.context;\n      // Savepoint\n      context.save();\n      if (interactive) {\n        ghostContext.save();\n      }\n      // We need measurements in order to properly position text for alignment\n      if (!this._textInfo) {\n        this._measure(status);\n      }\n      // Init\n      let radius = this.radius || 0;\n      let startAngle = this.startAngle || 0;\n      let deltaAngle = 0;\n      let orientation = this.orientation;\n      let inward = orientation == "auto" ? "auto" : orientation == "inward";\n      const inside = this.inside;\n      const align = this.style.textAlign || "left";\n      const kerning = this.kerning || 0;\n      let clockwise = align == "left" ? 1 : -1;\n      const shouldReverse = !this._textReversed;\n      // Check if we need to invert the whole stuff\n      if (inward == "auto") {\n        // Calc max angle so we know whether we need to flip it\n        let maxAngle = 0;\n        let midAngle = 0;\n        each(this._textInfo, (line, _index) => {\n          const deltaAngle = startAngle + line.width / (radius - line.height) / 2 * -clockwise;\n          if (deltaAngle > maxAngle) {\n            maxAngle = deltaAngle;\n          }\n        });\n        if (align == "left") {\n          midAngle = (maxAngle + deltaAngle / 2) * DEGREES;\n        } else if (align == "right") {\n          midAngle = (maxAngle - deltaAngle / 2) * DEGREES;\n        } else {\n          midAngle = startAngle * DEGREES;\n        }\n        midAngle = normalizeAngle(midAngle);\n        inward = midAngle >= 270 || midAngle <= 90;\n      }\n      if (inward == true && shouldReverse) {\n        this._textInfo.reverse();\n        this._textReversed = true;\n      }\n      // if ((inward == false && align == "left") || (inward == true && align == "right")) {\n      // \tclockwise *= -1;\n      // }\n      // Process text info produced by _measure()\n      each(this._textInfo, (line, _index) => {\n        const textHeight = line.height;\n        // Adjust radius (for `inside = false`)\n        // Radius adjustment for `inside = false` is below the line calculation\n        if (!inside) {\n          radius += textHeight;\n        }\n        // Reverse letters if we\'re painting them counter-clockwise\n        if ((clockwise == -1 && inward || clockwise == 1 && !inward) && shouldReverse) {\n          line.textChunks.reverse();\n        }\n        // Init angles\n        let lineStartAngle = startAngle;\n        deltaAngle = 0;\n        // Adjust for center-align\n        if (align == "center") {\n          lineStartAngle += line.width / (radius - textHeight) / 2 * -clockwise;\n          deltaAngle = lineStartAngle - startAngle;\n        }\n        // if (inward == "auto") {\n        // \tlet midAngle;\n        // \tif (align == "left") {\n        // \t\tmidAngle = (lineStartAngle + deltaAngle / 2) * $math.DEGREES;\n        // \t}\n        // \telse if () {\n        // \t\tmidAngle = (lineStartAngle - deltaAngle / 2) * $math.DEGREES;\n        // \t}\n        // \tinward = (midAngle >= 270) || (midAngle <= 90);\n        // }\n        // Rotate letters if they are facing outward\n        lineStartAngle += Math.PI * (inward ? 0 : 1); // Rotate 180 if outward\n        // Savepoint\n        context.save();\n        if (interactive) {\n          ghostContext.save();\n        }\n        // Assume starting angle\n        context.rotate(lineStartAngle);\n        if (interactive) {\n          ghostContext.rotate(lineStartAngle);\n        }\n        let angleShift = 0;\n        each(line.textChunks, (chunk, _index) => {\n          // Draw the letter\n          const char = chunk.text;\n          const charWidth = chunk.width;\n          // Rotate half a letter\n          angleShift = charWidth / 2 / (radius - textHeight) * clockwise;\n          context.rotate(angleShift);\n          if (interactive) {\n            ghostContext.rotate(angleShift);\n          }\n          // Set style\n          if (chunk.style) {\n            context.save();\n            ghostContext.save();\n            context.font = chunk.style;\n            if (interactive) {\n              ghostContext.font = chunk.style;\n            }\n          }\n          if (chunk.fill) {\n            context.save();\n            context.fillStyle = chunk.fill.toCSS();\n            // Color does not affect ghostContext so we not set it\n          }\n          // Center letters\n          context.textBaseline = "middle";\n          context.textAlign = "center";\n          if (interactive) {\n            ghostContext.textBaseline = "middle";\n            ghostContext.textAlign = "center";\n          }\n          // Plop the letter\n          if (layerDirty) {\n            context.fillText(char, 0, (inward ? 1 : -1) * (0 - radius + textHeight / 2));\n          }\n          if (interactive) {\n            ghostContext.fillText(char, 0, (inward ? 1 : -1) * (0 - radius + textHeight / 2));\n          }\n          if (chunk.fill) {\n            context.restore();\n            // Color does not affect ghostContext so we not set it\n          }\n          // Reset style\n          if (chunk.style) {\n            context.restore();\n            ghostContext.restore();\n          }\n          // Rotate half a letter and add spacing\n          angleShift = (charWidth / 2 + kerning) / (radius - textHeight) * clockwise;\n          context.rotate(angleShift);\n          if (interactive) {\n            ghostContext.rotate(angleShift);\n          }\n        });\n        // Restore angle\n        context.restore();\n        if (interactive) {\n          ghostContext.restore();\n        }\n        // Adjust radius (for `inside = true`)\n        if (inside) {\n          radius -= textHeight;\n        }\n      });\n      // Restore\n      context.restore();\n      if (interactive) {\n        ghostContext.restore();\n      }\n    }\n  }\n  _measure(status) {\n    switch (this.textType) {\n      case "circular":\n        return this._measureCircular(status);\n      default:\n        return super._measure(status);\n    }\n  }\n  _measureCircular(status) {\n    const context = status.layer.context;\n    const ghostContext = this._renderer._ghostLayer.context;\n    const rtl = this.style.direction == "rtl";\n    const oversizedBehavior = this.style.oversizedBehavior;\n    const maxWidth = this.style.maxWidth;\n    const truncate = Type_isNumber(maxWidth) && oversizedBehavior == "truncate";\n    const ellipsis = this.style.ellipsis || "";\n    let ellipsisMetrics;\n    //const wrap = $type.isNumber(maxWidth) && (oversizedBehavior == "wrap" || oversizedBehavior == "wrap-no-break");\n    // Reset text info\n    this.textVisible = true;\n    this._textInfo = [];\n    this._textReversed = false;\n    // Pre-render\n    context.save();\n    ghostContext.save();\n    this._prerender(status, true);\n    // Split up text into lines\n    const lines = this.text.toString().replace(/\\r/g, "").split(/\\n/);\n    let styleRestored = true;\n    let totalWidth = 0;\n    // Iterate through the lines\n    let offsetY = 0;\n    each(lines, (line, _index) => {\n      // Split up line into format/value chunks\n      let chunks = TextFormatter.chunk(line, false, this.style.ignoreFormatting);\n      // Init line object\n      let lineInfo = {\n        offsetY: offsetY,\n        ascent: 0,\n        width: 0,\n        height: 0,\n        left: 0,\n        right: 0,\n        textChunks: []\n      };\n      let currentStyle;\n      let currentFill;\n      let currentChunkWidth;\n      //while(chunk = chunks.shift()) {\n      each(chunks, (chunk, _index) => {\n        // Format chunk\n        if (chunk.type == "format") {\n          if (chunk.text == "[/]") {\n            if (!styleRestored) {\n              context.restore();\n              ghostContext.restore();\n              styleRestored = true;\n            }\n            currentFill = undefined;\n            currentStyle = undefined;\n            currentChunkWidth = undefined;\n          } else {\n            let format = TextFormatter.getTextStyle(chunk.text);\n            const fontStyle = this._getFontStyle(format);\n            context.save();\n            ghostContext.save();\n            context.font = fontStyle;\n            currentStyle = fontStyle;\n            if (format.fill) {\n              currentFill = format.fill;\n            }\n            if (format.width) {\n              currentChunkWidth = Type_toNumber(format.width);\n            }\n            styleRestored = false;\n          }\n          if (truncate) {\n            ellipsisMetrics = this._measureText(ellipsis, context);\n          }\n        }\n        // Text format\n        else if (chunk.type == "value") {\n          // Measure each letter\n          let chars = chunk.text.match(/./ug) || [];\n          if (rtl) {\n            chars = splitString(chunk.text);\n            chars.reverse();\n          }\n          for (let i = 0; i < chars.length; i++) {\n            const char = chars[i];\n            // Measure\n            const metrics = this._measureText(char, context);\n            let chunkWidth = metrics.width;\n            // Chunk width?\n            if (currentStyle && currentChunkWidth && currentChunkWidth > chunkWidth) {\n              chunkWidth = currentChunkWidth;\n            }\n            const chunkHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n            if (chunkHeight > lineInfo.height) {\n              lineInfo.height = chunkHeight;\n            }\n            if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {\n              lineInfo.ascent = metrics.actualBoundingBoxAscent;\n            }\n            totalWidth += chunkWidth;\n            // Handle oversized behavior\n            if (truncate) {\n              // Measure ellipsis and check if it fits\n              if (!ellipsisMetrics) {\n                ellipsisMetrics = this._measureText(ellipsis, context);\n              }\n              const ellipsisWidth = ellipsisMetrics.actualBoundingBoxLeft + ellipsisMetrics.actualBoundingBoxRight;\n              //totalWidth += ellipsisWidth;\n              if (totalWidth + ellipsisWidth > maxWidth) {\n                if (lineInfo.textChunks.length == 1) {\n                  this.textVisible = false;\n                } else {\n                  lineInfo.width += ellipsisWidth;\n                  lineInfo.left += ellipsisMetrics.actualBoundingBoxLeft;\n                  lineInfo.right += ellipsisMetrics.actualBoundingBoxRight;\n                  lineInfo.textChunks.push({\n                    style: currentStyle,\n                    fill: currentFill,\n                    text: ellipsis,\n                    width: ellipsisWidth,\n                    height: chunkHeight + ellipsisMetrics.actualBoundingBoxDescent,\n                    left: ellipsisMetrics.actualBoundingBoxLeft,\n                    right: ellipsisMetrics.actualBoundingBoxRight,\n                    ascent: ellipsisMetrics.actualBoundingBoxAscent,\n                    offsetX: 0,\n                    offsetY: chunkHeight,\n                    textDecoration: undefined\n                  });\n                }\n                break;\n              }\n            }\n            lineInfo.width += chunkWidth;\n            lineInfo.left += metrics.actualBoundingBoxLeft;\n            lineInfo.right += metrics.actualBoundingBoxRight;\n            lineInfo.textChunks.push({\n              style: currentStyle,\n              fill: currentFill,\n              text: char,\n              width: chunkWidth,\n              height: chunkHeight + metrics.actualBoundingBoxDescent,\n              left: metrics.actualBoundingBoxLeft,\n              right: metrics.actualBoundingBoxRight,\n              ascent: metrics.actualBoundingBoxAscent,\n              offsetX: 0,\n              offsetY: chunkHeight,\n              textDecoration: undefined\n            });\n            if (rtl) {\n              // @todo still needed?\n              //break;\n            }\n          }\n        }\n      });\n      if (this.style.lineHeight instanceof Percent) {\n        lineInfo.height *= this.style.lineHeight.value;\n      } else {\n        lineInfo.height *= this.style.lineHeight || 1.2;\n      }\n      this._textInfo.push(lineInfo);\n      //lineInfo.offsetY += lineInfo.ascent;\n      offsetY += lineInfo.height;\n    });\n    if (!styleRestored) {\n      context.restore();\n      ghostContext.restore();\n    }\n    if (oversizedBehavior == "hide" && totalWidth > maxWidth) {\n      this.textVisible = false;\n    }\n    // Adjust chunk internal offsets\n    each(this._textInfo, lineInfo => {\n      each(lineInfo.textChunks, chunk => {\n        chunk.offsetY += Math.round((lineInfo.height - chunk.height + (lineInfo.ascent - chunk.ascent)) / 2);\n      });\n    });\n    context.restore();\n    ghostContext.restore();\n    return {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n  }\n}\n/**\r\n * @ignore\r\n */\nclass CanvasImage extends CanvasDisplayObject {\n  constructor(renderer, image) {\n    super(renderer);\n    Object.defineProperty(this, "width", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "height", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "image", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "tainted", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "shadowColor", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "shadowBlur", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "shadowOffsetX", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "shadowOffsetY", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "shadowOpacity", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_imageMask", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.image = image;\n  }\n  _dispose() {\n    super._dispose();\n    if (this._imageMask) {\n      clearCanvas(this._imageMask);\n    }\n  }\n  getLocalBounds() {\n    if (!this._localBounds) {\n      let w = 0;\n      let h = 0;\n      if (this.width) {\n        w = this.width;\n      }\n      if (this.height) {\n        h = this.height;\n      }\n      this._localBounds = {\n        left: 0,\n        top: 0,\n        right: w,\n        bottom: h\n      };\n      this._addBounds(this._localBounds);\n    }\n    return this._localBounds;\n  }\n  _render(status) {\n    super._render(status);\n    if (this.image) {\n      if (this.tainted === undefined) {\n        this.tainted = isTainted(this.image);\n        status.layer.tainted = true;\n      }\n      if (this.tainted && this._renderer._omitTainted) {\n        return;\n      }\n      if (status.layer.dirty) {\n        if (this.shadowColor) {\n          status.layer.context.shadowColor = this.shadowColor.toCSS(this.shadowOpacity || 1);\n        }\n        if (this.shadowBlur) {\n          status.layer.context.shadowBlur = this.shadowBlur;\n        }\n        if (this.shadowOffsetX) {\n          status.layer.context.shadowOffsetX = this.shadowOffsetX;\n        }\n        if (this.shadowOffsetY) {\n          status.layer.context.shadowOffsetY = this.shadowOffsetY;\n        }\n        // TODO should this round ?\n        const width = this.width || this.image.naturalWidth;\n        const height = this.height || this.image.naturalHeight;\n        status.layer.context.drawImage(this.image, 0, 0, width, height);\n      }\n      if (this.interactive && this._isInteractive(status)) {\n        const mask = this._getMask(this.image);\n        this._renderer._ghostLayer.context.drawImage(mask, 0, 0);\n      }\n    }\n  }\n  clear() {\n    super.clear();\n    this.image = undefined;\n    this._imageMask = undefined;\n  }\n  _getMask(image) {\n    if (this._imageMask === undefined) {\n      // TODO should this round ?\n      const width = this.width || image.naturalWidth;\n      const height = this.height || image.naturalHeight;\n      // We need to create a second canvas because destination-in clears out the entire canvas\n      const canvas = document.createElement("canvas");\n      canvas.width = width;\n      canvas.height = height;\n      const context = canvas.getContext("2d");\n      context.imageSmoothingEnabled = false;\n      context.fillStyle = this._getColorId();\n      context.fillRect(0, 0, width, height);\n      if (!isTainted(image)) {\n        context.globalCompositeOperation = "destination-in";\n        context.drawImage(image, 0, 0, width, height);\n      }\n      this._imageMask = canvas;\n    }\n    return this._imageMask;\n  }\n}\n/**\r\n * @ignore\r\n */\nclass CanvasRendererEvent {\n  constructor(event, originalPoint, point, bbox) {\n    Object.defineProperty(this, "event", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: event\n    });\n    Object.defineProperty(this, "originalPoint", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: originalPoint\n    });\n    Object.defineProperty(this, "point", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: point\n    });\n    Object.defineProperty(this, "bbox", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: bbox\n    });\n    Object.defineProperty(this, "id", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "simulated", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "native", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    if (supports("touchevents") && event instanceof Touch) {\n      this.id = event.identifier;\n    } else {\n      this.id = null;\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nclass CanvasRenderer extends ArrayDisposer {\n  constructor(resolution) {\n    super();\n    Object.defineProperty(this, "view", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: document.createElement("div")\n    });\n    Object.defineProperty(this, "_layerDom", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: document.createElement("div")\n    });\n    Object.defineProperty(this, "layers", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "_dirtyLayers", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "defaultLayer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.getLayer(0)\n    });\n    Object.defineProperty(this, "_ghostLayer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new GhostLayer()\n    });\n    Object.defineProperty(this, "_patternCanvas", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: document.createElement("canvas")\n    });\n    Object.defineProperty(this, "_patternContext", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._patternCanvas.getContext("2d")\n    });\n    Object.defineProperty(this, "_realWidth", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_realHeight", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_calculatedWidth", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_calculatedHeight", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "resolution", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "interactionsEnabled", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, "_listeners", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_events", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_colorId", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_colorMap", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_forceInteractive", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_omitTainted", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    // TODO this should store the Id as well\n    Object.defineProperty(this, "_hovering", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Set()\n    });\n    Object.defineProperty(this, "_dragging", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "_mousedown", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "_lastPointerMoveEvent", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "tapToActivate", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "tapToActivateTimeout", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 3000\n    });\n    Object.defineProperty(this, "_touchActive", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_touchActiveTimeout", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    if (resolution == null) {\n      this.resolution = window.devicePixelRatio;\n    } else {\n      this.resolution = resolution;\n    }\n    this.view.style.position = "absolute";\n    this.view.setAttribute("aria-hidden", "true");\n    this.view.appendChild(this._layerDom);\n    this._disposers.push(new Disposer(() => {\n      Object_each(this._events, (_key, events) => {\n        events.disposer.dispose();\n      });\n      each(this.layers, layer => {\n        clearCanvas(layer.view);\n        if (layer.exportableView) {\n          clearCanvas(layer.exportableView);\n        }\n      });\n      clearCanvas(this._ghostLayer.view);\n      clearCanvas(this._patternCanvas);\n    }));\n    /*\r\n    this._disposers.push($utils.addEventListener(this._ghostLayer.view, "click", (originalEvent: MouseEvent) => {\r\n        const event = this.getEvent(originalEvent);\r\n        const target = this._getHitTarget(event.originalPoint, event.bbox);\r\n        console.debug(target);\r\n    }));\r\n    */\n    // Monitor for possible pixel ratio changes (when page is zoomed)\n    this._disposers.push(onZoom(() => {\n      if (resolution == null) {\n        this.resolution = window.devicePixelRatio;\n      }\n    }));\n    // We need this in order top prevent default touch gestures when dragging\n    // draggable elements\n    if (supports("touchevents")) {\n      const listener = ev => {\n        if (this._dragging.length !== 0) {\n          eachContinue(this._dragging, item => {\n            if (item.value.shouldCancelTouch()) {\n              ev.preventDefault();\n              return false;\n            }\n            return true;\n          });\n        }\n        // If touch down happends, delay touch out\n        if (this._touchActiveTimeout) {\n          this._delayTouchDeactivate();\n        }\n      };\n      this._disposers.push(Utils_addEventListener(window, "touchstart", listener, {\n        passive: false\n      }));\n      this._disposers.push(Utils_addEventListener(this.view, "touchstart", listener, {\n        passive: false\n      }));\n      this._disposers.push(Utils_addEventListener(this.view, "touchmove", () => {\n        // If touch is moving, delay touch out\n        if (this._touchActiveTimeout) {\n          this._delayTouchDeactivate();\n        }\n      }, {\n        passive: true\n      }));\n      this._disposers.push(Utils_addEventListener(window, "click", _ev => {\n        this._touchActive = false;\n      }, {\n        passive: true\n      }));\n      this._disposers.push(Utils_addEventListener(this.view, "click", _ev => {\n        window.setTimeout(() => {\n          this._touchActive = true;\n          this._delayTouchDeactivate();\n        }, 100);\n      }, {\n        passive: true\n      }));\n    }\n    // Prevent scrolling of the window when hovering on "wheelable" object\n    if (supports("wheelevents")) {\n      this._disposers.push(Utils_addEventListener(this.view, "wheel", ev => {\n        let prevent = false;\n        this._hovering.forEach(obj => {\n          if (obj.wheelable) {\n            prevent = true;\n            return false;\n          }\n        });\n        if (prevent) {\n          ev.preventDefault();\n        }\n      }, {\n        passive: false\n      }));\n    }\n  }\n  /*protected _mouseMoveThrottler: Throttler = new Throttler(() => {\r\n      this._dispatchGlobalMousemove(this._lastPointerMoveEvent.event, this._lastPointerMoveEvent.native);\r\n  });\r\n  */\n  resetImageArray() {\n    this._ghostLayer.imageArray = undefined;\n  }\n  _delayTouchDeactivate() {\n    if (this._touchActiveTimeout) {\n      clearTimeout(this._touchActiveTimeout);\n    }\n    if (this.tapToActivateTimeout > 0) {\n      this._touchActiveTimeout = window.setTimeout(() => {\n        this._touchActive = false;\n      }, this.tapToActivateTimeout);\n    }\n  }\n  get debugGhostView() {\n    return !!this._ghostLayer.view.parentNode;\n  }\n  set debugGhostView(value) {\n    if (value) {\n      if (!this._ghostLayer.view.parentNode) {\n        this.view.appendChild(this._ghostLayer.view);\n      }\n    } else {\n      if (this._ghostLayer.view.parentNode) {\n        this._ghostLayer.view.parentNode.removeChild(this._ghostLayer.view);\n      }\n    }\n  }\n  createLinearGradient(x1, y1, x2, y2) {\n    return this.defaultLayer.context.createLinearGradient(x1, y1, x2, y2);\n  }\n  createRadialGradient(x1, y1, radius1, x2, y2, radius2) {\n    return this.defaultLayer.context.createRadialGradient(x1, y1, radius1, x2, y2, radius2);\n  }\n  createPattern(graphics, background, repetition, width, height) {\n    // const patternCanvas = document.createElement("canvas");\n    // const patternContext = patternCanvas.getContext("2d")!;\n    // patternCanvas.width = width;\n    // patternCanvas.height = height;\n    // if (fill) {\n    // \tpatternContext.fillStyle = fill.toCSS();\n    // \tpatternContext.fillRect(0, 0, patternCanvas.width, patternCanvas.height);\n    // }\n    // const layer = {\n    // \tview: patternCanvas,\n    // \tcontext: patternContext,\n    // \tvisible: true,\n    // \torder: 0,\n    // \twidth: width,\n    // \theight: height,\n    // \tdirty: true\n    // };\n    // // patternContext.arc(0, 0, 50, 0, .5 * Math.PI);\n    // // patternContext.stroke();\n    // image.targetLayer = layer;\n    // image.render(layer);\n    //this._layerDom.appendChild(patternCanvas);\n    this._patternCanvas.width = width;\n    this._patternCanvas.height = height;\n    this._patternContext.clearRect(0, 0, width, height);\n    // patternCanvas.style.width = width * this.resolution + "px";\n    // patternCanvas.style.height = height * this.resolution + "px";\n    background.renderDetached(this._patternContext);\n    graphics.renderDetached(this._patternContext);\n    return this._patternContext.createPattern(this._patternCanvas, repetition);\n  }\n  makeContainer() {\n    return new CanvasContainer(this);\n  }\n  makeGraphics() {\n    return new CanvasGraphics(this);\n  }\n  makeText(text, style) {\n    return new CanvasText(this, text, style);\n  }\n  makeTextStyle() {\n    return new CanvasTextStyle();\n  }\n  makeRadialText(text, style) {\n    return new CanvasRadialText(this, text, style);\n  }\n  makePicture(image) {\n    return new CanvasImage(this, image);\n  }\n  resizeLayer(layer) {\n    layer.resize(this._calculatedWidth, this._calculatedHeight, this._calculatedWidth, this._calculatedHeight, this.resolution);\n  }\n  resizeGhost() {\n    this._ghostLayer.resize(this._calculatedWidth, this._calculatedHeight, this._calculatedWidth, this._calculatedHeight, this.resolution);\n  }\n  resize(realWidth, realHeight, calculatedWidth, calculatedHeight) {\n    this._realWidth = realWidth;\n    this._realHeight = realHeight;\n    this._calculatedWidth = calculatedWidth;\n    this._calculatedHeight = calculatedHeight;\n    each(this.layers, layer => {\n      if (layer) {\n        layer.dirty = true;\n        this.resizeLayer(layer);\n      }\n    });\n    this.resizeGhost();\n    this.view.style.width = calculatedWidth + "px";\n    this.view.style.height = calculatedHeight + "px";\n  }\n  createDetachedLayer(willReadFrequently = false) {\n    const view = document.createElement("canvas");\n    const context = view.getContext("2d", {\n      willReadFrequently: willReadFrequently\n    });\n    const layer = new CanvasLayer(view, context);\n    view.style.position = "absolute";\n    view.style.top = "0px";\n    view.style.left = "0px";\n    return layer;\n  }\n  getLayerByOrder(order) {\n    const layers = this.layers;\n    const length = layers.length;\n    for (let i = 0; i < length; i++) {\n      const layer = layers[i];\n      if (layer.order == order) {\n        return layer;\n      }\n    }\n  }\n  getLayer(order, visible = true) {\n    let existingLayer = this.getLayerByOrder(order);\n    if (existingLayer) {\n      return existingLayer;\n    }\n    const layer = this.createDetachedLayer(order == 99);\n    layer.order = order;\n    layer.visible = visible;\n    layer.view.className = "am5-layer-" + order;\n    if (layer.visible) {\n      this.resizeLayer(layer);\n    }\n    const layers = this.layers;\n    layers.push(layer);\n    layers.sort((a, b) => {\n      if (a.order > b.order) {\n        return 1;\n      } else if (a.order < b.order) {\n        return -1;\n      } else {\n        return 0;\n      }\n    });\n    const length = layers.length;\n    const layerIndex = indexOf(layers, layer);\n    let next;\n    for (let i = layerIndex + 1; i < length; i++) {\n      if (layers[i].visible) {\n        next = layers[i];\n        break;\n      }\n    }\n    if (layer.visible) {\n      if (next === undefined) {\n        this._layerDom.appendChild(layer.view);\n      } else {\n        this._layerDom.insertBefore(layer.view, next.view);\n      }\n    }\n    return layer;\n  }\n  render(root) {\n    this._dirtyLayers.length = 0;\n    each(this.layers, layer => {\n      if (layer) {\n        if (layer.dirty && layer.visible) {\n          this._dirtyLayers.push(layer);\n          layer.clear();\n        }\n      }\n    });\n    this._ghostLayer.clear();\n    root.render({\n      inactive: null,\n      layer: this.defaultLayer\n    });\n    this._ghostLayer.context.restore();\n    //setTimeout(() => {\n    // Remove this after the Chrome bug is fixed:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1279394\n    each(this.layers, layer => {\n      if (layer) {\n        const context = layer.context;\n        context.beginPath();\n        context.moveTo(0, 0);\n        context.stroke();\n      }\n    });\n    each(this._dirtyLayers, layer => {\n      layer.context.restore();\n      layer.dirty = false;\n    });\n    //}, 100)\n    if (this._hovering.size && this._lastPointerMoveEvent) {\n      const {\n        events,\n        target,\n        native\n      } = this._lastPointerMoveEvent;\n      //this._mouseMoveThrottler.run();\n      each(events, event => {\n        this._dispatchGlobalMousemove(event, target, native);\n      });\n    }\n  }\n  paintId(obj) {\n    const id = distributeId(++this._colorId);\n    const color = Color.fromHex(id).toCSS();\n    this._colorMap[color] = obj;\n    return color;\n  }\n  _removeObject(obj) {\n    if (obj._colorId !== undefined) {\n      delete this._colorMap[obj._colorId];\n    }\n  }\n  // protected _identifyObjectByColor(colorId: number): CanvasDisplayObject | undefined {\n  // \treturn this._colorMap[colorId];\n  // }\n  _adjustBoundingBox(bbox) {\n    const margin = this._ghostLayer.margin;\n    return new DOMRect(-margin.left, -margin.top, bbox.width + margin.left + margin.right, bbox.height + margin.top + margin.bottom);\n  }\n  getEvent(originalEvent, adjustPoint = true) {\n    const bbox = this.view.getBoundingClientRect();\n    const x = originalEvent.clientX || 0;\n    const y = originalEvent.clientY || 0;\n    const widthScale = this._calculatedWidth / this._realWidth;\n    const heightScale = this._calculatedHeight / this._realHeight;\n    const originalPoint = {\n      x: x - bbox.left,\n      y: y - bbox.top\n    };\n    const point = {\n      x: (x - (adjustPoint ? bbox.left : 0)) * widthScale,\n      y: (y - (adjustPoint ? bbox.top : 0)) * heightScale\n    };\n    return new CanvasRendererEvent(originalEvent, originalPoint, point, this._adjustBoundingBox(bbox));\n  }\n  _getHitTarget(point, bbox, target) {\n    if (bbox.width === 0 || bbox.height === 0 || point.x < bbox.left || point.x > bbox.right || point.y < bbox.top || point.y > bbox.bottom) {\n      return;\n    }\n    if (!target || !this._layerDom.contains(target)) {\n      return;\n    }\n    const pixel = this._ghostLayer.getImageData(point, bbox);\n    if (pixel.data[0] === 0 && pixel.data[1] === 0 && pixel.data[2] === 0) {\n      return false;\n    }\n    const colorId = Color.fromRGB(pixel.data[0], pixel.data[1], pixel.data[2]).toCSS();\n    const hit = this._colorMap[colorId];\n    return hit;\n  }\n  getObjectAtPoint(point) {\n    const data = this._ghostLayer.getImageArray(point);\n    if (data[0] === 0 && data[1] === 0 && data[2] === 0) {\n      return undefined;\n    }\n    const colorId = Color.fromRGB(data[0], data[1], data[2]).toCSS();\n    const hit = this._colorMap[colorId];\n    return hit;\n  }\n  _withEvents(key, f) {\n    const events = this._events[key];\n    if (events !== undefined) {\n      events.dispatching = true;\n      try {\n        f(events);\n      } finally {\n        events.dispatching = false;\n        if (events.cleanup) {\n          events.cleanup = false;\n          keepIf(events.callbacks, callback => {\n            return !callback.disposed;\n          });\n          if (events.callbacks.length === 0) {\n            events.disposer.dispose();\n            delete this._events[key];\n          }\n        }\n      }\n    }\n  }\n  _dispatchEventAll(key, event) {\n    if (!this.interactionsEnabled) {\n      return;\n    }\n    this._withEvents(key, events => {\n      each(events.callbacks, callback => {\n        if (!callback.disposed) {\n          callback.callback.call(callback.context, event);\n        }\n      });\n    });\n  }\n  _dispatchEvent(key, target, event) {\n    if (!this.interactionsEnabled) {\n      return false;\n    }\n    let dispatched = false;\n    this._withEvents(key, events => {\n      each(events.callbacks, callback => {\n        if (!callback.disposed && callback.object === target) {\n          callback.callback.call(callback.context, event);\n          dispatched = true;\n        }\n      });\n    });\n    return dispatched;\n  }\n  _dispatchMousedown(originalEvent, originalTarget) {\n    const button = originalEvent.button;\n    if (button != 0 && button != 2 && button != 1 && button !== undefined) {\n      // Ignore non-primary mouse buttons\n      return;\n    }\n    const event = this.getEvent(originalEvent);\n    const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n    if (target) {\n      const id = event.id;\n      let dragged = false;\n      eachTargets(target, obj => {\n        const info = {\n          id: id,\n          value: obj\n        };\n        this._mousedown.push(info);\n        if (!dragged && this._dispatchEvent("pointerdown", obj, event)) {\n          // Only dispatch the first element which matches\n          dragged = true;\n          const has = this._dragging.some(x => {\n            return x.value === obj && x.id === id;\n          });\n          if (!has) {\n            this._dragging.push(info);\n          }\n        }\n        return true;\n      });\n    }\n  }\n  _dispatchGlobalMousemove(originalEvent, originalTarget, native) {\n    const event = this.getEvent(originalEvent);\n    const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n    event.native = native;\n    if (target) {\n      this._hovering.forEach(obj => {\n        if (!obj.contains(target)) {\n          this._hovering.delete(obj);\n          if (obj.cursorOverStyle) {\n            Utils_setStyle(document.body, "cursor", obj._replacedCursorStyle);\n          }\n          this._dispatchEvent("pointerout", obj, event);\n        }\n      });\n      if (event.native) {\n        eachTargets(target, obj => {\n          if (!this._hovering.has(obj)) {\n            this._hovering.add(obj);\n            if (obj.cursorOverStyle) {\n              obj._replacedCursorStyle = getStyle(document.body, "cursor");\n              Utils_setStyle(document.body, "cursor", obj.cursorOverStyle);\n            }\n            this._dispatchEvent("pointerover", obj, event);\n          }\n          return true;\n        });\n      }\n      //} else if (target === false) {\n    } else {\n      this._hovering.forEach(obj => {\n        if (obj.cursorOverStyle) {\n          Utils_setStyle(document.body, "cursor", obj._replacedCursorStyle);\n        }\n        this._dispatchEvent("pointerout", obj, event);\n      });\n      this._hovering.clear();\n    }\n    this._dispatchEventAll("globalpointermove", event);\n  }\n  removeHovering(graphics) {\n    this._hovering.delete(graphics);\n    if (graphics.cursorOverStyle) {\n      Utils_setStyle(document.body, "cursor", graphics._replacedCursorStyle);\n    }\n  }\n  _dispatchGlobalMouseup(originalEvent, native) {\n    const event = this.getEvent(originalEvent);\n    event.native = native;\n    //const target = this._getHitTarget(event.originalPoint);\n    this._dispatchEventAll("globalpointerup", event);\n  }\n  _dispatchDragMove(originalEvent) {\n    if (this._dragging.length !== 0) {\n      const event = this.getEvent(originalEvent);\n      const id = event.id;\n      this._dragging.forEach(obj => {\n        if (obj.id === id) {\n          this._dispatchEvent("pointermove", obj.value, event);\n        }\n      });\n    }\n  }\n  _dispatchDragEnd(originalEvent, originalTarget) {\n    const button = originalEvent.button;\n    let clickevent;\n    if (button == 0 || button === undefined) {\n      clickevent = "click";\n    } else if (button == 2) {\n      clickevent = "rightclick";\n    } else if (button == 1) {\n      clickevent = "middleclick";\n    } else {\n      // Ignore non-primary mouse buttons\n      return;\n    }\n    const event = this.getEvent(originalEvent);\n    const id = event.id;\n    if (this._mousedown.length !== 0) {\n      const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n      if (target) {\n        this._mousedown.forEach(obj => {\n          if (obj.id === id && obj.value.contains(target)) {\n            this._dispatchEvent(clickevent, obj.value, event);\n          }\n        });\n      }\n      this._mousedown.length = 0;\n    }\n    if (this._dragging.length !== 0) {\n      this._dragging.forEach(obj => {\n        if (obj.id === id) {\n          this._dispatchEvent("pointerup", obj.value, event);\n        }\n      });\n      this._dragging.length = 0;\n    }\n  }\n  _dispatchDoubleClick(originalEvent, originalTarget) {\n    const event = this.getEvent(originalEvent);\n    const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n    if (target) {\n      eachTargets(target, obj => {\n        if (this._dispatchEvent("dblclick", obj, event)) {\n          return false;\n        } else {\n          return true;\n        }\n      });\n    }\n  }\n  _dispatchWheel(originalEvent, originalTarget) {\n    const event = this.getEvent(originalEvent);\n    const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);\n    if (target) {\n      eachTargets(target, obj => {\n        if (this._dispatchEvent("wheel", obj, event)) {\n          return false;\n        } else {\n          return true;\n        }\n      });\n    }\n  }\n  _makeSharedEvent(key, f) {\n    if (this._listeners[key] === undefined) {\n      const listener = f();\n      this._listeners[key] = new CounterDisposer(() => {\n        delete this._listeners[key];\n        listener.dispose();\n      });\n    }\n    return this._listeners[key].increment();\n  }\n  _onPointerEvent(name, f) {\n    let native = false;\n    let timer = null;\n    function clear() {\n      timer = null;\n      native = false;\n    }\n    return new Disposer_MultiDisposer([new Disposer(() => {\n      if (timer !== null) {\n        clearTimeout(timer);\n      }\n      clear();\n    }), Utils_addEventListener(this.view, getRendererEvent(name), _ => {\n      native = true;\n      if (timer !== null) {\n        clearTimeout(timer);\n      }\n      timer = window.setTimeout(clear, 0);\n    }), onPointerEvent(window, name, (ev, target) => {\n      if (timer !== null) {\n        clearTimeout(timer);\n        timer = null;\n      }\n      f(ev, target, native);\n      native = false;\n    })]);\n  }\n  // This ensures that only a single DOM event is added (e.g. only a single mousemove event listener)\n  _initEvent(key) {\n    switch (key) {\n      case "globalpointermove":\n      case "pointerover":\n      case "pointerout":\n        return this._makeSharedEvent("pointermove", () => {\n          const listener = (events, target, native) => {\n            this._lastPointerMoveEvent = {\n              events,\n              target,\n              native\n            };\n            each(events, event => {\n              this._dispatchGlobalMousemove(event, target, native);\n            });\n          };\n          return new Disposer_MultiDisposer([this._onPointerEvent("pointerdown", listener), this._onPointerEvent("pointermove", listener)]);\n        });\n      case "globalpointerup":\n        return this._makeSharedEvent("pointerup", () => {\n          const mouseup = this._onPointerEvent("pointerup", (events, target, native) => {\n            each(events, event => {\n              this._dispatchGlobalMouseup(event, native);\n            });\n            this._lastPointerMoveEvent = {\n              events,\n              target,\n              native\n            };\n          });\n          const pointercancel = this._onPointerEvent("pointercancel", (events, target, native) => {\n            each(events, event => {\n              this._dispatchGlobalMouseup(event, native);\n            });\n            this._lastPointerMoveEvent = {\n              events,\n              target,\n              native\n            };\n          });\n          return new Disposer(() => {\n            mouseup.dispose();\n            pointercancel.dispose();\n          });\n        });\n      case "click":\n      case "rightclick":\n      case "middleclick":\n      case "pointerdown":\n      /*\r\n          return this._makeSharedEvent("pointerdown", () => {\r\n              return this._onPointerEvent("pointerdown", (event, target, native) => {\r\n                  this._lastPointerMoveEvent = { event, target, native };\r\n                  this._dispatchMousedown(event)\r\n              });\r\n          });\r\n      */\n      case "pointermove":\n      case "pointerup":\n        return this._makeSharedEvent("pointerdown", () => {\n          //const throttler = new Throttler();\n          const mousedown = this._onPointerEvent("pointerdown", (events, target) => {\n            each(events, ev => {\n              this._dispatchMousedown(ev, target);\n            });\n          });\n          // TODO handle throttling properly for multitouch\n          const mousemove = this._onPointerEvent("pointermove", ev => {\n            //throttler.throttle(() => {\n            each(ev, ev => {\n              this._dispatchDragMove(ev);\n            });\n            //});\n          });\n\n          const mouseup = this._onPointerEvent("pointerup", (ev, target) => {\n            each(ev, ev => {\n              this._dispatchDragEnd(ev, target);\n            });\n          });\n          const pointercancel = this._onPointerEvent("pointercancel", (ev, target) => {\n            each(ev, ev => {\n              this._dispatchDragEnd(ev, target);\n            });\n          });\n          return new Disposer(() => {\n            mousedown.dispose();\n            mousemove.dispose();\n            mouseup.dispose();\n            pointercancel.dispose();\n          });\n        });\n      case "dblclick":\n        return this._makeSharedEvent("dblclick", () => {\n          return this._onPointerEvent("dblclick", (ev, target) => {\n            each(ev, ev => {\n              this._dispatchDoubleClick(ev, target);\n            });\n          });\n        });\n      case "wheel":\n        return this._makeSharedEvent("wheel", () => {\n          return Utils_addEventListener(this.view, getRendererEvent("wheel"), event => {\n            this._dispatchWheel(event, getEventTarget(event));\n          }, {\n            passive: false\n          });\n        });\n    }\n  }\n  _addEvent(object, key, callback, context) {\n    let events = this._events[key];\n    if (events === undefined) {\n      events = this._events[key] = {\n        disposer: this._initEvent(key),\n        callbacks: [],\n        dispatching: false,\n        cleanup: false\n      };\n    }\n    const listener = {\n      object,\n      context,\n      callback,\n      disposed: false\n    };\n    events.callbacks.push(listener);\n    return new Disposer(() => {\n      listener.disposed = true;\n      if (events.dispatching) {\n        events.cleanup = true;\n      } else {\n        removeFirst(events.callbacks, listener);\n        if (events.callbacks.length === 0) {\n          events.disposer.dispose();\n          delete this._events[key];\n        }\n      }\n    });\n  }\n  getCanvas(root, options) {\n    // Make sure everything is rendered\n    this.render(root);\n    if (!options) {\n      options = {};\n    }\n    let scale = this.resolution;\n    let canvasWidth = Math.floor(this._calculatedWidth * this.resolution);\n    let canvasHeight = Math.floor(this._calculatedHeight * this.resolution);\n    // Check if we need to scale\n    if (options.minWidth && options.minWidth > canvasWidth) {\n      let minScale = options.minWidth / canvasWidth;\n      if (minScale > scale) {\n        scale = minScale * this.resolution;\n      }\n    }\n    if (options.minHeight && options.minHeight > canvasHeight) {\n      let minScale = options.minHeight / canvasHeight;\n      if (minScale > scale) {\n        scale = minScale * this.resolution;\n      }\n    }\n    if (options.maxWidth && options.maxWidth < canvasWidth) {\n      let maxScale = options.maxWidth / canvasWidth;\n      if (maxScale < scale) {\n        scale = maxScale * this.resolution;\n      }\n    }\n    if (options.maxHeight && options.maxHeight > canvasHeight) {\n      let maxScale = options.maxHeight / canvasHeight;\n      if (maxScale < scale) {\n        scale = maxScale * this.resolution;\n      }\n    }\n    // Check if we need to compensate for pixel ratio\n    if (options.maintainPixelRatio) {\n      scale /= this.resolution;\n    }\n    // Init list canvases to remove from DOM after export\n    const canvases = [];\n    // Set up new canvas for export\n    let forceRender = false;\n    const canvas = document.createElement("canvas");\n    if (scale != this.resolution) {\n      forceRender = true;\n      canvasWidth = canvasWidth * scale / this.resolution;\n      canvasHeight = canvasHeight * scale / this.resolution;\n    }\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    // Add to DOM so it inherits CSS\n    canvas.style.position = "fixed";\n    canvas.style.top = "-10000px";\n    this.view.appendChild(canvas);\n    canvases.push(canvas);\n    // Context\n    const context = canvas.getContext("2d");\n    let width = 0;\n    let height = 0;\n    let needRerender = false;\n    each(this.layers, layer => {\n      if (layer && layer.visible) {\n        if (layer.tainted || forceRender) {\n          needRerender = true;\n          layer.exportableView = layer.view;\n          layer.exportableContext = layer.context;\n          layer.view = document.createElement("canvas");\n          // Add to DOM so it inherits CSS\n          layer.view.style.position = "fixed";\n          layer.view.style.top = "-10000px";\n          this.view.appendChild(layer.view);\n          canvases.push(layer.view);\n          let extraX = 0;\n          let extraY = 0;\n          if (layer.margin) {\n            extraX += layer.margin.left || 0 + layer.margin.right || 0;\n            extraY += layer.margin.top || 0 + layer.margin.bottom || 0;\n          }\n          layer.view.width = canvasWidth + extraX;\n          layer.view.height = canvasHeight + extraY;\n          layer.context = layer.view.getContext("2d");\n          layer.dirty = true;\n          layer.scale = scale;\n        }\n      }\n    });\n    if (needRerender) {\n      this._omitTainted = true;\n      this.render(root);\n      this._omitTainted = false;\n    }\n    each(this.layers, layer => {\n      if (layer && layer.visible) {\n        // Layer is fine. Just plop it into our target canvas\n        let x = 0;\n        let y = 0;\n        if (layer.margin) {\n          x = -(layer.margin.left || 0) * this.resolution;\n          y = -(layer.margin.top || 0) * this.resolution;\n        }\n        context.drawImage(layer.view, x, y);\n        // Restore layer original canvas\n        if (layer.exportableView) {\n          layer.view = layer.exportableView;\n          layer.exportableView = undefined;\n        }\n        if (layer.exportableContext) {\n          layer.context = layer.exportableContext;\n          layer.exportableContext = undefined;\n        }\n        if (width < layer.view.clientWidth) {\n          width = layer.view.clientWidth;\n        }\n        if (height < layer.view.clientHeight) {\n          height = layer.view.clientHeight;\n        }\n        layer.scale = undefined;\n      }\n    });\n    canvas.style.width = width + "px";\n    canvas.style.height = height + "px";\n    each(canvases, canvas => {\n      canvas.style.position = "";\n      canvas.style.top = "";\n      this.view.removeChild(canvas);\n    });\n    return canvas;\n  }\n}\nclass GhostLayer {\n  constructor() {\n    Object.defineProperty(this, "view", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "context", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "margin", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }\n    });\n    Object.defineProperty(this, "_resolution", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, "_width", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_height", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "imageArray", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.view = document.createElement("canvas");\n    this.context = this.view.getContext("2d", {\n      alpha: false,\n      willReadFrequently: true\n    });\n    this.context.imageSmoothingEnabled = false;\n    this.view.style.position = "absolute";\n    this.view.style.top = "0px";\n    this.view.style.left = "0px";\n  }\n  resize(canvasWidth, canvasHeight, domWidth, domHeight, resolution) {\n    this._resolution = resolution;\n    canvasWidth += this.margin.left + this.margin.right;\n    canvasHeight += this.margin.top + this.margin.bottom;\n    // TODO this should take into account calculateSize\n    domWidth += this.margin.left + this.margin.right;\n    domHeight += this.margin.top + this.margin.bottom;\n    this.view.style.left = -this.margin.left + "px";\n    this.view.style.top = -this.margin.top + "px";\n    this._width = Math.floor(canvasWidth * resolution);\n    this._height = Math.floor(canvasHeight * resolution);\n    this.view.width = this._width;\n    this.view.style.width = domWidth + "px";\n    this.view.height = this._height;\n    this.view.style.height = domHeight + "px";\n  }\n  getImageData(point, bbox) {\n    return this.context.getImageData(\n    // TODO should this round ?\n    Math.round((point.x - bbox.left) / bbox.width * this._width), Math.round((point.y - bbox.top) / bbox.height * this._height), 1, 1);\n  }\n  getImageArray(point) {\n    if (!this.imageArray) {\n      this.imageArray = this.context.getImageData(0, 0, this._width, this._height).data;\n    }\n    const data = this.imageArray;\n    const x = Math.round(point.x * this._resolution);\n    const y = Math.round(point.y * this._resolution);\n    const i = (y * this._width + x) * 4;\n    return [data[i], data[i + 1], data[i + 2], data[i + 3]];\n  }\n  setMargin(layers) {\n    this.margin.left = 0;\n    this.margin.right = 0;\n    this.margin.top = 0;\n    this.margin.bottom = 0;\n    each(layers, layer => {\n      if (layer.margin) {\n        this.margin.left = Math.max(this.margin.left, layer.margin.left);\n        this.margin.right = Math.max(this.margin.right, layer.margin.right);\n        this.margin.top = Math.max(this.margin.top, layer.margin.top);\n        this.margin.bottom = Math.max(this.margin.bottom, layer.margin.bottom);\n      }\n    });\n  }\n  clear() {\n    this.context.save();\n    this.context.fillStyle = \'#000\';\n    this.context.fillRect(0, 0, this._width, this._height);\n  }\n}\n/**\r\n * @ignore\r\n */\nclass CanvasLayer {\n  constructor(view, context) {\n    Object.defineProperty(this, "view", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "context", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "tainted", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, "margin", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "order", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "visible", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, "width", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "height", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "scale", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "dirty", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, "exportableView", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "exportableContext", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_width", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_height", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    this.view = view;\n    this.context = context;\n  }\n  resize(canvasWidth, canvasHeight, domWidth, domHeight, resolution) {\n    // TODO should this take into account calculateSize ?\n    if (this.width != null) {\n      canvasWidth = this.width;\n      domWidth = this.width;\n    }\n    // TODO should this take into account calculateSize ?\n    if (this.height != null) {\n      canvasHeight = this.height;\n      domHeight = this.height;\n    }\n    if (this.margin) {\n      canvasWidth += this.margin.left + this.margin.right;\n      canvasHeight += this.margin.top + this.margin.bottom;\n      // TODO this should take into account calculateSize\n      domWidth += this.margin.left + this.margin.right;\n      domHeight += this.margin.top + this.margin.bottom;\n      this.view.style.left = -this.margin.left + "px";\n      this.view.style.top = -this.margin.top + "px";\n    } else {\n      this.view.style.left = "0px";\n      this.view.style.top = "0px";\n    }\n    this._width = Math.floor(canvasWidth * resolution);\n    this._height = Math.floor(canvasHeight * resolution);\n    this.view.width = this._width;\n    this.view.style.width = domWidth + "px";\n    this.view.height = this._height;\n    this.view.style.height = domHeight + "px";\n  }\n  clear() {\n    this.context.save();\n    this.context.clearRect(0, 0, this._width, this._height);\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/Root.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction rAF(fps, callback) {\n  if (fps == null) {\n    requestAnimationFrame(callback);\n  } else {\n    setTimeout(() => {\n      requestAnimationFrame(callback);\n    }, 1000 / fps);\n  }\n}\n// TODO implement Disposer\n/**\r\n * Root element of the chart.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/getting-started/#Root_element} for more info\r\n */\nclass Root {\n  constructor(id, settings = {}, isReal) {\n    /**\r\n     * A reference to original chart container (div element).\r\n     */\n    Object.defineProperty(this, "dom", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_inner", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_settings", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_isDirty", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_isDirtyParents", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_isDirtyAnimation", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_dirty", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_dirtyParents", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_dirtyBounds", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_dirtyPositions", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_ticker", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, "_tickers", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "_updateTick", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    /**\r\n     * Root\'s event dispatcher.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info\r\n     */\n    Object.defineProperty(this, "events", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new EventDispatcher_EventDispatcher()\n    });\n    /**\r\n     * @ignore\r\n     * @todo needs description\r\n     */\n    Object.defineProperty(this, "animationTime", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, "_animations", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "_renderer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_rootContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * Main content container.\r\n     */\n    Object.defineProperty(this, "container", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * A [[Container]] used to display tooltips in.\r\n     */\n    Object.defineProperty(this, "tooltipContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_tooltipContainerSettings", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_tooltip", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    // Locale-related\n    /**\r\n     * @ignore\r\n     */\n    Object.defineProperty(this, "language", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: Language.new(this, {})\n    });\n    /**\r\n     * Locale used by the chart.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/}\r\n     */\n    Object.defineProperty(this, "locale", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: en\n    });\n    // Date-time related\n    /**\r\n     * Use UTC when formatting date/time.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/#utc-and-time-zones} for more info\r\n     */\n    Object.defineProperty(this, "utc", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    /**\r\n     * If set, will format date/time in specific time zone.\r\n     *\r\n     * The value should be named time zone, e.g.:\r\n     * `"America/Vancouver"`, `"Australia/Sydney"`, `"UTC"`.\r\n     *\r\n     * NOTE: Using time zone feature may noticeable affect performance of the\r\n     * chart, especially with large data sets, since every single date will need\r\n     * to be recalculated.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#time-zone} for more info\r\n     * @since 5.1.0\r\n     */\n    Object.defineProperty(this, "timezone", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * The maximum FPS that the Root will run at.\r\n     *\r\n     * If `undefined` it will run at the highest FPS.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Performance} for more info\r\n     */\n    Object.defineProperty(this, "fps", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * Number formatter.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-numbers/} for more info\r\n     */\n    Object.defineProperty(this, "numberFormatter", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: NumberFormatter.new(this, {})\n    });\n    /**\r\n     * Date/time formatter.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/} for more info\r\n     */\n    Object.defineProperty(this, "dateFormatter", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: DateFormatter.new(this, {})\n    });\n    /**\r\n     * Duration formatter.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/} for more info\r\n     */\n    Object.defineProperty(this, "durationFormatter", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: DurationFormatter.new(this, {})\n    });\n    // Accessibility\n    /**\r\n     * Global tab index for using for the whole chart\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/concepts/accessibility/} for more info\r\n     */\n    Object.defineProperty(this, "tabindex", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    //@todo maybe make this better\n    Object.defineProperty(this, "_tabindexes", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "_a11yD", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_focusElementDirty", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_focusElementContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_focusedSprite", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_isShift", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_keyboardDragPoint", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_tooltipElementContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_readerAlertElement", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_logo", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_tooltipDiv", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * Used for dynamically-created CSS and JavaScript with strict source policies.\r\n     */\n    Object.defineProperty(this, "nonce", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * Special color set to be used for various controls.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Interface_colors} for more info\r\n     */\n    Object.defineProperty(this, "interfaceColors", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * An instance of vertical layout object that can be used to set `layout` setting\r\n     * of a [[Container]].\r\n     *\r\n     * @default VerticalLayout.new()\r\n     */\n    Object.defineProperty(this, "verticalLayout", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: VerticalLayout.new(this, {})\n    });\n    /**\r\n     * An instance of horizontal layout object that can be used to set `layout` setting\r\n     * of a [[Container]].\r\n     *\r\n     * @default HorizontalLayout.new()\r\n     */\n    Object.defineProperty(this, "horizontalLayout", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: HorizontalLayout.new(this, {})\n    });\n    /**\r\n     * An instance of grid layout object that can be used to set `layout` setting\r\n     * of a [[Container]].\r\n     *\r\n     * @default VerticalLayout.new()\r\n     */\n    Object.defineProperty(this, "gridLayout", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: GridLayout.new(this, {})\n    });\n    Object.defineProperty(this, "_paused", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    /**\r\n     * Indicates whether chart should resized automatically when parent container\r\n     * width and/or height changes.\r\n     *\r\n     * If disabled (`autoResize = false`) you can make the chart resize manually\r\n     * by calling root element\'s `resize()` method.\r\n     */\n    Object.defineProperty(this, "autoResize", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, "_fontHash", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: ""\n    });\n    Object.defineProperty(this, "_isDisposed", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_disposers", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "_resizeSensorDisposer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_tooltips", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "_htmlElementContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_htmlEnabledContainers", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    if (!isReal) {\n      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");\n    }\n    this._settings = settings;\n    if (settings.accessible == false) {\n      this._a11yD = true;\n    }\n    if (settings.useSafeResolution == null) {\n      settings.useSafeResolution = true;\n    }\n    let resolution;\n    if (settings.useSafeResolution) {\n      resolution = getSafeResolution();\n    }\n    this._renderer = new CanvasRenderer(resolution);\n    let dom;\n    if (id instanceof HTMLElement) {\n      dom = id;\n    } else {\n      dom = document.getElementById(id);\n    }\n    each(registry.rootElements, root => {\n      if (root.dom === dom) {\n        throw new Error("You cannot have multiple Roots on the same DOM node");\n      }\n    });\n    this.interfaceColors = InterfaceColors.new(this, {});\n    if (dom === null) {\n      throw new Error("Could not find HTML element with id `" + id + "`");\n    }\n    this.dom = dom;\n    let inner = document.createElement("div");\n    inner.style.position = "relative";\n    inner.style.width = "100%";\n    inner.style.height = "100%";\n    dom.appendChild(inner);\n    const tooltipContainerBounds = settings.tooltipContainerBounds;\n    if (tooltipContainerBounds) {\n      this._tooltipContainerSettings = tooltipContainerBounds;\n    }\n    this._inner = inner;\n    this._updateComputedStyles();\n    registry.rootElements.push(this);\n  }\n  static new(id, settings) {\n    const root = new Root(id, settings, true);\n    root._init();\n    return root;\n  }\n  moveDOM(id) {\n    let dom;\n    if (id instanceof HTMLElement) {\n      dom = id;\n    } else {\n      dom = document.getElementById(id);\n    }\n    if (dom) {\n      while (this.dom.childNodes.length > 0) {\n        dom.appendChild(this.dom.childNodes[0]);\n      }\n      this.dom = dom;\n      this._initResizeSensor();\n      this.resize();\n    }\n  }\n  _handleLogo() {\n    if (this._logo) {\n      const w = this.dom.offsetWidth;\n      const h = this.dom.offsetHeight;\n      if (w <= 150 || h <= 60) {\n        this._logo.hide();\n      } else {\n        this._logo.show();\n      }\n    }\n  }\n  _showBranding() {\n    if (!this._logo) {\n      const logo = this.tooltipContainer.children.push(Container.new(this, {\n        interactive: true,\n        interactiveChildren: false,\n        position: "absolute",\n        setStateOnChildren: true,\n        paddingTop: 9,\n        paddingRight: 9,\n        paddingBottom: 9,\n        paddingLeft: 9,\n        scale: .6,\n        y: percent(100),\n        centerY: p100,\n        tooltipText: "Created using amCharts 5",\n        tooltipX: p100,\n        cursorOverStyle: "pointer",\n        background: Rectangle.new(this, {\n          fill: color(0x474758),\n          fillOpacity: 0,\n          tooltipY: 5\n        })\n      }));\n      const tooltip = Tooltip.new(this, {\n        pointerOrientation: "horizontal",\n        paddingTop: 4,\n        paddingRight: 7,\n        paddingBottom: 4,\n        paddingLeft: 7\n      });\n      tooltip.label.setAll({\n        fontSize: 12\n      });\n      tooltip.get("background").setAll({\n        fill: this.interfaceColors.get("background"),\n        stroke: this.interfaceColors.get("grid"),\n        strokeOpacity: 0.3\n      });\n      logo.set("tooltip", tooltip);\n      logo.events.on("click", () => {\n        window.open("https://www.amcharts.com/", "_blank");\n      });\n      logo.states.create("hover", {});\n      const m = logo.children.push(Graphics.new(this, {\n        stroke: color(0xcccccc),\n        strokeWidth: 3,\n        svgPath: "M5 25 L13 25h13.6c3.4 0 6 0 10.3-4.3s5.2-12 8.6-12c3.4 0 4.3 8.6 7.7 8.6M83.4 25H79.8c-3.4 0-6 0-10.3-4.3s-5.2-12-8.6-12-4.3 8.6-7.7 8.6"\n      }));\n      m.states.create("hover", {\n        stroke: color(0x3CABFF)\n      });\n      const a = logo.children.push(Graphics.new(this, {\n        stroke: color(0x888888),\n        strokeWidth: 3,\n        svgPath: "M83.4 25h-31C37 25 39.5 4.4 28.4 4.4S18.9 24.2 4.3 25H0"\n      }));\n      a.states.create("hover", {\n        stroke: color(0x474758)\n      });\n      //logo.set("tooltip", this._tooltip);\n      //logo.setPrivate("tooltipTarget", logo.get("background"));\n      this._logo = logo;\n      this._handleLogo();\n    }\n  }\n  _getRealSize() {\n    return this.dom.getBoundingClientRect();\n  }\n  _getCalculatedSize(rect) {\n    if (this._settings.calculateSize) {\n      return this._settings.calculateSize(rect);\n    } else {\n      return {\n        width: rect.width,\n        height: rect.height\n      };\n    }\n  }\n  _init() {\n    const settings = this._settings;\n    if (settings.accessible !== false) {\n      if (settings.focusable) {\n        this._inner.setAttribute("focusable", "true");\n        this._inner.setAttribute("tabindex", this.tabindex + "");\n      }\n      if (settings.ariaLabel) {\n        this._inner.setAttribute("aria-label", settings.ariaLabel);\n      }\n      if (settings.role) {\n        this._inner.setAttribute("role", settings.role);\n      }\n    }\n    const renderer = this._renderer;\n    const rect = this._getRealSize();\n    const size = this._getCalculatedSize(rect);\n    const width = Math.floor(size.width);\n    const height = Math.floor(size.height);\n    const realWidth = Math.floor(rect.width);\n    const realHeight = Math.floor(rect.height);\n    const rootContainer = Container.new(this, {\n      visible: true,\n      width: width,\n      height: height\n    });\n    this._rootContainer = rootContainer;\n    this._rootContainer._defaultThemes.push(DefaultTheme.new(this));\n    const container = rootContainer.children.push(Container.new(this, {\n      visible: true,\n      width: p100,\n      height: p100\n    }));\n    this.container = container;\n    renderer.resize(realWidth, realHeight, width, height);\n    //@todo: better appendChild - refer\n    this._inner.appendChild(renderer.view);\n    // TODO: TMP TMP TMP for testing only, remove\n    //renderer.debugGhostView = true;\n    this._initResizeSensor();\n    // HTML content holder\n    const htmlElementContainer = document.createElement("div");\n    this._htmlElementContainer = htmlElementContainer;\n    htmlElementContainer.className = "am5-html-container";\n    htmlElementContainer.style.position = "absolute";\n    htmlElementContainer.style.pointerEvents = "none";\n    if (!this._tooltipContainerSettings) {\n      htmlElementContainer.style.overflow = "hidden";\n    }\n    this._inner.appendChild(htmlElementContainer);\n    if (this._a11yD !== true) {\n      // Create element which is used to make announcements to screen reader\n      const readerAlertElement = document.createElement("div");\n      readerAlertElement.className = "am5-reader-container";\n      readerAlertElement.setAttribute("role", "alert");\n      // readerAlertElement.style.zIndex = "-100000";\n      // readerAlertElement.style.opacity = "0";\n      // readerAlertElement.style.top = "0";\n      readerAlertElement.style.position = "absolute";\n      readerAlertElement.style.width = "1px";\n      readerAlertElement.style.height = "1px";\n      readerAlertElement.style.overflow = "hidden";\n      readerAlertElement.style.clip = "rect(1px, 1px, 1px, 1px)";\n      this._readerAlertElement = readerAlertElement;\n      this._inner.appendChild(this._readerAlertElement);\n      const focusElementContainer = document.createElement("div");\n      focusElementContainer.className = "am5-focus-container";\n      focusElementContainer.style.position = "absolute";\n      focusElementContainer.style.pointerEvents = "none";\n      focusElementContainer.style.top = "0px";\n      focusElementContainer.style.left = "0px";\n      focusElementContainer.style.overflow = "hidden";\n      focusElementContainer.style.width = width + "px";\n      focusElementContainer.style.height = height + "px";\n      focusElementContainer.setAttribute("role", "graphics-document");\n      setInteractive(focusElementContainer, false);\n      this._focusElementContainer = focusElementContainer;\n      this._inner.appendChild(this._focusElementContainer);\n      const tooltipElementContainer = document.createElement("div");\n      this._tooltipElementContainer = tooltipElementContainer;\n      tooltipElementContainer.className = "am5-tooltip-container";\n      this._inner.appendChild(tooltipElementContainer);\n      // Add keyboard events for accessibility, e.g. simulating drag with arrow\n      // keys and click with ENTER\n      if (supports("keyboardevents")) {\n        this._disposers.push(Utils_addEventListener(window, "keydown", ev => {\n          const eventKey = getEventKey(ev);\n          if (eventKey == "Shift") {\n            this._isShift = true;\n          } else if (eventKey == "Tab") {\n            this._isShift = ev.shiftKey;\n          }\n        }));\n        this._disposers.push(Utils_addEventListener(window, "keyup", ev => {\n          const eventKey = getEventKey(ev);\n          if (eventKey == "Shift") {\n            this._isShift = false;\n          }\n        }));\n        this._disposers.push(Utils_addEventListener(focusElementContainer, "click", () => {\n          // Some screen readers convert ENTER (and some SPACE) press whil on\n          // focused element to a "click" event, preventing actual "keydown"\n          // event from firing. We\'re using this "click" event to still\n          // generate internal click events.\n          const focusedSprite = this._focusedSprite;\n          if (focusedSprite) {\n            const downEvent = renderer.getEvent(new MouseEvent("click"));\n            focusedSprite.events.dispatch("click", {\n              type: "click",\n              originalEvent: downEvent.event,\n              point: downEvent.point,\n              simulated: true,\n              target: focusedSprite\n            });\n          }\n        }));\n        this._disposers.push(Utils_addEventListener(focusElementContainer, "keydown", ev => {\n          const focusedSprite = this._focusedSprite;\n          if (focusedSprite) {\n            if (ev.key == "Escape") {\n              // ESC pressed - lose current focus\n              Utils_blur();\n              this._focusedSprite = undefined;\n            }\n            let dragOffsetX = 0;\n            let dragOffsetY = 0;\n            // TODO: figure out if using bogus MouseEvent is fine, or it will\n            // fail on some platforms\n            const eventKey = getEventKey(ev);\n            switch (eventKey) {\n              case "Enter":\n              case " ":\n                if (eventKey == " " && focusedSprite.get("role") != "checkbox") {\n                  return;\n                }\n                ev.preventDefault();\n                const downEvent = renderer.getEvent(new MouseEvent("click"));\n                focusedSprite.events.dispatch("click", {\n                  type: "click",\n                  originalEvent: downEvent.event,\n                  point: downEvent.point,\n                  simulated: true,\n                  target: focusedSprite\n                });\n                return;\n              case "ArrowLeft":\n                dragOffsetX = -6;\n                break;\n              case "ArrowRight":\n                dragOffsetX = 6;\n                break;\n              case "ArrowUp":\n                dragOffsetY = -6;\n                break;\n              case "ArrowDown":\n                dragOffsetY = 6;\n                break;\n              default:\n                return;\n            }\n            if (dragOffsetX != 0 || dragOffsetY != 0) {\n              ev.preventDefault();\n              if (!focusedSprite.isDragging()) {\n                // Start dragging\n                this._keyboardDragPoint = {\n                  x: 0,\n                  y: 0\n                };\n                const downEvent = renderer.getEvent(new MouseEvent("mousedown", {\n                  clientX: 0,\n                  clientY: 0\n                }));\n                if (focusedSprite.events.isEnabled("pointerdown")) {\n                  focusedSprite.events.dispatch("pointerdown", {\n                    type: "pointerdown",\n                    originalEvent: downEvent.event,\n                    point: downEvent.point,\n                    simulated: true,\n                    target: focusedSprite\n                  });\n                }\n              } else {\n                // Move focus marker\n                //this._positionFocusElement(focusedSprite);\n              }\n              // Move incrementally\n              const dragPoint = this._keyboardDragPoint;\n              dragPoint.x += dragOffsetX;\n              dragPoint.y += dragOffsetY;\n              const moveEvent = renderer.getEvent(new MouseEvent("mousemove", {\n                clientX: dragPoint.x,\n                clientY: dragPoint.y\n              }), false);\n              if (focusedSprite.events.isEnabled("globalpointermove")) {\n                focusedSprite.events.dispatch("globalpointermove", {\n                  type: "globalpointermove",\n                  originalEvent: moveEvent.event,\n                  point: moveEvent.point,\n                  simulated: true,\n                  target: focusedSprite\n                });\n              }\n            }\n          }\n        }));\n        this._disposers.push(Utils_addEventListener(focusElementContainer, "keyup", ev => {\n          if (this._focusedSprite) {\n            const focusedSprite = this._focusedSprite;\n            const eventKey = getEventKey(ev);\n            switch (eventKey) {\n              case "ArrowLeft":\n              case "ArrowRight":\n              case "ArrowTop":\n              case "ArrowDown":\n                if (focusedSprite.isDragging()) {\n                  // Simulate drag stop\n                  const dragPoint = this._keyboardDragPoint;\n                  const upEvent = renderer.getEvent(new MouseEvent("mouseup", {\n                    clientX: dragPoint.x,\n                    clientY: dragPoint.y\n                  }));\n                  if (focusedSprite.events.isEnabled("globalpointerup")) {\n                    focusedSprite.events.dispatch("globalpointerup", {\n                      type: "globalpointerup",\n                      originalEvent: upEvent.event,\n                      point: upEvent.point,\n                      simulated: true,\n                      target: focusedSprite\n                    });\n                  }\n                  //this._positionFocusElement(focusedSprite);\n                  this._keyboardDragPoint = undefined;\n                  // @todo dispatch mouseup event instead of calling dragStop?\n                  // this._dispatchEvent("globalpointerup", target, upEvent);\n                  return;\n                } else if (focusedSprite.get("focusableGroup")) {\n                  // Find next item in focusable group\n                  const group = focusedSprite.get("focusableGroup");\n                  const items = this._tabindexes.filter(item => {\n                    return item.get("focusableGroup") == group && item.getPrivate("focusable") !== false && item.isVisibleDeep() ? true : false;\n                  });\n                  let index = items.indexOf(focusedSprite);\n                  const lastIndex = items.length - 1;\n                  index += eventKey == "ArrowRight" || eventKey == "ArrowDown" ? 1 : -1;\n                  if (index < 0) {\n                    index = lastIndex;\n                  } else if (index > lastIndex) {\n                    index = 0;\n                  }\n                  Utils_focus(items[index].getPrivate("focusElement").dom);\n                }\n                break;\n            }\n          }\n        }));\n      }\n    }\n    this._startTicker();\n    this.setThemes([]);\n    this._addTooltip();\n    if (!this._hasLicense()) {\n      this._showBranding();\n    }\n  }\n  _initResizeSensor() {\n    if (this._resizeSensorDisposer) {\n      this._resizeSensorDisposer.dispose();\n    }\n    this._resizeSensorDisposer = new ResizeSensor(this.dom, () => {\n      if (this.autoResize) {\n        this.resize();\n      }\n    });\n    this._disposers.push(this._resizeSensorDisposer);\n  }\n  /**\r\n   * If automatic resizing of char is disabled (`root.autoResize = false`), it\r\n   * can be resized manually by calling this method.\r\n   */\n  resize() {\n    const rect = this._getRealSize();\n    const size = this._getCalculatedSize(rect);\n    const w = Math.floor(size.width);\n    const h = Math.floor(size.height);\n    if (w > 0 && h > 0) {\n      const realWidth = Math.floor(rect.width);\n      const realHeight = Math.floor(rect.height);\n      const htmlElementContainer = this._htmlElementContainer;\n      htmlElementContainer.style.width = w + "px";\n      htmlElementContainer.style.height = h + "px";\n      if (this._a11yD !== true) {\n        const focusElementContainer = this._focusElementContainer;\n        focusElementContainer.style.width = w + "px";\n        focusElementContainer.style.height = h + "px";\n      }\n      this._renderer.resize(realWidth, realHeight, w, h);\n      const rootContainer = this._rootContainer;\n      rootContainer.setPrivate("width", w);\n      rootContainer.setPrivate("height", h);\n      this._render();\n      this._handleLogo();\n    }\n  }\n  _render() {\n    this._renderer.render(this._rootContainer._display);\n    if (this._focusElementDirty) {\n      this._updateCurrentFocus();\n      this._focusElementDirty = false;\n    }\n  }\n  _runTickers(currentTime) {\n    each(this._tickers, f => {\n      f(currentTime);\n    });\n  }\n  _runAnimations(currentTime) {\n    let running = 0;\n    keepIf(this._animations, animation => {\n      const state = animation._runAnimation(currentTime);\n      if (state === AnimationState.Stopped) {\n        return false;\n      } else if (state === AnimationState.Playing) {\n        ++running;\n        return true;\n      } else {\n        return true;\n      }\n    });\n    this._isDirtyAnimation = false;\n    return running === 0;\n  }\n  _runDirties() {\n    //console.log("tick **************************************************************");\n    let allParents = {};\n    while (this._isDirtyParents) {\n      // This must be before calling _prepareChildren\n      this._isDirtyParents = false;\n      keys(this._dirtyParents).forEach(key => {\n        const parent = this._dirtyParents[key];\n        delete this._dirtyParents[key];\n        if (!parent.isDisposed()) {\n          allParents[parent.uid] = parent;\n          parent._prepareChildren();\n        }\n      });\n    }\n    keys(allParents).forEach(key => {\n      allParents[key]._updateChildren();\n    });\n    const objects = [];\n    //\t\tconsole.log("_beforeChanged")\n    keys(this._dirty).forEach(key => {\n      const entity = this._dirty[key];\n      if (entity.isDisposed()) {\n        delete this._dirty[entity.uid];\n      } else {\n        objects.push(entity);\n        entity._beforeChanged();\n      }\n    });\n    //\t\tconsole.log("_changed")\n    objects.forEach(entity => {\n      entity._changed();\n      delete this._dirty[entity.uid];\n      entity._clearDirty();\n    });\n    this._isDirty = false;\n    const depths = {};\n    const bounds = [];\n    keys(this._dirtyBounds).forEach(key => {\n      const entity = this._dirtyBounds[key];\n      delete this._dirtyBounds[key];\n      if (!entity.isDisposed()) {\n        depths[entity.uid] = entity.depth();\n        bounds.push(entity);\n      }\n    });\n    this._positionHTMLElements();\n    // High depth -> low depth\n    bounds.sort((x, y) => {\n      return compare(depths[y.uid], depths[x.uid]);\n    });\n    //\t\tconsole.log("_updateBounds")\n    bounds.forEach(entity => {\n      entity._updateBounds();\n    });\n    //\t\tconsole.log("_updatePosition")\n    const dirtyPositions = this._dirtyPositions;\n    keys(dirtyPositions).forEach(key => {\n      const sprite = dirtyPositions[key];\n      delete dirtyPositions[key];\n      if (!sprite.isDisposed()) {\n        sprite._updatePosition();\n      }\n    });\n    //\t\tconsole.log("_afterChanged")\n    objects.forEach(entity => {\n      entity._afterChanged();\n    });\n  }\n  _renderFrame(currentTime) {\n    if (this._updateTick) {\n      if (this.events.isEnabled("framestarted")) {\n        this.events.dispatch("framestarted", {\n          type: "framestarted",\n          target: this,\n          timestamp: currentTime\n        });\n      }\n      this._checkComputedStyles();\n      this._runTickers(currentTime);\n      const animationDone = this._runAnimations(currentTime);\n      this._runDirties();\n      this._render();\n      this._renderer.resetImageArray();\n      this._positionHTMLElements();\n      if (this.events.isEnabled("frameended")) {\n        this.events.dispatch("frameended", {\n          type: "frameended",\n          target: this,\n          timestamp: currentTime\n        });\n      }\n      return this._tickers.length === 0 && animationDone && !this._isDirtyAnimation && !this._isDirty;\n    } else {\n      return true;\n    }\n  }\n  _runTicker(currentTime, now) {\n    if (!this.isDisposed()) {\n      this.animationTime = currentTime;\n      const done = this._renderFrame(currentTime);\n      // No more work to do\n      if (done) {\n        this._ticker = null;\n        this.animationTime = null;\n      } else {\n        if (!this._paused) {\n          if (now) {\n            this._ticker;\n          } else {\n            rAF(this.fps, this._ticker);\n          }\n        }\n      }\n    }\n  }\n  _runTickerNow(timeout = 10000) {\n    if (!this.isDisposed()) {\n      const endTime = performance.now() + timeout;\n      for (;;) {\n        const currentTime = performance.now();\n        if (currentTime >= endTime) {\n          this.animationTime = null;\n          break;\n        }\n        this.animationTime = currentTime;\n        const done = this._renderFrame(currentTime);\n        if (done) {\n          this.animationTime = null;\n          break;\n        }\n      }\n    }\n  }\n  _startTicker() {\n    if (this._ticker === null) {\n      this.animationTime = null;\n      this._ticker = currentTime => {\n        this._runTicker(currentTime);\n      };\n      rAF(this.fps, this._ticker);\n    }\n  }\n  /**\r\n   * Returns whether the root is updating or not.\r\n   */\n  get updateTick() {\n    return this._updateTick;\n  }\n  /**\r\n   * Enables or disables the root updating.\r\n   */\n  set updateTick(value) {\n    this._updateTick = value;\n    if (value) {\n      this._startTicker();\n    }\n  }\n  _addDirtyEntity(entity) {\n    this._isDirty = true;\n    if (this._dirty[entity.uid] === undefined) {\n      this._dirty[entity.uid] = entity;\n    }\n    this._startTicker();\n  }\n  _addDirtyParent(parent) {\n    this._isDirty = true;\n    this._isDirtyParents = true;\n    if (this._dirtyParents[parent.uid] === undefined) {\n      this._dirtyParents[parent.uid] = parent;\n    }\n    this._startTicker();\n  }\n  _addDirtyBounds(entity) {\n    this._isDirty = true;\n    if (this._dirtyBounds[entity.uid] === undefined) {\n      this._dirtyBounds[entity.uid] = entity;\n    }\n    this._startTicker();\n  }\n  _addDirtyPosition(sprite) {\n    this._isDirty = true;\n    if (this._dirtyPositions[sprite.uid] === undefined) {\n      this._dirtyPositions[sprite.uid] = sprite;\n    }\n    this._startTicker();\n  }\n  _addAnimation(animation) {\n    this._isDirtyAnimation = true;\n    // TODO use numeric id instead\n    if (this._animations.indexOf(animation) === -1) {\n      this._animations.push(animation);\n    }\n    this._startTicker();\n  }\n  _markDirty() {\n    this._isDirty = true;\n  }\n  _markDirtyRedraw() {\n    this.events.once("frameended", () => {\n      this._isDirty = true;\n      this._startTicker();\n    });\n  }\n  eachFrame(f) {\n    this._tickers.push(f);\n    this._startTicker();\n    return new Disposer(() => {\n      removeFirst(this._tickers, f);\n    });\n  }\n  markDirtyGlobal(container) {\n    if (!container) {\n      container = this.container;\n    }\n    container.walkChildren(child => {\n      if (child instanceof Container) {\n        this.markDirtyGlobal(child);\n      }\n      child.markDirty();\n      child.markDirtyBounds();\n    });\n  }\n  /**\r\n   * Returns width of the target container, in pixels.\r\n   *\r\n   * @return Width\r\n   */\n  width() {\n    // TODO make this more efficient, maybe just return the renderer\'s width ?\n    return Math.floor(this._getCalculatedSize(this._getRealSize()).width);\n  }\n  /**\r\n   * Returns height of the target container, in pixels.\r\n   *\r\n   * @return Height\r\n   */\n  height() {\n    // TODO make this more efficient, maybe just return the renderer\'s height ?\n    return Math.floor(this._getCalculatedSize(this._getRealSize()).height);\n  }\n  /**\r\n   * Disposes root and all the content in it.\r\n   */\n  dispose() {\n    if (!this._isDisposed) {\n      this._isDisposed = true;\n      this._rootContainer.dispose();\n      this._renderer.dispose();\n      this.horizontalLayout.dispose();\n      this.verticalLayout.dispose();\n      this.interfaceColors.dispose();\n      each(this._disposers, x => {\n        x.dispose();\n      });\n      if (this._inner) {\n        removeElement(this._inner);\n      }\n      Array_remove(registry.rootElements, this);\n    }\n  }\n  /**\r\n   * Returns `true` if root element is disposed.\r\n   *\r\n   * @return Disposed?\r\n   */\n  isDisposed() {\n    return this._isDisposed;\n  }\n  /**\r\n   * Triggers screen reader read out a message.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/accessibility/} for more info\r\n   * @param  text  Alert text\r\n   */\n  readerAlert(text) {\n    if (this._a11yD !== true) {\n      this._readerAlertElement.innerHTML = stripTags(text);\n    }\n  }\n  /**\r\n   * Sets themes to be used for the chart.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/themes/} for more info\r\n   * @param  themes  A list of themes\r\n   */\n  setThemes(themes) {\n    this._rootContainer.set("themes", themes);\n    // otherwise new themes are not applied\n    const tooltipContainer = this.tooltipContainer;\n    if (tooltipContainer) {\n      tooltipContainer._applyThemes();\n    }\n    // @todo review this\n    const interfaceColors = this.interfaceColors;\n    if (interfaceColors) {\n      interfaceColors._applyThemes();\n    }\n  }\n  _addTooltip() {\n    if (!this.tooltipContainer) {\n      const tooltipContainerSettings = this._tooltipContainerSettings;\n      const tooltipContainer = this._rootContainer.children.push(Container.new(this, {\n        position: "absolute",\n        isMeasured: false,\n        width: p100,\n        height: p100,\n        layer: tooltipContainerSettings ? 35 : 30,\n        layerMargin: tooltipContainerSettings ? tooltipContainerSettings : undefined\n      }));\n      this.tooltipContainer = tooltipContainer;\n      const tooltip = Tooltip.new(this, {});\n      this.container.set("tooltip", tooltip);\n      tooltip.hide(0);\n      this._tooltip = tooltip;\n    }\n  }\n  /**\r\n   * Accesibility\r\n   */\n  _registerTabindexOrder(target) {\n    if (this._a11yD == true) {\n      return;\n    }\n    if (target.get("focusable")) {\n      pushOne(this._tabindexes, target);\n    } else {\n      Array_remove(this._tabindexes, target);\n    }\n    this._invalidateTabindexes();\n  }\n  _unregisterTabindexOrder(target) {\n    if (this._a11yD == true) {\n      return;\n    }\n    Array_remove(this._tabindexes, target);\n    this._invalidateTabindexes();\n  }\n  _invalidateTabindexes() {\n    if (this._a11yD == true) {\n      return;\n    }\n    this._tabindexes.sort((a, b) => {\n      const aindex = a.get("tabindexOrder", 0);\n      const bindex = b.get("tabindexOrder", 0);\n      if (aindex == bindex) {\n        return 0;\n      } else if (aindex > bindex) {\n        return 1;\n      } else {\n        return -1;\n      }\n    });\n    const groups = [];\n    each(this._tabindexes, (item, index) => {\n      if (!item.getPrivate("focusElement")) {\n        this._makeFocusElement(index, item);\n      } else {\n        this._moveFocusElement(index, item);\n      }\n      const group = item.get("focusableGroup");\n      if (group && item.getPrivate("focusable") !== false) {\n        if (groups.indexOf(group) !== -1) {\n          // Non-first element in the group, make it not directly focusable\n          item.getPrivate("focusElement").dom.setAttribute("tabindex", "-1");\n        } else {\n          groups.push(group);\n        }\n      }\n    });\n  }\n  _updateCurrentFocus() {\n    if (this._a11yD == true) {\n      return;\n    }\n    if (this._focusedSprite) {\n      this._decorateFocusElement(this._focusedSprite);\n      this._positionFocusElement(this._focusedSprite);\n    }\n  }\n  _decorateFocusElement(target, focusElement) {\n    if (this._a11yD == true) {\n      return;\n    }\n    // Decorate with proper accessibility attributes\n    if (!focusElement) {\n      focusElement = target.getPrivate("focusElement").dom;\n    }\n    if (!focusElement) {\n      return;\n    }\n    const role = target.get("role");\n    if (role) {\n      focusElement.setAttribute("role", role);\n    } else {\n      focusElement.removeAttribute("role");\n    }\n    const ariaLabel = target.get("ariaLabel");\n    if (ariaLabel) {\n      const label = populateString(target, ariaLabel);\n      focusElement.setAttribute("aria-label", label);\n    } else {\n      focusElement.removeAttribute("aria-label");\n    }\n    const ariaLive = target.get("ariaLive");\n    if (ariaLive) {\n      focusElement.setAttribute("aria-live", ariaLive);\n    } else {\n      focusElement.removeAttribute("aria-live");\n    }\n    const ariaChecked = target.get("ariaChecked");\n    if (ariaChecked != null && role && ["checkbox", "option", "radio", "menuitemcheckbox", "menuitemradio", "treeitem"].indexOf(role) !== -1) {\n      focusElement.setAttribute("aria-checked", ariaChecked ? "true" : "false");\n    } else {\n      focusElement.removeAttribute("aria-checked");\n    }\n    const ariaCurrent = target.get("ariaCurrent");\n    if (ariaCurrent != null) {\n      focusElement.setAttribute("aria-current", ariaCurrent);\n    } else {\n      focusElement.removeAttribute("aria-current");\n    }\n    const ariaSelected = target.get("ariaSelected");\n    if (ariaSelected != null && role && ["gridcell", "option", "row", "tab", "columnheader", "rowheader", "treeitem"].indexOf(role) !== -1) {\n      focusElement.setAttribute("aria-selected", ariaSelected ? "true" : "false");\n    } else {\n      focusElement.removeAttribute("aria-selected");\n    }\n    if (target.get("ariaHidden")) {\n      focusElement.setAttribute("aria-hidden", "true");\n    } else {\n      focusElement.removeAttribute("aria-hidden");\n    }\n    const ariaOrientation = target.get("ariaOrientation");\n    if (ariaOrientation) {\n      focusElement.setAttribute("aria-orientation", ariaOrientation);\n    } else {\n      focusElement.removeAttribute("aria-orientation");\n    }\n    const ariaValueNow = target.get("ariaValueNow");\n    if (ariaValueNow) {\n      focusElement.setAttribute("aria-valuenow", ariaValueNow);\n    } else {\n      focusElement.removeAttribute("aria-valuenow");\n    }\n    const ariaValueMin = target.get("ariaValueMin");\n    if (ariaValueMin) {\n      focusElement.setAttribute("aria-valuemin", ariaValueMin);\n    } else {\n      focusElement.removeAttribute("aria-valuemin");\n    }\n    const ariaValueMax = target.get("ariaValueMax");\n    if (ariaValueMax) {\n      focusElement.setAttribute("aria-valuemax", ariaValueMax);\n    } else {\n      focusElement.removeAttribute("aria-valuemax");\n    }\n    const ariaValueText = target.get("ariaValueText");\n    if (ariaValueText) {\n      focusElement.setAttribute("aria-valuetext", ariaValueText);\n    } else {\n      focusElement.removeAttribute("aria-valuetext");\n    }\n    const ariaControls = target.get("ariaControls");\n    if (ariaControls) {\n      focusElement.setAttribute("aria-controls", ariaControls);\n    } else {\n      focusElement.removeAttribute("aria-controls");\n    }\n    if (target.get("visible") && target.get("opacity") !== 0 && target.get("role") != "tooltip" && !target.isHidden() && target.getPrivate("focusable") !== false) {\n      if (focusElement.getAttribute("tabindex") != "-1") {\n        focusElement.setAttribute("tabindex", "" + this.tabindex);\n      }\n      focusElement.removeAttribute("aria-hidden");\n    } else {\n      focusElement.removeAttribute("tabindex");\n      focusElement.setAttribute("aria-hidden", "true");\n    }\n  }\n  _makeFocusElement(index, target) {\n    if (target.getPrivate("focusElement") || this._a11yD == true) {\n      return;\n    }\n    // Init\n    const focusElement = document.createElement("div");\n    if (target.get("role") != "tooltip") {\n      focusElement.tabIndex = this.tabindex;\n    }\n    focusElement.style.position = "absolute";\n    setInteractive(focusElement, false);\n    const disposers = [];\n    target.setPrivate("focusElement", {\n      dom: focusElement,\n      disposers\n    });\n    this._decorateFocusElement(target);\n    disposers.push(Utils_addEventListener(focusElement, "focus", ev => {\n      this._handleFocus(ev);\n    }));\n    disposers.push(Utils_addEventListener(focusElement, "blur", ev => {\n      this._handleBlur(ev);\n    }));\n    this._moveFocusElement(index, target);\n  }\n  _removeFocusElement(target) {\n    if (this._a11yD == true) {\n      return;\n    }\n    Array_remove(this._tabindexes, target);\n    const focusElement = target.getPrivate("focusElement");\n    if (focusElement) {\n      const container = this._focusElementContainer;\n      container.removeChild(focusElement.dom);\n      each(focusElement.disposers, x => {\n        x.dispose();\n      });\n    }\n  }\n  _hideFocusElement(target) {\n    if (this._a11yD == true) {\n      return;\n    }\n    const focusElement = target.getPrivate("focusElement");\n    focusElement.dom.style.display = "none";\n  }\n  _moveFocusElement(index, target) {\n    if (this._a11yD == true) {\n      return;\n    }\n    // Get container\n    const container = this._focusElementContainer;\n    const focusElement = target.getPrivate("focusElement").dom;\n    if (focusElement === this._focusElementContainer.children[index]) {\n      // Nothing to do\n      return;\n    }\n    const next = this._focusElementContainer.children[index + 1];\n    if (next) {\n      container.insertBefore(focusElement, next);\n    } else {\n      container.append(focusElement);\n    }\n  }\n  _positionFocusElement(target) {\n    if (this._a11yD == true || target == undefined) {\n      return;\n    }\n    const bounds = target.globalBounds();\n    let width = bounds.right == bounds.left ? target.width() : bounds.right - bounds.left;\n    let height = bounds.top == bounds.bottom ? target.height() : bounds.bottom - bounds.top;\n    const padding = this._settings.focusPadding !== undefined ? this._settings.focusPadding : 2;\n    let x = bounds.left - padding;\n    let y = bounds.top - padding;\n    if (width < 0) {\n      x += width;\n      width = Math.abs(width);\n    }\n    if (height < 0) {\n      y += height;\n      height = Math.abs(height);\n    }\n    const focusElement = target.getPrivate("focusElement").dom;\n    focusElement.style.top = y + "px";\n    focusElement.style.left = x + "px";\n    focusElement.style.width = width + padding * 2 + "px";\n    focusElement.style.height = height + padding * 2 + "px";\n  }\n  _getSpriteByFocusElement(target) {\n    let found;\n    eachContinue(this._tabindexes, (item, _index) => {\n      if (item.getPrivate("focusElement").dom === target) {\n        found = item;\n        return false;\n      }\n      return true;\n    });\n    return found;\n  }\n  _handleFocus(ev) {\n    if (this._a11yD == true) {\n      return;\n    }\n    // Get element\n    //const focused = this._tabindexes[index];\n    const focused = this._getSpriteByFocusElement(ev.target);\n    if (!focused) {\n      return;\n    }\n    // Jump over hidden elements\n    if (!focused.isVisibleDeep()) {\n      this._focusNext(ev.target, this._isShift ? -1 : 1);\n      return;\n    }\n    // Size and position\n    this._positionFocusElement(focused);\n    //this._decorateFocusElement(focused);\n    this._focusedSprite = focused;\n    if (focused.events.isEnabled("focus")) {\n      focused.events.dispatch("focus", {\n        type: "focus",\n        originalEvent: ev,\n        target: focused\n      });\n    }\n  }\n  _focusNext(el, direction) {\n    if (this._a11yD == true) {\n      return;\n    }\n    const focusableElements = Array.from(document.querySelectorAll([\'a[href]\', \'area[href]\', \'button:not([disabled])\', \'details\', \'input:not([disabled])\', \'iframe:not([disabled])\', \'select:not([disabled])\', \'textarea:not([disabled])\', \'[contentEditable=""]\', \'[contentEditable="true"]\', \'[contentEditable="TRUE"]\', \'[tabindex]:not([tabindex^="-"])\'\n    //\':not([disabled])\'\n    ].join(\',\')));\n    let index = focusableElements.indexOf(el) + direction;\n    if (index < 0) {\n      index = focusableElements.length - 1;\n    } else if (index >= focusableElements.length) {\n      index = 0;\n    }\n    focusableElements[index].focus();\n  }\n  _handleBlur(ev) {\n    if (this._a11yD == true) {\n      return;\n    }\n    const focused = this._focusedSprite;\n    if (focused && !focused.isDisposed() && focused.events.isEnabled("blur")) {\n      focused.events.dispatch("blur", {\n        type: "blur",\n        originalEvent: ev,\n        target: focused\n      });\n    }\n    this._focusedSprite = undefined;\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateTooltip(target) {\n    if (this._a11yD == true) {\n      return;\n    }\n    const text = stripTags(target._getText());\n    let tooltipElement = target.getPrivate("tooltipElement");\n    if (target.get("role") == "tooltip" && text != "") {\n      if (!tooltipElement) {\n        tooltipElement = this._makeTooltipElement(target);\n      }\n      if (tooltipElement.innerHTML != text) {\n        tooltipElement.innerHTML = text;\n      }\n      tooltipElement.setAttribute("aria-hidden", target.isVisibleDeep() ? "false" : "true");\n    } else if (tooltipElement) {\n      tooltipElement.remove();\n      target.removePrivate("tooltipElement");\n    }\n  }\n  _makeTooltipElement(target) {\n    const container = this._tooltipElementContainer;\n    const tooltipElement = document.createElement("div");\n    tooltipElement.style.position = "absolute";\n    tooltipElement.style.width = "1px";\n    tooltipElement.style.height = "1px";\n    tooltipElement.style.overflow = "hidden";\n    tooltipElement.style.clip = "rect(1px, 1px, 1px, 1px)";\n    setInteractive(tooltipElement, false);\n    this._decorateFocusElement(target, tooltipElement);\n    container.append(tooltipElement);\n    target.setPrivate("tooltipElement", tooltipElement);\n    return tooltipElement;\n  }\n  _removeTooltipElement(target) {\n    if (this._a11yD == true) {\n      return;\n    }\n    const tooltipElement = target.getPrivate("tooltipElement");\n    if (tooltipElement) {\n      const parent = tooltipElement.parentElement;\n      if (parent) {\n        parent.removeChild(tooltipElement);\n      }\n    }\n  }\n  _invalidateAccessibility(target) {\n    if (this._a11yD == true) {\n      return;\n    }\n    this._focusElementDirty = true;\n    const focusElement = target.getPrivate("focusElement");\n    if (target.get("focusable")) {\n      if (focusElement) {\n        this._decorateFocusElement(target);\n        this._positionFocusElement(target);\n      }\n      // else {\n      // \tthis._renderer._makeFocusElement(0, this);\n      // }\n    } else if (focusElement) {\n      this._removeFocusElement(target);\n    }\n    //this.updateCurrentFocus();\n  }\n  /**\r\n   * Returns `true` if `target` is currently focused.\r\n   *\r\n   * @param   target  Target\r\n   * @return          Focused?\r\n   */\n  focused(target) {\n    return this._focusedSprite === target;\n  }\n  /**\r\n   * Converts document coordinates to coordinates withing root element.\r\n   *\r\n   * @param   point  Document point\r\n   * @return         Root point\r\n   */\n  documentPointToRoot(point) {\n    const rect = this._getRealSize();\n    const size = this._getCalculatedSize(rect);\n    const scaleWidth = size.width / rect.width;\n    const scaleHeight = size.height / rect.height;\n    return {\n      x: (point.x - rect.left) * scaleWidth,\n      y: (point.y - rect.top) * scaleHeight\n    };\n  }\n  /**\r\n   * Converts root coordinates to document\r\n   *\r\n   * @param   point  Document point\r\n   * @return         Root point\r\n   */\n  rootPointToDocument(point) {\n    const rect = this._getRealSize();\n    const size = this._getCalculatedSize(rect);\n    const scaleWidth = size.width / rect.width;\n    const scaleHeight = size.height / rect.height;\n    return {\n      x: point.x / scaleWidth + rect.left,\n      y: point.y / scaleHeight + rect.top\n    };\n  }\n  /**\r\n   * @ignore\r\n   */\n  addDisposer(disposer) {\n    this._disposers.push(disposer);\n    return disposer;\n  }\n  _updateComputedStyles() {\n    const styles = window.getComputedStyle(this.dom);\n    let fontHash = "";\n    Object_each(styles, (key, val) => {\n      if (Type_isString(key) && key.match(/^font/)) {\n        fontHash += val;\n      }\n    });\n    const changed = fontHash != this._fontHash;\n    if (changed) {\n      this._fontHash = fontHash;\n    }\n    return changed;\n  }\n  _checkComputedStyles() {\n    if (this._updateComputedStyles()) {\n      this._invalidateLabelBounds(this.container);\n    }\n  }\n  _invalidateLabelBounds(target) {\n    if (target instanceof Container) {\n      target.children.each(child => {\n        this._invalidateLabelBounds(child);\n      });\n    } else if (target instanceof Text_Text) {\n      target.markDirtyBounds();\n    }\n  }\n  /**\r\n   * To all the clever heads out there. Yes, we did not make any attempts to\r\n   * scramble this.\r\n   *\r\n   * This is a part of a tool meant for our users to manage their commercial\r\n   * licenses for removal of amCharts branding from charts.\r\n   *\r\n   * The only legit way to do so is to purchase a commercial license for amCharts:\r\n   * https://www.amcharts.com/online-store/\r\n   *\r\n   * Removing or altering this code, or disabling amCharts branding in any other\r\n   * way is against the license and thus illegal.\r\n   */\n  _hasLicense() {\n    for (let i = 0; i < registry.licenses.length; i++) {\n      if (registry.licenses[i].match(/^AM5C.{5,}/i)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _licenseApplied() {\n    if (this._logo) {\n      this._logo.set("forceHidden", true);\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  get debugGhostView() {\n    return this._renderer.debugGhostView;\n  }\n  /**\r\n   * @ignore\r\n   */\n  set debugGhostView(value) {\n    this._renderer.debugGhostView = value;\n  }\n  /**\r\n   * Set this to `true` if you need chart to require first a tap onto it before\r\n   * touch gesture related functionality like zoom/pan is turned on.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Touch_related_options} for more info\r\n   * @default false\r\n   * @since 5.2.9\r\n   * @param  value  Needs a tap to activate touch functions\r\n   */\n  set tapToActivate(value) {\n    this._renderer.tapToActivate = value;\n  }\n  /**\r\n   * @return Needs a tap to activate touch functions\r\n   */\n  get tapToActivate() {\n    return this._renderer.tapToActivate;\n  }\n  /**\r\n   * If `tapToActivate` is set to `true`, this setting will determine number\r\n   * of milliseconds the chart will stay "active", before releasing the\r\n   * controls back to the page.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Touch_related_options} for more info\r\n   * @default 3000\r\n   * @since 5.2.9\r\n   * @param  value  Timeout\r\n   */\n  set tapToActivateTimeout(value) {\n    this._renderer.tapToActivateTimeout = value;\n  }\n  /**\r\n   * @return Timeout\r\n   */\n  get tapToActivateTimeout() {\n    return this._renderer.tapToActivateTimeout;\n  }\n  _makeHTMLElement(target) {\n    // Get container\n    const container = this._htmlElementContainer;\n    // Init\n    const htmlElement = document.createElement("div");\n    target.setPrivate("htmlElement", htmlElement);\n    //htmlElement.tabIndex = this.tabindex;\n    htmlElement.style.position = "absolute";\n    htmlElement.style.overflow = "auto";\n    htmlElement.style.boxSizing = "border-box";\n    setInteractive(htmlElement, target.get("interactive", false));\n    // Translate events\n    if (target.events.isEnabled("click")) {\n      setInteractive(htmlElement, true);\n      this._disposers.push(Utils_addEventListener(htmlElement, "click", ev => {\n        const downEvent = this._renderer.getEvent(ev);\n        target.events.dispatch("click", {\n          type: "click",\n          originalEvent: downEvent.event,\n          point: downEvent.point,\n          simulated: false,\n          target: target\n        });\n      }));\n    }\n    this._positionHTMLElement(target);\n    container.append(htmlElement);\n    pushOne(this._htmlEnabledContainers, target);\n    return htmlElement;\n  }\n  _positionHTMLElements() {\n    each(this._htmlEnabledContainers, target => {\n      this._positionHTMLElement(target);\n    });\n  }\n  _positionHTMLElement(target) {\n    const htmlElement = target.getPrivate("htmlElement");\n    if (htmlElement) {\n      // Translate settings\n      const visualSettings = ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "minWidth", "minHeight", "maxWidth", "maxHeight"];\n      each(visualSettings, setting => {\n        const value = target.get(setting);\n        if (value) {\n          htmlElement.style[setting] = value + "px";\n        } else {\n          htmlElement.style[setting] = "";\n        }\n      });\n      // Init and reset scale / rotation\n      const scale = target.compositeScale() || 1;\n      const rotation = target.compositeRotation() || 0;\n      htmlElement.style.transform = "";\n      htmlElement.style.transformOrigin = "";\n      // Deal with opacity\n      const opacity = target.compositeOpacity();\n      setTimeout(() => {\n        htmlElement.style.opacity = opacity + "";\n      }, 10);\n      const visible = target.isVisibleDeep();\n      if (visible) {\n        htmlElement.style.display = "block";\n      }\n      // Deal with position\n      const bounds = target.globalBounds();\n      htmlElement.style.top = bounds.top + "px";\n      htmlElement.style.left = bounds.left + "px";\n      // Use width/height if those are set\n      const width = target.get("width");\n      const height = target.get("height");\n      let w = 0;\n      let h = 0;\n      if (width) {\n        w = target.width();\n      }\n      if (height) {\n        h = target.height();\n      }\n      if (!width || !height) {\n        htmlElement.style.position = "fixed";\n        htmlElement.style.width = "";\n        htmlElement.style.height = "";\n        const bbox = htmlElement.getBoundingClientRect();\n        htmlElement.style.position = "absolute";\n        if (!width) w = bbox.width;\n        if (!height) h = bbox.height;\n        target._adjustedLocalBounds = {\n          left: 0,\n          right: 0,\n          top: 0,\n          bottom: 0\n        };\n        target.setPrivate("minWidth", w / scale);\n        target.setPrivate("minHeight", h / scale);\n      } else {\n        target.removePrivate("minWidth");\n        target.removePrivate("minHeight");\n      }\n      if (w > 0) {\n        htmlElement.style.minWidth = w + "px";\n      }\n      if (h > 0) {\n        htmlElement.style.minHeight = h + "px";\n      }\n      // Hide or show\n      if (!visible || opacity == 0) {\n        htmlElement.style.display = "none";\n      }\n      // Deal with scale\n      if (scale != 1) {\n        htmlElement.style.transform += "scale(" + scale + ")";\n      }\n      if (rotation != 0) {\n        htmlElement.style.transform += " rotate(" + rotation + "deg)";\n      }\n      if (htmlElement.style.transform != "") {\n        htmlElement.style.transformOrigin = target.get("centerX", 0) + "%  " + target.get("centerY", 0) + "%";\n      }\n    }\n  }\n  _setHTMLContent(target, html) {\n    let htmlElement = target.getPrivate("htmlElement");\n    if (!htmlElement) {\n      htmlElement = this._makeHTMLElement(target);\n    }\n    if (htmlElement.innerHTML != html) {\n      htmlElement.innerHTML = html;\n    }\n  }\n  _removeHTMLContent(target) {\n    let htmlElement = target.getPrivate("htmlElement");\n    if (htmlElement) {\n      this._htmlElementContainer.removeChild(htmlElement);\n      target.removePrivate("htmlElement");\n    }\n    Array_remove(this._htmlEnabledContainers, target);\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//export { Language, ILanguageSettings } from "./.internal/core/util/Language";\n//export { List, IListSettings } from "./.internal/core/util/List";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Data.js\n\n/**\r\n * A [[List]] that holds components data.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/data/} for more info\r\n */\nclass ListData extends List {\n  constructor() {\n    super(...arguments);\n    /**\r\n     * An optional processor for data.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Pre_processing_data} for more info\r\n     */\n    Object.defineProperty(this, "processor", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  incrementRef() {}\n  /**\r\n   * @ignore\r\n   */\n  decrementRef() {}\n  _onPush(newValue) {\n    if (this.processor) {\n      this.processor.processRow(newValue);\n    }\n    super._onPush(newValue);\n  }\n  _onInsertIndex(index, newValue) {\n    if (this.processor) {\n      this.processor.processRow(newValue);\n    }\n    super._onInsertIndex(index, newValue);\n  }\n  _onSetIndex(index, oldValue, newValue) {\n    if (this.processor) {\n      this.processor.processRow(newValue);\n    }\n    super._onSetIndex(index, oldValue, newValue);\n  }\n}\n/**\r\n * @deprecated\r\n * @todo remove\r\n */\nclass JsonData {\n  constructor(value) {\n    Object.defineProperty(this, "processor", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_value", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._value = value;\n  }\n  incrementRef() {}\n  decrementRef() {}\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js\n\n\n\n\n\n\n/**\r\n * A base element that holds data bit (data item) for any [[Component]].\r\n */\nclass DataItem extends Settings {\n  constructor(component, dataContext, settings) {\n    super(settings);\n    /**\r\n     * A data item\'s owener [[Component]].\r\n     */\n    Object.defineProperty(this, "component", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * A reference to actual item in source data this item is based on.\r\n     */\n    Object.defineProperty(this, "dataContext", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * @todo requires description\r\n     */\n    Object.defineProperty(this, "bullets", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * A set of "open" values.\r\n     */\n    Object.defineProperty(this, "open", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * A set of "close" values.\r\n     */\n    Object.defineProperty(this, "close", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.dataContext = dataContext;\n    this.component = component;\n    this._settings.visible = true;\n    this._checkDirty();\n  }\n  /**\r\n   * @ignore\r\n   */\n  markDirty() {\n    this.component.markDirtyValues(this);\n  }\n  _startAnimation() {\n    this.component._root._addAnimation(this);\n  }\n  _animationTime() {\n    return this.component._root.animationTime;\n  }\n  _dispose() {\n    if (this.component) {\n      this.component.disposeDataItem(this);\n    }\n    super._dispose();\n  }\n  /**\r\n   * Shows a data item that\'s currently hidden.\r\n   */\n  show(duration) {\n    this.setRaw("visible", true);\n    if (this.component) {\n      this.component.showDataItem(this, duration);\n    }\n  }\n  /**\r\n   * Hides a data item that\'s currently visible.\r\n   */\n  hide(duration) {\n    this.setRaw("visible", false);\n    if (this.component) {\n      this.component.hideDataItem(this, duration);\n    }\n  }\n  isHidden() {\n    return !this.get("visible");\n  }\n}\n/**\r\n * A base class for elements that make use of data.\r\n */\nclass Component extends Container {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_data", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListData()\n    });\n    Object.defineProperty(this, "_dataItems", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "_mainDataItems", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._dataItems\n    });\n    Object.defineProperty(this, "valueFields", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "fields", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: ["id"]\n    });\n    Object.defineProperty(this, "_valueFields", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_valueFieldsF", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_fields", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_fieldsF", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_valuesDirty", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_dataChanged", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_dataGrouped", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    /**\r\n     * Indicates if the component has already been initialized.\r\n     */\n    Object.defineProperty(this, "inited", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n  }\n  /**\r\n   * Component\'s data.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/data/} for more info\r\n   */\n  set data(data) {\n    data.incrementRef();\n    this._data.decrementRef();\n    this._data = data;\n  }\n  /**\r\n   * @return  Data\r\n   */\n  get data() {\n    return this._data;\n  }\n  _dispose() {\n    super._dispose();\n    this._data.decrementRef();\n  }\n  _onDataClear() {}\n  _afterNew() {\n    super._afterNew();\n    this._data.incrementRef();\n    this._updateFields();\n    this._disposers.push(this.data.events.onAll(change => {\n      const dataItems = this._mainDataItems;\n      this.markDirtyValues();\n      this._markDirtyGroup();\n      this._dataChanged = true;\n      if (change.type === "clear") {\n        each(dataItems, dataItem => {\n          dataItem.dispose();\n        });\n        dataItems.length = 0;\n        this._onDataClear();\n      } else if (change.type === "push") {\n        const dataItem = new DataItem(this, change.newValue, this._makeDataItem(change.newValue));\n        dataItems.push(dataItem);\n        this.processDataItem(dataItem);\n      } else if (change.type === "setIndex") {\n        const dataItem = dataItems[change.index];\n        const properties = this._makeDataItem(change.newValue);\n        if (dataItem.bullets && dataItem.bullets.length == 0) {\n          dataItem.bullets = undefined;\n        }\n        keys(properties).forEach(key => {\n          dataItem.animate({\n            key: key,\n            to: properties[key],\n            duration: this.get("interpolationDuration", 0),\n            easing: this.get("interpolationEasing")\n          });\n        });\n        dataItem.dataContext = change.newValue;\n      } else if (change.type === "insertIndex") {\n        const dataItem = new DataItem(this, change.newValue, this._makeDataItem(change.newValue));\n        dataItems.splice(change.index, 0, dataItem);\n        this.processDataItem(dataItem);\n      } else if (change.type === "removeIndex") {\n        const dataItem = dataItems[change.index];\n        dataItem.dispose();\n        dataItems.splice(change.index, 1);\n      } else if (change.type === "moveIndex") {\n        const dataItem = dataItems[change.oldIndex];\n        dataItems.splice(change.oldIndex, 1);\n        dataItems.splice(change.newIndex, 0, dataItem);\n      } else {\n        throw new Error("Unknown IStreamEvent type");\n      }\n      this._afterDataChange();\n    }));\n  }\n  _updateFields() {\n    if (this.valueFields) {\n      this._valueFields = [];\n      this._valueFieldsF = {};\n      each(this.valueFields, key => {\n        const field = this.get(key + "Field");\n        if (field) {\n          this._valueFields.push(key);\n          this._valueFieldsF[key] = {\n            fieldKey: key + "Field",\n            workingKey: key + "Working"\n          };\n        }\n      });\n    }\n    if (this.fields) {\n      this._fields = [];\n      this._fieldsF = {};\n      each(this.fields, key => {\n        const field = this.get(key + "Field");\n        if (field) {\n          this._fields.push(key);\n          this._fieldsF[key] = key + "Field";\n        }\n      });\n    }\n  }\n  /**\r\n   * A list of component\'s data items.\r\n   *\r\n   * @return  Data items\r\n   */\n  get dataItems() {\n    return this._dataItems;\n  }\n  processDataItem(_dataItem) {}\n  _makeDataItem(data) {\n    //const output: this["_dataItemSettings"] = {};\n    const output = {}; // temporary to solve error\n    if (this._valueFields) {\n      each(this._valueFields, key => {\n        const field = this.get(this._valueFieldsF[key].fieldKey);\n        output[key] = data[field];\n        output[this._valueFieldsF[key].workingKey] = output[key];\n      });\n    }\n    if (this._fields) {\n      each(this._fields, key => {\n        const field = this.get(this._fieldsF[key]);\n        output[key] = data[field];\n      });\n    }\n    return output;\n  }\n  /**\r\n   * @ignore\r\n   */\n  makeDataItem(data) {\n    let dataItem = new DataItem(this, undefined, data);\n    this.processDataItem(dataItem);\n    return dataItem;\n  }\n  /**\r\n   * @ignore\r\n   */\n  pushDataItem(data) {\n    const dataItem = this.makeDataItem(data);\n    this._mainDataItems.push(dataItem);\n    return dataItem;\n  }\n  /**\r\n   * @ignore\r\n   */\n  disposeDataItem(_dataItem) {}\n  /**\r\n   * Shows component\'s data item.\r\n   *\r\n   * @param   dataItem   Data item\r\n   * @param   _duration  Animation duration in milliseconds\r\n   * @return             Promise\r\n   */\n  showDataItem(dataItem, _duration) {\n    return __awaiter(this, void 0, void 0, function* () {\n      dataItem.set("visible", true);\n    });\n  }\n  /**\r\n   * Hides component\'s data item.\r\n   *\r\n   * @param   dataItem   Data item\r\n   * @param   _duration  Animation duration in milliseconds\r\n   * @return             Promise\r\n   */\n  hideDataItem(dataItem, _duration) {\n    return __awaiter(this, void 0, void 0, function* () {\n      dataItem.set("visible", false);\n    });\n  }\n  _clearDirty() {\n    super._clearDirty();\n    this._valuesDirty = false;\n  }\n  _afterDataChange() {}\n  _afterChanged() {\n    super._afterChanged();\n    if (this._dataChanged) {\n      const type = "datavalidated";\n      if (this.events.isEnabled(type)) {\n        this.events.dispatch(type, {\n          type: type,\n          target: this\n        });\n      }\n      this._dataChanged = false;\n    }\n    this.inited = true;\n  }\n  /**\r\n   * Forces a repaint of the element which relies on data.\r\n   *\r\n   * @since 5.0.21\r\n   */\n  markDirtyValues(_dataItem) {\n    this.markDirty();\n    this._valuesDirty = true;\n  }\n  _markDirtyGroup() {\n    this._dataGrouped = false;\n  }\n  /**\r\n   * @ignore\r\n   */\n  markDirtySize() {\n    this._sizeDirty = true;\n    this.markDirty();\n  }\n}\nObject.defineProperty(Component, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Component"\n});\nObject.defineProperty(Component, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Container.classNames.concat([Component.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Time.js\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n\n/**\r\n * Returns a `Promise` which can be used to execute code after number of\r\n * milliseconds.\r\n *\r\n * @param   ms  Sleep duration in ms\r\n * @return      Promise\r\n */\nfunction sleep(ms) {\n  return new Promise((resolve, _reject) => {\n    setTimeout(resolve, ms);\n  });\n}\n/**\r\n * Maps time period names to their numeric representations in milliseconds.\r\n *\r\n * @ignore Exclude from docs\r\n */\nlet timeUnitDurations = {\n  millisecond: 1,\n  second: 1000,\n  minute: 60000,\n  hour: 3600000,\n  day: 86400000,\n  week: 604800000,\n  month: 365.242 / 12 * 86400000,\n  year: 31536000000\n};\n/**\r\n * Returns the next time unit that goes after source `unit`.\r\n *\r\n * E.g. "hour" is the next unit after "minute", etc.\r\n *\r\n * @ignore Exclude from docs\r\n * @param unit  Source time unit\r\n * @return Next time unit\r\n */\nfunction getNextUnit(unit) {\n  switch (unit) {\n    case "year":\n      return;\n    case "month":\n      return "year";\n    case "week":\n      return "month";\n    case "day":\n      return "month";\n    // not a mistake\n    case "hour":\n      return "day";\n    case "minute":\n      return "hour";\n    case "second":\n      return "minute";\n    case "millisecond":\n      return "second";\n  }\n}\n/**\r\n * Returns number of milliseconds in the `count` of time `unit`.\r\n *\r\n * Available units: "millisecond", "second", "minute", "hour", "day", "week",\r\n * "month", and "year".\r\n *\r\n * @param unit   Time unit\r\n * @param count  Number of units\r\n * @return Milliseconds\r\n */\nfunction getDuration(unit, count) {\n  if (count == null) {\n    count = 1;\n  }\n  return timeUnitDurations[unit] * count;\n}\n/**\r\n * @ignore\r\n */\nfunction getIntervalDuration(interval) {\n  if (interval) {\n    return timeUnitDurations[interval.timeUnit] * interval.count;\n  }\n  return 0;\n}\nfunction getDateIntervalDuration(interval, date, firstDateOfWeek, utc, timezone) {\n  const unit = interval.timeUnit;\n  const count = interval.count;\n  if (unit == "hour" || unit == "minute" || unit == "second" || unit == "millisecond") {\n    return timeUnitDurations[interval.timeUnit] * interval.count;\n  } else {\n    const firstTime = Time_round(new Date(date.getTime()), unit, count, firstDateOfWeek, utc, undefined, timezone).getTime();\n    let lastTime = firstTime + count * getDuration(unit) * 1.05;\n    lastTime = Time_round(new Date(lastTime), unit, 1, firstDateOfWeek, utc, undefined, timezone).getTime();\n    return lastTime - firstTime;\n  }\n}\n/**\r\n * Returns current `Date` object.\r\n *\r\n * @return Current date\r\n */\nfunction Time_now() {\n  return new Date();\n}\n/**\r\n * Returns current timestamp.\r\n *\r\n * @return Current timestamp\r\n */\nfunction getTime() {\n  return Time_now().getTime();\n}\n/**\r\n * Returns a copy of the `Date` object.\r\n *\r\n * @param date  Source date\r\n * @return Copy\r\n */\nfunction Time_copy(date) {\n  return new Date(date.getTime()); // todo: check if this is ok. new Date(date) used to strip milliseconds on FF in v3\n}\n/**\r\n * Checks if the `unit` part of two `Date` objects do not match. Two dates\r\n * represent a "range" of time, rather the same time date.\r\n *\r\n * @param timeOne  timestamp\r\n * @param timeTwo  timestamp\r\n * @param unit     Time unit to check\r\n * @return Range?\r\n */\nfunction checkChange(timeOne, timeTwo, unit, utc, timezone) {\n  // quick\n  if (timeTwo - timeOne > getDuration(unit, 1.2)) {\n    return true;\n  }\n  let dateOne = new Date(timeOne);\n  let dateTwo = new Date(timeTwo);\n  if (timezone) {\n    dateOne = timezone.convertLocal(dateOne);\n    dateTwo = timezone.convertLocal(dateTwo);\n  }\n  let timeZoneOffset1 = 0;\n  let timeZoneOffset2 = 0;\n  if (!utc && unit != "millisecond") {\n    timeZoneOffset1 = dateOne.getTimezoneOffset();\n    dateOne.setUTCMinutes(dateOne.getUTCMinutes() - timeZoneOffset1);\n    timeZoneOffset2 = dateTwo.getTimezoneOffset();\n    dateTwo.setUTCMinutes(dateTwo.getUTCMinutes() - timeZoneOffset2);\n  }\n  let changed = false;\n  switch (unit) {\n    case "year":\n      if (dateOne.getUTCFullYear() != dateTwo.getUTCFullYear()) {\n        changed = true;\n      }\n      break;\n    case "month":\n      if (dateOne.getUTCFullYear() != dateTwo.getUTCFullYear()) {\n        changed = true;\n      } else if (dateOne.getUTCMonth() != dateTwo.getUTCMonth()) {\n        changed = true;\n      }\n      break;\n    case "day":\n      if (dateOne.getUTCMonth() != dateTwo.getUTCMonth()) {\n        changed = true;\n      } else if (dateOne.getUTCDate() != dateTwo.getUTCDate()) {\n        changed = true;\n      }\n      break;\n    case "hour":\n      if (dateOne.getUTCHours() != dateTwo.getUTCHours()) {\n        changed = true;\n      }\n      break;\n    case "minute":\n      if (dateOne.getUTCMinutes() != dateTwo.getUTCMinutes()) {\n        changed = true;\n      }\n      break;\n    case "second":\n      if (dateOne.getUTCSeconds() != dateTwo.getUTCSeconds()) {\n        changed = true;\n      }\n      break;\n    case "millisecond":\n      if (dateOne.getTime() != dateTwo.getTime()) {\n        changed = true;\n      }\n      break;\n  }\n  if (changed) {\n    return changed;\n  }\n  let nextUnit = getNextUnit(unit);\n  if (nextUnit) {\n    return checkChange(timeOne, timeTwo, nextUnit, utc, timezone);\n  } else {\n    return false;\n  }\n}\n/**\r\n * Adds `count` of time `unit` to the source date. Returns a modified `Date` object.\r\n *\r\n * @param date   Source date\r\n * @param unit   Time unit\r\n * @param count  Number of units to add\r\n * @return Modified date\r\n */\nfunction Time_add(date, unit, count, utc, timezone) {\n  let timeZoneOffset = 0;\n  if (!utc && unit != "millisecond") {\n    timeZoneOffset = date.getTimezoneOffset();\n    if (timezone) {\n      timeZoneOffset -= timezone.offsetUTC(date);\n    }\n    date.setUTCMinutes(date.getUTCMinutes() - timeZoneOffset);\n  }\n  switch (unit) {\n    case "day":\n      let day = date.getUTCDate();\n      date.setUTCDate(day + count);\n      break;\n    case "second":\n      let seconds = date.getUTCSeconds();\n      date.setUTCSeconds(seconds + count);\n      break;\n    case "millisecond":\n      let milliseconds = date.getUTCMilliseconds();\n      date.setUTCMilliseconds(milliseconds + count);\n      break;\n    case "hour":\n      let hours = date.getUTCHours();\n      date.setUTCHours(hours + count);\n      break;\n    case "minute":\n      let minutes = date.getUTCMinutes();\n      date.setUTCMinutes(minutes + count);\n      break;\n    case "year":\n      let year = date.getUTCFullYear();\n      date.setUTCFullYear(year + count);\n      break;\n    case "month":\n      const endDays = date.getUTCDate();\n      const startDays = new Date(date.getUTCFullYear(), date.getUTCMonth(), 0).getUTCDate();\n      let month = date.getUTCMonth();\n      if (endDays > startDays) {\n        date.setUTCMonth(month + count, startDays);\n      } else {\n        date.setUTCMonth(month + count);\n      }\n      break;\n    case "week":\n      let wday = date.getUTCDate();\n      date.setUTCDate(wday + count * 7);\n      break;\n  }\n  if (!utc && unit != "millisecond") {\n    date.setUTCMinutes(date.getUTCMinutes() + timeZoneOffset);\n    if (unit == "day" || unit == "week" || unit == "month" || unit == "year") {\n      let newTimeZoneOffset = date.getTimezoneOffset();\n      if (timezone) {\n        newTimeZoneOffset += timezone.offsetUTC(date);\n      }\n      if (newTimeZoneOffset != timeZoneOffset) {\n        let diff = newTimeZoneOffset - timeZoneOffset;\n        date.setUTCMinutes(date.getUTCMinutes() + diff);\n        // solves issues if new time falls back to old time zone\n        if (date.getTimezoneOffset() != newTimeZoneOffset) {\n          date.setUTCMinutes(date.getUTCMinutes() - diff);\n        }\n      }\n    }\n  }\n  return date;\n}\n/**\r\n * @ignore\r\n */\nfunction roun(time, unit, count, root, firstTime) {\n  let firstDate;\n  if (firstTime != null) {\n    firstDate = new Date(firstTime);\n  }\n  return Time_round(new Date(time), unit, count, root.locale.firstDayOfWeek, root.utc, firstDate, root.timezone).getTime();\n}\n/**\r\n * "Rounds" the date to specific time unit.\r\n *\r\n * @param date             Source date\r\n * @param unit             Time unit\r\n * @param count            Number of units to round to\r\n * @param firstDateOfWeek  First day of week\r\n * @param utc              Use UTC timezone\r\n * @param firstDate        First date to round to\r\n * @param roundMinutes     Minutes to round to (some timezones use non-whole hour)\r\n * @param timezone         Use specific named timezone when rounding\r\n * @return New date\r\n */\nfunction Time_round(date, unit, count, firstDateOfWeek, utc, firstDate, timezone) {\n  if (!timezone || utc) {\n    let timeZoneOffset = 0;\n    if (!utc && unit != "millisecond") {\n      timeZoneOffset = date.getTimezoneOffset();\n      date.setUTCMinutes(date.getUTCMinutes() - timeZoneOffset);\n    }\n    switch (unit) {\n      case "day":\n        let day = date.getUTCDate();\n        if (count > 1) {\n          //\tday = Math.floor(day / count) * count;\n          if (firstDate) {\n            firstDate = Time_round(firstDate, "day", 1);\n            let difference = date.getTime() - firstDate.getTime();\n            let unitCount = Math.floor(difference / getDuration("day") / count);\n            let duration = getDuration("day", unitCount * count);\n            date.setTime(firstDate.getTime() + duration - timeZoneOffset * getDuration("minute"));\n          }\n        } else {\n          date.setUTCDate(day);\n        }\n        date.setUTCHours(0, 0, 0, 0);\n        break;\n      case "second":\n        let seconds = date.getUTCSeconds();\n        if (count > 1) {\n          seconds = Math.floor(seconds / count) * count;\n        }\n        date.setUTCSeconds(seconds, 0);\n        break;\n      case "millisecond":\n        if (count == 1) {\n          return date; // much better for perf!\n        }\n\n        let milliseconds = date.getUTCMilliseconds();\n        milliseconds = Math.floor(milliseconds / count) * count;\n        date.setUTCMilliseconds(milliseconds);\n        break;\n      case "hour":\n        let hours = date.getUTCHours();\n        if (count > 1) {\n          hours = Math.floor(hours / count) * count;\n        }\n        date.setUTCHours(hours, 0, 0, 0);\n        break;\n      case "minute":\n        let minutes = date.getUTCMinutes();\n        if (count > 1) {\n          minutes = Math.floor(minutes / count) * count;\n        }\n        date.setUTCMinutes(minutes, 0, 0);\n        break;\n      case "month":\n        let month = date.getUTCMonth();\n        if (count > 1) {\n          month = Math.floor(month / count) * count;\n        }\n        date.setUTCMonth(month, 1);\n        date.setUTCHours(0, 0, 0, 0);\n        break;\n      case "year":\n        let year = date.getUTCFullYear();\n        if (count > 1) {\n          year = Math.floor(year / count) * count;\n        }\n        date.setUTCFullYear(year, 0, 1);\n        date.setUTCHours(0, 0, 0, 0);\n        break;\n      case "week":\n        if (count > 1) {\n          if (firstDate) {\n            firstDate = Time_round(firstDate, "week", 1);\n            let difference = date.getTime() - firstDate.getTime();\n            let unitCount = Math.floor(difference / getDuration("week") / count);\n            let duration = getDuration("week", unitCount * count);\n            date.setTime(firstDate.getTime() + duration - timeZoneOffset * getDuration("minute"));\n          }\n        }\n        let wday = date.getUTCDate();\n        let weekDay = date.getUTCDay();\n        if (!Type_isNumber(firstDateOfWeek)) {\n          firstDateOfWeek = 1;\n        }\n        if (weekDay >= firstDateOfWeek) {\n          wday = wday - weekDay + firstDateOfWeek;\n        } else {\n          wday = wday - (7 + weekDay) + firstDateOfWeek;\n        }\n        date.setUTCDate(wday);\n        date.setUTCHours(0, 0, 0, 0);\n        break;\n    }\n    if (!utc && unit != "millisecond") {\n      date.setUTCMinutes(date.getUTCMinutes() + timeZoneOffset);\n      if (unit == "day" || unit == "week" || unit == "month" || unit == "year") {\n        let newTimeZoneOffset = date.getTimezoneOffset();\n        if (newTimeZoneOffset != timeZoneOffset) {\n          let diff = newTimeZoneOffset - timeZoneOffset;\n          date.setUTCMinutes(date.getUTCMinutes() + diff);\n        }\n      }\n    }\n    return date;\n  } else {\n    if (isNaN(date.getTime())) {\n      return date;\n    }\n    let tzoffset = timezone.offsetUTC(date);\n    let timeZoneOffset = date.getTimezoneOffset();\n    let parsedDate = timezone.parseDate(date);\n    let year = parsedDate.year;\n    let month = parsedDate.month;\n    let day = parsedDate.day;\n    let hour = parsedDate.hour;\n    let minute = parsedDate.minute;\n    let second = parsedDate.second;\n    let millisecond = parsedDate.millisecond;\n    let weekday = parsedDate.weekday;\n    let offsetDif = tzoffset - timeZoneOffset;\n    switch (unit) {\n      case "day":\n        if (count > 1 && firstDate) {\n          firstDate = Time_round(firstDate, "day", 1, firstDateOfWeek, utc, undefined, timezone);\n          let difference = date.getTime() - firstDate.getTime();\n          let unitCount = Math.floor(difference / getDuration("day") / count);\n          let duration = getDuration("day", unitCount * count);\n          date.setTime(firstDate.getTime() + duration);\n          parsedDate = timezone.parseDate(date);\n          year = parsedDate.year;\n          month = parsedDate.month;\n          day = parsedDate.day;\n        }\n        hour = 0;\n        minute = offsetDif;\n        second = 0;\n        millisecond = 0;\n        break;\n      case "second":\n        minute += offsetDif;\n        if (count > 1) {\n          second = Math.floor(second / count) * count;\n        }\n        millisecond = 0;\n        break;\n      case "millisecond":\n        minute += offsetDif;\n        if (count > 1) {\n          millisecond = Math.floor(millisecond / count) * count;\n        }\n        break;\n      case "hour":\n        if (count > 1) {\n          hour = Math.floor(hour / count) * count;\n        }\n        minute = offsetDif;\n        second = 0;\n        millisecond = 0;\n        break;\n      case "minute":\n        if (count > 1) {\n          minute = Math.floor(minute / count) * count;\n        }\n        minute += offsetDif;\n        second = 0;\n        millisecond = 0;\n        break;\n      case "month":\n        if (count > 1) {\n          month = Math.floor(month / count) * count;\n        }\n        day = 1;\n        hour = 0;\n        minute = offsetDif;\n        second = 0;\n        millisecond = 0;\n        break;\n      case "year":\n        if (count > 1) {\n          year = Math.floor(year / count) * count;\n        }\n        month = 0;\n        day = 1;\n        hour = 0;\n        minute = offsetDif;\n        second = 0;\n        millisecond = 0;\n        break;\n      case "week":\n        if (!Type_isNumber(firstDateOfWeek)) {\n          firstDateOfWeek = 1;\n        }\n        if (weekday >= firstDateOfWeek) {\n          day = day - weekday + firstDateOfWeek;\n        } else {\n          day = day - (7 + weekday) + firstDateOfWeek;\n        }\n        hour = 0;\n        minute = offsetDif;\n        second = 0;\n        millisecond = 0;\n        break;\n    }\n    date = new Date(year, month, day, hour, minute, second, millisecond);\n    let newTimeZoneOffset = date.getTimezoneOffset();\n    let newTzoffset = timezone.offsetUTC(date);\n    let newDiff = newTzoffset - newTimeZoneOffset;\n    if (newDiff != offsetDif) {\n      date.setTime(date.getTime() + (newDiff - offsetDif) * 60000);\n    }\n    return date;\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction chooseInterval(index, duration, gridCount, intervals) {\n  let gridInterval = intervals[index];\n  let intervalDuration = getIntervalDuration(gridInterval);\n  let lastIndex = intervals.length - 1;\n  if (index >= lastIndex) {\n    return Object.assign({}, intervals[lastIndex]);\n  }\n  let count = Math.ceil(duration / intervalDuration);\n  if (duration < intervalDuration && index > 0) {\n    return Object.assign({}, intervals[index - 1]);\n  }\n  if (count <= gridCount) {\n    return Object.assign({}, intervals[index]);\n  } else {\n    if (index + 1 < intervals.length) {\n      return chooseInterval(index + 1, duration, gridCount, intervals);\n    } else {\n      return Object.assign({}, intervals[index]);\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction getUnitValue(date, unit) {\n  switch (unit) {\n    case "day":\n      return date.getDate();\n    case "second":\n      return date.getSeconds();\n    case "millisecond":\n      return date.getMilliseconds();\n    case "hour":\n      return date.getHours();\n    case "minute":\n      return date.getMinutes();\n    case "month":\n      return date.getMonth();\n    case "year":\n      return date.getFullYear();\n    case "week":\n      return $utils.getWeek(date);\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Series.js\n\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * A base class for all series.\r\n */\nclass Series extends Component {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_aggregatesCalculated", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_selectionAggregatesCalculated", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_dataProcessed", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_psi", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_pei", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * A chart series belongs to.\r\n     */\n    Object.defineProperty(this, "chart", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * List of bullets to use for the series.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/bullets/} for more info\r\n     */\n    Object.defineProperty(this, "bullets", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new List()\n    });\n    /**\r\n     * A [[Container]] series\' bullets are stored in.\r\n     *\r\n     * @default Container.new()\r\n     */\n    Object.defineProperty(this, "bulletsContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: Container.new(this._root, {\n        width: p100,\n        height: p100,\n        position: "absolute"\n      })\n    });\n  }\n  _afterNew() {\n    this.valueFields.push("value", "customValue");\n    super._afterNew();\n    this.setPrivate("customData", {});\n    this._disposers.push(this.bullets.events.onAll(change => {\n      if (change.type === "clear") {\n        this._handleBullets(this.dataItems);\n      } else if (change.type === "push") {\n        this._handleBullets(this.dataItems);\n      } else if (change.type === "setIndex") {\n        this._handleBullets(this.dataItems);\n      } else if (change.type === "insertIndex") {\n        this._handleBullets(this.dataItems);\n      } else if (change.type === "removeIndex") {\n        this._handleBullets(this.dataItems);\n      } else if (change.type === "moveIndex") {\n        this._handleBullets(this.dataItems);\n      } else {\n        throw new Error("Unknown IListEvent type");\n      }\n    }));\n  }\n  _dispose() {\n    this.bulletsContainer.dispose(); // can be in a different parent\n    super._dispose();\n  }\n  startIndex() {\n    let len = this.dataItems.length;\n    return Math.min(this.getPrivate("startIndex", 0), len);\n  }\n  endIndex() {\n    let len = this.dataItems.length;\n    return Math.min(this.getPrivate("endIndex", len), len);\n  }\n  _handleBullets(dataItems) {\n    each(dataItems, dataItem => {\n      const bullets = dataItem.bullets;\n      if (bullets) {\n        each(bullets, bullet => {\n          bullet.dispose();\n        });\n        dataItem.bullets = undefined;\n      }\n    });\n    this.markDirtyValues();\n  }\n  /**\r\n   * Looks up and returns a data item by its ID.\r\n   *\r\n   * @param   id  ID\r\n   * @return      Data item\r\n   */\n  getDataItemById(id) {\n    return find(this.dataItems, dataItem => {\n      return dataItem.get("id") == id;\n    });\n  }\n  _makeBullets(dataItem) {\n    if (this._shouldMakeBullet(dataItem)) {\n      dataItem.bullets = [];\n      this.bullets.each(bulletFunction => {\n        this._makeBullet(dataItem, bulletFunction);\n      });\n    }\n  }\n  _shouldMakeBullet(_dataItem) {\n    return true;\n  }\n  _makeBullet(dataItem, bulletFunction, index) {\n    const bullet = bulletFunction(this._root, this, dataItem);\n    if (bullet) {\n      bullet._index = index;\n      this._makeBulletReal(dataItem, bullet);\n    }\n    return bullet;\n  }\n  _makeBulletReal(dataItem, bullet) {\n    let sprite = bullet.get("sprite");\n    if (sprite) {\n      sprite._setDataItem(dataItem);\n      sprite.setRaw("position", "absolute");\n      this.bulletsContainer.children.push(sprite);\n    }\n    bullet.series = this;\n    dataItem.bullets.push(bullet);\n  }\n  /**\r\n   * Adds bullet directly to a data item.\r\n   *\r\n   * Please note: method accepts [[Bullet]] instance as a paramter, not a\r\n   * reference to a function.\r\n   *\r\n   * You should add Bullet instance, not a method like you do it on series.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/bullets/#Adding_directly_to_data_item} for more info\r\n   * @since 5.6.0\r\n   *\r\n   * @param  dataItem  Target data item\r\n   * @param  bullet    Bullet instance\r\n   */\n  addBullet(dataItem, bullet) {\n    if (!dataItem.bullets) {\n      dataItem.bullets = [];\n    }\n    if (bullet) {\n      this._makeBulletReal(dataItem, bullet);\n    }\n  }\n  _clearDirty() {\n    super._clearDirty();\n    this._aggregatesCalculated = false;\n    this._selectionAggregatesCalculated = false;\n  }\n  _prepareChildren() {\n    super._prepareChildren();\n    let startIndex = this.startIndex();\n    let endIndex = this.endIndex();\n    if (this.isDirty("name")) {\n      this.updateLegendValue();\n    }\n    if (this.isDirty("heatRules")) {\n      this._valuesDirty = true;\n    }\n    if (this.isPrivateDirty("baseValueSeries")) {\n      const baseValueSeries = this.getPrivate("baseValueSeries");\n      if (baseValueSeries) {\n        this._disposers.push(baseValueSeries.onPrivate("startIndex", () => {\n          this.markDirtyValues();\n        }));\n      }\n    }\n    const calculateAggregates = this.get("calculateAggregates");\n    if (calculateAggregates) {\n      if (this._valuesDirty && !this._dataProcessed) {\n        if (!this._aggregatesCalculated) {\n          this._calculateAggregates(0, this.dataItems.length);\n          this._aggregatesCalculated = true;\n          if (startIndex != 0) {\n            this._psi = undefined;\n          }\n        }\n      }\n      if ((this._psi != startIndex || this._pei != endIndex || this.isPrivateDirty("adjustedStartIndex")) && !this._selectionAggregatesCalculated) {\n        if (startIndex === 0 && endIndex === this.dataItems.length && this._aggregatesCalculated) {\n          // void\n        } else {\n          this._calculateAggregates(startIndex, endIndex);\n        }\n        this._selectionAggregatesCalculated = true;\n      }\n    }\n    if (this.isDirty("tooltip")) {\n      let tooltip = this.get("tooltip");\n      if (tooltip) {\n        tooltip.hide(0);\n        tooltip.set("tooltipTarget", this);\n      }\n    }\n    if (this.isDirty("fill") || this.isDirty("stroke")) {\n      let markerRectangle;\n      const legendDataItem = this.get("legendDataItem");\n      if (legendDataItem) {\n        markerRectangle = legendDataItem.get("markerRectangle");\n        if (markerRectangle) {\n          if (this.isVisible()) {\n            if (this.isDirty("stroke")) {\n              let stroke = this.get("stroke");\n              markerRectangle.set("stroke", stroke);\n            }\n            if (this.isDirty("fill")) {\n              let fill = this.get("fill");\n              markerRectangle.set("fill", fill);\n            }\n          }\n        }\n      }\n      this.updateLegendMarker(undefined);\n    }\n    if (this.bullets.length > 0) {\n      let startIndex = this.startIndex();\n      let endIndex = this.endIndex();\n      if (endIndex < this.dataItems.length) {\n        endIndex++;\n      }\n      for (let i = startIndex; i < endIndex; i++) {\n        let dataItem = this.dataItems[i];\n        if (!dataItem.bullets) {\n          this._makeBullets(dataItem);\n        }\n      }\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  _adjustStartIndex(index) {\n    return index;\n  }\n  _calculateAggregates(startIndex, endIndex) {\n    let fields = this._valueFields;\n    if (!fields) {\n      throw new Error("No value fields are set for the series.");\n    }\n    const sum = {};\n    const absSum = {};\n    const count = {};\n    const low = {};\n    const high = {};\n    const open = {};\n    const close = {};\n    const average = {};\n    const previous = {};\n    each(fields, key => {\n      sum[key] = 0;\n      absSum[key] = 0;\n      count[key] = 0;\n    });\n    each(fields, key => {\n      let change = key + "Change";\n      let changePercent = key + "ChangePercent";\n      let changePrevious = key + "ChangePrevious";\n      let changePreviousPercent = key + "ChangePreviousPercent";\n      let changeSelection = key + "ChangeSelection";\n      let changeSelectionPercent = key + "ChangeSelectionPercent";\n      let openKey = "valueY";\n      if (key == "valueX" || key == "openValueX" || key == "lowValueX" || key == "highValueX") {\n        openKey = "valueX";\n      }\n      const baseValueSeries = this.getPrivate("baseValueSeries");\n      const adjustedStartIndex = this.getPrivate("adjustedStartIndex", startIndex);\n      for (let i = adjustedStartIndex; i < endIndex; i++) {\n        const dataItem = this.dataItems[i];\n        if (dataItem) {\n          let value = dataItem.get(key);\n          if (value != null) {\n            count[key]++;\n            sum[key] += value;\n            absSum[key] += Math.abs(value);\n            average[key] = sum[key] / count[key];\n            if (low[key] > value || low[key] == null) {\n              low[key] = value;\n            }\n            if (high[key] < value || high[key] == null) {\n              high[key] = value;\n            }\n            close[key] = value;\n            if (open[key] == null) {\n              open[key] = value;\n              previous[key] = value;\n              if (baseValueSeries) {\n                open[openKey] = baseValueSeries._getBase(openKey);\n              }\n            }\n            if (startIndex === 0) {\n              dataItem.setRaw(change, value - open[openKey]);\n              dataItem.setRaw(changePercent, (value - open[openKey]) / open[openKey] * 100);\n            }\n            dataItem.setRaw(changePrevious, value - previous[openKey]);\n            dataItem.setRaw(changePreviousPercent, (value - previous[openKey]) / previous[openKey] * 100);\n            dataItem.setRaw(changeSelection, value - open[openKey]);\n            dataItem.setRaw(changeSelectionPercent, (value - open[openKey]) / open[openKey] * 100);\n            previous[key] = value;\n          }\n        }\n      }\n      if (endIndex < this.dataItems.length - 1) {\n        const dataItem = this.dataItems[endIndex];\n        if (dataItem) {\n          let value = dataItem.get(key);\n          dataItem.setRaw(changePrevious, value - previous[openKey]);\n          dataItem.setRaw(changePreviousPercent, (value - previous[openKey]) / previous[openKey] * 100);\n          dataItem.setRaw(changeSelection, value - open[openKey]);\n          dataItem.setRaw(changeSelectionPercent, (value - open[openKey]) / open[openKey] * 100);\n        }\n      }\n      if (startIndex > 0) {\n        startIndex--;\n      }\n      delete previous[key];\n      for (let i = startIndex; i < adjustedStartIndex; i++) {\n        const dataItem = this.dataItems[i];\n        if (dataItem) {\n          let value = dataItem.get(key);\n          if (previous[key] == null) {\n            previous[key] = value;\n          }\n          if (value != null) {\n            dataItem.setRaw(changePrevious, value - previous[openKey]);\n            dataItem.setRaw(changePreviousPercent, (value - previous[openKey]) / previous[openKey] * 100);\n            dataItem.setRaw(changeSelection, value - open[openKey]);\n            dataItem.setRaw(changeSelectionPercent, (value - open[openKey]) / open[openKey] * 100);\n            previous[key] = value;\n          }\n        }\n      }\n    });\n    each(fields, key => {\n      this.setPrivate(key + "AverageSelection", average[key]);\n      this.setPrivate(key + "CountSelection", count[key]);\n      this.setPrivate(key + "SumSelection", sum[key]);\n      this.setPrivate(key + "AbsoluteSumSelection", absSum[key]);\n      this.setPrivate(key + "LowSelection", low[key]);\n      this.setPrivate(key + "HighSelection", high[key]);\n      this.setPrivate(key + "OpenSelection", open[key]);\n      this.setPrivate(key + "CloseSelection", close[key]);\n    });\n    if (startIndex === 0 && endIndex === this.dataItems.length) {\n      each(fields, key => {\n        this.setPrivate(key + "Average", average[key]);\n        this.setPrivate(key + "Count", count[key]);\n        this.setPrivate(key + "Sum", sum[key]);\n        this.setPrivate(key + "AbsoluteSum", absSum[key]);\n        this.setPrivate(key + "Low", low[key]);\n        this.setPrivate(key + "High", high[key]);\n        this.setPrivate(key + "Open", open[key]);\n        this.setPrivate(key + "Close", close[key]);\n      });\n    }\n  }\n  _updateChildren() {\n    super._updateChildren();\n    this._psi = this.startIndex();\n    this._pei = this.endIndex();\n    if (this.isDirty("visible")) {\n      this.bulletsContainer.set("visible", this.get("visible"));\n    }\n    // Apply heat rules\n    const rules = this.get("heatRules");\n    if (this._valuesDirty && rules && rules.length > 0) {\n      each(rules, rule => {\n        const minValue = rule.minValue || this.getPrivate(rule.dataField + "Low") || 0;\n        const maxValue = rule.maxValue || this.getPrivate(rule.dataField + "High") || 0;\n        each(rule.target._entities, target => {\n          const value = target.dataItem.get(rule.dataField);\n          if (!Type_isNumber(value)) {\n            if (rule.neutral) {\n              target.set(rule.key, rule.neutral);\n            }\n            const states = target.states;\n            if (states) {\n              const defaultState = states.lookup("default");\n              if (defaultState && rule.neutral) {\n                defaultState.set(rule.key, rule.neutral);\n              }\n            }\n            if (!rule.customFunction) {\n              return;\n            }\n          }\n          if (rule.customFunction) {\n            rule.customFunction.call(this, target, minValue, maxValue, value);\n          } else {\n            let percent;\n            if (rule.logarithmic) {\n              percent = (Math.log(value) * Math.LOG10E - Math.log(minValue) * Math.LOG10E) / (Math.log(maxValue) * Math.LOG10E - Math.log(minValue) * Math.LOG10E);\n            } else {\n              percent = (value - minValue) / (maxValue - minValue);\n            }\n            if (Type_isNumber(value) && (!Type_isNumber(percent) || Math.abs(percent) == Infinity)) {\n              percent = 0.5;\n            }\n            // fixes problems if all values are the same\n            let propertyValue;\n            if (Type_isNumber(rule.min)) {\n              propertyValue = rule.min + (rule.max - rule.min) * percent;\n            } else if (rule.min instanceof Color) {\n              propertyValue = Color.interpolate(percent, rule.min, rule.max);\n            } else if (rule.min instanceof Percent) {\n              propertyValue = percentInterpolate(percent, rule.min, rule.max);\n            }\n            target.set(rule.key, propertyValue);\n            const states = target.states;\n            if (states) {\n              const defaultState = states.lookup("default");\n              if (defaultState) {\n                defaultState.set(rule.key, propertyValue);\n              }\n            }\n          }\n        });\n      });\n    }\n    if (this.get("visible")) {\n      let count = this.dataItems.length;\n      let startIndex = this.startIndex();\n      let endIndex = this.endIndex();\n      if (endIndex < count) {\n        endIndex++;\n      }\n      if (startIndex > 0) {\n        startIndex--;\n      }\n      for (let i = 0; i < startIndex; i++) {\n        this._hideBullets(this.dataItems[i]);\n      }\n      for (let i = startIndex; i < endIndex; i++) {\n        this._positionBullets(this.dataItems[i]);\n      }\n      for (let i = endIndex; i < count; i++) {\n        this._hideBullets(this.dataItems[i]);\n      }\n    }\n  }\n  _positionBullets(dataItem) {\n    if (dataItem.bullets) {\n      each(dataItem.bullets, bullet => {\n        this._positionBullet(bullet);\n        const sprite = bullet.get("sprite");\n        if (bullet.get("dynamic")) {\n          if (sprite) {\n            sprite._markDirtyKey("fill");\n            sprite.markDirtySize();\n          }\n          if (sprite instanceof Container) {\n            sprite.walkChildren(child => {\n              child._markDirtyKey("fill");\n              child.markDirtySize();\n              if (child instanceof Label) {\n                child.text.markDirtyText();\n              }\n            });\n          }\n        }\n        if (sprite instanceof Label && sprite.get("populateText")) {\n          sprite.text.markDirtyText();\n        }\n      });\n    }\n  }\n  _hideBullets(dataItem) {\n    if (dataItem.bullets) {\n      each(dataItem.bullets, bullet => {\n        let sprite = bullet.get("sprite");\n        if (sprite) {\n          sprite.setPrivate("visible", false);\n        }\n      });\n    }\n  }\n  _positionBullet(_bullet) {}\n  _placeBulletsContainer(chart) {\n    chart.bulletsContainer.children.moveValue(this.bulletsContainer);\n  }\n  _removeBulletsContainer() {\n    const bulletsContainer = this.bulletsContainer;\n    if (bulletsContainer.parent) {\n      bulletsContainer.parent.children.removeValue(bulletsContainer);\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  disposeDataItem(dataItem) {\n    //super.disposeDataItem(dataItem); // does nothing\n    const bullets = dataItem.bullets;\n    if (bullets) {\n      each(bullets, bullet => {\n        bullet.dispose();\n      });\n    }\n  }\n  _getItemReaderLabel() {\n    return "";\n  }\n  /**\r\n   * Shows series\'s data item.\r\n   *\r\n   * @param   dataItem  Data item\r\n   * @param   duration  Animation duration in milliseconds\r\n   * @return            Promise\r\n   */\n  showDataItem(dataItem, duration) {\n    const _super = Object.create(null, {\n      showDataItem: {\n        get: () => super.showDataItem\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const promises = [_super.showDataItem.call(this, dataItem, duration)];\n      const bullets = dataItem.bullets;\n      if (bullets) {\n        each(bullets, bullet => {\n          const sprite = bullet.get("sprite");\n          if (sprite) {\n            promises.push(sprite.show(duration));\n          }\n        });\n      }\n      yield Promise.all(promises);\n    });\n  }\n  /**\r\n   * Hides series\'s data item.\r\n   *\r\n   * @param   dataItem  Data item\r\n   * @param   duration  Animation duration in milliseconds\r\n   * @return            Promise\r\n   */\n  hideDataItem(dataItem, duration) {\n    const _super = Object.create(null, {\n      hideDataItem: {\n        get: () => super.hideDataItem\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const promises = [_super.hideDataItem.call(this, dataItem, duration)];\n      const bullets = dataItem.bullets;\n      if (bullets) {\n        each(bullets, bullet => {\n          const sprite = bullet.get("sprite");\n          if (sprite) {\n            promises.push(sprite.hide(duration));\n          }\n        });\n      }\n      yield Promise.all(promises);\n    });\n  }\n  _sequencedShowHide(show, duration) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.get("sequencedInterpolation")) {\n        if (!Type_isNumber(duration)) {\n          duration = this.get("interpolationDuration", 0);\n        }\n        if (duration > 0) {\n          const startIndex = this.startIndex();\n          const endIndex = this.endIndex();\n          yield Promise.all(Array_map(this.dataItems, (dataItem, i) => __awaiter(this, void 0, void 0, function* () {\n            let realDuration = duration || 0;\n            if (i < startIndex - 10 || i > endIndex + 10) {\n              realDuration = 0;\n            }\n            //let delay = this.get("sequencedDelay", 0) * i + realDuration * (i - startIndex) / (endIndex - startIndex);\n            let delay = this.get("sequencedDelay", 0) + realDuration / (endIndex - startIndex);\n            yield sleep(delay * (i - startIndex));\n            if (show) {\n              yield this.showDataItem(dataItem, realDuration);\n            } else {\n              yield this.hideDataItem(dataItem, realDuration);\n            }\n          })));\n        } else {\n          yield Promise.all(Array_map(this.dataItems, dataItem => {\n            if (show) {\n              return this.showDataItem(dataItem, 0);\n            } else {\n              return this.hideDataItem(dataItem, 0);\n            }\n          }));\n        }\n      }\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateLegendValue(dataItem) {\n    if (dataItem) {\n      const legendDataItem = dataItem.get("legendDataItem");\n      if (legendDataItem) {\n        const valueLabel = legendDataItem.get("valueLabel");\n        if (valueLabel) {\n          const text = valueLabel.text;\n          let txt = "";\n          valueLabel._setDataItem(dataItem);\n          txt = this.get("legendValueText", text.get("text", ""));\n          valueLabel.set("text", txt);\n          text.markDirtyText();\n        }\n        const label = legendDataItem.get("label");\n        if (label) {\n          const text = label.text;\n          let txt = "";\n          label._setDataItem(dataItem);\n          txt = this.get("legendLabelText", text.get("text", ""));\n          label.set("text", txt);\n          text.markDirtyText();\n        }\n      }\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateLegendMarker(_dataItem) {}\n  _onHide() {\n    super._onHide();\n    const tooltip = this.getTooltip();\n    if (tooltip) {\n      tooltip.hide();\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  hoverDataItem(_dataItem) {}\n  /**\r\n   * @ignore\r\n   */\n  unhoverDataItem(_dataItem) {}\n  /**\r\n   * @ignore\r\n   */\n  _getBase(key) {\n    const dataItem = this.dataItems[this.startIndex()];\n    if (dataItem) {\n      return dataItem.get(key);\n    }\n    return 0;\n  }\n}\nObject.defineProperty(Series, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Series"\n});\nObject.defineProperty(Series, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Component.classNames.concat([Series.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js\n\n\n\n\n/**\r\n * Draws a rectangle with rounded corners.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info\r\n * @important\r\n */\nclass RoundedRectangle extends Rectangle {\n  _beforeChanged() {\n    super._beforeChanged();\n    if (this.isDirty("cornerRadiusTL") || this.isDirty("cornerRadiusTR") || this.isDirty("cornerRadiusBR") || this.isDirty("cornerRadiusBL")) {\n      this._clear = true;\n    }\n  }\n  _draw() {\n    let width = this.width();\n    let height = this.height();\n    let w = width;\n    let h = height;\n    let wSign = w / Math.abs(width);\n    let hSign = h / Math.abs(height);\n    if (Type_isNumber(w) && Type_isNumber(h)) {\n      let minSide = Math.min(w, h) / 2;\n      let crtl = relativeToValue(this.get("cornerRadiusTL", 8), minSide);\n      let crtr = relativeToValue(this.get("cornerRadiusTR", 8), minSide);\n      let crbr = relativeToValue(this.get("cornerRadiusBR", 8), minSide);\n      let crbl = relativeToValue(this.get("cornerRadiusBL", 8), minSide);\n      let maxcr = Math.min(Math.abs(w / 2), Math.abs(h / 2));\n      crtl = fitToRange(crtl, 0, maxcr);\n      crtr = fitToRange(crtr, 0, maxcr);\n      crbr = fitToRange(crbr, 0, maxcr);\n      crbl = fitToRange(crbl, 0, maxcr);\n      const display = this._display;\n      display.moveTo(crtl * wSign, 0);\n      display.lineTo(w - crtr * wSign, 0);\n      if (crtr > 0) {\n        display.arcTo(w, 0, w, crtr * hSign, crtr);\n      }\n      display.lineTo(w, h - crbr * hSign);\n      if (crbr > 0) {\n        display.arcTo(w, h, w - crbr * wSign, h, crbr);\n      }\n      display.lineTo(crbl * wSign, h);\n      if (crbl > 0) {\n        display.arcTo(0, h, 0, h - crbl * hSign, crbl);\n      }\n      display.lineTo(0, crtl * hSign);\n      if (crtl > 0) {\n        display.arcTo(0, 0, crtl * wSign, 0, crtl);\n      }\n      display.closePath();\n    }\n  }\n}\nObject.defineProperty(RoundedRectangle, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "RoundedRectangle"\n});\nObject.defineProperty(RoundedRectangle, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Rectangle.classNames.concat([RoundedRectangle.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Legend.js\n\n\n\n\n\n\n\n/**\r\n * A universal legend control.\r\n *\r\n * @important\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/legend/} for more info\r\n */\nclass Legend extends Series {\n  constructor() {\n    super(...arguments);\n    /**\r\n     * List of all [[Container]] elements for legend items.\r\n     *\r\n     * @default new ListTemplate<Container>\r\n     */\n    Object.defineProperty(this, "itemContainers", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListTemplate(Template.new({}), () => Container._new(this._root, {\n        themeTags: mergeTags(this.itemContainers.template.get("themeTags", []), ["legend", "item"]),\n        themeTagsSelf: mergeTags(this.itemContainers.template.get("themeTagsSelf", []), ["itemcontainer"]),\n        background: RoundedRectangle.new(this._root, {\n          themeTags: mergeTags(this.itemContainers.template.get("themeTags", []), ["legend", "item", "background"]),\n          themeTagsSelf: mergeTags(this.itemContainers.template.get("themeTagsSelf", []), ["itemcontainer"])\n        })\n      }, [this.itemContainers.template]))\n    });\n    /**\r\n     * List of legend marker elements.\r\n     *\r\n     * @default new ListTemplate<Container>\r\n     */\n    Object.defineProperty(this, "markers", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListTemplate(Template.new({}), () => Container._new(this._root, {\n        themeTags: mergeTags(this.markers.template.get("themeTags", []), ["legend", "marker"])\n      }, [this.markers.template]))\n    });\n    /**\r\n     * List of legend label elements.\r\n     *\r\n     * @default new ListTemplate<Label>\r\n     */\n    Object.defineProperty(this, "labels", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListTemplate(Template.new({}), () => Label._new(this._root, {\n        themeTags: mergeTags(this.labels.template.get("themeTags", []), ["legend", "label"])\n      }, [this.labels.template]))\n    });\n    /**\r\n     * List of legend value label elements.\r\n     *\r\n     * @default new ListTemplate<label>\r\n     */\n    Object.defineProperty(this, "valueLabels", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListTemplate(Template.new({}), () => Label._new(this._root, {\n        themeTags: mergeTags(this.valueLabels.template.get("themeTags", []), ["legend", "label", "value"])\n      }, [this.valueLabels.template]))\n    });\n    /**\r\n     * List of rectangle elements used for default legend markers.\r\n     *\r\n     * @default new ListTemplate<RoundedRectangle>\r\n     */\n    Object.defineProperty(this, "markerRectangles", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListTemplate(Template.new({}), () => RoundedRectangle._new(this._root, {\n        themeTags: mergeTags(this.markerRectangles.template.get("themeTags", []), ["legend", "marker", "rectangle"])\n      }, [this.markerRectangles.template]))\n    });\n  }\n  _afterNew() {\n    this._settings.themeTags = mergeTags(this._settings.themeTags, ["legend"]);\n    this.fields.push("name", "stroke", "fill");\n    super._afterNew();\n  }\n  /**\r\n   * @ignore\r\n   */\n  makeItemContainer(dataItem) {\n    const itemContainer = this.children.push(this.itemContainers.make());\n    itemContainer._setDataItem(dataItem);\n    this.itemContainers.push(itemContainer);\n    itemContainer.states.create("disabled", {});\n    return itemContainer;\n  }\n  /**\r\n   * @ignore\r\n   */\n  makeMarker() {\n    const marker = this.markers.make();\n    this.markers.push(marker);\n    marker.states.create("disabled", {});\n    return marker;\n  }\n  /**\r\n   * @ignore\r\n   */\n  makeLabel() {\n    const label = this.labels.make();\n    label.states.create("disabled", {});\n    return label;\n  }\n  /**\r\n   * @ignore\r\n   */\n  makeValueLabel() {\n    const valueLabel = this.valueLabels.make();\n    valueLabel.states.create("disabled", {});\n    return valueLabel;\n  }\n  /**\r\n   * @ignore\r\n   */\n  makeMarkerRectangle() {\n    const markerRectangle = this.markerRectangles.make();\n    markerRectangle.states.create("disabled", {});\n    return markerRectangle;\n  }\n  processDataItem(dataItem) {\n    super.processDataItem(dataItem);\n    const itemContainer = this.makeItemContainer(dataItem);\n    const nameField = this.get("nameField");\n    const fillField = this.get("fillField");\n    const strokeField = this.get("strokeField");\n    if (itemContainer) {\n      const clickTarget = this.get("clickTarget", "itemContainer");\n      const item = dataItem.dataContext;\n      if (item && item.set) {\n        item.set("legendDataItem", dataItem);\n      }\n      itemContainer._setDataItem(dataItem);\n      dataItem.set("itemContainer", itemContainer);\n      const marker = this.makeMarker();\n      if (marker) {\n        itemContainer.children.push(marker);\n        marker._setDataItem(dataItem);\n        dataItem.set("marker", marker);\n        const useDefaultMarker = this.get("useDefaultMarker");\n        const markerRectangle = marker.children.push(this.makeMarkerRectangle());\n        let fill = dataItem.get("fill");\n        let stroke = dataItem.get("stroke");\n        dataItem.set("markerRectangle", markerRectangle);\n        if (item && item.get) {\n          fill = item.get(fillField, fill);\n          stroke = item.get(strokeField, stroke);\n        }\n        if (!stroke) {\n          stroke = fill;\n        }\n        if (!useDefaultMarker) {\n          if (item && item.createLegendMarker) {\n            item.createLegendMarker();\n          }\n        } else {\n          if (item.on) {\n            item.on(fillField, () => {\n              markerRectangle.set("fill", item.get(fillField));\n            });\n            item.on(strokeField, () => {\n              markerRectangle.set("stroke", item.get(strokeField));\n            });\n          }\n        }\n        markerRectangle.setAll({\n          fill,\n          stroke\n        });\n        // this solves if template field is set on slice\n        const component = item.component;\n        if (component && component.updateLegendMarker) {\n          component.updateLegendMarker(item);\n        }\n      }\n      const label = this.makeLabel();\n      if (label) {\n        itemContainer.children.push(label);\n        label._setDataItem(dataItem);\n        dataItem.set("label", label);\n        label.text.on("text", () => {\n          itemContainer.setRaw("ariaLabel", label.text._getText() + (this.get("clickTarget") !== "none" ? "; " + this._t("Press ENTER to toggle") : ""));\n          itemContainer.markDirtyAccessibility();\n        });\n        if (item && item.get) {\n          dataItem.set("name", item.get(nameField));\n        }\n        let name = dataItem.get("name");\n        if (name) {\n          label.set("text", name);\n        }\n      }\n      const valueLabel = this.makeValueLabel();\n      if (valueLabel) {\n        itemContainer.children.push(valueLabel);\n        valueLabel._setDataItem(dataItem);\n        dataItem.set("valueLabel", valueLabel);\n      }\n      if (item && item.show) {\n        item.on("visible", visible => {\n          itemContainer.set("disabled", !visible);\n        });\n        if (!item.get("visible")) {\n          itemContainer.set("disabled", true);\n        }\n        if (clickTarget != "none") {\n          let clickContainer = itemContainer;\n          if (clickTarget == "marker") {\n            clickContainer = marker;\n          }\n          this._addClickEvents(clickContainer, item, dataItem);\n        }\n      }\n      // Sort children\n      this.children.values.sort((a, b) => {\n        const targetA = a.dataItem.dataContext;\n        const targetB = b.dataItem.dataContext;\n        if (targetA && targetB) {\n          const indexA = this.data.indexOf(targetA);\n          const indexB = this.data.indexOf(targetB);\n          if (indexA > indexB) {\n            return 1;\n          } else if (indexA < indexB) {\n            return -1;\n          }\n        }\n        return 0;\n      });\n      if (item && item.updateLegendValue) {\n        item.updateLegendValue();\n      }\n    }\n  }\n  _addClickEvents(container, item, dataItem) {\n    container.set("cursorOverStyle", "pointer");\n    container.events.on("pointerover", () => {\n      const component = item.component;\n      if (component && component.hoverDataItem) {\n        component.hoverDataItem(item);\n      }\n    });\n    container.events.on("pointerout", () => {\n      const component = item.component;\n      if (component && component.hoverDataItem) {\n        component.unhoverDataItem(item);\n      }\n    });\n    container.events.on("click", () => {\n      const labelText = dataItem.get("label").text._getText();\n      if (item.show && item.isHidden && (item.isHidden() || item.get("visible") === false)) {\n        item.show();\n        container.set("disabled", false);\n        this._root.readerAlert(this._t("%1 shown", this._root.locale, labelText));\n      } else if (item.hide) {\n        item.hide();\n        container.set("disabled", true);\n        this._root.readerAlert(this._t("%1 hidden", this._root.locale, labelText));\n      }\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  disposeDataItem(dataItem) {\n    super.disposeDataItem(dataItem);\n    const dataContext = dataItem.dataContext;\n    if (dataContext && dataContext.get) {\n      const di = dataContext.get("legendDataItem");\n      if (di == dataItem) {\n        dataContext.set("legendDataItem", undefined);\n      }\n    }\n    let itemContainer = dataItem.get("itemContainer");\n    if (itemContainer) {\n      this.itemContainers.removeValue(itemContainer);\n      itemContainer.dispose();\n    }\n    let marker = dataItem.get("marker");\n    if (marker) {\n      this.markers.removeValue(marker);\n      marker.dispose();\n    }\n    let markerRectangle = dataItem.get("markerRectangle");\n    if (markerRectangle) {\n      this.markerRectangles.removeValue(markerRectangle);\n      markerRectangle.dispose();\n    }\n    let label = dataItem.get("label");\n    if (label) {\n      this.labels.removeValue(label);\n      label.dispose();\n    }\n    let valueLabel = dataItem.get("valueLabel");\n    if (valueLabel) {\n      this.valueLabels.removeValue(valueLabel);\n      valueLabel.dispose();\n    }\n  }\n}\nObject.defineProperty(Legend, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Legend"\n});\nObject.defineProperty(Legend, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Series.classNames.concat([Legend.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Bullet.js\n\n/**\r\n * A universal placeholder for bullet elements.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/bullets/} for more info\r\n */\nclass Bullet extends Entity {\n  constructor() {\n    super(...arguments);\n    // used by MapPolygons where one data item can have multiple bullets of the same kind\n    Object.defineProperty(this, "_index", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * Target series object if it\'s a bullet for series.\r\n     */\n    Object.defineProperty(this, "series", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  _afterNew() {\n    // Applying themes because bullet will not have parent\n    super._afterNewApplyThemes();\n  }\n  _beforeChanged() {\n    super._beforeChanged();\n    if (this.isDirty("sprite")) {\n      const sprite = this.get("sprite");\n      if (sprite) {\n        sprite.setAll({\n          position: "absolute",\n          role: "figure"\n        });\n        this._disposers.push(sprite);\n      }\n    }\n    if (this.isDirty("locationX") || this.isDirty("locationY")) {\n      if (this.series) {\n        this.series._positionBullet(this);\n      }\n    }\n  }\n}\nObject.defineProperty(Bullet, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Bullet"\n});\nObject.defineProperty(Bullet, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Entity.classNames.concat([Bullet.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Circle.js\n\n/**\r\n * Draws a circle.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info\r\n * @important\r\n */\nclass Circle extends Graphics {\n  _afterNew() {\n    super._afterNew();\n    this._display.isMeasured = true;\n    this.setPrivateRaw("trustBounds", true);\n  }\n  _beforeChanged() {\n    super._beforeChanged();\n    if (this.isDirty("radius")) {\n      this._clear = true;\n    }\n  }\n  _changed() {\n    super._changed();\n    if (this._clear) {\n      this._display.drawCircle(0, 0, this.get("radius", 10));\n    }\n  }\n}\nObject.defineProperty(Circle, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Circle"\n});\nObject.defineProperty(Circle, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Graphics.classNames.concat([Circle.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/ColorSet.js\n\n\n/**\r\n * An object which holds list of colors and can generate new ones.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Color_sets} for more info\r\n */\nclass ColorSet extends Entity {\n  //protected _currentPass: number = 0;\n  _afterNew() {\n    // Applying themes because color set will not have parent\n    super._afterNewApplyThemes();\n    this._dirty["colors"] = false;\n  }\n  _beforeChanged() {\n    if (this.isDirty("colors")) {\n      this.reset();\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  generateColors() {\n    this.setPrivate("currentPass", this.getPrivate("currentPass", 0) + 1);\n    const pass = this.getPrivate("currentPass");\n    const colors = this.get("colors", [this.get("baseColor", Color.fromHex(0xff0000))]);\n    if (!this.getPrivate("numColors")) {\n      this.setPrivate("numColors", colors.length);\n    }\n    //const len = colors.length;\n    const len = this.getPrivate("numColors");\n    //const start = len - this.getPrivate("numColors")!;\n    const start = 0;\n    const passOptions = this.get("passOptions");\n    const reuse = this.get("reuse");\n    for (let i = start; i < len; i++) {\n      if (reuse) {\n        colors.push(colors[i]);\n      } else {\n        const hsl = colors[i].toHSL();\n        let h = hsl.h + (passOptions.hue || 0) * pass;\n        while (h > 1) h -= 1;\n        let s = hsl.s + (passOptions.saturation || 0) * pass;\n        //if (s > 1) s -= Math.floor(s);\n        if (s > 1) s = 1;\n        if (s < 0) s = 0;\n        let l = hsl.l + (passOptions.lightness || 0) * pass;\n        //if (l > 1) l -= Math.floor(l);\n        while (l > 1) l -= 1;\n        colors.push(Color.fromHSL(h, s, l));\n      }\n    }\n  }\n  /**\r\n   * Returns a [[Color]] at specific index.\r\n   *\r\n   * If there\'s no color at this index, a new color is generated.\r\n   *\r\n   * @param   index  Index\r\n   * @return         Color\r\n   */\n  getIndex(index) {\n    const colors = this.get("colors", []);\n    const saturation = this.get("saturation");\n    if (index >= colors.length) {\n      this.generateColors();\n      return this.getIndex(index);\n    }\n    return saturation != null ? Color.saturate(colors[index], saturation) : colors[index];\n  }\n  /**\r\n   * Returns next [[Color]] in the list.\r\n   *\r\n   * If the list is out of colors, new ones are generated dynamically.\r\n   */\n  next() {\n    let currentStep = this.getPrivate("currentStep", this.get("startIndex", 0));\n    this.setPrivate("currentStep", currentStep + this.get("step", 1));\n    return this.getIndex(currentStep);\n  }\n  /**\r\n   * Resets counter to the start of the list, so the next call for `next()` will\r\n   * return the first color.\r\n   */\n  reset() {\n    this.setPrivate("currentStep", this.get("startIndex", 0));\n    this.setPrivate("currentPass", 0);\n  }\n}\nObject.defineProperty(ColorSet, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "ColorSet"\n});\nObject.defineProperty(ColorSet, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Entity.classNames.concat([ColorSet.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChartDefaultTheme.js\n\n\n\n\n\n\n\n\n\n\n/**\r\n * @ignore\r\n */\nclass XYChartDefaultTheme extends Theme {\n  setupDefaultRules() {\n    super.setupDefaultRules();\n    const ic = this._root.interfaceColors;\n    const language = this._root.language;\n    const r = this.rule.bind(this);\n    /**\r\n     * ========================================================================\r\n     * charts/xy\r\n     * ========================================================================\r\n     */\n    r("XYChart").setAll({\n      colors: ColorSet.new(this._root, {}),\n      paddingLeft: 20,\n      paddingRight: 20,\n      paddingTop: 16,\n      paddingBottom: 16,\n      panX: false,\n      panY: false,\n      wheelStep: 0.25,\n      arrangeTooltips: true,\n      pinchZoomX: false,\n      pinchZoomY: false\n    });\n    r("XYSeries").setAll({\n      legendLabelText: "{name}"\n    });\n    r("Rectangle", ["plotbackground", "xy", "background"]).setAll({\n      fill: Color.fromHex(0x000000),\n      fillOpacity: 0\n    });\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * charts/xy: XYChartScrollbar\r\n     * ------------------------------------------------------------------------\r\n     */\n    r("XYChart", ["scrollbar", "chart"]).setAll({\n      paddingBottom: 0,\n      paddingLeft: 0,\n      paddingTop: 0,\n      paddingRight: 0,\n      colors: ColorSet.new(this._root, {\n        saturation: 0\n      })\n    });\n    {\n      const rule = r("Graphics", ["scrollbar", "overlay"]);\n      rule.setAll({\n        fillOpacity: 0.5\n      });\n      setColor(rule, "fill", ic, "background");\n    }\n    // Class: RoundedRectangle\n    r("RoundedRectangle", ["xy", "scrollbar", "thumb"]).setAll({\n      cornerRadiusTR: 0,\n      cornerRadiusTL: 0,\n      cornerRadiusBR: 0,\n      cornerRadiusBL: 0,\n      fillOpacity: 0,\n      focusable: true\n    });\n    r("RoundedRectangle", ["xy", "scrollbar", "thumb"]).states.create("hover", {\n      fillOpacity: 0.4\n    });\n    r("RoundedRectangle", ["xy", "scrollbar", "chart", "background"]).setAll({\n      cornerRadiusTL: 0,\n      cornerRadiusBL: 0,\n      cornerRadiusTR: 0,\n      cornerRadiusBR: 0\n    });\n    r("RoundedRectangle", ["xy", "scrollbar", "chart", "background", "resize", "button"]).setAll({\n      cornerRadiusBL: 40,\n      cornerRadiusBR: 40,\n      cornerRadiusTL: 40,\n      cornerRadiusTR: 40\n    });\n    r("AxisRendererX", ["xy", "chart", "scrollbar"]).setAll({\n      strokeOpacity: 0,\n      inside: true\n    });\n    r("AxisRendererY", ["xy", "chart", "scrollbar"]).setAll({\n      strokeOpacity: 0,\n      inside: true,\n      minGridDistance: 5\n    });\n    r("AxisLabel", ["xy", "scrollbar", "x"]).setAll({\n      opacity: 0.5,\n      centerY: p100,\n      minPosition: 0.01,\n      maxPosition: 0.99,\n      fontSize: "0.8em"\n    });\n    r("AxisLabel", ["category"]).setAll({\n      text: "{category}",\n      populateText: true\n    });\n    r("AxisLabel", ["x"]).setAll({\n      centerY: 0\n    });\n    r("AxisLabel", ["x", "inside"]).setAll({\n      centerY: p100\n    });\n    r("AxisLabel", ["x", "inside", "opposite"]).setAll({\n      centerY: 0\n    });\n    r("AxisLabel", ["x", "opposite"]).setAll({\n      centerY: p100\n    });\n    r("AxisLabel", ["y"]).setAll({\n      centerX: p100\n    });\n    r("AxisLabel", ["y", "inside"]).setAll({\n      centerX: 0\n    });\n    r("AxisLabel", ["y", "inside", "opposite"]).setAll({\n      centerX: p100\n    });\n    r("AxisLabel", ["y", "opposite"]).setAll({\n      centerX: 0\n    });\n    r("AxisLabel", ["minor"]).setAll({\n      fontSize: "0.6em"\n    });\n    r("AxisLabel", ["xy", "scrollbar", "y"]).setAll({\n      visible: false\n    });\n    // Class: Grid\n    r("Grid", ["xy", "scrollbar", "y"]).setAll({\n      visible: false\n    });\n    // Class: Grid\n    r("Grid", ["xy", "scrollbar", "x"]).setAll({\n      opacity: 0.5\n    });\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * charts/xy: Cursor\r\n     * ------------------------------------------------------------------------\r\n     */\n    r("XYCursor").setAll({\n      behavior: "none",\n      layer: 30,\n      exportable: false,\n      snapToSeriesBy: "xy",\n      moveThreshold: 1\n    });\n    {\n      const rule = r("Grid", ["cursor", "x"]);\n      rule.setAll({\n        forceInactive: true,\n        strokeOpacity: 0.8,\n        strokeDasharray: [2, 2],\n        role: "slider",\n        ariaLabel: language.translate("Use left and right arrows to move selection")\n      });\n      setColor(rule, "stroke", ic, "alternativeBackground");\n    }\n    {\n      const rule = r("Grid", ["cursor", "y"]);\n      rule.setAll({\n        forceInactive: true,\n        strokeOpacity: 0.8,\n        strokeDasharray: [2, 2],\n        role: "slider",\n        ariaLabel: language.translate("Use up and down arrows to move selection")\n      });\n      setColor(rule, "stroke", ic, "alternativeBackground");\n    }\n    {\n      const rule = r("Graphics", ["cursor", "selection"]);\n      rule.setAll({\n        fillOpacity: 0.15\n      });\n      setColor(rule, "fill", ic, "alternativeBackground");\n    }\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * charts/xy: Axes\r\n     * ------------------------------------------------------------------------\r\n     */\n    r("Axis").setAll({\n      start: 0,\n      end: 1,\n      minZoomCount: 1,\n      maxZoomCount: Infinity,\n      maxZoomFactor: 1000,\n      maxDeviation: 0.1,\n      snapTooltip: true,\n      tooltipLocation: 0.5,\n      panX: true,\n      panY: true,\n      zoomX: true,\n      zoomY: true,\n      fixAxisSize: true\n    });\n    r("AxisLabel").setAll({\n      location: 0.5,\n      multiLocation: 0,\n      centerX: p50,\n      centerY: p50,\n      paddingTop: 3,\n      paddingBottom: 3,\n      paddingLeft: 5,\n      paddingRight: 5\n    });\n    // The following is deprecated following text measuring updates in 5.0.5\n    // r("AxisLabel", ["y"]).setAll({\n    // \ttextAlign: "right"\n    // });\n    // r("AxisLabel", ["y", "opposite"]).setAll({\n    // \ttextAlign: "left"\n    // });\n    r("Container", ["axis", "header"]).setAll({\n      layer: 30\n    });\n    r("Rectangle", ["axis", "header", "background"]).setAll({\n      crisp: true\n    });\n    {\n      const rule = r("AxisRenderer");\n      rule.setAll({\n        crisp: true,\n        strokeOpacity: 0\n      });\n      setColor(rule, "stroke", ic, "grid");\n    }\n    r("AxisRendererX").setAll({\n      minGridDistance: 120,\n      opposite: false,\n      inversed: false,\n      cellStartLocation: 0,\n      cellEndLocation: 1,\n      width: p100\n    });\n    r("AxisRendererY").setAll({\n      minGridDistance: 40,\n      opposite: false,\n      inversed: false,\n      cellStartLocation: 0,\n      cellEndLocation: 1,\n      height: p100\n    });\n    {\n      const rule = r("Rectangle", ["axis", "thumb"]);\n      rule.setAll({\n        fillOpacity: 0\n      });\n      setColor(rule, "fill", ic, "alternativeBackground");\n      rule.states.create("hover", {\n        fillOpacity: 0.1\n      });\n    }\n    r("Rectangle", ["axis", "thumb", "x"]).setAll({\n      cursorOverStyle: "ew-resize"\n    });\n    r("Rectangle", ["axis", "thumb", "y"]).setAll({\n      cursorOverStyle: "ns-resize"\n    });\n    {\n      const rule = r("Grid");\n      rule.setAll({\n        location: 0,\n        strokeOpacity: 0.15,\n        crisp: true\n      });\n      setColor(rule, "stroke", ic, "grid");\n    }\n    {\n      const rule = r("Grid", ["minor"]);\n      rule.setAll({\n        location: 0,\n        strokeOpacity: 0.07,\n        crisp: true\n      });\n      setColor(rule, "stroke", ic, "grid");\n    }\n    r("Grid", ["base"]).setAll({\n      strokeOpacity: 0.3\n    });\n    {\n      const rule = r("Graphics", ["axis", "fill"]);\n      rule.setAll({\n        visible: false,\n        isMeasured: false,\n        position: "absolute",\n        fillOpacity: 0.05\n      });\n      setColor(rule, "fill", ic, "alternativeBackground");\n    }\n    r("Graphics", ["axis", "fill", "range"]).setAll({\n      isMeasured: true\n    });\n    // hides all elements of series axis range\n    r("Graphics", ["series", "fill", "range"]).setAll({\n      visible: false,\n      isMeasured: true\n    });\n    r("Grid", ["series", "range"]).setAll({\n      visible: false\n    });\n    r("AxisTick", ["series", "range"]).setAll({\n      visible: false\n    });\n    r("AxisLabel", ["series", "range"]).setAll({\n      visible: false\n    });\n    {\n      const rule = r("AxisTick");\n      rule.setAll({\n        location: 0.5,\n        multiLocation: 0,\n        strokeOpacity: 1,\n        isMeasured: false,\n        position: "absolute",\n        visible: false\n      });\n      setColor(rule, "stroke", ic, "grid");\n    }\n    r("CategoryAxis").setAll({\n      startLocation: 0,\n      endLocation: 1,\n      fillRule: (dataItem, index) => {\n        const axisFill = dataItem.get("axisFill");\n        if (axisFill) {\n          if (!Type_isNumber(index) || index % 2 == 0) {\n            axisFill.setPrivate("visible", true);\n          } else {\n            axisFill.setPrivate("visible", false);\n          }\n        }\n      }\n    });\n    const gridIntervals = [{\n      timeUnit: "millisecond",\n      count: 1\n    }, {\n      timeUnit: "millisecond",\n      count: 5\n    }, {\n      timeUnit: "millisecond",\n      count: 10\n    }, {\n      timeUnit: "millisecond",\n      count: 50\n    }, {\n      timeUnit: "millisecond",\n      count: 100\n    }, {\n      timeUnit: "millisecond",\n      count: 500\n    }, {\n      timeUnit: "second",\n      count: 1\n    }, {\n      timeUnit: "second",\n      count: 5\n    }, {\n      timeUnit: "second",\n      count: 10\n    }, {\n      timeUnit: "second",\n      count: 30\n    }, {\n      timeUnit: "minute",\n      count: 1\n    }, {\n      timeUnit: "minute",\n      count: 5\n    }, {\n      timeUnit: "minute",\n      count: 10\n    }, {\n      timeUnit: "minute",\n      count: 15\n    }, {\n      timeUnit: "minute",\n      count: 30\n    }, {\n      timeUnit: "hour",\n      count: 1\n    }, {\n      timeUnit: "hour",\n      count: 3\n    }, {\n      timeUnit: "hour",\n      count: 6\n    }, {\n      timeUnit: "hour",\n      count: 12\n    }, {\n      timeUnit: "day",\n      count: 1\n    }, {\n      timeUnit: "day",\n      count: 2\n    }, {\n      timeUnit: "day",\n      count: 3\n    }, {\n      timeUnit: "day",\n      count: 4\n    }, {\n      timeUnit: "day",\n      count: 5\n    }, {\n      timeUnit: "week",\n      count: 1\n    }, {\n      timeUnit: "month",\n      count: 1\n    }, {\n      timeUnit: "month",\n      count: 2\n    }, {\n      timeUnit: "month",\n      count: 3\n    }, {\n      timeUnit: "month",\n      count: 6\n    }, {\n      timeUnit: "year",\n      count: 1\n    }, {\n      timeUnit: "year",\n      count: 2\n    }, {\n      timeUnit: "year",\n      count: 5\n    }, {\n      timeUnit: "year",\n      count: 10\n    }, {\n      timeUnit: "year",\n      count: 50\n    }, {\n      timeUnit: "year",\n      count: 100\n    }, {\n      timeUnit: "year",\n      count: 200\n    }, {\n      timeUnit: "year",\n      count: 500\n    }, {\n      timeUnit: "year",\n      count: 1000\n    }, {\n      timeUnit: "year",\n      count: 2000\n    }, {\n      timeUnit: "year",\n      count: 5000\n    }, {\n      timeUnit: "year",\n      count: 10000\n    }, {\n      timeUnit: "year",\n      count: 100000\n    }];\n    const dateFormats = {\n      "millisecond": language.translate("_date_millisecond"),\n      "second": language.translate("_date_second"),\n      "minute": language.translate("_date_minute"),\n      "hour": language.translate("_date_hour"),\n      "day": language.translate("_date_day"),\n      "week": language.translate("_date_day"),\n      "month": language.translate("_date_month"),\n      "year": language.translate("_date_year")\n    };\n    const periodChangeDateFormats = {\n      "millisecond": language.translate("_date_millisecond"),\n      "second": language.translate("_date_second"),\n      "minute": language.translate("_date_minute"),\n      "hour": language.translate("_date_day"),\n      "day": language.translate("_date_day"),\n      "week": language.translate("_date_day"),\n      "month": language.translate("_date_month") + " " + language.translate("_date_year"),\n      "year": language.translate("_date_year")\n    };\n    const tooltipDateFormats = {\n      "millisecond": language.translate("_date_millisecond_full"),\n      "second": language.translate("_date_second_full"),\n      "minute": language.translate("_date_minute_full"),\n      "hour": language.translate("_date_hour_full"),\n      "day": language.translate("_date_day_full"),\n      "week": language.translate("_date_week_full"),\n      "month": language.translate("_date_month_full"),\n      "year": language.translate("_date_year")\n    };\n    r("CategoryDateAxis").setAll({\n      markUnitChange: true,\n      gridIntervals: copy(gridIntervals),\n      dateFormats: Object_copy(dateFormats),\n      periodChangeDateFormats: Object_copy(periodChangeDateFormats)\n    });\n    r("DateAxis").setAll({\n      maxZoomFactor: null,\n      strictMinMax: true,\n      startLocation: 0,\n      endLocation: 1,\n      markUnitChange: true,\n      groupData: false,\n      groupCount: 500,\n      gridIntervals: copy(gridIntervals),\n      dateFormats: Object_copy(dateFormats),\n      periodChangeDateFormats: Object_copy(periodChangeDateFormats),\n      tooltipDateFormats: tooltipDateFormats,\n      groupIntervals: [{\n        timeUnit: "millisecond",\n        count: 1\n      }, {\n        timeUnit: "millisecond",\n        count: 10\n      }, {\n        timeUnit: "millisecond",\n        count: 100\n      }, {\n        timeUnit: "second",\n        count: 1\n      }, {\n        timeUnit: "second",\n        count: 10\n      }, {\n        timeUnit: "minute",\n        count: 1\n      }, {\n        timeUnit: "minute",\n        count: 10\n      }, {\n        timeUnit: "hour",\n        count: 1\n      }, {\n        timeUnit: "day",\n        count: 1\n      }, {\n        timeUnit: "week",\n        count: 1\n      }, {\n        timeUnit: "month",\n        count: 1\n      }, {\n        timeUnit: "year",\n        count: 1\n      }],\n      fillRule: dataItem => {\n        const axisFill = dataItem.get("axisFill");\n        if (axisFill) {\n          const axis = dataItem.component;\n          const value = dataItem.get("value");\n          const endValue = dataItem.get("endValue");\n          const intervalDuration = axis.intervalDuration();\n          const baseInterval = axis.getPrivate("baseInterval");\n          const gridInterval = axis.getPrivate("gridInterval", baseInterval);\n          let min = axis.getPrivate("min", 0);\n          min = Time_round(new Date(min), gridInterval.timeUnit, gridInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, undefined, this._root.timezone).getTime();\n          if (value != null && endValue != null) {\n            const val = Math.round(Math.round((value - min) / intervalDuration)) / 2;\n            if (val == Math.round(val)) {\n              axisFill.setPrivate("visible", true);\n            } else {\n              axisFill.setPrivate("visible", false);\n            }\n          }\n        }\n      }\n    });\n    r("GaplessDateAxis").setAll({\n      fillRule: dataItem => {\n        const axisFill = dataItem.get("axisFill");\n        if (axisFill) {\n          const index = dataItem.get("index");\n          let visible = false;\n          if (!Type_isNumber(index) || index % 2 == 0) {\n            visible = true;\n          }\n          axisFill.setPrivate("visible", visible);\n        }\n      }\n    });\n    r("ValueAxis").setAll({\n      baseValue: 0,\n      logarithmic: false,\n      strictMinMax: false,\n      autoZoom: true,\n      fillRule: dataItem => {\n        const axisFill = dataItem.get("axisFill");\n        if (axisFill) {\n          const axis = dataItem.component;\n          const value = dataItem.get("value");\n          const step = axis.getPrivate("step");\n          if (Type_isNumber(value) && Type_isNumber(step)) {\n            if (round(value / step / 2, 5) == Math.round(value / step / 2)) {\n              axisFill.setPrivate("visible", false);\n            } else {\n              axisFill.setPrivate("visible", true);\n            }\n          }\n        }\n      }\n    });\n    r("DurationAxis").setAll({\n      baseUnit: "second"\n    });\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * charts/xy: Series\r\n     * ------------------------------------------------------------------------\r\n     */\n    r("XYSeries").setAll({\n      maskBullets: true,\n      stackToNegative: true,\n      locationX: 0.5,\n      locationY: 0.5,\n      snapTooltip: false,\n      openValueXGrouped: "open",\n      openValueYGrouped: "open",\n      valueXGrouped: "close",\n      valueYGrouped: "close",\n      seriesTooltipTarget: "series"\n    });\n    r("BaseColumnSeries").setAll({\n      adjustBulletPosition: true\n    });\n    r("ColumnSeries").setAll({\n      clustered: true\n    });\n    r("RoundedRectangle", ["series", "column"]).setAll({\n      position: "absolute",\n      isMeasured: false,\n      width: percent(70),\n      height: percent(70),\n      strokeWidth: 1,\n      strokeOpacity: 1,\n      cornerRadiusBL: 0,\n      cornerRadiusTL: 0,\n      cornerRadiusBR: 0,\n      cornerRadiusTR: 0,\n      fillOpacity: 1,\n      role: "figure"\n    });\n    r("LineSeries").setAll({\n      connect: true,\n      autoGapCount: 1.1,\n      stackToNegative: false\n    });\n    r("Graphics", ["series", "stroke"]).setAll({\n      position: "absolute",\n      strokeWidth: 1,\n      strokeOpacity: 1,\n      isMeasured: false\n    });\n    r("Graphics", ["series", "fill"]).setAll({\n      visible: false,\n      fillOpacity: 0,\n      position: "absolute",\n      strokeWidth: 0,\n      strokeOpacity: 0,\n      isMeasured: false\n    });\n    r("Graphics", ["line", "series", "legend", "marker", "stroke"]).setAll({\n      draw: (display, sprite) => {\n        const parent = sprite.parent;\n        if (parent) {\n          const h = parent.height();\n          const w = parent.width();\n          display.moveTo(0, h / 2);\n          display.lineTo(w, h / 2);\n        }\n      }\n    });\n    {\n      const rule = r("Graphics", ["line", "series", "legend", "marker", "stroke"]).states.create("disabled", {});\n      setColor(rule, "stroke", ic, "disabled");\n    }\n    r("Graphics", ["line", "series", "legend", "marker", "fill"]).setAll({\n      draw: (display, sprite) => {\n        const parent = sprite.parent;\n        if (parent) {\n          const h = parent.height();\n          const w = parent.width();\n          display.moveTo(0, 0);\n          display.lineTo(w, 0);\n          display.lineTo(w, h);\n          display.lineTo(0, h);\n          display.lineTo(0, 0);\n        }\n      }\n    });\n    {\n      const rule = r("Graphics", ["line", "series", "legend", "marker", "fill"]).states.create("disabled", {});\n      setColor(rule, "stroke", ic, "disabled");\n    }\n    r("SmoothedXYLineSeries").setAll({\n      tension: 0.5\n    });\n    r("SmoothedXLineSeries").setAll({\n      tension: 0.5\n    });\n    r("SmoothedYLineSeries").setAll({\n      tension: 0.5\n    });\n    r("Candlestick").setAll({\n      position: "absolute",\n      isMeasured: false,\n      width: percent(50),\n      height: percent(50),\n      strokeWidth: 1,\n      strokeOpacity: 1,\n      cornerRadiusBL: 0,\n      cornerRadiusTL: 0,\n      cornerRadiusBR: 0,\n      cornerRadiusTR: 0,\n      fillOpacity: 1,\n      role: "figure"\n    });\n    r("OHLC").setAll({\n      width: percent(80),\n      height: percent(80)\n    });\n    r("CandlestickSeries").setAll({\n      lowValueXGrouped: "low",\n      lowValueYGrouped: "low",\n      highValueXGrouped: "high",\n      highValueYGrouped: "high",\n      openValueXGrouped: "open",\n      openValueYGrouped: "open",\n      valueXGrouped: "close",\n      valueYGrouped: "close"\n    });\n    // These rules can be used for regular columns, too\n    {\n      const rule = r("Rectangle", ["column", "autocolor"]).states.create("riseFromOpen", {});\n      setColor(rule, "fill", ic, "positive");\n      setColor(rule, "stroke", ic, "positive");\n    }\n    {\n      const rule = r("Rectangle", ["column", "autocolor"]).states.create("dropFromOpen", {});\n      setColor(rule, "fill", ic, "negative");\n      setColor(rule, "stroke", ic, "negative");\n    }\n    // Hollow\n    r("Rectangle", ["column", "autocolor", "pro"]).states.create("riseFromOpen", {\n      fillOpacity: 0\n    });\n    r("Rectangle", ["column", "autocolor", "pro"]).states.create("dropFromOpen", {\n      fillOpacity: 1\n    });\n    {\n      const rule = r("Rectangle", ["column", "autocolor", "pro"]).states.create("riseFromPrevious", {});\n      setColor(rule, "fill", ic, "positive");\n      setColor(rule, "stroke", ic, "positive");\n    }\n    {\n      const rule = r("Rectangle", ["column", "autocolor", "pro"]).states.create("dropFromPrevious", {});\n      setColor(rule, "fill", ic, "negative");\n      setColor(rule, "stroke", ic, "negative");\n    }\n    // AXIS RANGE GRIP\n    {\n      const rule = r("RoundedRectangle", ["rangegrip"]);\n      rule.setAll({\n        strokeOpacity: 0,\n        fillOpacity: 0,\n        strokeWidth: 1,\n        width: 12,\n        height: 12\n      });\n    }\n    {\n      const rule = r("Graphics", ["rangegrip", "button", "icon"]);\n      rule.setAll({\n        interactive: false,\n        crisp: true,\n        strokeOpacity: 0.5,\n        draw: display => {\n          display.moveTo(0, 0.5);\n          display.lineTo(0, 12.5);\n          display.moveTo(2, 0.5);\n          display.lineTo(2, 12.5);\n          display.moveTo(4, 0.5);\n          display.lineTo(4, 12.5);\n        }\n      });\n      setColor(rule, "stroke", ic, "secondaryButtonText");\n    }\n    r("Button", ["rangegrip"]).setAll({\n      draggable: true,\n      paddingTop: 0,\n      paddingBottom: 0\n    });\n    r("Button", ["rangegrip", "vertical"]).setAll({\n      rotation: 90,\n      cursorOverStyle: "ns-resize",\n      centerX: p50\n    });\n    r("Button", ["rangegrip", "horizontal"]).setAll({\n      cursorOverStyle: "ew-resize",\n      centerX: p50\n    });\n    r("Button", ["rangegrip", "vertical", "left"]).setAll({\n      centerY: p100\n    });\n    r("Button", ["rangegrip", "vertical", "right"]).setAll({\n      centerY: 0\n    });\n    r("Button", ["rangegrip", "horizontal", "top"]).setAll({\n      centerY: 0\n    });\n    r("Button", ["rangegrip", "horizontal", "bottom"]).setAll({\n      centerY: p100\n    });\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Chart.js\n\n\n/**\r\n * A base class for all charts.\r\n */\nclass Chart extends Container {\n  constructor() {\n    super(...arguments);\n    /**\r\n     * A [[Container]] chart places its elements in.\r\n     *\r\n     * @default Container.new()\r\n     */\n    Object.defineProperty(this, "chartContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.children.push(Container.new(this._root, {\n        width: p100,\n        height: p100,\n        interactiveChildren: false\n      }))\n    });\n    /**\r\n     * A [[Container]] chart places its bullets in.\r\n     *\r\n     * @default Container.new()\r\n     */\n    Object.defineProperty(this, "bulletsContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: Container.new(this._root, {\n        interactiveChildren: false,\n        isMeasured: false,\n        position: "absolute",\n        width: p100,\n        height: p100\n      })\n    });\n  }\n}\nObject.defineProperty(Chart, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Chart"\n});\nObject.defineProperty(Chart, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Container.classNames.concat([Chart.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/SerialChart.js\n\n\n\n\n\n/**\r\n * A base class for all series-based charts.\r\n */\nclass SerialChart extends Chart {\n  constructor() {\n    super(...arguments);\n    /**\r\n     * A [[Container]] where chart will store all series.\r\n     *\r\n     * @default Container.new()\r\n     */\n    Object.defineProperty(this, "seriesContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: Container.new(this._root, {\n        width: p100,\n        height: p100,\n        isMeasured: false\n      })\n    });\n    /**\r\n     * A list of chart\'s series.\r\n     */\n    Object.defineProperty(this, "series", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListAutoDispose()\n    });\n  }\n  _afterNew() {\n    super._afterNew();\n    this._disposers.push(this.series);\n    const children = this.seriesContainer.children;\n    this._disposers.push(this.series.events.onAll(change => {\n      if (change.type === "clear") {\n        each(change.oldValues, series => {\n          this._removeSeries(series);\n        });\n        const colors = this.get("colors");\n        if (colors) {\n          colors.reset();\n        }\n      } else if (change.type === "push") {\n        children.moveValue(change.newValue);\n        this._processSeries(change.newValue);\n      } else if (change.type === "setIndex") {\n        children.setIndex(change.index, change.newValue);\n        this._processSeries(change.newValue);\n      } else if (change.type === "insertIndex") {\n        children.insertIndex(change.index, change.newValue);\n        this._processSeries(change.newValue);\n      } else if (change.type === "removeIndex") {\n        this._removeSeries(change.oldValue);\n      } else if (change.type === "moveIndex") {\n        children.moveValue(change.value, change.newIndex);\n        this._processSeries(change.value);\n      } else {\n        throw new Error("Unknown IListEvent type");\n      }\n    }));\n  }\n  _processSeries(series) {\n    series.chart = this;\n    series._placeBulletsContainer(this);\n  }\n  _removeSeries(series) {\n    if (!series.isDisposed()) {\n      this.seriesContainer.children.removeValue(series);\n      series._removeBulletsContainer();\n    }\n  }\n}\nObject.defineProperty(SerialChart, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "SerialChart"\n});\nObject.defineProperty(SerialChart, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Chart.classNames.concat([SerialChart.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Button.js\n\n\n\n/**\r\n * Draws an interactive button.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/buttons/} for more info\r\n * @important\r\n */\nclass Button extends Container {\n  _afterNew() {\n    this._settings.themeTags = mergeTags(this._settings.themeTags, ["button"]);\n    super._afterNew();\n    if (!this._settings.background) {\n      this.set("background", RoundedRectangle.new(this._root, {\n        themeTags: mergeTags(this._settings.themeTags, ["background"])\n      }));\n    }\n    this.setPrivate("trustBounds", true);\n  }\n  _prepareChildren() {\n    super._prepareChildren();\n    if (this.isDirty("icon")) {\n      const previous = this._prevSettings.icon;\n      const icon = this.get("icon");\n      if (icon !== previous) {\n        this._disposeProperty("icon");\n        if (previous) {\n          previous.dispose();\n        }\n        if (icon) {\n          this.children.push(icon);\n        }\n        this._prevSettings.icon = icon;\n      }\n    }\n    if (this.isDirty("label")) {\n      const previous = this._prevSettings.label;\n      const label = this.get("label");\n      if (label !== previous) {\n        this._disposeProperty("label");\n        if (previous) {\n          previous.dispose();\n        }\n        if (label) {\n          this.children.push(label);\n        }\n        this._prevSettings.label = label;\n      }\n    }\n  }\n}\nObject.defineProperty(Button, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Button"\n});\nObject.defineProperty(Button, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Container.classNames.concat([Button.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChart.js\n;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * Creates an XY chart.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/} for more info\r\n * @important\r\n */\nclass XYChart extends SerialChart {\n  constructor() {\n    super(...arguments);\n    /**\r\n     * A list of horizontal axes.\r\n     */\n    Object.defineProperty(this, "xAxes", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListAutoDispose()\n    });\n    /**\r\n     * A list of vertical axes.\r\n     */\n    Object.defineProperty(this, "yAxes", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListAutoDispose()\n    });\n    /**\r\n     * A [[Container]] located on top of the chart, used to store top horizontal\r\n     * axes.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n    Object.defineProperty(this, "topAxesContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.chartContainer.children.push(Container.new(this._root, {\n        width: p100,\n        layout: this._root.verticalLayout\n      }))\n    });\n    /**\r\n     * A [[Container]] located in the middle the chart, used to store vertical axes\r\n     * and plot area container.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n    Object.defineProperty(this, "yAxesAndPlotContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.chartContainer.children.push(Container.new(this._root, {\n        width: p100,\n        height: p100,\n        layout: this._root.horizontalLayout\n      }))\n    });\n    /**\r\n     * A [[Container]] located on bottom of the chart, used to store bottom\r\n     * horizontal axes.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n    Object.defineProperty(this, "bottomAxesContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.chartContainer.children.push(Container.new(this._root, {\n        width: p100,\n        layout: this._root.verticalLayout\n      }))\n    });\n    /**\r\n     * A [[Container]] located on left of the chart, used to store left-hand\r\n     * vertical axes.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n    Object.defineProperty(this, "leftAxesContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.yAxesAndPlotContainer.children.push(Container.new(this._root, {\n        height: p100,\n        layout: this._root.horizontalLayout\n      }))\n    });\n    /**\r\n     * A [[Container]] located in the middle of the chart, used to store plotContainer and topPlotContainer\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n    Object.defineProperty(this, "plotsContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.yAxesAndPlotContainer.children.push(Container.new(this._root, {\n        width: p100,\n        height: p100,\n        maskContent: false\n      }))\n    });\n    /**\r\n     * A [[Container]] located in the middle of the chart, used to store actual\r\n     * plots (series).\r\n     *\r\n     * NOTE: `plotContainer` will automatically have its `background` preset. If\r\n     * you need to modify background or outline for chart\'s plot area, you can\r\n     * use `plotContainer.get("background")` for that.*\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n    Object.defineProperty(this, "plotContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.plotsContainer.children.push(Container.new(this._root, {\n        width: p100,\n        height: p100\n      }))\n    });\n    /**\r\n     * A [[Container]] used for any elements that need to be displayed over\r\n     * regular `plotContainer`.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n    Object.defineProperty(this, "topPlotContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.plotsContainer.children.push(Container.new(this._root, {\n        width: p100,\n        height: p100\n      }))\n    });\n    /**\r\n     * A [[Container]] axis grid elements are stored in.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n    Object.defineProperty(this, "gridContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.plotContainer.children.push(Container.new(this._root, {\n        width: p100,\n        height: p100,\n        isMeasured: false\n      }))\n    });\n    /**\r\n     * A [[Container]] axis background grid elements are stored in.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n    Object.defineProperty(this, "topGridContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: Container.new(this._root, {\n        width: p100,\n        height: p100,\n        isMeasured: false\n      })\n    });\n    /**\r\n     * A [[Container]] located on right of the chart, used to store right-hand\r\n     * vertical axes.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n    Object.defineProperty(this, "rightAxesContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.yAxesAndPlotContainer.children.push(Container.new(this._root, {\n        height: p100,\n        layout: this._root.horizontalLayout\n      }))\n    });\n    /**\r\n     * A [[Container]] axis headers are stored in.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-headers/} for more info\r\n     * @default Container.new()\r\n     */\n    Object.defineProperty(this, "axisHeadersContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.plotContainer.children.push(Container.new(this._root, {}))\n    });\n    /**\r\n     * A button that is shown when chart is not fully zoomed out.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/zoom-and-pan/#Zoom_out_button} for more info\r\n     * @default Button.new()\r\n     */\n    Object.defineProperty(this, "zoomOutButton", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.topPlotContainer.children.push(Button.new(this._root, {\n        themeTags: ["zoom"],\n        icon: Graphics.new(this._root, {\n          themeTags: ["button", "icon"]\n        })\n      }))\n    });\n    Object.defineProperty(this, "_movePoint", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {\n        x: 0,\n        y: 0\n      }\n    });\n    Object.defineProperty(this, "_wheelDp", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_otherCharts", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_movePoints", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_downStartX", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_downEndX", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_downStartY", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_downEndY", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  _afterNew() {\n    this._defaultThemes.push(XYChartDefaultTheme.new(this._root));\n    super._afterNew();\n    this._disposers.push(this.xAxes);\n    this._disposers.push(this.yAxes);\n    const root = this._root;\n    let verticalLayout = this._root.verticalLayout;\n    const zoomOutButton = this.zoomOutButton;\n    zoomOutButton.events.on("click", () => {\n      this.zoomOut();\n    });\n    zoomOutButton.hide(0);\n    zoomOutButton.states.lookup("default").set("opacity", 1);\n    this.chartContainer.set("layout", verticalLayout);\n    const plotContainer = this.plotContainer;\n    plotContainer.children.push(this.seriesContainer);\n    this._disposers.push(this._processAxis(this.xAxes, this.bottomAxesContainer));\n    this._disposers.push(this._processAxis(this.yAxes, this.leftAxesContainer));\n    plotContainer.children.push(this.topGridContainer);\n    plotContainer.children.push(this.bulletsContainer);\n    // Setting trasnparent background so that full body of the plot container\n    // is interactive\n    plotContainer.set("interactive", true);\n    plotContainer.set("interactiveChildren", false);\n    plotContainer.set("background", Rectangle.new(root, {\n      themeTags: ["plotbackground", "xy", "background"]\n    }));\n    this._disposers.push(plotContainer.events.on("pointerdown", event => {\n      this._handlePlotDown(event);\n    }));\n    this._disposers.push(plotContainer.events.on("globalpointerup", event => {\n      this._handlePlotUp(event);\n    }));\n    this._disposers.push(plotContainer.events.on("globalpointermove", event => {\n      this._handlePlotMove(event);\n    }));\n    this._maskGrid();\n    this._setUpTouch();\n  }\n  _beforeChanged() {\n    super._beforeChanged();\n    if (this.isDirty("pinchZoomX") || this.isDirty("pinchZoomY") || this.get("panX") || this.get("panY")) {\n      this._setUpTouch();\n    }\n  }\n  _setUpTouch() {\n    if (!this.plotContainer._display.cancelTouch) {\n      this.plotContainer._display.cancelTouch = this.get("pinchZoomX") || this.get("pinchZoomY") || this.get("panX") || this.get("panY") ? true : false;\n    }\n  }\n  _maskGrid() {\n    this.gridContainer.set("maskContent", true);\n    this.topGridContainer.set("maskContent", true);\n  }\n  _removeSeries(series) {\n    series._unstack();\n    if (series._posXDp) {\n      series._posXDp.dispose();\n    }\n    if (series._posYDp) {\n      series._posYDp.dispose();\n    }\n    series.set("baseAxis", undefined);\n    const xAxis = series.get("xAxis");\n    if (xAxis) {\n      Array_remove(xAxis.series, series);\n      xAxis.markDirtyExtremes();\n    }\n    const yAxis = series.get("yAxis");\n    if (yAxis) {\n      Array_remove(yAxis.series, series);\n      yAxis.markDirtyExtremes();\n    }\n    const cursor = this.get("cursor");\n    if (cursor) {\n      const snapToSeries = cursor.get("snapToSeries");\n      if (snapToSeries) {\n        Array_remove(snapToSeries, series);\n      }\n    }\n    super._removeSeries(series);\n  }\n  /**\r\n   * This method is invoked when mouse wheel is used over chart\'s plot\r\n   * container, and handles zooming/pan.\r\n   *\r\n   * You can invoke this method manually, if you need to mimic chart\'s wheel\r\n   * behavior over other elements of the chart.\r\n   */\n  handleWheel(event) {\n    const wheelX = this.get("wheelX");\n    const wheelY = this.get("wheelY");\n    const plotContainer = this.plotContainer;\n    const wheelEvent = event.originalEvent;\n    // Ignore wheel event if it is happening on a non-chart element, e.g. if\n    // some page element is over the chart.\n    if (isLocalEvent(wheelEvent, this)) {\n      wheelEvent.preventDefault();\n    } else {\n      return;\n    }\n    const plotPoint = plotContainer.toLocal(event.point);\n    const wheelStep = this.get("wheelStep", 0.2);\n    const shiftY = wheelEvent.deltaY / 100;\n    const shiftX = wheelEvent.deltaX / 100;\n    const wheelZoomPositionX = this.get("wheelZoomPositionX");\n    const wheelZoomPositionY = this.get("wheelZoomPositionY");\n    if ((wheelX === "zoomX" || wheelX === "zoomXY") && shiftX != 0) {\n      this.xAxes.each(axis => {\n        if (axis.get("zoomX")) {\n          let start = axis.get("start");\n          let end = axis.get("end");\n          let position = axis.fixPosition(plotPoint.x / plotContainer.width());\n          if (wheelZoomPositionX != null) {\n            position = wheelZoomPositionX;\n          }\n          let newStart = start - wheelStep * (end - start) * shiftX * position;\n          let newEnd = end + wheelStep * (end - start) * shiftX * (1 - position);\n          if (1 / (newEnd - newStart) < axis.getPrivate("maxZoomFactor", Infinity) / axis.get("minZoomCount", 1)) {\n            this._handleWheelAnimation(axis.zoom(newStart, newEnd));\n          }\n        }\n      });\n    }\n    if ((wheelY === "zoomX" || wheelY === "zoomXY") && shiftY != 0) {\n      this.xAxes.each(axis => {\n        if (axis.get("zoomX")) {\n          let start = axis.get("start");\n          let end = axis.get("end");\n          let position = axis.fixPosition(plotPoint.x / plotContainer.width());\n          if (wheelZoomPositionX != null) {\n            position = wheelZoomPositionX;\n          }\n          let newStart = start - wheelStep * (end - start) * shiftY * position;\n          let newEnd = end + wheelStep * (end - start) * shiftY * (1 - position);\n          if (1 / (newEnd - newStart) < axis.getPrivate("maxZoomFactor", Infinity) / axis.get("minZoomCount", 1)) {\n            this._handleWheelAnimation(axis.zoom(newStart, newEnd));\n          }\n        }\n      });\n    }\n    if ((wheelX === "zoomY" || wheelX === "zoomXY") && shiftX != 0) {\n      this.yAxes.each(axis => {\n        if (axis.get("zoomY")) {\n          let start = axis.get("start");\n          let end = axis.get("end");\n          let position = axis.fixPosition(plotPoint.y / plotContainer.height());\n          if (wheelZoomPositionY != null) {\n            position = wheelZoomPositionY;\n          }\n          let newStart = start - wheelStep * (end - start) * shiftX * position;\n          let newEnd = end + wheelStep * (end - start) * shiftX * (1 - position);\n          if (1 / (newEnd - newStart) < axis.getPrivate("maxZoomFactor", Infinity) / axis.get("minZoomCount", 1)) {\n            this._handleWheelAnimation(axis.zoom(newStart, newEnd));\n          }\n        }\n      });\n    }\n    if ((wheelY === "zoomY" || wheelY === "zoomXY") && shiftY != 0) {\n      this.yAxes.each(axis => {\n        if (axis.get("zoomY")) {\n          let start = axis.get("start");\n          let end = axis.get("end");\n          let position = axis.fixPosition(plotPoint.y / plotContainer.height());\n          if (wheelZoomPositionY != null) {\n            position = wheelZoomPositionY;\n          }\n          let newStart = start - wheelStep * (end - start) * shiftY * position;\n          let newEnd = end + wheelStep * (end - start) * shiftY * (1 - position);\n          if (1 / (newEnd - newStart) < axis.getPrivate("maxZoomFactor", Infinity) / axis.get("minZoomCount", 1)) {\n            this._handleWheelAnimation(axis.zoom(newStart, newEnd));\n          }\n        }\n      });\n    }\n    if ((wheelX === "panX" || wheelX === "panXY") && shiftX != 0) {\n      this.xAxes.each(axis => {\n        if (axis.get("panX")) {\n          let start = axis.get("start");\n          let end = axis.get("end");\n          let delta = this._getWheelSign(axis) * wheelStep * (end - start) * shiftX;\n          let newStart = start + delta;\n          let newEnd = end + delta;\n          let se = this._fixWheel(newStart, newEnd);\n          newStart = se[0];\n          newEnd = se[1];\n          this._handleWheelAnimation(axis.zoom(newStart, newEnd));\n        }\n      });\n    }\n    if ((wheelY === "panX" || wheelY === "panXY") && shiftY != 0) {\n      this.xAxes.each(axis => {\n        if (axis.get("panX")) {\n          let start = axis.get("start");\n          let end = axis.get("end");\n          let delta = this._getWheelSign(axis) * wheelStep * (end - start) * shiftY;\n          let newStart = start + delta;\n          let newEnd = end + delta;\n          let se = this._fixWheel(newStart, newEnd);\n          newStart = se[0];\n          newEnd = se[1];\n          this._handleWheelAnimation(axis.zoom(newStart, newEnd));\n        }\n      });\n    }\n    if ((wheelX === "panY" || wheelX === "panXY") && shiftX != 0) {\n      this.yAxes.each(axis => {\n        if (axis.get("panY")) {\n          let start = axis.get("start");\n          let end = axis.get("end");\n          let delta = this._getWheelSign(axis) * wheelStep * (end - start) * shiftX;\n          let newStart = start + delta;\n          let newEnd = end + delta;\n          let se = this._fixWheel(newStart, newEnd);\n          newStart = se[0];\n          newEnd = se[1];\n          this._handleWheelAnimation(axis.zoom(newStart, newEnd));\n        }\n      });\n    }\n    if ((wheelY === "panY" || wheelY === "panXY") && shiftY != 0) {\n      this.yAxes.each(axis => {\n        if (axis.get("panY")) {\n          let start = axis.get("start");\n          let end = axis.get("end");\n          let delta = this._getWheelSign(axis) * wheelStep * (end - start) * shiftY;\n          let newStart = start - delta;\n          let newEnd = end - delta;\n          let se = this._fixWheel(newStart, newEnd);\n          newStart = se[0];\n          newEnd = se[1];\n          this._handleWheelAnimation(axis.zoom(newStart, newEnd));\n        }\n      });\n    }\n  }\n  _handleSetWheel() {\n    const wheelX = this.get("wheelX");\n    const wheelY = this.get("wheelY");\n    const plotContainer = this.plotContainer;\n    if (wheelX !== "none" || wheelY !== "none") {\n      this._wheelDp = plotContainer.events.on("wheel", event => {\n        const wheelEvent = event.originalEvent;\n        if (wheelX !== "none" && Math.abs(wheelEvent.deltaX) != 0 || wheelY !== "none" && Math.abs(wheelEvent.deltaY) != 0) {\n          this.handleWheel(event);\n        }\n      });\n      this._disposers.push(this._wheelDp);\n    } else {\n      if (this._wheelDp) {\n        this._wheelDp.dispose();\n      }\n    }\n  }\n  _getWheelSign(axis) {\n    let sign = 1;\n    if (axis.get("renderer").get("inversed")) {\n      sign = -1;\n    }\n    return sign;\n  }\n  _fixWheel(start, end) {\n    const diff = end - start;\n    if (start < 0) {\n      start = 0;\n      end = start + diff;\n    }\n    if (end > 1) {\n      end = 1;\n      start = end - diff;\n    }\n    return [start, end];\n  }\n  _handlePlotDown(event) {\n    const originalEvent = event.originalEvent;\n    if (originalEvent.button == 2) {\n      return;\n    }\n    const plotContainer = this.plotContainer;\n    let local = plotContainer.toLocal(event.point);\n    if (this.get("pinchZoomX") || this.get("pinchZoomY")) {\n      const pointerId = originalEvent.pointerId;\n      if (pointerId) {\n        if (keys(plotContainer._downPoints).length > 0) {\n          const xAxis = this.xAxes.getIndex(0);\n          const yAxis = this.yAxes.getIndex(0);\n          if (xAxis) {\n            this._downStartX = xAxis.get("start", 0);\n            this._downEndX = xAxis.get("end", 1);\n          }\n          if (yAxis) {\n            this._downStartY = yAxis.get("start", 0);\n            this._downEndY = yAxis.get("end", 1);\n          }\n        }\n      }\n    }\n    if (this.get("panX") || this.get("panY")) {\n      if (local.x >= 0 && local.y >= 0 && local.x <= plotContainer.width() && local.y <= this.height()) {\n        //this._downPoint = local;\n        this._downPoint = {\n          x: originalEvent.clientX,\n          y: originalEvent.clientY\n        };\n        const panX = this.get("panX");\n        const panY = this.get("panY");\n        if (panX) {\n          this.xAxes.each(axis => {\n            axis._panStart = axis.get("start");\n            axis._panEnd = axis.get("end");\n          });\n        }\n        if (panY) {\n          this.yAxes.each(axis => {\n            axis._panStart = axis.get("start");\n            axis._panEnd = axis.get("end");\n          });\n        }\n        const eventType = "panstarted";\n        if (this.events.isEnabled(eventType)) {\n          this.events.dispatch(eventType, {\n            type: eventType,\n            target: this,\n            originalEvent: event.originalEvent\n          });\n        }\n      }\n    }\n  }\n  _handleWheelAnimation(animation) {\n    if (animation) {\n      animation.events.on("stopped", () => {\n        this._dispatchWheelAnimation();\n      });\n    } else {\n      this._dispatchWheelAnimation();\n    }\n  }\n  _dispatchWheelAnimation() {\n    const eventType = "wheelended";\n    if (this.events.isEnabled(eventType)) {\n      this.events.dispatch(eventType, {\n        type: eventType,\n        target: this\n      });\n    }\n  }\n  _handlePlotUp(event) {\n    const downPoint = this._downPoint;\n    if (downPoint) {\n      if (this.get("panX") || this.get("panY")) {\n        if (event.originalEvent.clientX == downPoint.x && event.originalEvent.clientY == downPoint.y) {\n          const eventType = "pancancelled";\n          if (this.events.isEnabled(eventType)) {\n            this.events.dispatch(eventType, {\n              type: eventType,\n              target: this,\n              originalEvent: event.originalEvent\n            });\n          }\n        }\n        const eventType = "panended";\n        if (this.events.isEnabled(eventType)) {\n          this.events.dispatch(eventType, {\n            type: eventType,\n            target: this,\n            originalEvent: event.originalEvent\n          });\n        }\n      }\n    }\n    // TODO: handle multitouch\n    this._downPoint = undefined;\n    this.xAxes.each(xAxis => {\n      xAxis._isPanning = false;\n    });\n    this.yAxes.each(yAxis => {\n      yAxis._isPanning = false;\n    });\n  }\n  _handlePlotMove(event) {\n    const plotContainer = this.plotContainer;\n    if (this.get("pinchZoomX") || this.get("pinchZoomY")) {\n      const touchEvent = event.originalEvent;\n      const pointerId = touchEvent.pointerId;\n      if (pointerId) {\n        this._movePoints[pointerId] = event.point;\n        if (keys(plotContainer._downPoints).length > 1) {\n          this._handlePinch();\n          return;\n        }\n      }\n    }\n    let downPoint = this._downPoint;\n    if (downPoint) {\n      downPoint = plotContainer.toLocal(this._root.documentPointToRoot(downPoint));\n      let local = plotContainer.toLocal(event.point);\n      const panX = this.get("panX");\n      const panY = this.get("panY");\n      if (panX) {\n        let scrollbarX = this.get("scrollbarX");\n        if (scrollbarX) {\n          scrollbarX.events.disableType("rangechanged");\n        }\n        this.xAxes.each(axis => {\n          if (axis.get("panX")) {\n            axis._isPanning = true;\n            //const maxDeviation = axis.get("maxDeviation", 0);\n            let panStart = axis._panStart;\n            let panEnd = axis._panEnd;\n            let difference = panEnd - panStart;\n            let deltaX = difference * (downPoint.x - local.x) / plotContainer.width();\n            if (axis.get("renderer").get("inversed")) {\n              deltaX *= -1;\n            }\n            let start = panStart + deltaX;\n            let end = panEnd + deltaX;\n            if (end - start < 1 + axis.get("maxDeviation", 1) * 2) {\n              axis.set("start", start);\n              axis.set("end", end);\n            }\n          }\n        });\n        if (scrollbarX) {\n          scrollbarX.events.enableType("rangechanged");\n        }\n      }\n      if (panY) {\n        let scrollbarY = this.get("scrollbarY");\n        if (scrollbarY) {\n          scrollbarY.events.disableType("rangechanged");\n        }\n        this.yAxes.each(axis => {\n          if (axis.get("panY")) {\n            axis._isPanning = true;\n            //const maxDeviation = axis.get("maxDeviation", 0);\n            let panStart = axis._panStart;\n            let panEnd = axis._panEnd;\n            let difference = panEnd - panStart;\n            let deltaY = difference * (downPoint.y - local.y) / plotContainer.height();\n            if (axis.get("renderer").get("inversed")) {\n              deltaY *= -1;\n            }\n            let start = panStart - deltaY;\n            let end = panEnd - deltaY;\n            if (end - start < 1 + axis.get("maxDeviation", 1) * 2) {\n              axis.set("start", start);\n              axis.set("end", end);\n            }\n          }\n        });\n        if (scrollbarY) {\n          scrollbarY.events.enableType("rangechanged");\n        }\n      }\n    }\n  }\n  _handlePinch() {\n    const plotContainer = this.plotContainer;\n    let i = 0;\n    let downPoints = [];\n    let movePoints = [];\n    Object_each(plotContainer._downPoints, (k, point) => {\n      downPoints[i] = point;\n      let movePoint = this._movePoints[k];\n      if (movePoint) {\n        movePoints[i] = movePoint;\n      }\n      i++;\n    });\n    if (downPoints.length > 1 && movePoints.length > 1) {\n      const w = plotContainer.width();\n      const h = plotContainer.height();\n      let downPoint0 = downPoints[0];\n      let downPoint1 = downPoints[1];\n      let movePoint0 = movePoints[0];\n      let movePoint1 = movePoints[1];\n      if (downPoint0 && downPoint1 && movePoint0 && movePoint1) {\n        movePoint0 = plotContainer.toLocal(movePoint0);\n        movePoint1 = plotContainer.toLocal(movePoint1);\n        downPoint0 = plotContainer.toLocal(downPoint0);\n        downPoint1 = plotContainer.toLocal(downPoint1);\n        if (this.get("pinchZoomX")) {\n          const downStartX = this._downStartX;\n          const downEndX = this._downEndX;\n          if (downStartX != null && downEndX != null) {\n            if (downPoint0.x > downPoint1.x) {\n              [downPoint0, downPoint1] = [downPoint1, downPoint0];\n              [movePoint0, movePoint1] = [movePoint1, movePoint0];\n            }\n            let downPos0 = downStartX + downPoint0.x / w * (downEndX - downStartX);\n            let downPos1 = downStartX + downPoint1.x / w * (downEndX - downStartX);\n            let movePos0 = downStartX + movePoint0.x / w * (downEndX - downStartX);\n            let movePos1 = downStartX + movePoint1.x / w * (downEndX - downStartX);\n            let initialDistance = Math.max(0.001, downPos1 - downPos0);\n            let currentDistance = Math.max(0.001, movePos1 - movePos0);\n            let d = initialDistance / currentDistance;\n            let s = downStartX * d + downPos0 - movePos0 * d;\n            let e = downEndX * d + downPos1 - movePos1 * d;\n            this.xAxes.each(xAxis => {\n              let sa = xAxis.fixPosition(s);\n              let ea = xAxis.fixPosition(e);\n              xAxis.zoom(sa, ea, 0);\n            });\n          }\n        }\n        if (this.get("pinchZoomY")) {\n          const downStartY = this._downStartY;\n          const downEndY = this._downEndY;\n          if (downStartY != null && downEndY != null) {\n            if (downPoint0.y < downPoint1.y) {\n              [downPoint0, downPoint1] = [downPoint1, downPoint0];\n              [movePoint0, movePoint1] = [movePoint1, movePoint0];\n            }\n            let downPos0 = downStartY + (1 - downPoint0.y / h) * (downEndY - downStartY);\n            let downPos1 = downStartY + (1 - downPoint1.y / h) * (downEndY - downStartY);\n            let movePos0 = downStartY + (1 - movePoint0.y / h) * (downEndY - downStartY);\n            let movePos1 = downStartY + (1 - movePoint1.y / h) * (downEndY - downStartY);\n            let initialDistance = Math.max(0.001, downPos1 - downPos0);\n            let currentDistance = Math.max(0.001, movePos1 - movePos0);\n            let d = initialDistance / currentDistance;\n            let s = downStartY * d + downPos0 - movePos0 * d;\n            let e = downEndY * d + downPos1 - movePos1 * d;\n            this.yAxes.each(yAxis => {\n              let sa = yAxis.fixPosition(s);\n              let ea = yAxis.fixPosition(e);\n              yAxis.zoom(sa, ea, 0);\n            });\n          }\n        }\n      }\n    }\n  }\n  _handleCursorPosition() {\n    const cursor = this.get("cursor");\n    if (cursor) {\n      const cursorPoint = cursor.getPrivate("point");\n      let snapToSeries = cursor.get("snapToSeries");\n      if (cursor._downPoint) {\n        snapToSeries = undefined;\n      }\n      if (snapToSeries && cursorPoint) {\n        const snapToSeriesBy = cursor.get("snapToSeriesBy");\n        const dataItems = [];\n        each(snapToSeries, series => {\n          if (!series.isHidden() && !series.isHiding()) {\n            if (snapToSeriesBy != "x!" && snapToSeriesBy != "y!") {\n              const startIndex = series.startIndex();\n              const endIndex = series.endIndex();\n              for (let i = startIndex; i < endIndex; i++) {\n                const dataItem = series.dataItems[i];\n                if (dataItem && !dataItem.isHidden()) {\n                  dataItems.push(dataItem);\n                }\n              }\n            } else {\n              const tooltipDataItem = series.get("tooltipDataItem");\n              if (tooltipDataItem) {\n                dataItems.push(tooltipDataItem);\n              }\n            }\n          }\n        });\n        let minDistance = Infinity;\n        let closestItem;\n        each(dataItems, dataItem => {\n          const point = dataItem.get("point");\n          if (point) {\n            let distance = 0;\n            if (snapToSeriesBy == "x" || snapToSeriesBy == "x!") {\n              distance = Math.abs(cursorPoint.x - point.x);\n            } else if (snapToSeriesBy == "y" || snapToSeriesBy == "y!") {\n              distance = Math.abs(cursorPoint.y - point.y);\n            } else {\n              distance = Math.hypot(cursorPoint.x - point.x, cursorPoint.y - point.y);\n            }\n            if (distance < minDistance) {\n              minDistance = distance;\n              closestItem = dataItem;\n            }\n          }\n        });\n        each(snapToSeries, series => {\n          const tooltip = series.get("tooltip");\n          if (tooltip) {\n            tooltip._setDataItem(undefined);\n          }\n        });\n        if (closestItem) {\n          let series = closestItem.component;\n          series.showDataItemTooltip(closestItem);\n          series.setRaw("tooltipDataItem", closestItem);\n          const point = closestItem.get("point");\n          if (point) {\n            // removing x and y to solve #72225\n            cursor.handleMove(series.toGlobal({\n              x: point.x - series.x(),\n              y: point.y - series.y()\n            }), true);\n          }\n        }\n      }\n    }\n  }\n  _updateCursor() {\n    let cursor = this.get("cursor");\n    if (cursor) {\n      cursor.updateCursor();\n    }\n  }\n  _addCursor(cursor) {\n    this.plotContainer.children.push(cursor);\n  }\n  _prepareChildren() {\n    super._prepareChildren();\n    this.series.each(series => {\n      this._colorize(series);\n    });\n    if (this.isDirty("wheelX") || this.isDirty("wheelY")) {\n      this._handleSetWheel();\n    }\n    if (this.isDirty("cursor")) {\n      const previous = this._prevSettings.cursor;\n      const cursor = this.get("cursor");\n      if (cursor !== previous) {\n        this._disposeProperty("cursor");\n        if (previous) {\n          previous.dispose();\n        }\n        if (cursor) {\n          cursor._setChart(this);\n          this._addCursor(cursor);\n          this._pushPropertyDisposer("cursor", cursor.events.on("selectended", () => {\n            this._handleCursorSelectEnd();\n          }));\n        }\n        //this.setRaw("cursor", cursor) // to reset previous value\n        this._prevSettings.cursor = cursor;\n      }\n    }\n    if (this.isDirty("scrollbarX")) {\n      const previous = this._prevSettings.scrollbarX;\n      const scrollbarX = this.get("scrollbarX");\n      if (scrollbarX !== previous) {\n        this._disposeProperty("scrollbarX");\n        if (previous) {\n          previous.dispose();\n        }\n        if (scrollbarX) {\n          if (!scrollbarX.parent) {\n            this.topAxesContainer.children.push(scrollbarX);\n          }\n          this._pushPropertyDisposer("scrollbarX", scrollbarX.events.on("rangechanged", e => {\n            this._handleScrollbar(this.xAxes, e.start, e.end, e.grip);\n          }));\n          this._pushPropertyDisposer("scrollbarX", scrollbarX.events.on("released", () => {\n            this.xAxes.each(axis => {\n              if (axis.get("zoomable")) {\n                this._handleAxisSelection(axis);\n              }\n            });\n          }));\n          // Used to populate `ariaLabel` with meaningful values\n          scrollbarX.setPrivate("positionTextFunction", position => {\n            const axis = this.xAxes.getIndex(0);\n            return axis ? axis.getTooltipText(position, false) || "" : "";\n          });\n        }\n        this._prevSettings.scrollbarX = scrollbarX;\n      }\n    }\n    if (this.isDirty("scrollbarY")) {\n      const previous = this._prevSettings.scrollbarY;\n      const scrollbarY = this.get("scrollbarY");\n      if (scrollbarY !== previous) {\n        this._disposeProperty("scrollbarY");\n        if (previous) {\n          previous.dispose();\n        }\n        if (scrollbarY) {\n          if (!scrollbarY.parent) {\n            this.rightAxesContainer.children.push(scrollbarY);\n          }\n          this._pushPropertyDisposer("scrollbarY", scrollbarY.events.on("rangechanged", e => {\n            this._handleScrollbar(this.yAxes, e.start, e.end, e.grip);\n          }));\n          this._pushPropertyDisposer("scrollbarY", scrollbarY.events.on("released", () => {\n            this.yAxes.each(axis => {\n              if (axis.get("zoomable")) {\n                this._handleAxisSelection(axis);\n              }\n            });\n          }));\n          // Used to populate `ariaLabel` with meaningful values\n          scrollbarY.setPrivate("positionTextFunction", position => {\n            const axis = this.yAxes.getIndex(0);\n            return axis ? axis.getTooltipText(position, false) || "" : "";\n          });\n        }\n        this._prevSettings.scrollbarY = scrollbarY;\n      }\n    }\n    this._handleZoomOut();\n  }\n  _processSeries(series) {\n    super._processSeries(series);\n    const xAxis = series.get("xAxis");\n    const yAxis = series.get("yAxis");\n    move(xAxis.series, series);\n    move(yAxis.series, series);\n    series._posXDp = series.addDisposer(xAxis.events.on("positionchanged", () => {\n      series._fixPosition();\n    }));\n    series._posXDp = series.addDisposer(yAxis.events.on("positionchanged", () => {\n      series._fixPosition();\n    }));\n    if (!series.get("baseAxis")) {\n      if (yAxis.isType("CategoryAxis") || yAxis.isType("DateAxis")) {\n        series.set("baseAxis", yAxis);\n      } else {\n        series.set("baseAxis", xAxis);\n      }\n    }\n    if (series.get("stacked")) {\n      series._markDirtyKey("stacked");\n      each(series.dataItems, dataItem => {\n        dataItem.set("stackToItemY", undefined);\n        dataItem.set("stackToItemX", undefined);\n      });\n    }\n    series._markDirtyAxes();\n    yAxis.markDirtyExtremes();\n    xAxis.markDirtyExtremes();\n    xAxis._seriesAdded = true;\n    yAxis._seriesAdded = true;\n    this._colorize(series);\n  }\n  _colorize(series) {\n    const colorSet = this.get("colors");\n    if (colorSet) {\n      if (series.get("fill") == null) {\n        const color = colorSet.next();\n        series._setSoft("stroke", color);\n        series._setSoft("fill", color);\n      }\n    }\n  }\n  _handleCursorSelectEnd() {\n    const cursor = this.get("cursor");\n    const behavior = cursor.get("behavior");\n    const downPositionX = cursor.getPrivate("downPositionX", 0);\n    const downPositionY = cursor.getPrivate("downPositionY", 0);\n    const positionX = Math.min(1, Math.max(0, cursor.getPrivate("positionX", 0.5)));\n    const positionY = Math.min(1, Math.max(0, cursor.getPrivate("positionY", 0.5)));\n    this.xAxes.each(axis => {\n      if (behavior === "zoomX" || behavior === "zoomXY") {\n        let position0 = axis.toAxisPosition(downPositionX);\n        let position1 = axis.toAxisPosition(positionX);\n        axis.zoom(position0, position1);\n      }\n      axis.setPrivate("updateScrollbar", true);\n    });\n    this.yAxes.each(axis => {\n      if (behavior === "zoomY" || behavior === "zoomXY") {\n        let position0 = axis.toAxisPosition(downPositionY);\n        let position1 = axis.toAxisPosition(positionY);\n        axis.zoom(position0, position1);\n      }\n      axis.setPrivate("updateScrollbar", true);\n    });\n  }\n  _handleScrollbar(axes, start, end, priority) {\n    axes.each(axis => {\n      let axisStart = axis.fixPosition(start);\n      let axisEnd = axis.fixPosition(end);\n      let zoomAnimation = axis.zoom(axisStart, axisEnd, undefined, priority);\n      const updateScrollbar = "updateScrollbar";\n      axis.setPrivateRaw(updateScrollbar, false);\n      if (zoomAnimation) {\n        zoomAnimation.events.on("stopped", () => {\n          axis.setPrivateRaw(updateScrollbar, true);\n        });\n      } else {\n        axis.setPrivateRaw(updateScrollbar, true);\n      }\n    });\n  }\n  _processAxis(axes, container) {\n    return axes.events.onAll(change => {\n      if (change.type === "clear") {\n        each(change.oldValues, axis => {\n          this._removeAxis(axis);\n        });\n      } else if (change.type === "push") {\n        container.children.push(change.newValue);\n        change.newValue.processChart(this);\n      } else if (change.type === "setIndex") {\n        container.children.setIndex(change.index, change.newValue);\n        change.newValue.processChart(this);\n      } else if (change.type === "insertIndex") {\n        container.children.insertIndex(change.index, change.newValue);\n        change.newValue.processChart(this);\n      } else if (change.type === "removeIndex") {\n        this._removeAxis(change.oldValue);\n      } else if (change.type === "moveIndex") {\n        container.children.moveValue(change.value, change.newIndex);\n        change.value.processChart(this);\n      } else {\n        throw new Error("Unknown IListEvent type");\n      }\n    });\n  }\n  _removeAxis(axis) {\n    if (!axis.isDisposed()) {\n      const axisParent = axis.parent;\n      if (axisParent) {\n        axisParent.children.removeValue(axis);\n      }\n      const gridContainer = axis.gridContainer;\n      const gridParent = gridContainer.parent;\n      if (gridParent) {\n        gridParent.children.removeValue(gridContainer);\n      }\n      const topGridContainer = axis.topGridContainer;\n      const topGridParent = topGridContainer.parent;\n      if (topGridParent) {\n        topGridParent.children.removeValue(topGridContainer);\n      }\n    }\n  }\n  _updateChartLayout() {\n    const left = this.leftAxesContainer.width();\n    const right = this.rightAxesContainer.width();\n    const bottomAxesContainer = this.bottomAxesContainer;\n    bottomAxesContainer.set("paddingLeft", left);\n    bottomAxesContainer.set("paddingRight", right);\n    const topAxesContainer = this.topAxesContainer;\n    topAxesContainer.set("paddingLeft", left);\n    topAxesContainer.set("paddingRight", right);\n  }\n  /**\r\n   * @ignore\r\n   */\n  processAxis(axis) {\n    var cursor = this.get("cursor");\n    if (cursor) {\n      this.addDisposer(axis.on("start", () => {\n        this._updateCursor();\n      }));\n      this.addDisposer(axis.on("end", () => {\n        this._updateCursor();\n      }));\n    }\n  }\n  _handleAxisSelection(axis, force) {\n    let start = axis.fixPosition(axis.get("start", 0));\n    let end = axis.fixPosition(axis.get("end", 1));\n    if (start > end) {\n      [start, end] = [end, start];\n    }\n    if (this.xAxes.indexOf(axis) != -1) {\n      if (force || axis.getPrivate("updateScrollbar")) {\n        let scrollbarX = this.get("scrollbarX");\n        if (scrollbarX && (!scrollbarX.getPrivate("isBusy") || force)) {\n          scrollbarX.setRaw("start", start);\n          scrollbarX.setRaw("end", end);\n          scrollbarX.updateGrips();\n        }\n      }\n    } else if (this.yAxes.indexOf(axis) != -1) {\n      if (force || axis.getPrivate("updateScrollbar")) {\n        let scrollbarY = this.get("scrollbarY");\n        if (scrollbarY && (!scrollbarY.getPrivate("isBusy") || force)) {\n          scrollbarY.setRaw("start", start);\n          scrollbarY.setRaw("end", end);\n          scrollbarY.updateGrips();\n        }\n      }\n    }\n    this._handleZoomOut();\n  }\n  _handleZoomOut() {\n    let zoomOutButton = this.zoomOutButton;\n    if (zoomOutButton && zoomOutButton.parent) {\n      let visible = false;\n      this.xAxes.each(axis => {\n        if (axis.get("start") != 0 || axis.get("end") != 1) {\n          visible = true;\n        }\n      });\n      this.yAxes.each(axis => {\n        if (axis.get("start") != 0 || axis.get("end") != 1) {\n          visible = true;\n        }\n      });\n      if (visible) {\n        if (zoomOutButton.isHidden()) {\n          zoomOutButton.show();\n        }\n      } else {\n        zoomOutButton.hide();\n      }\n    }\n  }\n  /**\r\n   * Checks if point is within plot area.\r\n   *\r\n   * @param   point  Reference point\r\n   * @return         Is within plot area?\r\n   */\n  inPlot(point) {\n    const plotContainer = this.plotContainer;\n    const otherCharts = this.getPrivate("otherCharts", this._otherCharts);\n    const global = plotContainer.toGlobal(point);\n    if (point.x >= -0.5 && point.y >= -0.5 && point.x <= plotContainer.width() + 0.5 && point.y <= plotContainer.height() + 0.5) {\n      return true;\n    }\n    if (otherCharts) {\n      for (let i = otherCharts.length - 1; i >= 0; i--) {\n        const chart = otherCharts[i];\n        if (chart != this) {\n          const chartPlotContainer = chart.plotContainer;\n          const documentPoint = this._root.rootPointToDocument(global);\n          const chartRoot = chart._root.documentPointToRoot(documentPoint);\n          const local = chartPlotContainer.toLocal(chartRoot);\n          if (local.x >= -0.1 && local.y >= -0.1 && local.x <= chartPlotContainer.width() + 0.1 && local.y <= chartPlotContainer.height() + 0.1) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  /**\r\n   * @ignore\r\n   */\n  arrangeTooltips() {\n    const plotContainer = this.plotContainer;\n    const w = plotContainer.width();\n    const h = plotContainer.height();\n    const hh = this.height();\n    let plotT = plotContainer._display.toGlobal({\n      x: 0,\n      y: 0\n    });\n    let plotB = plotContainer._display.toGlobal({\n      x: w,\n      y: h\n    });\n    const tooltips = [];\n    let sum = 0;\n    let minDistance = Infinity;\n    let movePoint = this._movePoint;\n    let maxTooltipDistance = this.get("maxTooltipDistance");\n    let maxTooltipDistanceBy = this.get("maxTooltipDistanceBy", "xy");\n    let closest;\n    let closestPoint;\n    if (Type_isNumber(maxTooltipDistance)) {\n      this.series.each(series => {\n        if (!series.isHidden()) {\n          const tooltip = series.get("tooltip");\n          if (tooltip) {\n            let point = tooltip.get("pointTo");\n            if (point) {\n              let distance = Math.hypot(movePoint.x - point.x, movePoint.y - point.y);\n              if (maxTooltipDistanceBy == "x") {\n                distance = Math.abs(movePoint.x - point.x);\n              } else if (maxTooltipDistanceBy == "y") {\n                distance = Math.abs(movePoint.y - point.y);\n              }\n              if (distance < minDistance) {\n                minDistance = distance;\n                closest = series;\n                closestPoint = point;\n              }\n            }\n          }\n        }\n      });\n    }\n    const tooltipSeries = [];\n    this.series.each(series => {\n      const tooltip = series.get("tooltip");\n      if (tooltip && !tooltip.get("forceHidden")) {\n        let hidden = false;\n        let point = tooltip.get("pointTo");\n        if (point) {\n          if (maxTooltipDistance >= 0) {\n            let point = tooltip.get("pointTo");\n            if (point && closestPoint) {\n              if (series != closest) {\n                let distance = Math.hypot(closestPoint.x - point.x, closestPoint.y - point.y);\n                if (maxTooltipDistanceBy == "x") {\n                  distance = Math.abs(closestPoint.x - point.x);\n                } else if (maxTooltipDistanceBy == "y") {\n                  distance = Math.abs(closestPoint.y - point.y);\n                }\n                if (distance > maxTooltipDistance) {\n                  hidden = true;\n                }\n              }\n            }\n          } else if (maxTooltipDistance == -1) {\n            if (series != closest) {\n              hidden = true;\n            }\n          }\n          if (!this.inPlot(this._tooltipToLocal(point)) || !tooltip.dataItem) {\n            hidden = true;\n          } else {\n            if (!hidden) {\n              sum += point.y;\n            }\n          }\n          if (hidden || series.isHidden() || series.isHiding()) {\n            tooltip.hide(0);\n          } else {\n            tooltip.show();\n            tooltips.push(tooltip);\n            tooltipSeries.push(series);\n          }\n        }\n      }\n    });\n    this.setPrivate("tooltipSeries", tooltipSeries);\n    if (this.get("arrangeTooltips")) {\n      const tooltipContainer = this._root.tooltipContainer;\n      const count = tooltips.length;\n      const average = sum / count;\n      if (average > h / 2 + plotT.y) {\n        tooltips.sort((a, b) => compareNumber(b.get("pointTo").y, a.get("pointTo").y));\n        let prevY = plotB.y;\n        each(tooltips, tooltip => {\n          let height = tooltip.height();\n          let centerY = tooltip.get("centerY");\n          if (centerY instanceof Percent) {\n            height *= centerY.value;\n          }\n          height += tooltip.get("marginBottom", 0);\n          tooltip.set("bounds", {\n            left: plotT.x,\n            top: plotT.y,\n            right: plotB.x,\n            bottom: prevY\n          });\n          tooltip.setPrivate("customData", {\n            left: plotT.x,\n            top: plotT.y,\n            right: plotB.x,\n            bottom: prevY\n          });\n          prevY = Math.min(prevY - height, tooltip._fy - height);\n          if (tooltip.parent == tooltipContainer) {\n            tooltipContainer.children.moveValue(tooltip, 0);\n          }\n        });\n        if (prevY < 0) {\n          tooltips.reverse();\n          let prevBottom = prevY;\n          each(tooltips, tooltip => {\n            let bounds = tooltip.get("bounds");\n            if (bounds) {\n              let top = bounds.top - prevY;\n              let bottom = bounds.bottom - prevY;\n              if (top < prevBottom) {\n                top = prevBottom;\n                bottom = top + tooltip.height();\n              }\n              tooltip.set("bounds", {\n                left: bounds.left,\n                top: top,\n                right: bounds.right,\n                bottom: bottom\n              });\n              prevBottom = bounds.bottom - prevY + tooltip.get("marginBottom", 0);\n            }\n          });\n        }\n      } else {\n        tooltips.reverse();\n        tooltips.sort((a, b) => compareNumber(a.get("pointTo").y, b.get("pointTo").y));\n        let prevY = 0;\n        each(tooltips, tooltip => {\n          let height = tooltip.height();\n          let centerY = tooltip.get("centerY");\n          if (centerY instanceof Percent) {\n            height *= centerY.value;\n          }\n          height += tooltip.get("marginBottom", 0);\n          tooltip.set("bounds", {\n            left: plotT.x,\n            top: prevY,\n            right: plotB.x,\n            bottom: Math.max(plotT.y + hh, prevY + height)\n          });\n          if (tooltip.parent == tooltipContainer) {\n            tooltipContainer.children.moveValue(tooltip, 0);\n          }\n          prevY = Math.max(prevY + height, tooltip._fy + height);\n        });\n        if (prevY > hh) {\n          tooltips.reverse();\n          let prevBottom = hh;\n          each(tooltips, tooltip => {\n            let bounds = tooltip.get("bounds");\n            if (bounds) {\n              let top = bounds.top - (hh - prevY);\n              let bottom = bounds.bottom - (hh - prevY);\n              if (bottom > prevBottom) {\n                bottom = prevBottom;\n                top = bottom - tooltip.height();\n              }\n              tooltip.set("bounds", {\n                left: bounds.left,\n                top: top,\n                right: bounds.right,\n                bottom: bottom\n              });\n              prevBottom = bottom - tooltip.height() - tooltip.get("marginBottom", 0);\n            }\n          });\n        }\n      }\n    }\n  }\n  _tooltipToLocal(point) {\n    return this.plotContainer.toLocal(point);\n  }\n  /**\r\n   * Fully zooms out the chart.\r\n   */\n  zoomOut() {\n    this.xAxes.each(axis => {\n      axis.setPrivate("updateScrollbar", true);\n      axis.zoom(0, 1);\n    });\n    this.yAxes.each(axis => {\n      axis.setPrivate("updateScrollbar", true);\n      axis.zoom(0, 1);\n    });\n  }\n}\nObject.defineProperty(XYChart, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "XYChart"\n});\nObject.defineProperty(XYChart, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: SerialChart.classNames.concat([XYChart.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/util/Draw.js\n/** @ignore */ /** */\n\n/**\r\n * @ignore\r\n */\nfunction segmentedLine(display, segments) {\n  for (let s = 0, len = segments.length; s < len; s++) {\n    const groups = segments[s];\n    if (groups.length > 0) {\n      let firstGroup = groups[0];\n      if (firstGroup.length > 0) {\n        let firstPoint = firstGroup[0];\n        display.moveTo(firstPoint.x, firstPoint.y);\n        for (let g = 0, len = groups.length; g < len; g++) {\n          line(display, groups[g]);\n        }\n      }\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction line(display, points) {\n  for (let p = 0, len = points.length; p < len; p++) {\n    const point = points[p];\n    display.lineTo(point.x, point.y);\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction moveTo(display, point) {\n  display.moveTo(point.x, point.y);\n}\n/**\r\n * @ignore\r\n */\nfunction Draw_clear(display) {\n  display.clear();\n}\n/**\r\n * @ignore\r\n */\nfunction smoothedSegmentedline(display, segments, tensionX, tensionY) {\n  for (let s = 0, len = segments.length; s < len; s++) {\n    const groups = segments[s];\n    if (groups.length > 0) {\n      let firstGroup = groups[0];\n      if (firstGroup.length > 0) {\n        let firstPoint = firstGroup[0];\n        display.moveTo(firstPoint.x, firstPoint.y);\n        for (let g = 0, len = groups.length; g < len; g++) {\n          const points = groups[g];\n          if (points.length > 0) {\n            display.lineTo(points[0].x, points[0].y);\n          }\n          smoothedLine(display, points, tensionX, tensionY);\n        }\n      }\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction smoothedLine(display, points, tensionX, tensionY) {\n  for (let i = points.length - 1; i > 0; i--) {\n    let p0 = points[i];\n    let p1 = points[i - 1];\n    if (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {\n      points.splice(i - 1, 1);\n    }\n  }\n  if (points.length < 3 || tensionX >= 1 && tensionY >= 1) {\n    line(display, points);\n    return;\n  }\n  tensionX = 1 - tensionX + 0.00001;\n  tensionY = 1 - tensionY + 0.00001;\n  let first = points[0];\n  let last = points[points.length - 1];\n  let closed = false;\n  if ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\n    closed = true;\n  }\n  // Can\'t moveTo here, as it wont be possible to have fill then.\n  let path = "";\n  for (let i = 0, len = points.length - 1; i < len; i++) {\n    let p0 = points[i - 1];\n    let p1 = points[i];\n    let p2 = points[i + 1];\n    let p3 = points[i + 2];\n    if (i === 0) {\n      if (closed) {\n        p0 = points[len - 2];\n      } else {\n        p0 = points[0];\n      }\n    } else if (i == len - 1) {\n      if (closed) {\n        p3 = points[1];\n      } else {\n        p3 = p2;\n      }\n    }\n    let controlPointA = $math.getCubicControlPointA(p0, p1, p2, tensionX, tensionY);\n    let controlPointB = $math.getCubicControlPointB(p1, p2, p3, tensionX, tensionY);\n    display.bezierCurveTo(controlPointA.x, controlPointA.y, controlPointB.x, controlPointB.y, p2.x, p2.y);\n  }\n  return path;\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Line.js\n\n\n/**\r\n * Draws a line.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info\r\n * @important\r\n */\nclass Line extends Graphics {\n  _beforeChanged() {\n    super._beforeChanged();\n    if (this.isDirty("points") || this.isDirty("segments") || this._sizeDirty || this.isPrivateDirty("width") || this.isPrivateDirty("height")) {\n      this._clear = true;\n    }\n  }\n  _changed() {\n    super._changed();\n    if (this._clear) {\n      const points = this.get("points");\n      const segments = this.get("segments");\n      if (points && points.length > 0) {\n        let point = points[0];\n        this._display.moveTo(point.x, point.y);\n        segmentedLine(this._display, [[points]]);\n      } else if (segments) {\n        segmentedLine(this._display, segments);\n      } else if (!this.get("draw")) {\n        let w = this.width();\n        let h = this.height();\n        this._display.moveTo(0, 0);\n        this._display.lineTo(w, h);\n      }\n    }\n  }\n}\nObject.defineProperty(Line, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Line"\n});\nObject.defineProperty(Line, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Graphics.classNames.concat([Line.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Tick.js\n\n/**\r\n * Draws a tick element (mostly used on axes).\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info\r\n */\nclass Tick extends Line {}\nObject.defineProperty(Tick, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Tick"\n});\nObject.defineProperty(Tick, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Line.classNames.concat([Tick.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisTick.js\n\n/**\r\n * Draws an axis tick.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Ticks} for more info\r\n * @important\r\n */\nclass AxisTick extends Tick {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_tickPoints", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n  }\n}\nObject.defineProperty(AxisTick, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "AxisTick"\n});\nObject.defineProperty(AxisTick, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Tick.classNames.concat([AxisTick.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Grid.js\n\n/**\r\n * Creates an axis grid line.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Grid} for more info\r\n * @important\r\n */\nclass Grid extends Graphics {\n  _beforeChanged() {\n    super._beforeChanged();\n    if (this.isPrivateDirty("width") || this.isPrivateDirty("height")) {\n      this._clear = true;\n    }\n  }\n}\nObject.defineProperty(Grid, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Grid"\n});\nObject.defineProperty(Grid, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Graphics.classNames.concat([Grid.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisLabel.js\n\n/**\r\n * Draws an axis label.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Labels} for more info\r\n * @important\r\n */\nclass AxisLabel extends Label {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_tickPoints", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n  }\n}\nObject.defineProperty(AxisLabel, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "AxisLabel"\n});\nObject.defineProperty(AxisLabel, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Label.classNames.concat([AxisLabel.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRenderer.js\n\n\n\n\n\n\n\n/**\r\n * Base class for an axis renderer.\r\n *\r\n * Should not be used on its own.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Axis_renderer} for more info\r\n */\nclass AxisRenderer extends Graphics {\n  constructor() {\n    super(...arguments);\n    // save for quick access\n    Object.defineProperty(this, "_axisLength", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 100\n    });\n    Object.defineProperty(this, "_start", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_end", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, "_inversed", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_minSize", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    /**\r\n     * Chart the renderer is used in.\r\n     */\n    Object.defineProperty(this, "chart", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_lc", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, "_ls", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_thumbDownPoint", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_downStart", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_downEnd", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * A list of ticks in the axis.\r\n     *\r\n     * `ticks.template` can be used to configure ticks.\r\n     *\r\n     * @default new ListTemplate<AxisTick>\r\n     */\n    Object.defineProperty(this, "ticks", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListTemplate(Template.new({}), () => AxisTick._new(this._root, {\n        themeTags: mergeTags(this.ticks.template.get("themeTags", []), this.get("themeTags", []))\n      }, [this.ticks.template]))\n    });\n    /**\r\n     * A list of grid elements in the axis.\r\n     *\r\n     * `grid.template` can be used to configure grid.\r\n     *\r\n     * @default new ListTemplate<Grid>\r\n     */\n    Object.defineProperty(this, "grid", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListTemplate(Template.new({}), () => Grid._new(this._root, {\n        themeTags: mergeTags(this.grid.template.get("themeTags", []), this.get("themeTags", []))\n      }, [this.grid.template]))\n    });\n    /**\r\n     * A list of fills in the axis.\r\n     *\r\n     * `axisFills.template` can be used to configure axis fills.\r\n     *\r\n     * @default new ListTemplate<Graphics>\r\n     */\n    Object.defineProperty(this, "axisFills", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListTemplate(Template.new({}), () => Graphics._new(this._root, {\n        themeTags: mergeTags(this.axisFills.template.get("themeTags", ["axis", "fill"]), this.get("themeTags", []))\n      }, [this.axisFills.template]))\n    });\n    /**\r\n     * A list of labels in the axis.\r\n     *\r\n     * `labels.template` can be used to configure axis labels.\r\n     *\r\n     * @default new ListTemplate<AxisLabel>\r\n     */\n    Object.defineProperty(this, "labels", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListTemplate(Template.new({}), () => AxisLabel._new(this._root, {\n        themeTags: mergeTags(this.labels.template.get("themeTags", []), this.get("themeTags", []))\n      }, [this.labels.template]))\n    });\n    /**\r\n     * An [[Axis]] renderer is for.\r\n     */\n    Object.defineProperty(this, "axis", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "thumb", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  makeTick(dataItem, themeTags) {\n    const tick = this.ticks.make();\n    tick._setDataItem(dataItem);\n    dataItem.setRaw("tick", tick);\n    tick.set("themeTags", mergeTags(tick.get("themeTags"), themeTags));\n    this.axis.labelsContainer.children.push(tick);\n    this.ticks.push(tick);\n    return tick;\n  }\n  /**\r\n   * @ignore\r\n   */\n  makeGrid(dataItem, themeTags) {\n    const grid = this.grid.make();\n    grid._setDataItem(dataItem);\n    dataItem.setRaw("grid", grid);\n    grid.set("themeTags", mergeTags(grid.get("themeTags"), themeTags));\n    this.axis.gridContainer.children.push(grid);\n    this.grid.push(grid);\n    return grid;\n  }\n  /**\r\n   * @ignore\r\n   */\n  makeAxisFill(dataItem, themeTags) {\n    const axisFill = this.axisFills.make();\n    axisFill._setDataItem(dataItem);\n    axisFill.set("themeTags", mergeTags(axisFill.get("themeTags"), themeTags));\n    this.axis.gridContainer.children.push(axisFill);\n    dataItem.setRaw("axisFill", axisFill);\n    this.axisFills.push(axisFill);\n    return axisFill;\n  }\n  /**\r\n   * @ignore\r\n   */\n  makeLabel(dataItem, themeTags) {\n    const label = this.labels.make();\n    label.set("themeTags", mergeTags(label.get("themeTags"), themeTags));\n    this.axis.labelsContainer.children.moveValue(label, 0);\n    label._setDataItem(dataItem);\n    dataItem.setRaw("label", label);\n    this.labels.push(label);\n    return label;\n  }\n  axisLength() {\n    return 0;\n  }\n  /**\r\n   * @ignore\r\n   */\n  gridCount() {\n    return this.axisLength() / this.get("minGridDistance", 50);\n  }\n  _updatePositions() {}\n  _afterNew() {\n    super._afterNew();\n    this.set("isMeasured", false);\n    const thumb = this.thumb;\n    if (thumb) {\n      this._disposers.push(thumb.events.on("pointerdown", event => {\n        this._handleThumbDown(event);\n      }));\n      this._disposers.push(thumb.events.on("globalpointerup", event => {\n        this._handleThumbUp(event);\n      }));\n      this._disposers.push(thumb.events.on("globalpointermove", event => {\n        this._handleThumbMove(event);\n      }));\n    }\n  }\n  _beforeChanged() {\n    super._beforeChanged();\n    if (this.isDirty("minGridDistance")) {\n      this.root.events.once("frameended", () => {\n        this.axis.markDirtySize();\n      });\n    }\n  }\n  _changed() {\n    super._changed();\n    if (this.isDirty("pan")) {\n      const thumb = this.thumb;\n      if (thumb) {\n        const labelsContainer = this.axis.labelsContainer;\n        const pan = this.get("pan");\n        if (pan == "zoom") {\n          labelsContainer.children.push(thumb);\n        } else if (pan == "none") {\n          labelsContainer.children.removeValue(thumb);\n        }\n      }\n    }\n  }\n  _handleThumbDown(event) {\n    this._thumbDownPoint = this.toLocal(event.point);\n    const axis = this.axis;\n    this._downStart = axis.get("start");\n    this._downEnd = axis.get("end");\n  }\n  _handleThumbUp(_event) {\n    this._thumbDownPoint = undefined;\n  }\n  _handleThumbMove(event) {\n    const downPoint = this._thumbDownPoint;\n    if (downPoint) {\n      const point = this.toLocal(event.point);\n      const downStart = this._downStart;\n      const downEnd = this._downEnd;\n      const extra = this._getPan(point, downPoint) * Math.min(1, downEnd - downStart) / 2;\n      this.axis.zoom(downStart - extra, downEnd + extra, 0);\n    }\n  }\n  _getPan(_point1, _point2) {\n    return 0;\n  }\n  /**\r\n   * Converts relative position (0-1) on axis to a pixel coordinate.\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @return Coordinate (px)\r\n   */\n  positionToCoordinate(position) {\n    if (this._inversed) {\n      return (this._end - position) * this._axisLength;\n    } else {\n      return (position - this._start) * this._axisLength;\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateTooltipBounds(_tooltip) {}\n  _updateSize() {\n    this.markDirty();\n    this._clear = true;\n  }\n  /**\r\n   * @ignore\r\n   */\n  toAxisPosition(position) {\n    const start = this._start || 0;\n    const end = this._end || 1;\n    position = position * (end - start);\n    if (!this.get("inversed")) {\n      position = start + position;\n    } else {\n      position = end - position;\n    }\n    return position;\n  }\n  /**\r\n   * @ignore\r\n   */\n  toGlobalPosition(position) {\n    const start = this._start || 0;\n    const end = this._end || 1;\n    if (!this.get("inversed")) {\n      position = position - start;\n    } else {\n      position = end - position;\n    }\n    position = position / (end - start);\n    return position;\n  }\n  /**\r\n   * @ignore\r\n   */\n  fixPosition(position) {\n    if (this.get("inversed")) {\n      return 1 - position;\n    }\n    return position;\n  }\n  /**\r\n   * @ignore\r\n   */\n  _updateLC() {}\n  toggleVisibility(sprite, position, minPosition, maxPosition) {\n    let axis = this.axis;\n    const start = axis.get("start", 0);\n    const end = axis.get("end", 1);\n    let updatedStart = start + (end - start) * (minPosition - 0.0001);\n    let updatedEnd = start + (end - start) * (maxPosition + 0.0001);\n    if (position < updatedStart || position > updatedEnd) {\n      sprite.setPrivate("visible", false);\n    } else {\n      sprite.setPrivate("visible", true);\n    }\n  }\n  _positionTooltip(tooltip, point) {\n    const chart = this.chart;\n    if (chart) {\n      tooltip.set("pointTo", this._display.toGlobal(point));\n      if (!chart.inPlot(point)) {\n        tooltip.hide();\n      }\n    }\n  }\n  processAxis() {}\n}\nObject.defineProperty(AxisRenderer, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "AxisRenderer"\n});\nObject.defineProperty(AxisRenderer, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Graphics.classNames.concat([AxisRenderer.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererX.js\n\n\n\n\n\n/**\r\n * Used to render horizontal axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Axis_renderer} for more info\r\n * @important\r\n */\nclass AxisRendererX extends AxisRenderer {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "thumb", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: Rectangle.new(this._root, {\n        width: p100,\n        isMeasured: false,\n        themeTags: ["axis", "x", "thumb"]\n      })\n    });\n  }\n  _afterNew() {\n    this._settings.themeTags = mergeTags(this._settings.themeTags, ["renderer", "x"]);\n    super._afterNew();\n    this.setPrivateRaw("letter", "X");\n    const gridTemplate = this.grid.template;\n    gridTemplate.set("height", p100);\n    gridTemplate.set("width", 0);\n    gridTemplate.set("draw", (display, graphics) => {\n      display.moveTo(0, 0);\n      display.lineTo(0, graphics.height());\n    });\n    this.set("draw", (display, graphics) => {\n      display.moveTo(0, 0);\n      display.lineTo(graphics.width(), 0);\n    });\n  }\n  _changed() {\n    super._changed();\n    const axis = this.axis;\n    axis.ghostLabel.setPrivate("visible", !this.get("inside"));\n    axis.ghostLabel.set("x", -1000);\n    const opposite = "opposite";\n    const inside = "inside";\n    if (this.isDirty(opposite) || this.isDirty(inside)) {\n      const chart = this.chart;\n      const axisChildren = axis.children;\n      if (this.get(inside)) {\n        axis.addTag(inside);\n      } else {\n        axis.removeTag(inside);\n      }\n      if (chart) {\n        if (this.get(opposite)) {\n          const children = chart.topAxesContainer.children;\n          if (children.indexOf(axis) == -1) {\n            children.insertIndex(0, axis);\n          }\n          axis.addTag(opposite);\n          axisChildren.moveValue(this);\n        } else {\n          const children = chart.bottomAxesContainer.children;\n          if (children.indexOf(axis) == -1) {\n            children.moveValue(axis);\n          }\n          axis.removeTag(opposite);\n          axisChildren.moveValue(this, 0);\n        }\n        axis.ghostLabel._applyThemes();\n        this.labels.each(label => {\n          label._applyThemes();\n        });\n        this.root._markDirtyRedraw();\n      }\n      axis.markDirtySize();\n    }\n    this.thumb.setPrivate("height", axis.labelsContainer.height());\n  }\n  _getPan(point1, point2) {\n    return (point2.x - point1.x) / this.width();\n  }\n  /**\r\n   * @ignore\r\n   */\n  toAxisPosition(position) {\n    const start = this._start || 0;\n    const end = this._end || 1;\n    position -= this._ls;\n    position = position * (end - start) / this._lc;\n    if (!this.get("inversed")) {\n      position = start + position;\n    } else {\n      position = end - position;\n    }\n    return position;\n  }\n  /**\r\n   * @ignore\r\n   */\n  toGlobalPosition(position) {\n    const start = this._start || 0;\n    const end = this._end || 1;\n    if (!this.get("inversed")) {\n      position = position - start;\n    } else {\n      position = end - position;\n    }\n    position = position / (end - start) * this._lc;\n    position += this._ls;\n    return position;\n  }\n  /**\r\n   * @ignore\r\n   */\n  _updateLC() {\n    const axis = this.axis;\n    const parent = axis.parent;\n    if (parent) {\n      const w = parent.innerWidth();\n      this._lc = this.axisLength() / w;\n      this._ls = (axis.x() - parent.get("paddingLeft", 0)) / w;\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  _updatePositions() {\n    const axis = this.axis;\n    const x = axis.x() - relativeToValue(axis.get("centerX", 0), axis.width()) - axis.parent.get("paddingLeft", 0);\n    axis.gridContainer.set("x", x);\n    axis.topGridContainer.set("x", x);\n    axis.bulletsContainer.set("y", this.y());\n    const chart = axis.chart;\n    if (chart) {\n      const plotContainer = chart.plotContainer;\n      const axisHeader = axis.axisHeader;\n      let width = axis.get("marginLeft", 0);\n      let x = axis.x() - width;\n      const parent = axis.parent;\n      if (parent) {\n        x -= parent.get("paddingLeft", 0);\n      }\n      if (axisHeader.children.length > 0) {\n        width = axis.axisHeader.width();\n        axis.set("marginLeft", width + 1);\n      } else {\n        axisHeader.set("width", width);\n      }\n      axisHeader.setAll({\n        x: x,\n        y: -1,\n        height: plotContainer.height() + 2\n      });\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  processAxis() {\n    super.processAxis();\n    const axis = this.axis;\n    if (axis.get("width") == null) {\n      axis.set("width", p100);\n    }\n    ;\n    const verticalLayout = this._root.verticalLayout;\n    axis.set("layout", verticalLayout);\n    axis.labelsContainer.set("width", p100);\n    axis.axisHeader.setAll({\n      layout: verticalLayout\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  axisLength() {\n    return this.axis.width();\n  }\n  /**\r\n   * Converts axis relative position to actual coordinate in pixels.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Point\r\n   */\n  positionToPoint(position) {\n    return {\n      x: this.positionToCoordinate(position),\n      y: 0\n    };\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateTick(tick, position, endPosition, count) {\n    if (tick) {\n      if (!Type_isNumber(position)) {\n        position = 0;\n      }\n      let location = 0.5;\n      if (Type_isNumber(count) && count > 1) {\n        location = tick.get("multiLocation", location);\n      } else {\n        location = tick.get("location", location);\n      }\n      if (Type_isNumber(endPosition) && endPosition != position) {\n        position = position + (endPosition - position) * location;\n      }\n      tick.set("x", this.positionToCoordinate(position));\n      let length = tick.get("length", 0);\n      const inside = tick.get("inside", this.get("inside", false));\n      if (this.get("opposite")) {\n        tick.set("y", p100);\n        if (!inside) {\n          length *= -1;\n        }\n      } else {\n        tick.set("y", 0);\n        if (inside) {\n          length *= -1;\n        }\n      }\n      tick.set("draw", display => {\n        display.moveTo(0, 0);\n        display.lineTo(0, length);\n      });\n      this.toggleVisibility(tick, position, tick.get("minPosition", 0), tick.get("maxPosition", 1));\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateLabel(label, position, endPosition, count) {\n    if (label) {\n      let location = 0.5;\n      if (Type_isNumber(count) && count > 1) {\n        location = label.get("multiLocation", location);\n      } else {\n        location = label.get("location", location);\n      }\n      if (!Type_isNumber(position)) {\n        position = 0;\n      }\n      const inside = label.get("inside", this.get("inside", false));\n      const opposite = this.get("opposite");\n      if (opposite) {\n        if (!inside) {\n          label.set("position", "relative");\n          label.set("y", p100);\n        } else {\n          label.set("position", "absolute");\n          label.set("y", 0);\n        }\n      } else {\n        if (!inside) {\n          label.set("y", undefined);\n          label.set("position", "relative");\n        } else {\n          label.set("y", 0);\n          label.set("position", "absolute");\n        }\n      }\n      if (Type_isNumber(endPosition) && endPosition != position) {\n        position = position + (endPosition - position) * location;\n      }\n      label.set("x", this.positionToCoordinate(position));\n      this.toggleVisibility(label, position, label.get("minPosition", 0), label.get("maxPosition", 1));\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateGrid(grid, position, endPosition) {\n    if (grid) {\n      if (!Type_isNumber(position)) {\n        position = 0;\n      }\n      let location = grid.get("location", 0.5);\n      if (Type_isNumber(endPosition) && endPosition != position) {\n        position = position + (endPosition - position) * location;\n      }\n      grid.set("x", this.positionToCoordinate(position));\n      this.toggleVisibility(grid, position, 0, 1);\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateBullet(bullet, position, endPosition) {\n    if (bullet) {\n      const sprite = bullet.get("sprite");\n      if (sprite) {\n        if (!Type_isNumber(position)) {\n          position = 0;\n        }\n        let location = bullet.get("location", 0.5);\n        if (Type_isNumber(endPosition) && endPosition != position) {\n          position = position + (endPosition - position) * location;\n        }\n        let bulletPosition = this.axis.roundAxisPosition(position, location);\n        let previousBullet = this.axis._bullets[bulletPosition];\n        let d = -1;\n        if (this.get("opposite")) {\n          d = 1;\n        }\n        if (bullet.get("stacked")) {\n          if (previousBullet) {\n            let previousSprite = previousBullet.get("sprite");\n            if (previousSprite) {\n              sprite.set("y", previousSprite.y() + previousSprite.height() * d);\n            }\n          } else {\n            sprite.set("y", 0);\n          }\n        }\n        this.axis._bullets[bulletPosition] = bullet;\n        sprite.set("x", this.positionToCoordinate(position));\n        this.toggleVisibility(sprite, position, 0, 1);\n      }\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateFill(fill, position, endPosition) {\n    if (fill) {\n      if (!Type_isNumber(position)) {\n        position = 0;\n      }\n      if (!Type_isNumber(endPosition)) {\n        endPosition = 1;\n      }\n      let x0 = this.positionToCoordinate(position);\n      let x1 = this.positionToCoordinate(endPosition);\n      this.fillDrawMethod(fill, x0, x1);\n    }\n  }\n  fillDrawMethod(fill, x0, x1) {\n    fill.set("draw", display => {\n      //display.drawRect(x0, 0, x1 - x0, this.axis!.gridContainer.height());\n      // using for holes, so can not be rectangle\n      const h = this.axis.gridContainer.height();\n      const w = this.width();\n      if (x1 < x0) {\n        [x1, x0] = [x0, x1];\n      }\n      if (x0 > w || x1 < 0) {\n        return;\n      }\n      /*\r\n      const limit = 10000;\r\n        x0 = Math.max(-limit, x0);\r\n      x1 = Math.min(limit, x1);\r\n      */\n      display.moveTo(x0, 0);\n      display.lineTo(x1, 0);\n      display.lineTo(x1, h);\n      display.lineTo(x0, h);\n      display.lineTo(x0, 0);\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  positionTooltip(tooltip, position) {\n    this._positionTooltip(tooltip, {\n      x: this.positionToCoordinate(position),\n      y: 0\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateTooltipBounds(tooltip) {\n    const inside = this.get("inside");\n    const num = 100000;\n    let global = this._display.toGlobal({\n      x: 0,\n      y: 0\n    });\n    let x = global.x;\n    let y = 0;\n    let w = this.axisLength();\n    let h = num;\n    let pointerOrientation = "up";\n    if (this.get("opposite")) {\n      if (inside) {\n        pointerOrientation = "up";\n        y = global.y;\n        h = num;\n      } else {\n        pointerOrientation = "down";\n        y = global.y - num;\n        h = num;\n      }\n    } else {\n      if (inside) {\n        pointerOrientation = "down";\n        y = global.y - num;\n        h = num;\n      } else {\n        pointerOrientation = "up";\n        y = global.y;\n        h = num;\n      }\n    }\n    const bounds = {\n      left: x,\n      right: x + w,\n      top: y,\n      bottom: y + h\n    };\n    const oldBounds = tooltip.get("bounds");\n    if (!sameBounds(bounds, oldBounds)) {\n      tooltip.set("bounds", bounds);\n      tooltip.set("pointerOrientation", pointerOrientation);\n    }\n  }\n}\nObject.defineProperty(AxisRendererX, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "AxisRendererX"\n});\nObject.defineProperty(AxisRendererX, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: AxisRenderer.classNames.concat([AxisRendererX.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Axis.js\n\n\n\n\n\n\n\n\n\n/**\r\n * A base class for all axes.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Adding_axes} for more info\r\n */\nclass Axis extends Component {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_series", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "_isPanning", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    /**\r\n     * Array of minor data items.\r\n     */\n    Object.defineProperty(this, "minorDataItems", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    /**\r\n     * A [[Container]] that holds all the axis label elements.\r\n     *\r\n     * @default Container.new()\r\n     */\n    Object.defineProperty(this, "labelsContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.children.push(Container.new(this._root, {}))\n    });\n    /**\r\n     * A [[Container]] that holds all the axis grid and fill elements.\r\n     *\r\n     * @default Container.new()\r\n     */\n    Object.defineProperty(this, "gridContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: Container.new(this._root, {\n        width: p100,\n        height: p100\n      })\n    });\n    /**\r\n     * A [[Container]] that holds axis grid elements which goes above the series.\r\n     *\r\n     * @default Container.new()\r\n     */\n    Object.defineProperty(this, "topGridContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: Container.new(this._root, {\n        width: p100,\n        height: p100\n      })\n    });\n    /**\r\n     * A [[Container]] that holds all the axis bullet elements.\r\n     *\r\n     * @default new Container\r\n     */\n    Object.defineProperty(this, "bulletsContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.children.push(Container.new(this._root, {\n        isMeasured: false,\n        width: p100,\n        height: p100,\n        position: "absolute"\n      }))\n    });\n    /**\r\n     * A referenece to the the chart the axis belongs to.\r\n     */\n    Object.defineProperty(this, "chart", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_rangesDirty", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_panStart", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_panEnd", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, "_sAnimation", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_eAnimation", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_skipSync", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    /**\r\n     * A list of axis ranges.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info\r\n     * @default new List()\r\n     */\n    Object.defineProperty(this, "axisRanges", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new List()\n    });\n    Object.defineProperty(this, "_seriesAxisRanges", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    /**\r\n     * A control label that is invisible but is used to keep width the width of\r\n     * the axis constant.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Ghost_label} for more info\r\n     */\n    Object.defineProperty(this, "ghostLabel", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_cursorPosition", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: -1\n    });\n    Object.defineProperty(this, "_snapToSeries", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_seriesValuesDirty", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_seriesAdded", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    /**\r\n     * A container above the axis that can be used to add additional stuff into\r\n     * it. For example a legend, label, or an icon.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-headers/} for more info\r\n     * @default new Container\r\n     */\n    Object.defineProperty(this, "axisHeader", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.children.push(Container.new(this._root, {\n        themeTags: ["axis", "header"],\n        position: "absolute",\n        background: Rectangle.new(this._root, {\n          themeTags: ["header", "background"],\n          fill: this._root.interfaceColors.get("background")\n        })\n      }))\n    });\n    Object.defineProperty(this, "_bullets", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n  }\n  _dispose() {\n    // these could be in other parents, so disposing just in case\n    this.gridContainer.dispose();\n    this.topGridContainer.dispose();\n    this.bulletsContainer.dispose();\n    this.labelsContainer.dispose();\n    this.axisHeader.dispose();\n    super._dispose();\n  }\n  _afterNew() {\n    super._afterNew();\n    this.setPrivate("updateScrollbar", true);\n    this._disposers.push(this.axisRanges.events.onAll(change => {\n      if (change.type === "clear") {\n        each(change.oldValues, dataItem => {\n          this.disposeDataItem(dataItem);\n        });\n      } else if (change.type === "push") {\n        this._processAxisRange(change.newValue, ["range"]);\n      } else if (change.type === "setIndex") {\n        this._processAxisRange(change.newValue, ["range"]);\n      } else if (change.type === "insertIndex") {\n        this._processAxisRange(change.newValue, ["range"]);\n      } else if (change.type === "removeIndex") {\n        this.disposeDataItem(change.oldValue);\n      } else if (change.type === "moveIndex") {\n        this._processAxisRange(change.value, ["range"]);\n      } else {\n        throw new Error("Unknown IStreamEvent type");\n      }\n    }));\n    const renderer = this.get("renderer");\n    if (renderer) {\n      renderer.axis = this;\n      renderer.processAxis();\n    }\n    this.children.push(renderer);\n    this.ghostLabel = renderer.makeLabel(new DataItem(this, undefined, {}), []);\n    this.ghostLabel.adapters.disable("text");\n    this.ghostLabel.setAll({\n      opacity: 0,\n      tooltipText: undefined,\n      tooltipHTML: undefined,\n      interactive: false\n    });\n    this.ghostLabel.events.disable();\n  }\n  _updateFinals(_start, _end) {}\n  /**\r\n   * Zooms the axis to relative locations.\r\n   *\r\n   * Both `start` and `end` are relative: 0 means start of the axis, 1 - end.\r\n   *\r\n   * @param   start     Relative start\r\n   * @param   end       Relative end\r\n   * @param   duration  Duration of the zoom animation in milliseconds\r\n   * @return            Zoom animation\r\n   */\n  zoom(start, end, duration, priority) {\n    if (this.get("zoomable", true)) {\n      this._updateFinals(start, end);\n      if (this.get("start") !== start || this.get("end") != end) {\n        let sAnimation = this._sAnimation;\n        let eAnimation = this._eAnimation;\n        let maxDeviation = this.get("maxDeviation", 0.5) * Math.min(1, end - start);\n        if (start < -maxDeviation) {\n          start = -maxDeviation;\n        }\n        if (end > 1 + maxDeviation) {\n          end = 1 + maxDeviation;\n        }\n        if (start > end) {\n          [start, end] = [end, start];\n        }\n        if (!Type_isNumber(duration)) {\n          duration = this.get("interpolationDuration", 0);\n        }\n        if (!priority) {\n          priority = "end";\n        }\n        let maxZoomFactor = this.getPrivate("maxZoomFactor", this.get("maxZoomFactor", 100));\n        let maxZoomFactorReal = maxZoomFactor;\n        if (end === 1 && start !== 0) {\n          if (start < this.get("start", 0)) {\n            priority = "start";\n          } else {\n            priority = "end";\n          }\n        }\n        if (start === 0 && end !== 1) {\n          if (end > this.get("end", 1)) {\n            priority = "end";\n          } else {\n            priority = "start";\n          }\n        }\n        let minZoomCount = this.get("minZoomCount", 0);\n        let maxZoomCount = this.get("maxZoomCount", Infinity);\n        if (Type_isNumber(minZoomCount)) {\n          maxZoomFactor = maxZoomFactorReal / minZoomCount;\n        }\n        let minZoomFactor = 1;\n        if (Type_isNumber(maxZoomCount)) {\n          minZoomFactor = maxZoomFactorReal / maxZoomCount;\n        }\n        // most likely we are dragging left scrollbar grip here, so we tend to modify end\n        if (priority === "start") {\n          if (maxZoomCount > 0) {\n            // add to the end\n            if (1 / (end - start) < minZoomFactor) {\n              end = start + 1 / minZoomFactor;\n            }\n          }\n          // add to the end\n          if (1 / (end - start) > maxZoomFactor) {\n            end = start + 1 / maxZoomFactor;\n          }\n          //unless end is > 0\n          if (end > 1 && end - start < 1 / maxZoomFactor) {\n            //end = 1;\n            start = end - 1 / maxZoomFactor;\n          }\n        }\n        // most likely we are dragging right, so we modify left\n        else {\n          if (maxZoomCount > 0) {\n            // add to the end\n            if (1 / (end - start) < minZoomFactor) {\n              start = end - 1 / minZoomFactor;\n            }\n          }\n          // remove from start\n          if (1 / (end - start) > maxZoomFactor) {\n            start = end - 1 / maxZoomFactor;\n          }\n          if (start < 0 && end - start < 1 / maxZoomFactor) {\n            //start = 0;\n            end = start + 1 / maxZoomFactor;\n          }\n        }\n        if (1 / (end - start) > maxZoomFactor) {\n          end = start + 1 / maxZoomFactor;\n        }\n        if (1 / (end - start) > maxZoomFactor) {\n          start = end - 1 / maxZoomFactor;\n        }\n        if (maxZoomCount != null && minZoomCount != null && start == this.get("start") && end == this.get("end")) {\n          const chart = this.chart;\n          if (chart) {\n            chart._handleAxisSelection(this, true);\n          }\n        }\n        if ((sAnimation && sAnimation.playing && sAnimation.to == start || this.get("start") == start) && (eAnimation && eAnimation.playing && eAnimation.to == end || this.get("end") == end)) {\n          return;\n        }\n        if (duration > 0) {\n          let easing = this.get("interpolationEasing");\n          let sAnimation, eAnimation;\n          if (this.get("start") != start) {\n            sAnimation = this.animate({\n              key: "start",\n              to: start,\n              duration: duration,\n              easing: easing\n            });\n          }\n          if (this.get("end") != end) {\n            eAnimation = this.animate({\n              key: "end",\n              to: end,\n              duration: duration,\n              easing: easing\n            });\n          }\n          this._sAnimation = sAnimation;\n          this._eAnimation = eAnimation;\n          if (sAnimation) {\n            return sAnimation;\n          } else if (eAnimation) {\n            return eAnimation;\n          }\n        } else {\n          this.set("start", start);\n          this.set("end", end);\n        }\n      } else {\n        if (this._sAnimation) {\n          this._sAnimation.stop();\n        }\n        if (this._eAnimation) {\n          this._eAnimation.stop();\n        }\n      }\n    }\n  }\n  /**\r\n   * A list of series using this axis.\r\n   *\r\n   * @return Series\r\n   */\n  get series() {\n    return this._series;\n  }\n  _processAxisRange(dataItem, themeTags) {\n    dataItem.setRaw("isRange", true);\n    this._createAssets(dataItem, themeTags);\n    this._rangesDirty = true;\n    this._prepareDataItem(dataItem);\n    const above = dataItem.get("above");\n    const container = this.topGridContainer;\n    const grid = dataItem.get("grid");\n    if (above && grid) {\n      container.children.moveValue(grid);\n    }\n    const fill = dataItem.get("axisFill");\n    if (above && fill) {\n      container.children.moveValue(fill);\n    }\n  }\n  _prepareDataItem(_dataItem, _index) {}\n  /**\r\n   * @ignore\r\n   */\n  markDirtyExtremes() {}\n  /**\r\n   * @ignore\r\n   */\n  markDirtySelectionExtremes() {}\n  _calculateTotals() {}\n  _updateAxisRanges() {\n    this._bullets = {};\n    this.axisRanges.each(axisRange => {\n      this._prepareDataItem(axisRange);\n    });\n    each(this._seriesAxisRanges, axisRange => {\n      this._prepareDataItem(axisRange);\n    });\n  }\n  _prepareChildren() {\n    super._prepareChildren();\n    if (this.get("fixAxisSize")) {\n      this.ghostLabel.set("visible", true);\n    } else {\n      this.ghostLabel.set("visible", false);\n    }\n    if (this.isDirty("start") || this.isDirty("end")) {\n      const chart = this.chart;\n      if (chart) {\n        chart._updateCursor();\n      }\n      let start = this.get("start", 0);\n      let end = this.get("end", 1);\n      let maxDeviation = this.get("maxDeviation", 0.5) * Math.min(1, end - start);\n      if (start < -maxDeviation) {\n        let delta = start + maxDeviation;\n        start = -maxDeviation;\n        this.setRaw("start", start);\n        if (this.isDirty("end")) {\n          this.setRaw("end", end - delta);\n        }\n      }\n      if (end > 1 + maxDeviation) {\n        let delta = end - 1 - maxDeviation;\n        end = 1 + maxDeviation;\n        this.setRaw("end", end);\n        if (this.isDirty("start")) {\n          this.setRaw("start", start - delta);\n        }\n      }\n    }\n    const renderer = this.get("renderer");\n    renderer._start = this.get("start");\n    renderer._end = this.get("end");\n    renderer._inversed = renderer.get("inversed", false);\n    renderer._axisLength = renderer.axisLength() / (renderer._end - renderer._start);\n    renderer._updateLC();\n    if (this.isDirty("tooltip")) {\n      const tooltip = this.get("tooltip");\n      if (tooltip) {\n        const rendererTags = renderer.get("themeTags");\n        tooltip.addTag("axis");\n        tooltip.addTag(this.className.toLowerCase());\n        tooltip._applyThemes();\n        if (rendererTags) {\n          tooltip.set("themeTags", mergeTags(tooltip.get("themeTags"), rendererTags));\n          tooltip.label._applyThemes();\n        }\n      }\n    }\n  }\n  _updateTooltipBounds() {\n    const tooltip = this.get("tooltip");\n    if (tooltip) {\n      this.get("renderer").updateTooltipBounds(tooltip);\n    }\n  }\n  _updateBounds() {\n    super._updateBounds();\n    this._updateTooltipBounds();\n  }\n  /**\r\n   * @ignore\r\n   */\n  processChart(chart) {\n    this.chart = chart;\n    const renderer = this.get("renderer");\n    renderer.chart = chart;\n    chart.gridContainer.children.push(this.gridContainer);\n    chart.topGridContainer.children.push(this.topGridContainer);\n    chart.axisHeadersContainer.children.push(this.axisHeader);\n    this.on("start", () => {\n      chart._handleAxisSelection(this);\n    });\n    this.on("end", () => {\n      chart._handleAxisSelection(this);\n    });\n    chart.plotContainer.onPrivate("width", () => {\n      this.markDirtySize();\n    });\n    chart.plotContainer.onPrivate("height", () => {\n      this.markDirtySize();\n    });\n    chart.processAxis(this);\n  }\n  /**\r\n   * @ignore\r\n   */\n  hideDataItem(dataItem) {\n    this._toggleFHDataItem(dataItem, true);\n    return super.hideDataItem(dataItem);\n  }\n  /**\r\n   * @ignore\r\n   */\n  showDataItem(dataItem) {\n    this._toggleFHDataItem(dataItem, false);\n    return super.showDataItem(dataItem);\n  }\n  _toggleFHDataItem(dataItem, forceHidden) {\n    const fh = "forceHidden";\n    const label = dataItem.get("label");\n    if (label) {\n      label.set(fh, forceHidden);\n    }\n    const grid = dataItem.get("grid");\n    if (grid) {\n      grid.set(fh, forceHidden);\n    }\n    const tick = dataItem.get("tick");\n    if (tick) {\n      tick.set(fh, forceHidden);\n    }\n    const axisFill = dataItem.get("axisFill");\n    if (axisFill) {\n      axisFill.set(fh, forceHidden);\n    }\n    const bullet = dataItem.get("bullet");\n    if (bullet) {\n      const sprite = bullet.get("sprite");\n      if (sprite) {\n        sprite.set(fh, forceHidden);\n      }\n    }\n  }\n  _toggleDataItem(dataItem, visible) {\n    const label = dataItem.get("label");\n    const v = "visible";\n    if (label) {\n      label.setPrivate(v, visible);\n    }\n    const grid = dataItem.get("grid");\n    if (grid) {\n      grid.setPrivate(v, visible);\n    }\n    const tick = dataItem.get("tick");\n    if (tick) {\n      tick.setPrivate(v, visible);\n    }\n    const axisFill = dataItem.get("axisFill");\n    if (axisFill) {\n      axisFill.setPrivate(v, visible);\n    }\n    const bullet = dataItem.get("bullet");\n    if (bullet) {\n      const sprite = bullet.get("sprite");\n      if (sprite) {\n        sprite.setPrivate(v, visible);\n      }\n    }\n  }\n  _createAssets(dataItem, tags, minor) {\n    var _a, _b, _c;\n    const renderer = this.get("renderer");\n    let m = "minor";\n    const label = dataItem.get("label");\n    if (!label) {\n      renderer.makeLabel(dataItem, tags);\n    } else {\n      let themeTags = label.get("themeTags");\n      let remove = false;\n      if (minor) {\n        if ((themeTags === null || themeTags === void 0 ? void 0 : themeTags.indexOf(m)) == -1) {\n          remove = true;\n        }\n      } else {\n        if ((themeTags === null || themeTags === void 0 ? void 0 : themeTags.indexOf(m)) != -1) {\n          remove = true;\n        }\n      }\n      if (remove) {\n        (_a = label.parent) === null || _a === void 0 ? void 0 : _a.children.removeValue(label);\n        renderer.makeLabel(dataItem, tags);\n        label.dispose();\n        renderer.labels.removeValue(label);\n      }\n    }\n    const grid = dataItem.get("grid");\n    if (!grid) {\n      renderer.makeGrid(dataItem, tags);\n    } else {\n      let themeTags = grid.get("themeTags");\n      let remove = false;\n      if (minor) {\n        if ((themeTags === null || themeTags === void 0 ? void 0 : themeTags.indexOf(m)) == -1) {\n          remove = true;\n        }\n      } else {\n        if ((themeTags === null || themeTags === void 0 ? void 0 : themeTags.indexOf(m)) != -1) {\n          remove = true;\n        }\n      }\n      if (remove) {\n        (_b = grid.parent) === null || _b === void 0 ? void 0 : _b.children.removeValue(grid);\n        renderer.makeGrid(dataItem, tags);\n        grid.dispose();\n        renderer.grid.removeValue(grid);\n      }\n    }\n    const tick = dataItem.get("tick");\n    if (!tick) {\n      renderer.makeTick(dataItem, tags);\n    } else {\n      let remove = false;\n      let themeTags = tick.get("themeTags");\n      if (minor) {\n        if ((themeTags === null || themeTags === void 0 ? void 0 : themeTags.indexOf(m)) == -1) {\n          remove = true;\n        }\n      } else {\n        if ((themeTags === null || themeTags === void 0 ? void 0 : themeTags.indexOf(m)) != -1) {\n          remove = true;\n        }\n      }\n      if (remove) {\n        (_c = tick.parent) === null || _c === void 0 ? void 0 : _c.children.removeValue(tick);\n        renderer.makeTick(dataItem, tags);\n        tick.dispose();\n        renderer.ticks.removeValue(tick);\n      }\n    }\n    if (!minor && !dataItem.get("axisFill")) {\n      renderer.makeAxisFill(dataItem, tags);\n    }\n    this._processBullet(dataItem);\n  }\n  _processBullet(dataItem) {\n    let bullet = dataItem.get("bullet");\n    let axisBullet = this.get("bullet");\n    if (!bullet && axisBullet && !dataItem.get("isRange")) {\n      bullet = axisBullet(this._root, this, dataItem);\n    }\n    if (bullet) {\n      bullet.axis = this;\n      const sprite = bullet.get("sprite");\n      if (sprite) {\n        sprite._setDataItem(dataItem);\n        dataItem.setRaw("bullet", bullet);\n        if (!sprite.parent) {\n          this.bulletsContainer.children.push(sprite);\n        }\n      }\n    }\n  }\n  _afterChanged() {\n    super._afterChanged();\n    const chart = this.chart;\n    if (chart) {\n      chart._updateChartLayout();\n      chart.axisHeadersContainer.markDirtySize();\n    }\n    this.get("renderer")._updatePositions();\n    this._seriesAdded = false;\n  }\n  /**\r\n   * @ignore\r\n   */\n  disposeDataItem(dataItem) {\n    super.disposeDataItem(dataItem);\n    const renderer = this.get("renderer");\n    const label = dataItem.get("label");\n    if (label) {\n      renderer.labels.removeValue(label);\n      label.dispose();\n    }\n    const tick = dataItem.get("tick");\n    if (tick) {\n      renderer.ticks.removeValue(tick);\n      tick.dispose();\n    }\n    const grid = dataItem.get("grid");\n    if (grid) {\n      renderer.grid.removeValue(grid);\n      grid.dispose();\n    }\n    const axisFill = dataItem.get("axisFill");\n    if (axisFill) {\n      renderer.axisFills.removeValue(axisFill);\n      axisFill.dispose();\n    }\n    const bullet = dataItem.get("bullet");\n    if (bullet) {\n      bullet.dispose();\n    }\n  }\n  _updateGhost() {\n    this.setPrivate("cellWidth", this.getCellWidthPosition() * this.get("renderer").axisLength());\n    const ghostLabel = this.ghostLabel;\n    if (!ghostLabel.isHidden()) {\n      const bounds = ghostLabel.localBounds();\n      const gWidth = Math.ceil(bounds.right - bounds.left);\n      let text = ghostLabel.get("text");\n      each(this.dataItems, dataItem => {\n        const label = dataItem.get("label");\n        if (label && !label.isHidden()) {\n          const bounds = label.localBounds();\n          const w = Math.ceil(bounds.right - bounds.left);\n          if (w > gWidth) {\n            text = label.text._getText();\n          }\n        }\n      });\n      ghostLabel.set("text", text);\n    }\n    let start = this.get("start", 0);\n    let end = this.get("end", 1);\n    this.get("renderer").updateLabel(ghostLabel, start + (end - start) * 0.5);\n  }\n  _handleCursorPosition(position, snapToSeries) {\n    const renderer = this.get("renderer");\n    position = renderer.toAxisPosition(position);\n    this._cursorPosition = position;\n    this._snapToSeries = snapToSeries;\n    this.updateTooltip();\n  }\n  /**\r\n   * Can be called when axis zoom changes and you need to update tooltip\r\n   * position.\r\n   */\n  updateTooltip() {\n    const snapToSeries = this._snapToSeries;\n    let position = this._cursorPosition;\n    const tooltip = this.get("tooltip");\n    const renderer = this.get("renderer");\n    if (Type_isNumber(position)) {\n      each(this.series, series => {\n        if (series.get("baseAxis") === this) {\n          const dataItem = this.getSeriesItem(series, position, this.get("tooltipLocation"));\n          if (snapToSeries && snapToSeries.indexOf(series) != -1) {\n            series.updateLegendMarker(dataItem);\n            series.updateLegendValue(dataItem);\n            series._settings.tooltipDataItem = dataItem;\n          } else {\n            series.showDataItemTooltip(dataItem);\n            series.setRaw("tooltipDataItem", dataItem);\n          }\n        }\n      });\n      if (this.get("snapTooltip")) {\n        position = this.roundAxisPosition(position, this.get("tooltipLocation", 0.5));\n      }\n      this.setPrivateRaw("tooltipPosition", position);\n      if (tooltip) {\n        renderer.updateTooltipBounds(tooltip);\n        if (!Type_isNaN(position)) {\n          this._updateTooltipText(tooltip, position);\n          renderer.positionTooltip(tooltip, position);\n          if (position < this.get("start", 0) || position > this.get("end", 1)) {\n            tooltip.hide(0);\n          } else {\n            tooltip.show(0);\n          }\n        } else {\n          tooltip.hide(0);\n        }\n      }\n    }\n  }\n  _updateTooltipText(tooltip, position) {\n    tooltip.label.set("text", this.getTooltipText(position));\n  }\n  /**\r\n   * @ignore\r\n   */\n  roundAxisPosition(position, _location) {\n    return position;\n  }\n  /**\r\n   * @ignore\r\n   */\n  handleCursorShow() {\n    let tooltip = this.get("tooltip");\n    if (tooltip) {\n      tooltip.show();\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  handleCursorHide() {\n    let tooltip = this.get("tooltip");\n    if (tooltip) {\n      tooltip.hide();\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  processSeriesDataItem(_dataItem, _fields) {}\n  _clearDirty() {\n    super._clearDirty();\n    this._sizeDirty = false;\n    this._rangesDirty = false;\n  }\n  /**\r\n   * Converts pixel coordinate to a relative position on axis.\r\n   *\r\n   * @param   coordinate  Coordinate\r\n   * @return              Relative position\r\n   */\n  coordinateToPosition(coordinate) {\n    const renderer = this.get("renderer");\n    return renderer.toAxisPosition(coordinate / renderer.axisLength());\n  }\n  /**\r\n   * Converts relative position of the plot area to relative position of the\r\n   * axis with zoom taken into account.\r\n   *\r\n   * @param position Position\r\n   * @return Relative position\r\n   */\n  toAxisPosition(position) {\n    return this.get("renderer").toAxisPosition(position);\n  }\n  /**\r\n   * Converts relative position of the axis to a global position taking current\r\n   * zoom into account (opposite to what `toAxisPosition` does).\r\n   *\r\n   * @since 5.4.2\r\n   * @param position Position\r\n   * @return Global position\r\n   */\n  toGlobalPosition(position) {\n    return this.get("renderer").toGlobalPosition(position);\n  }\n  /**\r\n   * Adjusts position with inversed taken into account.\r\n   *\r\n   * @ignore\r\n   */\n  fixPosition(position) {\n    return this.get("renderer").fixPosition(position);\n  }\n  /**\r\n   * @ignore\r\n   */\n  shouldGap(_dataItem, _nextItem, _autoGapCount, _fieldName) {\n    return false;\n  }\n  /**\r\n   * Creates and returns an axis range object.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info\r\n   * @param   axisDataItem  Axis data item\r\n   * @return                Axis range\r\n   */\n  createAxisRange(axisDataItem) {\n    return this.axisRanges.push(axisDataItem);\n  }\n  /**\r\n   * @ignore\r\n   */\n  _groupSeriesData(_series) {}\n  /**\r\n   * Returns relative position between two grid lines of the axis.\r\n   *\r\n   * @return Position\r\n   */\n  getCellWidthPosition() {\n    return 0.05;\n  }\n}\nObject.defineProperty(Axis, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Axis"\n});\nObject.defineProperty(Axis, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Component.classNames.concat([Axis.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/CategoryAxis.js\n\n\n\n\n\n\n/**\r\n * Creates a category axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/category-axis/} for more info\r\n * @important\r\n */\nclass CategoryAxis extends Axis {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_frequency", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, "_itemMap", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n  }\n  _afterNew() {\n    this._settings.themeTags = mergeTags(this._settings.themeTags, ["axis"]);\n    this.fields.push("category");\n    this.setPrivateRaw("name", "category");\n    this.addTag("category");\n    super._afterNew();\n  }\n  _prepareChildren() {\n    super._prepareChildren();\n    const len = this.dataItems.length;\n    let i = 0;\n    if (this._valuesDirty) {\n      this._itemMap = {};\n      each(this.dataItems, dataItem => {\n        dataItem.setRaw("index", i);\n        this._itemMap[dataItem.get("category")] = dataItem;\n        i++;\n      });\n      this.setPrivateRaw("maxZoomFactor", len);\n    }\n    this.setPrivateRaw("startIndex", Math.max(Math.round(this.get("start", 0) * len), 0));\n    this.setPrivateRaw("endIndex", Math.min(Math.round(this.get("end", 1) * len), len));\n    if (this._sizeDirty || this._valuesDirty || this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("endIndex") || this.isPrivateDirty("startIndex") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) {\n      if (this.dataItems.length > 0) {\n        this._handleRangeChange();\n        this._prepareAxisItems();\n        this._updateAxisRanges();\n      }\n    }\n  }\n  _handleRangeChange() {\n    each(this.series, series => {\n      let startCategory = this.dataItems[this.startIndex()].get("category");\n      let endCategory = this.dataItems[this.endIndex() - 1].get("category");\n      let baseAxis = series.get("baseAxis");\n      let xAxis = series.get("xAxis");\n      let yAxis = series.get("yAxis");\n      if (xAxis instanceof CategoryAxis && yAxis instanceof CategoryAxis) {\n        series._markDirtyAxes();\n      } else if (baseAxis === this) {\n        let key;\n        let openKey;\n        let otherAxis = yAxis;\n        if (xAxis === baseAxis) {\n          if (series.get("categoryXField")) {\n            key = "categoryX";\n          }\n          if (series.get("openCategoryXField")) {\n            openKey = "openCategoryX";\n          }\n        } else if (yAxis === baseAxis) {\n          if (series.get("categoryYField")) {\n            key = "categoryY";\n          }\n          if (series.get("openCategoryYField")) {\n            openKey = "openCategoryY";\n          }\n          otherAxis = xAxis;\n        }\n        if (otherAxis.className == "ValueAxis") {\n          if (key || openKey) {\n            let startDataItem;\n            let endDataItem;\n            for (let i = 0, len = series.dataItems.length; i < len; i++) {\n              let dataItem = series.dataItems[i];\n              if (key) {\n                if (dataItem.get(key) === startCategory) {\n                  startDataItem = dataItem;\n                  break;\n                }\n              }\n              if (openKey) {\n                if (dataItem.get(openKey) === startCategory) {\n                  startDataItem = dataItem;\n                  break;\n                }\n              }\n            }\n            for (let i = series.dataItems.length - 1; i >= 0; i--) {\n              let dataItem = series.dataItems[i];\n              if (key) {\n                if (dataItem.get(key) === endCategory) {\n                  endDataItem = dataItem;\n                  break;\n                }\n              }\n              if (openKey) {\n                if (dataItem.get(openKey) === endCategory) {\n                  endDataItem = dataItem;\n                  break;\n                }\n              }\n            }\n            let startIndex = 0;\n            let endIndex = series.dataItems.length;\n            if (startDataItem) {\n              startIndex = series.dataItems.indexOf(startDataItem);\n            }\n            if (endDataItem) {\n              endIndex = series.dataItems.indexOf(endDataItem) + 1;\n            }\n            series.setPrivate("startIndex", startIndex);\n            series.setPrivate("endIndex", endIndex);\n            let hasValue = false;\n            for (let i = startIndex; i < endIndex; i++) {\n              const dataItem = series.dataItems[i];\n              each(series.__valueXShowFields, key => {\n                let value = dataItem.get(key);\n                if (value != null) {\n                  hasValue = true;\n                }\n              });\n              each(series.__valueYShowFields, key => {\n                let value = dataItem.get(key);\n                if (value != null) {\n                  hasValue = true;\n                }\n              });\n              if (hasValue) {\n                break;\n              }\n            }\n            series.setPrivate("outOfSelection", !hasValue);\n          }\n        }\n        series._markDirtyAxes(); // must be outside\n      }\n    });\n  }\n\n  _prepareAxisItems() {\n    var _a;\n    const renderer = this.get("renderer");\n    const len = this.dataItems.length;\n    let startIndex = this.startIndex();\n    if (startIndex > 0) {\n      startIndex--;\n    }\n    let endIndex = this.endIndex();\n    if (endIndex < len) {\n      endIndex++;\n    }\n    const minorLabelsEnabled = renderer.get("minorLabelsEnabled");\n    const minorGridEnabled = renderer.get("minorGridEnabled", minorLabelsEnabled);\n    let maxCount = renderer.axisLength() / Math.max(renderer.get("minGridDistance"), 1);\n    let frequency = Math.max(1, Math.min(len, Math.ceil((endIndex - startIndex) / maxCount)));\n    startIndex = Math.floor(startIndex / frequency) * frequency;\n    this._frequency = frequency;\n    for (let j = 0; j < len; j++) {\n      this._toggleDataItem(this.dataItems[j], false);\n    }\n    let f = this.dataItems[startIndex].get("index", 0);\n    for (let i = startIndex; i < endIndex; i = i + frequency) {\n      let dataItem = this.dataItems[i];\n      this._createAssets(dataItem, []);\n      this._toggleDataItem(dataItem, true);\n      let count = frequency;\n      if (minorGridEnabled) {\n        count = 1;\n      }\n      this._prepareDataItem(dataItem, f, count);\n      f++;\n    }\n    if (renderer.get("minorGridEnabled")) {\n      for (let i = startIndex; i < endIndex; i++) {\n        let dataItem = this.dataItems[i];\n        if (i % frequency != 0) {\n          this._createAssets(dataItem, ["minor"], true);\n          this._toggleDataItem(dataItem, true);\n          this._prepareDataItem(dataItem, 0, 1);\n          if (!minorLabelsEnabled) {\n            (_a = dataItem.get("label")) === null || _a === void 0 ? void 0 : _a.setPrivate("visible", false);\n          }\n        }\n      }\n    }\n    this._updateGhost();\n  }\n  _prepareDataItem(dataItem, fillIndex, count) {\n    let renderer = this.get("renderer");\n    let categoryLocation = dataItem.get("categoryLocation", 0);\n    let endCategoryLocation = dataItem.get("endCategoryLocation", 1);\n    let index = dataItem.get("index");\n    if (!Type_isNumber(index)) {\n      index = this.categoryToIndex(dataItem.get("category"));\n    }\n    let position = this.indexToPosition(index, categoryLocation);\n    let endCategory = dataItem.get("endCategory");\n    let endIndex;\n    if (endCategory) {\n      endIndex = this.categoryToIndex(endCategory);\n      if (!Type_isNumber(endIndex)) {\n        endIndex = index;\n      }\n    } else {\n      endIndex = index;\n    }\n    let endPosition = this.indexToPosition(endIndex, endCategoryLocation);\n    let fillEndIndex;\n    let fillEndPosition;\n    if (dataItem.get("isRange")) {\n      fillEndIndex = endIndex;\n    } else {\n      fillEndIndex = index + this._frequency - 1;\n    }\n    fillEndPosition = this.indexToPosition(fillEndIndex, endCategoryLocation);\n    renderer.updateLabel(dataItem.get("label"), position, endPosition, count);\n    renderer.updateGrid(dataItem.get("grid"), position, endPosition);\n    renderer.updateTick(dataItem.get("tick"), position, endPosition, count);\n    renderer.updateFill(dataItem.get("axisFill"), position, fillEndPosition);\n    this._processBullet(dataItem);\n    renderer.updateBullet(dataItem.get("bullet"), position, endPosition);\n    const fillRule = this.get("fillRule");\n    if (fillRule) {\n      fillRule(dataItem, fillIndex);\n    }\n  }\n  startIndex() {\n    let len = this.dataItems.length;\n    return Math.min(Math.max(this.getPrivate("startIndex", 0), 0), len - 1);\n  }\n  endIndex() {\n    let len = this.dataItems.length;\n    return Math.max(1, Math.min(this.getPrivate("endIndex", len), len));\n  }\n  /**\r\n   * @ignore\r\n   */\n  baseValue() {}\n  /**\r\n   * @ignore\r\n   */\n  basePosition() {\n    return 0;\n  }\n  /**\r\n   * Returns X coordinate in pixels corresponding to specific category index.\r\n   *\r\n   * @param   value  Index\r\n   * @return         X coordinate\r\n   */\n  getX(value) {\n    let axisDataItem = this._itemMap[value];\n    if (axisDataItem) {\n      return this._settings.renderer.positionToCoordinate(this.indexToPosition(axisDataItem.get("index", 0)));\n    }\n    return NaN;\n  }\n  /**\r\n   * Returns Y coordinate in pixels corresponding to specific category index.\r\n   *\r\n   * @param   value  Index\r\n   * @return         Y coordinate\r\n   */\n  getY(value) {\n    let axisDataItem = this._itemMap[value];\n    if (axisDataItem) {\n      return this._settings.renderer.positionToCoordinate(this.indexToPosition(axisDataItem.get("index", 0)));\n    }\n    return NaN;\n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemPositionX(dataItem, field, cellLocation, _axisLocation) {\n    const category = dataItem.get(field);\n    const axisDataItem = this._itemMap[category];\n    if (axisDataItem) {\n      return this.indexToPosition(axisDataItem.get("index", 0), cellLocation);\n    }\n    return NaN;\n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemCoordinateX(dataItem, field, cellLocation, _axisLocation) {\n    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, _axisLocation));\n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemPositionY(dataItem, field, cellLocation, _axisLocation) {\n    const category = dataItem.get(field);\n    const axisDataItem = this._itemMap[category];\n    if (axisDataItem) {\n      return this.indexToPosition(axisDataItem.get("index", 0), cellLocation);\n    }\n    return NaN;\n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemCoordinateY(dataItem, field, cellLocation, _axisLocation) {\n    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, _axisLocation));\n  }\n  /**\r\n   * Converts category index to a relative position.\r\n   *\r\n   * `location` indicates relative position within category: 0 - start, 1 - end.\r\n   *\r\n   * If not set, will use middle (0.5) of the category.\r\n   *\r\n   * @param   index     Index\r\n   * @param   location  Location\r\n   * @return            Index\r\n   */\n  indexToPosition(index, location) {\n    if (!Type_isNumber(location)) {\n      location = 0.5;\n    }\n    let len = this.dataItems.length;\n    let startLocation = this.get("startLocation", 0);\n    let endLocation = this.get("endLocation", 1);\n    len -= startLocation;\n    len -= 1 - endLocation;\n    let position = (index + location - startLocation) / len;\n    let dataItem = this.dataItems[index];\n    if (dataItem) {\n      position += dataItem.get("deltaPosition", 0);\n    }\n    return position;\n  }\n  /**\r\n   * Returns an index of a category.\r\n   *\r\n   * @param   category  Category to look up\r\n   * @return            Index\r\n   */\n  categoryToIndex(category) {\n    let dataItem = this._itemMap[category];\n    if (dataItem) {\n      return dataItem.get("index");\n    }\n    return NaN;\n  }\n  /**\r\n   * @ignore\r\n   */\n  dataItemToPosition(dataItem) {\n    return this.indexToPosition(dataItem.get("index"));\n  }\n  /**\r\n   * @ignore\r\n   */\n  roundAxisPosition(position, location) {\n    position += (0.5 - location) / this.dataItems.length;\n    return this.indexToPosition(this.axisPositionToIndex(position), location);\n  }\n  /**\r\n   * Returns an index of the category that corresponds to specific pixel\r\n   * position within axis.\r\n   *\r\n   * @param position  Position (px)\r\n   * @return Category index\r\n   */\n  axisPositionToIndex(position) {\n    let len = this.dataItems.length;\n    return fitToRange(Math.floor(position * len), 0, len - 1); //$math.fitToRange(Math.floor((end - start) * len * position + len * start), 0, len - 1);\n  }\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n  getTooltipText(position, _adjustPosition) {\n    //@todo number formatter + tag\n    const dataItem = this.dataItems[this.axisPositionToIndex(position)];\n    if (dataItem) {\n      const label = dataItem.get("label");\n      if (label) {\n        return populateString(label, this.get("tooltipText", ""));\n      }\n    }\n  }\n  _updateTooltipText(tooltip, position) {\n    tooltip._setDataItem(this.dataItems[this.axisPositionToIndex(position)]);\n    tooltip.label.text.markDirtyText();\n  }\n  /**\r\n   * Returns a data item from series that is closest to the `position`.\r\n   *\r\n   * @param   series    Series\r\n   * @param   position  Relative position\r\n   * @return            Data item\r\n   */\n  getSeriesItem(series, position) {\n    if (this.dataItems.length > 0) {\n      let fieldName = this.getPrivate("name") + this.get("renderer").getPrivate("letter");\n      let index = this.axisPositionToIndex(position);\n      // try simple first\n      let seriesDataItem = series.dataItems[index];\n      let axisDataItem = this.dataItems[index];\n      let category = axisDataItem.get("category");\n      if (seriesDataItem && axisDataItem) {\n        if (seriesDataItem.get(fieldName) === category) {\n          return seriesDataItem;\n        }\n      }\n      // if not found, try looking\n      for (let i = 0, len = series.dataItems.length; i < len; i++) {\n        let dataItem = series.dataItems[i];\n        if (dataItem.get(fieldName) === category) {\n          return dataItem;\n        }\n      }\n    }\n  }\n  /**\r\n   * Zooms the axis to specific `start` and `end` indexes.\r\n   *\r\n   * Optional `duration` specifies duration of zoom animation in milliseconds.\r\n   *\r\n   * @param  start     Start index\r\n   * @param  end       End index\r\n   * @param  duration  Duration in milliseconds\r\n   */\n  zoomToIndexes(start, end, duration) {\n    let len = this.dataItems.length;\n    this.zoom(start / len, end / len, duration);\n  }\n  zoomToCategories(startCategory, endCategory, duration) {\n    this.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1, duration);\n  }\n  /**\r\n   * Returns position span between start and end of a single cell in axis.\r\n   *\r\n   * @since 5.2.30\r\n   * @return Position\r\n   */\n  getCellWidthPosition() {\n    return this._frequency / this.dataItems.length / (this.get("end", 1) - this.get("start", 0));\n  }\n  /**\r\n   * @ignore\r\n   */\n  nextPosition(count) {\n    if (count == null) {\n      count = 1;\n    }\n    if (this.get("renderer").getPrivate("letter") == "Y") {\n      count *= -1;\n    }\n    const position = this.getPrivate("tooltipPosition", 0);\n    const index = fitToRange(this.axisPositionToIndex(position) + count, 0, this.dataItems.length - 1);\n    return this.toGlobalPosition(this.indexToPosition(index));\n  }\n}\nObject.defineProperty(CategoryAxis, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "CategoryAxis"\n});\nObject.defineProperty(CategoryAxis, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Axis.classNames.concat([CategoryAxis.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/ValueAxis.js\n\n\n\n\n\n\n\n/**\r\n * Creates a value axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/} for more info\r\n * @important\r\n */\nclass ValueAxis extends Axis {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_dirtyExtremes", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_dirtySelectionExtremes", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_deltaMinMax", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, "_minReal", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_maxReal", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_minRealLog", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_baseValue", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_syncDp", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_minLogAdjusted", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  markDirtyExtremes() {\n    this._dirtyExtremes = true;\n    this.markDirty();\n  }\n  /**\r\n   * @ignore\r\n   */\n  markDirtySelectionExtremes() {\n    this._dirtySelectionExtremes = true;\n    this.markDirty();\n  }\n  _afterNew() {\n    this._settings.themeTags = mergeTags(this._settings.themeTags, ["axis"]);\n    this.setPrivateRaw("name", "value");\n    this.addTag("value");\n    super._afterNew();\n  }\n  _prepareChildren() {\n    super._prepareChildren();\n    if (this.isDirty("syncWithAxis")) {\n      let previousValue = this._prevSettings.syncWithAxis;\n      if (previousValue) {\n        if (this._syncDp) {\n          this._syncDp.dispose();\n        }\n      }\n      let syncWithAxis = this.get("syncWithAxis");\n      if (syncWithAxis) {\n        this._syncDp = new Disposer_MultiDisposer([syncWithAxis.onPrivate("selectionMinFinal", () => {\n          this._dirtySelectionExtremes = true;\n        }), syncWithAxis.onPrivate("selectionMaxFinal", () => {\n          this._dirtySelectionExtremes = true;\n        })]);\n      }\n    }\n    let someDirty = false;\n    if (this.isDirty("min") || this.isDirty("max") || this.isDirty("maxPrecision") || this.isDirty("numberFormat")) {\n      someDirty = true;\n      this.ghostLabel.set("text", "");\n    }\n    //if (this._dirtyExtremes || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("min") || this.isDirty("max") || this.isDirty("extraMin") || this.isDirty("extraMax") || this.isDirty("logarithmic") || this.isDirty("treatZeroAs") || this.isDirty("baseValue") || this.isDirty("strictMinMax") || this.isDirty("maxPrecision")) {\n    if (this._sizeDirty || this._dirtyExtremes || this._valuesDirty || someDirty || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("extraMin") || this.isDirty("extraMax") || this.isDirty("logarithmic") || this.isDirty("treatZeroAs") || this.isDirty("baseValue") || this.isDirty("strictMinMax") || this.isDirty("strictMinMaxSelection")) {\n      this._getMinMax();\n      this._dirtyExtremes = false;\n    }\n    this._handleSizeDirty();\n    if (this._dirtySelectionExtremes && !this._isPanning && this.get("autoZoom", true)) {\n      this._getSelectionMinMax();\n      this._dirtySelectionExtremes = false;\n    }\n    this._groupData();\n    if (this._sizeDirty || this._valuesDirty || this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("min") || this.isPrivateDirty("selectionMax") || this.isPrivateDirty("selectionMin") || this.isPrivateDirty("max") || this.isPrivateDirty("step") || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("logarithmic")) {\n      this._handleRangeChange();\n      this._prepareAxisItems();\n      this._updateAxisRanges();\n    }\n    this._baseValue = this.baseValue();\n  }\n  _handleSizeDirty() {\n    if (this._sizeDirty) {\n      this._dirtySelectionExtremes = true;\n    }\n  }\n  _groupData() {}\n  _formatText(value) {\n    const numberFormat = this.get("numberFormat");\n    const formatter = this.getNumberFormatter();\n    let text = "";\n    if (numberFormat) {\n      text = formatter.format(value, numberFormat);\n    } else {\n      text = formatter.format(value, undefined, this.getPrivate("stepDecimalPlaces"));\n    }\n    return text;\n  }\n  _prepareAxisItems() {\n    const min = this.getPrivate("min");\n    const max = this.getPrivate("max");\n    if (Type_isNumber(min) && Type_isNumber(max)) {\n      const logarithmic = this.get("logarithmic");\n      const step = this.getPrivate("step");\n      const selectionMin = this.getPrivate("selectionMin");\n      const selectionMax = this.getPrivate("selectionMax") + step;\n      let value = selectionMin - step;\n      let differencePower = 1;\n      let minLog = min;\n      if (logarithmic) {\n        value = this._minLogAdjusted;\n        if (value < selectionMin) {\n          while (value < selectionMin) {\n            value += step;\n          }\n        }\n        minLog = value;\n        if (minLog <= 0) {\n          minLog = 1;\n          if (step < 1) {\n            if (Type_isNumber(this._minRealLog)) {\n              minLog = this._minRealLog;\n            } else {\n              minLog = Math.pow(10, -50);\n            }\n          }\n        }\n        differencePower = Math.log(selectionMax - step) * Math.LOG10E - Math.log(minLog) * Math.LOG10E;\n        if (differencePower > 2) {\n          value = Math.pow(10, Math.log(minLog) * Math.LOG10E - 50);\n        }\n      }\n      /// minor grid\n      const renderer = this.get("renderer");\n      const minorLabelsEnabled = renderer.get("minorLabelsEnabled");\n      const minorGridEnabled = renderer.get("minorGridEnabled", minorLabelsEnabled);\n      let stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));\n      const stepAdjusted = Math.round(step / stepPower);\n      let minorGridCount = 2;\n      if (round(stepAdjusted / 5, 10) % 1 == 0) {\n        minorGridCount = 5;\n      }\n      if (round(stepAdjusted / 10, 10) % 1 == 0) {\n        minorGridCount = 10;\n      }\n      let minorStep = step / minorGridCount;\n      // end of minor grid\n      let i = 0;\n      let m = 0;\n      let previous = -Infinity;\n      while (value < selectionMax) {\n        let dataItem;\n        if (this.dataItems.length < i + 1) {\n          dataItem = new DataItem(this, undefined, {});\n          this._dataItems.push(dataItem);\n          this.processDataItem(dataItem);\n        } else {\n          dataItem = this.dataItems[i];\n        }\n        this._createAssets(dataItem, []);\n        this._toggleDataItem(dataItem, true);\n        dataItem.setRaw("value", value);\n        const label = dataItem.get("label");\n        if (label) {\n          label.set("text", this._formatText(value));\n        }\n        this._prepareDataItem(dataItem);\n        let nextValue = value;\n        if (!logarithmic) {\n          nextValue += step;\n        } else {\n          if (differencePower > 2) {\n            nextValue = Math.pow(10, Math.log(minLog) * Math.LOG10E + i - 50);\n          } else {\n            nextValue += step;\n          }\n        }\n        // minor grid\n        if (minorGridEnabled) {\n          let minorValue = value + minorStep;\n          if (logarithmic) {\n            if (differencePower > 2) {\n              let minorMinMaxStep = this._adjustMinMax(value, nextValue, 10);\n              minorStep = minorMinMaxStep.step;\n            }\n            minorValue = value + minorStep;\n          }\n          while (minorValue < nextValue - step * 0.00000000001) {\n            let minorDataItem;\n            if (this.minorDataItems.length < m + 1) {\n              minorDataItem = new DataItem(this, undefined, {});\n              this.minorDataItems.push(minorDataItem);\n              this.processDataItem(minorDataItem);\n            } else {\n              minorDataItem = this.minorDataItems[m];\n            }\n            this._createAssets(minorDataItem, ["minor"], true);\n            this._toggleDataItem(minorDataItem, true);\n            minorDataItem.setRaw("value", minorValue);\n            const minorLabel = minorDataItem.get("label");\n            if (minorLabel) {\n              if (minorLabelsEnabled) {\n                minorLabel.set("text", this._formatText(minorValue));\n              } else {\n                minorLabel.setPrivate("visible", false);\n              }\n            }\n            this._prepareDataItem(minorDataItem);\n            minorValue += minorStep;\n            m++;\n          }\n        }\n        value = nextValue;\n        if (previous == value) {\n          break;\n        }\n        let stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));\n        if (stepPower < 1 && !logarithmic) {\n          // exponent is less then 1 too. Count decimals of exponent\n          let decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 2;\n          // round value to avoid floating point issues\n          value = round(value, decCount);\n        }\n        i++;\n        previous = value;\n      }\n      for (let j = i; j < this.dataItems.length; j++) {\n        this._toggleDataItem(this.dataItems[j], false);\n      }\n      for (let j = m; j < this.minorDataItems.length; j++) {\n        this._toggleDataItem(this.minorDataItems[j], false);\n      }\n      each(this.series, series => {\n        if (series.inited) {\n          series._markDirtyAxes();\n        }\n      });\n      this._updateGhost();\n    }\n  }\n  _prepareDataItem(dataItem, count) {\n    let renderer = this.get("renderer");\n    let value = dataItem.get("value");\n    let endValue = dataItem.get("endValue");\n    let position = this.valueToPosition(value);\n    let endPosition = position;\n    let fillEndPosition = this.valueToPosition(value + this.getPrivate("step"));\n    if (Type_isNumber(endValue)) {\n      endPosition = this.valueToPosition(endValue);\n      fillEndPosition = endPosition;\n    }\n    if (dataItem.get("isRange")) {\n      if (endValue == null) {\n        fillEndPosition = position;\n      }\n    }\n    let labelEndPosition = endPosition;\n    let labelEndValue = dataItem.get("labelEndValue");\n    if (labelEndValue != null) {\n      labelEndPosition = this.valueToPosition(labelEndValue);\n    }\n    renderer.updateLabel(dataItem.get("label"), position, labelEndPosition, count);\n    const grid = dataItem.get("grid");\n    renderer.updateGrid(grid, position, endPosition);\n    if (grid) {\n      if (value == this.get("baseValue", 0)) {\n        grid.addTag("base");\n        grid._applyThemes();\n      } else if (grid.hasTag("base")) {\n        grid.removeTag("base");\n        grid._applyThemes();\n      }\n    }\n    renderer.updateTick(dataItem.get("tick"), position, labelEndPosition, count);\n    renderer.updateFill(dataItem.get("axisFill"), position, fillEndPosition);\n    this._processBullet(dataItem);\n    renderer.updateBullet(dataItem.get("bullet"), position, endPosition);\n    if (!dataItem.get("isRange")) {\n      const fillRule = this.get("fillRule");\n      if (fillRule) {\n        fillRule(dataItem);\n      }\n    }\n  }\n  _handleRangeChange() {\n    let selectionMin = this.positionToValue(this.get("start", 0));\n    let selectionMax = this.positionToValue(this.get("end", 1));\n    const gridCount = this.get("renderer").gridCount();\n    let minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);\n    let stepDecimalPlaces = decimalPlaces(minMaxStep.step);\n    this.setPrivateRaw("stepDecimalPlaces", stepDecimalPlaces);\n    selectionMin = round(selectionMin, stepDecimalPlaces);\n    selectionMax = round(selectionMax, stepDecimalPlaces);\n    minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);\n    let step = minMaxStep.step;\n    selectionMin = minMaxStep.min;\n    selectionMax = minMaxStep.max;\n    if (this.getPrivate("selectionMin") !== selectionMin || this.getPrivate("selectionMax") !== selectionMax || this.getPrivate("step") !== step) {\n      // do not change to setPrivate, will cause SO\n      this.setPrivateRaw("selectionMin", selectionMin);\n      this.setPrivateRaw("selectionMax", selectionMax);\n      this.setPrivateRaw("step", step);\n    }\n  }\n  /**\r\n   * Converts a relative position to a corresponding numeric value from axis\r\n   * scale.\r\n   *\r\n   * @param   position  Relative position\r\n   * @return            Value\r\n   */\n  positionToValue(position) {\n    const min = this.getPrivate("min");\n    const max = this.getPrivate("max");\n    if (!this.get("logarithmic")) {\n      return position * (max - min) + min;\n    } else {\n      return Math.pow(Math.E, (position * (Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E) + Math.log(min) * Math.LOG10E) / Math.LOG10E);\n    }\n  }\n  /**\r\n   * Convers value to a relative position on axis.\r\n   *\r\n   * @param   value  Value\r\n   * @return         Relative position\r\n   */\n  valueToPosition(value) {\n    const min = this.getPrivate("min");\n    const max = this.getPrivate("max");\n    if (!this.get("logarithmic")) {\n      return (value - min) / (max - min);\n    } else {\n      if (value <= 0) {\n        let treatZeroAs = this.get("treatZeroAs");\n        if (Type_isNumber(treatZeroAs)) {\n          value = treatZeroAs;\n        }\n      }\n      return (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / (Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E);\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  valueToFinalPosition(value) {\n    const min = this.getPrivate("minFinal");\n    const max = this.getPrivate("maxFinal");\n    if (!this.get("logarithmic")) {\n      return (value - min) / (max - min);\n    } else {\n      if (value <= 0) {\n        let treatZeroAs = this.get("treatZeroAs");\n        if (Type_isNumber(treatZeroAs)) {\n          value = treatZeroAs;\n        }\n      }\n      return (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / (Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E);\n    }\n  }\n  /**\r\n   * Returns X coordinate in pixels corresponding to specific value.\r\n   *\r\n   * @param   value     Numeric value\r\n   * @param   location  Location\r\n   * @param   baseValue Base value\r\n   * @return            X coordinate\r\n   */\n  getX(value, location, baseValue) {\n    value = baseValue + (value - baseValue) * location;\n    const position = this.valueToPosition(value);\n    return this._settings.renderer.positionToCoordinate(position);\n  }\n  /**\r\n   * Returns X coordinate in pixels corresponding to specific value.\r\n   *\r\n   * @param   value     Numeric value\r\n   * @param   location  Location\r\n   * @param   baseValue Base value\r\n   * @return            X coordinate\r\n   */\n  getY(value, location, baseValue) {\n    value = baseValue + (value - baseValue) * location;\n    const position = this.valueToPosition(value);\n    return this._settings.renderer.positionToCoordinate(position);\n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemCoordinateX(dataItem, field, _cellLocation, axisLocation) {\n    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, _cellLocation, axisLocation));\n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemPositionX(dataItem, field, _cellLocation, axisLocation) {\n    let value = dataItem.get(field);\n    const stackToItem = dataItem.get("stackToItemX");\n    if (stackToItem) {\n      const series = dataItem.component;\n      value = value * axisLocation + series.getStackedXValueWorking(dataItem, field);\n    } else {\n      value = this._baseValue + (value - this._baseValue) * axisLocation;\n    }\n    return this.valueToPosition(value);\n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemCoordinateY(dataItem, field, _cellLocation, axisLocation) {\n    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, _cellLocation, axisLocation));\n  }\n  /**\r\n   * @ignore\r\n   */\n  getDataItemPositionY(dataItem, field, _cellLocation, axisLocation) {\n    let value = dataItem.get(field);\n    const stackToItem = dataItem.get("stackToItemY");\n    if (stackToItem) {\n      const series = dataItem.component;\n      value = value * axisLocation + series.getStackedYValueWorking(dataItem, field);\n    } else {\n      value = this._baseValue + (value - this._baseValue) * axisLocation;\n    }\n    return this.valueToPosition(value);\n  }\n  /**\r\n   * Returns relative position of axis\' `baseValue`.\r\n   *\r\n   * @return  Base value position\r\n   */\n  basePosition() {\n    return this.valueToPosition(this.baseValue());\n  }\n  /**\r\n   * Base value of the [[ValueAxis]], which determines positive and negative\r\n   * values.\r\n   *\r\n   * @return Base value\r\n   */\n  baseValue() {\n    const min = Math.min(this.getPrivate("minFinal", -Infinity), this.getPrivate("selectionMin", -Infinity));\n    const max = Math.max(this.getPrivate("maxFinal", Infinity), this.getPrivate("selectionMax", Infinity));\n    let baseValue = this.get("baseValue", 0);\n    if (baseValue < min) {\n      baseValue = min;\n    }\n    if (baseValue > max) {\n      baseValue = max;\n    }\n    return baseValue;\n  }\n  /**\r\n   * @ignore\r\n   */\n  cellEndValue(value) {\n    return value;\n  }\n  fixSmallStep(step) {\n    // happens because of floating point error\n    if (1 + step === 1) {\n      step *= 2;\n      return this.fixSmallStep(step);\n    }\n    return step;\n  }\n  _fixMin(min) {\n    return min;\n  }\n  _fixMax(max) {\n    return max;\n  }\n  _calculateTotals() {\n    if (this.get("calculateTotals")) {\n      let series = this.series[0];\n      if (series) {\n        let startIndex = series.startIndex();\n        if (series.dataItems.length > 0) {\n          if (startIndex > 0) {\n            startIndex--;\n          }\n          let endIndex = series.endIndex();\n          if (endIndex < series.dataItems.length) {\n            endIndex++;\n          }\n          let field;\n          let vc;\n          if (series.get("yAxis") == this) {\n            field = "valueY";\n            vc = "vcy";\n          } else if (series.get("xAxis") == this) {\n            field = "valueX";\n            vc = "vcx";\n          }\n          let fieldWorking = field + "Working";\n          if (field) {\n            for (let i = startIndex; i < endIndex; i++) {\n              let sum = 0;\n              let total = 0;\n              each(this.series, series => {\n                if (!series.get("excludeFromTotal")) {\n                  let dataItem = series.dataItems[i];\n                  if (dataItem) {\n                    let value = dataItem.get(fieldWorking) * series.get(vc);\n                    if (!Type_isNaN(value)) {\n                      sum += value;\n                      total += Math.abs(value);\n                    }\n                  }\n                }\n              });\n              each(this.series, series => {\n                if (!series.get("excludeFromTotal")) {\n                  let dataItem = series.dataItems[i];\n                  if (dataItem) {\n                    let value = dataItem.get(fieldWorking) * series.get(vc);\n                    if (!Type_isNaN(value)) {\n                      dataItem.set(field + "Total", total);\n                      dataItem.set(field + "Sum", sum);\n                      dataItem.set(field + "TotalPercent", value / total * 100);\n                    }\n                  }\n                }\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  _getSelectionMinMax() {\n    const min = this.getPrivate("minFinal");\n    const max = this.getPrivate("maxFinal");\n    const minDefined = this.get("min");\n    const maxDefined = this.get("max");\n    let extraMin = this.get("extraMin", 0);\n    let extraMax = this.get("extraMax", 0);\n    if (this.get("logarithmic")) {\n      if (this.get("extraMin") == null) {\n        extraMin = 0.1;\n      }\n      if (this.get("extraMax") == null) {\n        extraMax = 0.2;\n      }\n    }\n    const gridCount = this.get("renderer").gridCount();\n    const selectionStrictMinMax = this.get("strictMinMaxSelection");\n    let strictMinMax = this.get("strictMinMax");\n    if (Type_isNumber(min) && Type_isNumber(max)) {\n      let selectionMin = max;\n      let selectionMax = min;\n      each(this.series, series => {\n        if (!series.get("ignoreMinMax")) {\n          let seriesMin;\n          let seriesMax;\n          const outOfSelection = series.getPrivate("outOfSelection");\n          if (series.get("xAxis") === this) {\n            if (!outOfSelection) {\n              let minX = series.getPrivate("minX");\n              let maxX = series.getPrivate("maxX");\n              // solves #90085\n              if (series.startIndex() != 0 || series.endIndex() != series.dataItems.length) {\n                minX = undefined;\n                maxX = undefined;\n              }\n              seriesMin = series.getPrivate("selectionMinX", minX);\n              seriesMax = series.getPrivate("selectionMaxX", maxX);\n            }\n          } else if (series.get("yAxis") === this) {\n            if (!outOfSelection) {\n              let minY = series.getPrivate("minY");\n              let maxY = series.getPrivate("maxY");\n              // solves #90085\n              if (series.startIndex() != 0 || series.endIndex() != series.dataItems.length) {\n                minY = undefined;\n                maxY = undefined;\n              }\n              seriesMin = series.getPrivate("selectionMinY", minY);\n              seriesMax = series.getPrivate("selectionMaxY", maxY);\n            }\n          }\n          if (!series.isHidden() && !series.isShowing()) {\n            if (Type_isNumber(seriesMin)) {\n              selectionMin = Math.min(selectionMin, seriesMin);\n            }\n            if (Type_isNumber(seriesMax)) {\n              selectionMax = Math.max(selectionMax, seriesMax);\n            }\n          }\n        }\n      });\n      this.axisRanges.each(range => {\n        if (range.get("affectsMinMax")) {\n          let value = range.get("value");\n          if (value != null) {\n            selectionMin = Math.min(selectionMin, value);\n            selectionMax = Math.max(selectionMax, value);\n          }\n          value = range.get("endValue");\n          if (value != null) {\n            selectionMin = Math.min(selectionMin, value);\n            selectionMax = Math.max(selectionMax, value);\n          }\n        }\n      });\n      if (selectionMin > selectionMax) {\n        [selectionMin, selectionMax] = [selectionMax, selectionMin];\n      }\n      if (Type_isNumber(minDefined)) {\n        if (strictMinMax) {\n          selectionMin = minDefined;\n        } else {\n          selectionMin = min;\n        }\n      } else if (strictMinMax) {\n        if (Type_isNumber(this._minReal)) {\n          selectionMin = this._minReal;\n        }\n      }\n      if (Type_isNumber(maxDefined)) {\n        if (strictMinMax) {\n          selectionMax = maxDefined;\n        } else {\n          selectionMax = max;\n        }\n      } else if (strictMinMax) {\n        if (Type_isNumber(this._maxReal)) {\n          selectionMax = this._maxReal;\n        }\n      }\n      if (selectionMin === selectionMax) {\n        let smin = selectionMin;\n        selectionMin -= this._deltaMinMax;\n        selectionMax += this._deltaMinMax;\n        if (selectionMin < min) {\n          let d = smin - min;\n          if (d == 0) {\n            d = this._deltaMinMax;\n          }\n          selectionMin = smin - d;\n          selectionMax = smin + d;\n          strictMinMax = true;\n        }\n        let minMaxStep2 = this._adjustMinMax(selectionMin, selectionMax, gridCount, strictMinMax);\n        selectionMin = minMaxStep2.min;\n        selectionMax = minMaxStep2.max;\n      }\n      let selectionMinReal = selectionMin;\n      let selectionMaxReal = selectionMax;\n      selectionMin -= (selectionMax - selectionMin) * extraMin;\n      selectionMax += (selectionMax - selectionMin) * extraMax;\n      let minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount);\n      selectionMin = minMaxStep.min;\n      selectionMax = minMaxStep.max;\n      selectionMin = fitToRange(selectionMin, min, max);\n      selectionMax = fitToRange(selectionMax, min, max);\n      // do it for the second time !important\t\t\t\n      minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);\n      if (!strictMinMax) {\n        selectionMin = minMaxStep.min;\n        selectionMax = minMaxStep.max;\n      }\n      const syncWithAxis = this.get("syncWithAxis");\n      if (syncWithAxis) {\n        minMaxStep = this._syncAxes(selectionMin, selectionMax, minMaxStep.step, syncWithAxis.getPrivate("selectionMinFinal", syncWithAxis.getPrivate("minFinal", 0)), syncWithAxis.getPrivate("selectionMaxFinal", syncWithAxis.getPrivate("maxFinal", 1)), syncWithAxis.getPrivate("selectionStepFinal", syncWithAxis.getPrivate("step", 1)));\n        if (minMaxStep.min < min) {\n          minMaxStep.min = min;\n        }\n        if (minMaxStep.max > max) {\n          minMaxStep.max = max;\n        }\n        selectionMin = minMaxStep.min;\n        selectionMax = minMaxStep.max;\n      }\n      if (strictMinMax) {\n        if (Type_isNumber(minDefined)) {\n          selectionMin = Math.max(selectionMin, minDefined);\n        }\n        if (Type_isNumber(maxDefined)) {\n          selectionMax = Math.min(selectionMax, maxDefined);\n        }\n      }\n      if (selectionStrictMinMax) {\n        selectionMin = selectionMinReal - (selectionMax - selectionMin) * extraMin;\n        selectionMax = selectionMaxReal + (selectionMax - selectionMin) * extraMax;\n      }\n      if (this.get("logarithmic")) {\n        if (selectionMin <= 0) {\n          selectionMin = selectionMinReal * (1 - Math.min(extraMin, 0.99));\n        }\n        if (selectionMin < min) {\n          selectionMin = min;\n        }\n        if (selectionMax > max) {\n          selectionMax = max;\n        }\n      }\n      let len = Math.min(20, Math.ceil(Math.log(this.getPrivate("maxZoomFactor", 100) + 1) / Math.LN10) + 2);\n      let start = round(this.valueToFinalPosition(selectionMin), len);\n      let end = round(this.valueToFinalPosition(selectionMax), len);\n      this.setPrivateRaw("selectionMinFinal", selectionMin);\n      this.setPrivateRaw("selectionMaxFinal", selectionMax);\n      this.setPrivateRaw("selectionStepFinal", minMaxStep.step);\n      this.zoom(start, end);\n    }\n  }\n  _getMinMax() {\n    let minDefined = this.get("min");\n    let maxDefined = this.get("max");\n    let min = Infinity;\n    let max = -Infinity;\n    let extraMin = this.get("extraMin", 0);\n    let extraMax = this.get("extraMax", 0);\n    if (this.get("logarithmic")) {\n      if (this.get("extraMin") == null) {\n        extraMin = 0.1;\n      }\n      if (this.get("extraMax") == null) {\n        extraMax = 0.2;\n      }\n    }\n    let minDiff = Infinity;\n    each(this.series, series => {\n      if (!series.get("ignoreMinMax")) {\n        let seriesMin;\n        let seriesMax;\n        if (series.get("xAxis") === this) {\n          seriesMin = series.getPrivate("minX");\n          seriesMax = series.getPrivate("maxX");\n        } else if (series.get("yAxis") === this) {\n          seriesMin = series.getPrivate("minY");\n          seriesMax = series.getPrivate("maxY");\n        }\n        if (Type_isNumber(seriesMin) && Type_isNumber(seriesMax)) {\n          min = Math.min(min, seriesMin);\n          max = Math.max(max, seriesMax);\n          let diff = seriesMax - seriesMin;\n          if (diff <= 0) {\n            diff = Math.abs(seriesMax / 100);\n          }\n          if (diff < minDiff) {\n            minDiff = diff;\n          }\n        }\n      }\n    });\n    this.axisRanges.each(range => {\n      if (range.get("affectsMinMax")) {\n        let value = range.get("value");\n        if (value != null) {\n          min = Math.min(min, value);\n          max = Math.max(max, value);\n        }\n        value = range.get("endValue");\n        if (value != null) {\n          min = Math.min(min, value);\n          max = Math.max(max, value);\n        }\n      }\n    });\n    if (this.get("logarithmic")) {\n      let treatZeroAs = this.get("treatZeroAs");\n      if (Type_isNumber(treatZeroAs)) {\n        if (min <= 0) {\n          min = treatZeroAs;\n        }\n      }\n      if (min <= 0) {\n        new Error("Logarithmic value axis can not have values <= 0.");\n      }\n    }\n    if (min === 0 && max === 0) {\n      max = 0.9;\n      min = -0.9;\n    }\n    if (Type_isNumber(minDefined)) {\n      min = minDefined;\n    }\n    if (Type_isNumber(maxDefined)) {\n      max = maxDefined;\n    }\n    // meaning no min/max found on series/ranges and no min/max was defined\n    if (min === Infinity || max === -Infinity) {\n      this.setPrivate("minFinal", undefined);\n      this.setPrivate("maxFinal", undefined);\n      return;\n    }\n    if (min > max) {\n      [min, max] = [max, min];\n    }\n    const initialMin = min;\n    const initialMax = max;\n    // adapter\n    let minAdapted = this.adapters.fold("min", min);\n    let maxAdapted = this.adapters.fold("max", max);\n    this._minRealLog = min;\n    if (Type_isNumber(minAdapted)) {\n      min = minAdapted;\n    }\n    if (Type_isNumber(maxAdapted)) {\n      max = maxAdapted;\n    }\n    // DateAxis does some magic here\n    min = this._fixMin(min);\n    max = this._fixMax(max);\n    // this happens if starLocation and endLocation are 0.5 and DateAxis has only one date\t\t\n    if (max - min <= 1 / Math.pow(10, 15)) {\n      if (max - min !== 0) {\n        this._deltaMinMax = (max - min) / 2;\n      } else {\n        this._getDelta(max);\n      }\n      min -= this._deltaMinMax;\n      max += this._deltaMinMax;\n    }\n    // add extras\n    min -= (max - min) * extraMin;\n    max += (max - min) * extraMax;\n    if (this.get("logarithmic")) {\n      // don\'t let min go below 0 if real min is >= 0\n      if (min < 0 && initialMin >= 0) {\n        min = 0;\n      }\n      // don\'t let max go above 0 if real max is <= 0\n      if (max > 0 && initialMax <= 0) {\n        max = 0;\n      }\n    }\n    this._minReal = min;\n    this._maxReal = max;\n    let strictMinMax = this.get("strictMinMax");\n    let strictMinMaxSelection = this.get("strictMinMaxSelection", false);\n    if (strictMinMaxSelection) {\n      strictMinMax = strictMinMaxSelection;\n    }\n    let strict = strictMinMax;\n    if (Type_isNumber(maxDefined)) {\n      strict = true;\n    }\n    let gridCount = this.get("renderer").gridCount();\n    let minMaxStep = this._adjustMinMax(min, max, gridCount, strict);\n    min = minMaxStep.min;\n    max = minMaxStep.max;\n    // do it for the second time with strict true (importat!)\n    minMaxStep = this._adjustMinMax(min, max, gridCount, true);\n    min = minMaxStep.min;\n    max = minMaxStep.max;\n    // return min max if strict\n    if (strictMinMax) {\n      if (Type_isNumber(minDefined)) {\n        min = minDefined;\n      } else {\n        min = this._minReal;\n      }\n      if (Type_isNumber(maxDefined)) {\n        max = maxDefined;\n      } else {\n        max = this._maxReal;\n      }\n      if (max - min <= 0.00000001) {\n        min -= this._deltaMinMax;\n        max += this._deltaMinMax;\n      }\n      min -= (max - min) * extraMin;\n      max += (max - min) * extraMax;\n    }\n    minAdapted = this.adapters.fold("min", min);\n    maxAdapted = this.adapters.fold("max", max);\n    if (Type_isNumber(minAdapted)) {\n      min = minAdapted;\n    }\n    if (Type_isNumber(maxAdapted)) {\n      max = maxAdapted;\n    }\n    if (minDiff == Infinity) {\n      minDiff = max - min;\n    }\n    // this is to avoid floating point number error\n    let decCount = Math.round(Math.abs(Math.log(Math.abs(max - min)) * Math.LOG10E)) + 5;\n    min = round(min, decCount);\n    max = round(max, decCount);\n    const syncWithAxis = this.get("syncWithAxis");\n    if (syncWithAxis) {\n      minMaxStep = this._syncAxes(min, max, minMaxStep.step, syncWithAxis.getPrivate("minFinal", syncWithAxis.getPrivate("min", 0)), syncWithAxis.getPrivate("maxFinal", syncWithAxis.getPrivate("max", 1)), syncWithAxis.getPrivate("step", 1));\n      min = minMaxStep.min;\n      max = minMaxStep.max;\n    }\n    this.setPrivateRaw("maxZoomFactor", Math.max(1, Math.ceil((max - min) / minDiff * this.get("maxZoomFactor", 100))));\n    this._fixZoomFactor();\n    if (this.get("logarithmic")) {\n      this._minLogAdjusted = min;\n      min = this._minReal;\n      max = this._maxReal;\n      if (min <= 0) {\n        min = initialMin * (1 - Math.min(extraMin, 0.99));\n      }\n    }\n    if (Type_isNumber(min) && Type_isNumber(max)) {\n      if (this.getPrivate("minFinal") !== min || this.getPrivate("maxFinal") !== max) {\n        this.setPrivate("minFinal", min);\n        this.setPrivate("maxFinal", max);\n        this._saveMinMax(min, max);\n        const duration = this.get("interpolationDuration", 0);\n        const easing = this.get("interpolationEasing");\n        this.animatePrivate({\n          key: "min",\n          to: min,\n          duration,\n          easing\n        });\n        this.animatePrivate({\n          key: "max",\n          to: max,\n          duration,\n          easing\n        });\n      }\n    }\n  }\n  _fixZoomFactor() {}\n  _getDelta(max) {\n    // the number by which we need to raise 10 to get difference\n    let exponent = Math.log(Math.abs(max)) * Math.LOG10E;\n    // here we find a number which is power of 10 and has the same count of numbers as difference has\n    let power = Math.pow(10, Math.floor(exponent));\n    // reduce this number by 10 times\n    power = power / 10;\n    this._deltaMinMax = power;\n  }\n  _saveMinMax(_min, _max) {}\n  _adjustMinMax(min, max, gridCount, strictMode) {\n    // will fail if 0\n    if (gridCount <= 1) {\n      gridCount = 1;\n    }\n    gridCount = Math.round(gridCount);\n    let initialMin = min;\n    let initialMax = max;\n    let difference = max - min;\n    // in case min and max is the same, use max\n    if (difference === 0) {\n      difference = Math.abs(max);\n    }\n    // the number by which we need to raise 10 to get difference\n    let exponent = Math.log(Math.abs(difference)) * Math.LOG10E;\n    // here we find a number which is power of 10 and has the same count of numbers as difference has\n    let power = Math.pow(10, Math.floor(exponent));\n    // reduce this number by 10 times\n    power = power / 10;\n    let extra = power;\n    if (strictMode) {\n      extra = 0;\n    }\n    // round down min\n    if (strictMode) {\n      min = Math.floor(min / power) * power;\n      // round up max\n      max = Math.ceil(max / power) * power;\n    } else {\n      min = Math.ceil(min / power) * power - extra;\n      // round up max\n      max = Math.floor(max / power) * power + extra;\n    }\n    // don\'t let min go below 0 if real min is >= 0\n    if (min < 0 && initialMin >= 0) {\n      min = 0;\n    }\n    // don\'t let max go above 0 if real max is <= 0\n    if (max > 0 && initialMax <= 0) {\n      max = 0;\n    }\n    exponent = Math.log(Math.abs(difference)) * Math.LOG10E;\n    power = Math.pow(10, Math.floor(exponent));\n    power = power / 100; // used to be 10 in v4, but this caused issue that there could be limited number of grids with even very small minGridDistance\n    // approximate difference between two grid lines\n    let step = Math.ceil(difference / gridCount / power) * power;\n    let stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));\n    // the step should divide by  2, 5, and 10.\n    let stepDivisor = Math.ceil(step / stepPower); // number 0 - 10\n    if (stepDivisor > 5) {\n      stepDivisor = 10;\n    } else if (stepDivisor <= 5 && stepDivisor > 2) {\n      stepDivisor = 5;\n    }\n    // now get real step\n    step = Math.ceil(step / (stepPower * stepDivisor)) * stepPower * stepDivisor;\n    let maxPrecision = this.get("maxPrecision");\n    if (Type_isNumber(maxPrecision)) {\n      let ceiledStep = ceil(step, maxPrecision);\n      if (maxPrecision < Number.MAX_VALUE && step !== ceiledStep) {\n        step = ceiledStep;\n        if (step == 0) {\n          step = 1;\n        }\n      }\n    }\n    let decCount = 0;\n    // in case numbers are smaller than 1\n    if (stepPower < 1) {\n      // exponent is less then 1 too. Count decimals of exponent\n      decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 1;\n      // round step\n      step = round(step, decCount);\n    }\n    // final min and max\n    let minCount = Math.floor(min / step);\n    min = round(step * minCount, decCount);\n    let maxCount;\n    if (!strictMode) {\n      maxCount = Math.ceil(max / step);\n    } else {\n      maxCount = Math.floor(max / step);\n    }\n    if (maxCount === minCount) {\n      maxCount++;\n    }\n    max = round(step * maxCount, decCount);\n    if (max < initialMax) {\n      max = max + step;\n    }\n    if (min > initialMin) {\n      min = min - step;\n    }\n    step = this.fixSmallStep(step);\n    return {\n      min: min,\n      max: max,\n      step: step\n    };\n  }\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n  getTooltipText(position, _adjustPosition) {\n    const numberFormat = this.get("tooltipNumberFormat", this.get("numberFormat"));\n    const formatter = this.getNumberFormatter();\n    const extraDecimals = this.get("extraTooltipPrecision", 0);\n    const decimals = this.getPrivate("stepDecimalPlaces", 0) + extraDecimals;\n    const value = round(this.positionToValue(position), decimals);\n    if (numberFormat) {\n      return formatter.format(value, numberFormat);\n    } else {\n      return formatter.format(value, undefined, decimals);\n    }\n  }\n  /**\r\n   * Returns a data item from series that is closest to the `position`.\r\n   *\r\n   * @param   series    Series\r\n   * @param   position  Relative position\r\n   * @return            Data item\r\n   */\n  getSeriesItem(series, position) {\n    let fieldName = this.getPrivate("name") + this.get("renderer").getPrivate("letter");\n    let value = this.positionToValue(position);\n    let index = undefined;\n    let oldDiff;\n    each(series.dataItems, (dataItem, i) => {\n      const diff = Math.abs(dataItem.get(fieldName) - value);\n      if (index === undefined || diff < oldDiff) {\n        index = i;\n        oldDiff = diff;\n      }\n    });\n    if (index != null) {\n      return series.dataItems[index];\n    }\n  }\n  /**\r\n   * Zooms the axis to specific `start` and `end` values.\r\n   *\r\n   * Optional `duration` specifies duration of zoom animation in milliseconds.\r\n   *\r\n   * @param  start     Start value\r\n   * @param  end       End value\r\n   * @param  duration  Duration in milliseconds\r\n   */\n  zoomToValues(start, end, duration) {\n    const min = this.getPrivate("minFinal", 0);\n    const max = this.getPrivate("maxFinal", 0);\n    if (this.getPrivate("min") != null && this.getPrivate("max") != null) {\n      this.zoom((start - min) / (max - min), (end - min) / (max - min), duration);\n    }\n  }\n  /**\r\n   * Syncs with a target axis.\r\n   *\r\n   * @param  min  Min\r\n   * @param  max  Max\r\n   * @param  step Step\r\n   */\n  _syncAxes(min, max, step, syncMin, syncMax, syncStep) {\n    let axis = this.get("syncWithAxis");\n    if (axis) {\n      let count = Math.round(syncMax - syncMin) / syncStep;\n      let currentCount = Math.round((max - min) / step);\n      let gridCount = this.get("renderer").gridCount();\n      if (Type_isNumber(count) && Type_isNumber(currentCount)) {\n        let synced = false;\n        let c = 0;\n        let diff = (max - min) * 0.01;\n        let omin = min;\n        let omax = max;\n        let ostep = step;\n        while (synced != true) {\n          synced = this._checkSync(omin, omax, ostep, count);\n          c++;\n          if (c > 500) {\n            synced = true;\n          }\n          if (!synced) {\n            if (c / 3 == Math.round(c / 3)) {\n              omin = min - diff * c;\n              if (min >= 0 && omin < 0) {\n                omin = 0;\n              }\n            } else {\n              omax = max + diff * c;\n              if (omax <= 0 && omax > 0) {\n                omax = 0;\n              }\n            }\n            let minMaxStep = this._adjustMinMax(omin, omax, gridCount, true);\n            omin = minMaxStep.min;\n            omax = minMaxStep.max;\n            ostep = minMaxStep.step;\n          } else {\n            min = omin;\n            max = omax;\n            step = ostep;\n          }\n        }\n      }\n    }\n    return {\n      min: min,\n      max: max,\n      step: step\n    };\n  }\n  /**\r\n   * Returns `true` if axis needs to be resunced with some other axis.\r\n   */\n  _checkSync(min, max, step, count) {\n    let currentCount = (max - min) / step;\n    for (let i = 1; i < count; i++) {\n      if (round(currentCount / i, 1) == count || currentCount * i == count) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\r\n   * Returns relative position between two grid lines of the axis.\r\n   *\r\n   * @return Position\r\n   */\n  getCellWidthPosition() {\n    let max = this.getPrivate("selectionMax", this.getPrivate("max"));\n    let min = this.getPrivate("selectionMin", this.getPrivate("min"));\n    if (Type_isNumber(max) && Type_isNumber(min)) {\n      return this.getPrivate("step", 1) / (max - min);\n    }\n    return 0.05;\n  }\n  /**\r\n   * @ignore\r\n   */\n  nextPosition(count) {\n    if (count == null) {\n      count = 1;\n    }\n    if (this.get("renderer").getPrivate("letter") == "Y") {\n      count *= -1;\n    }\n    let value = this.positionToValue(this.getPrivate("tooltipPosition", 0));\n    value += this.getPrivate("step", 1) * count;\n    value = fitToRange(value, this.getPrivate("selectionMin", 0), this.getPrivate("selectionMax", 1));\n    return this.toGlobalPosition(this.valueToPosition(value));\n  }\n}\nObject.defineProperty(ValueAxis, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "ValueAxis"\n});\nObject.defineProperty(ValueAxis, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Axis.classNames.concat([ValueAxis.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererY.js\n\n\n\n\n\n/**\r\n * Used to render vertical axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Axis_renderer} for more info\r\n * @important\r\n */\nclass AxisRendererY extends AxisRenderer {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_downY", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "thumb", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: Rectangle.new(this._root, {\n        height: p100,\n        isMeasured: false,\n        themeTags: ["axis", "y", "thumb"]\n      })\n    });\n  }\n  _afterNew() {\n    this._settings.themeTags = mergeTags(this._settings.themeTags, ["renderer", "y"]);\n    if (this._settings.opposite) {\n      this._settings.themeTags.push("opposite");\n    }\n    super._afterNew();\n    this.setPrivateRaw("letter", "Y");\n    const gridTemplate = this.grid.template;\n    gridTemplate.set("width", p100);\n    gridTemplate.set("height", 0);\n    gridTemplate.set("draw", (display, graphics) => {\n      display.moveTo(0, 0);\n      display.lineTo(graphics.width(), 0);\n    });\n    this.set("draw", (display, renderer) => {\n      display.moveTo(0, 0);\n      display.lineTo(0, renderer.height());\n    });\n  }\n  _getPan(point1, point2) {\n    return (point1.y - point2.y) / this.height();\n  }\n  _changed() {\n    super._changed();\n    const axis = this.axis;\n    axis.ghostLabel.setPrivate("visible", !this.get("inside"));\n    axis.ghostLabel.set("y", -1000);\n    const thumb = this.thumb;\n    const opposite = "opposite";\n    const inside = "inside";\n    const chart = this.chart;\n    if (this.isDirty(opposite) || this.isDirty(inside)) {\n      const axisChildren = axis.children;\n      if (this.get(inside)) {\n        axis.addTag(inside);\n      } else {\n        axis.removeTag(inside);\n      }\n      if (chart) {\n        if (this.get(opposite)) {\n          const children = chart.rightAxesContainer.children;\n          if (children.indexOf(axis) == -1) {\n            children.moveValue(axis, 0);\n          }\n          axis.addTag(opposite);\n          axisChildren.moveValue(this, 0);\n        } else {\n          const children = chart.leftAxesContainer.children;\n          if (children.indexOf(axis) == -1) {\n            children.moveValue(axis);\n          }\n          axis.removeTag(opposite);\n          axisChildren.moveValue(this);\n        }\n        axis.ghostLabel._applyThemes();\n        this.labels.each(label => {\n          label._applyThemes();\n        });\n        this.root._markDirtyRedraw();\n      }\n      axis.markDirtySize();\n    }\n    const w = axis.labelsContainer.width();\n    if (chart) {\n      if (this.get(opposite)) {\n        thumb.set("centerX", 0);\n      } else {\n        thumb.set("centerX", w);\n      }\n    }\n    thumb.setPrivate("width", w);\n  }\n  /**\r\n   * @ignore\r\n   */\n  processAxis() {\n    super.processAxis();\n    const axis = this.axis;\n    if (axis.get("height") == null) {\n      axis.set("height", p100);\n    }\n    const horizontalLayout = this._root.horizontalLayout;\n    axis.set("layout", horizontalLayout);\n    axis.labelsContainer.set("height", p100);\n    axis.axisHeader.set("layout", horizontalLayout);\n  }\n  _updatePositions() {\n    const axis = this.axis;\n    const y = axis.y() - relativeToValue(axis.get("centerY", 0), axis.height());\n    axis.gridContainer.set("y", y);\n    axis.topGridContainer.set("y", y);\n    axis.bulletsContainer.set("x", this.x());\n    const chart = axis.chart;\n    if (chart) {\n      const plotContainer = chart.plotContainer;\n      const axisHeader = axis.axisHeader;\n      let height = axis.get("marginTop", 0);\n      if (axisHeader.children.length > 0) {\n        height = axis.axisHeader.height();\n        axis.set("marginTop", height + 1);\n      } else {\n        axisHeader.set("height", height);\n      }\n      axisHeader.setAll({\n        y: axis.y() - height,\n        x: -1,\n        width: plotContainer.width() + 2\n      });\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  axisLength() {\n    return this.axis.innerHeight();\n  }\n  /**\r\n   * Converts axis relative position to actual coordinate in pixels.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Point\r\n   */\n  positionToPoint(position) {\n    return {\n      x: 0,\n      y: this.positionToCoordinate(position)\n    };\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateLabel(label, position, endPosition, count) {\n    if (label) {\n      if (!Type_isNumber(position)) {\n        position = 0;\n      }\n      let location = 0.5;\n      if (Type_isNumber(count) && count > 1) {\n        location = label.get("multiLocation", location);\n      } else {\n        location = label.get("location", location);\n      }\n      const opposite = this.get("opposite");\n      const inside = label.get("inside", this.get("inside", false));\n      if (opposite) {\n        label.set("x", 0);\n        if (inside) {\n          label.set("position", "absolute");\n        } else {\n          label.set("position", "relative");\n        }\n      } else {\n        if (inside) {\n          label.set("x", 0);\n          label.set("position", "absolute");\n        } else {\n          label.set("x", undefined);\n          label.set("position", "relative");\n        }\n      }\n      if (Type_isNumber(endPosition) && endPosition != position) {\n        position = position + (endPosition - position) * location;\n      }\n      label.set("y", this.positionToCoordinate(position));\n      this.toggleVisibility(label, position, label.get("minPosition", 0), label.get("maxPosition", 1));\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateGrid(grid, position, endPosition) {\n    if (grid) {\n      if (!Type_isNumber(position)) {\n        position = 0;\n      }\n      let location = grid.get("location", 0.5);\n      if (Type_isNumber(endPosition) && endPosition != position) {\n        position = position + (endPosition - position) * location;\n      }\n      grid.set("y", this.positionToCoordinate(position));\n      this.toggleVisibility(grid, position, 0, 1);\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateTick(tick, position, endPosition, count) {\n    if (tick) {\n      if (!Type_isNumber(position)) {\n        position = 0;\n      }\n      let location = 0.5;\n      if (Type_isNumber(count) && count > 1) {\n        location = tick.get("multiLocation", location);\n      } else {\n        location = tick.get("location", location);\n      }\n      if (Type_isNumber(endPosition) && endPosition != position) {\n        position = position + (endPosition - position) * location;\n      }\n      tick.set("y", this.positionToCoordinate(position));\n      let length = tick.get("length", 0);\n      const inside = tick.get("inside", this.get("inside", false));\n      if (this.get("opposite")) {\n        tick.set("x", 0);\n        if (inside) {\n          length *= -1;\n        }\n      } else {\n        if (!inside) {\n          length *= -1;\n        }\n      }\n      tick.set("draw", display => {\n        display.moveTo(0, 0);\n        display.lineTo(length, 0);\n      });\n      this.toggleVisibility(tick, position, tick.get("minPosition", 0), tick.get("maxPosition", 1));\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateBullet(bullet, position, endPosition) {\n    if (bullet) {\n      const sprite = bullet.get("sprite");\n      if (sprite) {\n        if (!Type_isNumber(position)) {\n          position = 0;\n        }\n        let location = bullet.get("location", 0.5);\n        if (Type_isNumber(endPosition) && endPosition != position) {\n          position = position + (endPosition - position) * location;\n        }\n        let bulletPosition = this.axis.roundAxisPosition(position, location);\n        let previousBullet = this.axis._bullets[bulletPosition];\n        let d = 1;\n        if (this.get("opposite")) {\n          d = -1;\n        }\n        if (bullet.get("stacked")) {\n          if (previousBullet) {\n            let previousSprite = previousBullet.get("sprite");\n            if (previousSprite) {\n              sprite.set("x", previousSprite.x() + previousSprite.width() * d);\n            }\n          } else {\n            sprite.set("x", 0);\n          }\n        }\n        this.axis._bullets[bulletPosition] = bullet;\n        sprite.set("y", this.positionToCoordinate(position));\n        this.toggleVisibility(sprite, position, 0, 1);\n      }\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateFill(fill, position, endPosition) {\n    if (fill) {\n      if (!Type_isNumber(position)) {\n        position = 0;\n      }\n      if (!Type_isNumber(endPosition)) {\n        endPosition = 1;\n      }\n      let y0 = this.positionToCoordinate(position);\n      let y1 = this.positionToCoordinate(endPosition);\n      this.fillDrawMethod(fill, y0, y1);\n    }\n  }\n  fillDrawMethod(fill, y0, y1) {\n    fill.set("draw", display => {\n      // using for holes, so can not be rectangle\n      const w = this.axis.gridContainer.width();\n      const h = this.height();\n      if (y1 < y0) {\n        [y1, y0] = [y0, y1];\n      }\n      if (y0 > h || y1 < 0) {\n        return;\n      }\n      //y0 = Math.max(0, y0);\n      //y1 = Math.min(h, y1);\n      display.moveTo(0, y0);\n      display.lineTo(w, y0);\n      display.lineTo(w, y1);\n      display.lineTo(0, y1);\n      display.lineTo(0, y0);\n    });\n  }\n  /**\r\n   * Converts relative position (0-1) on axis to a pixel coordinate.\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @return Coordinate (px)\r\n   */\n  positionToCoordinate(position) {\n    if (!this._inversed) {\n      return (this._end - position) * this._axisLength;\n    } else {\n      return (position - this._start) * this._axisLength;\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  positionTooltip(tooltip, position) {\n    this._positionTooltip(tooltip, {\n      x: 0,\n      y: this.positionToCoordinate(position)\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateTooltipBounds(tooltip) {\n    const inside = this.get("inside");\n    const num = 100000;\n    let global = this._display.toGlobal({\n      x: 0,\n      y: 0\n    });\n    let y = global.y;\n    let x = 0;\n    let h = this.axisLength();\n    let w = num;\n    let pointerOrientation = "right";\n    if (this.get("opposite")) {\n      if (inside) {\n        pointerOrientation = "right";\n        x = global.x - num;\n        w = num;\n      } else {\n        pointerOrientation = "left";\n        x = global.x;\n        w = num;\n      }\n    } else {\n      if (inside) {\n        pointerOrientation = "left";\n        x = global.x;\n        w = num;\n      } else {\n        pointerOrientation = "right";\n        x = global.x - num;\n        w = num;\n      }\n    }\n    const bounds = {\n      left: x,\n      right: x + w,\n      top: y,\n      bottom: y + h\n    };\n    const oldBounds = tooltip.get("bounds");\n    if (!sameBounds(bounds, oldBounds)) {\n      tooltip.set("bounds", bounds);\n      tooltip.set("pointerOrientation", pointerOrientation);\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  _updateLC() {\n    const axis = this.axis;\n    const parent = axis.parent;\n    if (parent) {\n      const h = parent.innerHeight();\n      this._lc = this.axisLength() / h;\n      this._ls = axis.y() / h;\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  toAxisPosition(position) {\n    const start = this._start || 0;\n    const end = this._end || 1;\n    position -= this._ls;\n    position = position * (end - start) / this._lc;\n    if (this.get("inversed")) {\n      position = start + position;\n    } else {\n      position = end - position;\n    }\n    return position;\n  }\n  /**\r\n   * @ignore\r\n   */\n  toGlobalPosition(position) {\n    const start = this._start || 0;\n    const end = this._end || 1;\n    if (this.get("inversed")) {\n      position = position - start;\n    } else {\n      position = end - position;\n    }\n    position = position / (end - start) * this._lc;\n    position += this._ls;\n    return position;\n  }\n  /**\r\n   * @ignore\r\n   */\n  fixPosition(position) {\n    if (!this.get("inversed")) {\n      return 1 - position;\n    }\n    return position;\n  }\n}\nObject.defineProperty(AxisRendererY, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "AxisRendererY"\n});\nObject.defineProperty(AxisRendererY, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: AxisRenderer.classNames.concat([AxisRendererY.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/XYSeries.js\n\n\n\n\n\n\n\n\n\n\n/**\r\n * @ignore\r\n */\nfunction min(left, right) {\n  if (left == null) {\n    return right;\n  } else if (right == null) {\n    return left;\n  } else if (right < left) {\n    return right;\n  } else {\n    return left;\n  }\n}\n/**\r\n * @ignore\r\n */\nfunction max(left, right) {\n  if (left == null) {\n    return right;\n  } else if (right == null) {\n    return left;\n  } else if (right > left) {\n    return right;\n  } else {\n    return left;\n  }\n}\n/**\r\n * A base class for all XY chart series.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/} for more info\r\n */\nclass XYSeries extends Series {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_xField", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_yField", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_xOpenField", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_yOpenField", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_xLowField", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_xHighField", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_yLowField", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_yHighField", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_axesDirty", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_stackDirty", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_selectionProcessed", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_dataSets", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_mainContainerMask", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_x", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_y", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_bullets", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    /**\r\n     * A [[Container]] that us used to put series\' elements in.\r\n     *\r\n     * @default Container.new()\r\n     */\n    Object.defineProperty(this, "mainContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.children.push(Container.new(this._root, {}))\n    });\n    /**\r\n     * A list of axis ranges that affect the series.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info\r\n     */\n    Object.defineProperty(this, "axisRanges", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new List()\n    });\n    Object.defineProperty(this, "_skipped", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_couldStackTo", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "_reallyStackedTo", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_stackedSeries", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, "_aLocationX0", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_aLocationX1", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, "_aLocationY0", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_aLocationY1", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, "_showBullets", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, "valueXFields", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: ["valueX", "openValueX", "lowValueX", "highValueX"]\n    });\n    Object.defineProperty(this, "valueYFields", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: ["valueY", "openValueY", "lowValueY", "highValueY"]\n    });\n    Object.defineProperty(this, "_valueXFields", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_valueYFields", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    // used for full min/max\n    Object.defineProperty(this, "_valueXShowFields", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_valueYShowFields", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    // used for selection (uses working)\n    Object.defineProperty(this, "__valueXShowFields", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "__valueYShowFields", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_emptyDataItem", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new DataItem(this, undefined, {})\n    });\n    Object.defineProperty(this, "_dataSetId", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_tooltipFieldX", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_tooltipFieldY", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_posXDp", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_posYDp", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  _afterNew() {\n    this.fields.push("categoryX", "categoryY", "openCategoryX", "openCategoryY");\n    this.valueFields.push("valueX", "valueY", "openValueX", "openValueY", "lowValueX", "lowValueY", "highValueX", "highValueY");\n    this._setRawDefault("vcx", 1);\n    this._setRawDefault("vcy", 1);\n    // this can\'t go to themes, as data might be parsed before theme\n    this._setRawDefault("valueXShow", "valueXWorking");\n    this._setRawDefault("valueYShow", "valueYWorking");\n    this._setRawDefault("openValueXShow", "openValueXWorking");\n    this._setRawDefault("openValueYShow", "openValueYWorking");\n    this._setRawDefault("lowValueXShow", "lowValueXWorking");\n    this._setRawDefault("lowValueYShow", "lowValueYWorking");\n    this._setRawDefault("highValueXShow", "highValueXWorking");\n    this._setRawDefault("highValueYShow", "highValueYWorking");\n    this._setRawDefault("lowValueXGrouped", "low");\n    this._setRawDefault("lowValueYGrouped", "low");\n    this._setRawDefault("highValueXGrouped", "high");\n    this._setRawDefault("highValueYGrouped", "high");\n    super._afterNew();\n    this.set("maskContent", true);\n    this._disposers.push(this.axisRanges.events.onAll(change => {\n      if (change.type === "clear") {\n        each(change.oldValues, axisRange => {\n          this._removeAxisRange(axisRange);\n        });\n      } else if (change.type === "push") {\n        this._processAxisRange(change.newValue);\n      } else if (change.type === "setIndex") {\n        this._processAxisRange(change.newValue);\n      } else if (change.type === "insertIndex") {\n        this._processAxisRange(change.newValue);\n      } else if (change.type === "removeIndex") {\n        this._removeAxisRange(change.oldValue);\n      } else if (change.type === "moveIndex") {\n        this._processAxisRange(change.value);\n      } else {\n        throw new Error("Unknown IStreamEvent type");\n      }\n    }));\n    this.states.create("hidden", {\n      opacity: 1,\n      visible: false\n    });\n    this.onPrivate("startIndex", () => {\n      this.root.events.once("frameended", () => {\n        this.updateLegendValue();\n      });\n    });\n    this.onPrivate("endIndex", () => {\n      this.root.events.once("frameended", () => {\n        this.updateLegendValue();\n      });\n    });\n    this._makeFieldNames();\n  }\n  _processAxisRange(axisRange) {\n    const container = Container.new(this._root, {});\n    axisRange.container = container;\n    this.children.push(container);\n    axisRange.series = this;\n    const axisDataItem = axisRange.axisDataItem;\n    axisDataItem.setRaw("isRange", true);\n    const axis = axisDataItem.component;\n    if (axis) {\n      axis._processAxisRange(axisDataItem, ["range", "series"]);\n      const bullet = axisDataItem.get("bullet");\n      if (bullet) {\n        const sprite = bullet.get("sprite");\n        if (sprite) {\n          sprite.setPrivate("visible", false);\n        }\n      }\n      const axisFill = axisDataItem.get("axisFill");\n      if (axisFill) {\n        container.set("mask", axisFill);\n      }\n      axis._seriesAxisRanges.push(axisDataItem);\n    }\n  }\n  _removeAxisRange(axisRange) {\n    const axisDataItem = axisRange.axisDataItem;\n    const axis = axisDataItem.component;\n    axis.disposeDataItem(axisDataItem);\n    Array_remove(axis._seriesAxisRanges, axisDataItem);\n    const container = axisRange.container;\n    if (container) {\n      container.dispose();\n    }\n  }\n  _updateFields() {\n    super._updateFields();\n    this._valueXFields = [];\n    this._valueYFields = [];\n    this._valueXShowFields = [];\n    this._valueYShowFields = [];\n    this.__valueXShowFields = [];\n    this.__valueYShowFields = [];\n    if (this.valueXFields) {\n      each(this.valueXFields, key => {\n        const field = this.get(key + "Field");\n        if (field) {\n          this._valueXFields.push(key);\n          let field = this.get(key + "Show");\n          this.__valueXShowFields.push(field);\n          if (field.indexOf("Working") != -1) {\n            this._valueXShowFields.push(field.split("Working")[0]);\n          } else {\n            this._valueXShowFields.push(field);\n          }\n        }\n      });\n    }\n    if (this.valueYFields) {\n      each(this.valueYFields, key => {\n        const field = this.get(key + "Field");\n        if (field) {\n          this._valueYFields.push(key);\n          let field = this.get(key + "Show");\n          this.__valueYShowFields.push(field);\n          if (field.indexOf("Working") != -1) {\n            this._valueYShowFields.push(field.split("Working")[0]);\n          } else {\n            this._valueYShowFields.push(field);\n          }\n        }\n      });\n    }\n  }\n  _dispose() {\n    super._dispose();\n    this._bullets = {};\n    const chart = this.chart;\n    if (chart) {\n      chart.series.removeValue(this);\n    }\n    removeFirst(this.get("xAxis").series, this);\n    removeFirst(this.get("yAxis").series, this);\n  }\n  // TODO use  SelectKeys<this["_privateSettings"], number | undefined>\n  _min(key, value) {\n    let newValue = min(this.getPrivate(key), value);\n    this.setPrivate(key, newValue);\n  }\n  // TODO use  SelectKeys<this["_privateSettings"], number | undefined>\n  _max(key, value) {\n    let newValue = max(this.getPrivate(key), value);\n    this.setPrivate(key, newValue);\n  }\n  _shouldMakeBullet(dataItem) {\n    const xAxis = this.get("xAxis");\n    const yAxis = this.get("yAxis");\n    const baseAxis = this.get("baseAxis");\n    if (!xAxis.inited || !yAxis.inited) {\n      return false;\n    }\n    const minBulletDistance = this.get("minBulletDistance", 0);\n    if (minBulletDistance > 0) {\n      let startIndex = this.startIndex();\n      let endIndex = this.endIndex();\n      let count = endIndex - startIndex;\n      if (xAxis == baseAxis) {\n        if (xAxis.get("renderer").axisLength() / count < minBulletDistance / 5) {\n          return false;\n        }\n      } else if (yAxis == baseAxis) {\n        if (yAxis.get("renderer").axisLength() / count < minBulletDistance / 5) {\n          return false;\n        }\n      }\n    }\n    if (dataItem.get(this._xField) != null && dataItem.get(this._yField) != null) {\n      return true;\n    }\n    return false;\n  }\n  _makeFieldNames() {\n    const xAxis = this.get("xAxis");\n    const yAxis = this.get("yAxis");\n    const xName = xAxis.getPrivate("name");\n    const xCapName = capitalizeFirst(xName);\n    const yName = yAxis.getPrivate("name");\n    const yCapName = capitalizeFirst(yName);\n    const xLetter = xAxis.get("renderer").getPrivate("letter");\n    const yLetter = yAxis.get("renderer").getPrivate("letter");\n    const open = "open";\n    const low = "low";\n    const high = "high";\n    const show = "Show";\n    if (xAxis.className === "ValueAxis") {\n      this._xField = this.get(xName + xLetter + show);\n      this._xOpenField = this.get(open + xCapName + xLetter + show);\n      this._xLowField = this.get(low + xCapName + xLetter + show);\n      this._xHighField = this.get(high + xCapName + xLetter + show);\n    } else {\n      this._xField = xName + xLetter;\n      this._xOpenField = open + xCapName + xLetter;\n      this._xLowField = low + xCapName + xLetter;\n      this._xHighField = high + xCapName + xLetter;\n    }\n    if (yAxis.className === "ValueAxis") {\n      this._yField = this.get(yName + yLetter + show);\n      this._yOpenField = this.get(open + yCapName + yLetter + show);\n      this._yLowField = this.get(low + yCapName + yLetter + show);\n      this._yHighField = this.get(high + yCapName + yLetter + show);\n    } else {\n      this._yField = yName + yLetter;\n      this._yOpenField = open + yCapName + yLetter;\n      this._yLowField = low + yCapName + yLetter;\n      this._yHighField = high + yCapName + yLetter;\n    }\n  }\n  _fixVC() {\n    const xAxis = this.get("xAxis");\n    const yAxis = this.get("yAxis");\n    const baseAxis = this.get("baseAxis");\n    const hiddenState = this.states.lookup("hidden");\n    const sequencedInterpolation = this.get("sequencedInterpolation");\n    if (hiddenState) {\n      let value = 0;\n      if (sequencedInterpolation) {\n        value = 0.999999999999; // makes animate, good for stacked\n      }\n\n      if (xAxis === baseAxis) {\n        hiddenState.set("vcy", value);\n      } else if (yAxis === baseAxis) {\n        hiddenState.set("vcx", value);\n      } else {\n        hiddenState.set("vcy", value);\n        hiddenState.set("vcx", value);\n      }\n    }\n  }\n  _handleMaskBullets() {\n    if (this.isDirty("maskBullets")) {\n      this.bulletsContainer.set("maskContent", this.get("maskBullets"));\n    }\n  }\n  _fixPosition() {\n    const xAxis = this.get("xAxis");\n    const yAxis = this.get("yAxis");\n    this.set("x", xAxis.x() - relativeToValue(xAxis.get("centerX", 0), xAxis.width()) - xAxis.parent.get("paddingLeft", 0));\n    this.set("y", yAxis.y() - relativeToValue(yAxis.get("centerY", 0), yAxis.height()) - yAxis.parent.get("paddingTop", 0));\n    this.bulletsContainer.set("y", this.y());\n    this.bulletsContainer.set("x", this.x());\n  }\n  _prepareChildren() {\n    super._prepareChildren();\n    this._bullets = {};\n    if (this.isDirty("valueYShow") || this.isDirty("valueXShow") || this.isDirty("openValueYShow") || this.isDirty("openValueXShow") || this.isDirty("lowValueYShow") || this.isDirty("lowValueXShow") || this.isDirty("highValueYShow") || this.isDirty("highValueXShow")) {\n      this._updateFields();\n      this._makeFieldNames();\n      this._valuesDirty = true;\n    }\n    if (this.isDirty("xAxis") || this.isDirty("yAxis")) {\n      this._valuesDirty = true;\n    }\n    this.set("width", this.get("xAxis").width());\n    this.set("height", this.get("yAxis").height());\n    this._handleMaskBullets();\n    const xAxis = this.get("xAxis");\n    const yAxis = this.get("yAxis");\n    const baseAxis = this.get("baseAxis");\n    const tooltipPositionX = this.get("tooltipPositionX");\n    let tooltipFieldX;\n    switch (tooltipPositionX) {\n      case "open":\n        tooltipFieldX = this._xOpenField;\n        break;\n      case "low":\n        tooltipFieldX = this._xLowField;\n        break;\n      case "high":\n        tooltipFieldX = this._xHighField;\n        break;\n      default:\n        tooltipFieldX = this._xField;\n    }\n    this._tooltipFieldX = tooltipFieldX;\n    const tooltipPositionY = this.get("tooltipPositionY");\n    let tooltipFieldY;\n    switch (tooltipPositionY) {\n      case "open":\n        tooltipFieldY = this._yOpenField;\n        break;\n      case "low":\n        tooltipFieldY = this._yLowField;\n        break;\n      case "high":\n        tooltipFieldY = this._yHighField;\n        break;\n      default:\n        tooltipFieldY = this._yField;\n    }\n    this._tooltipFieldY = tooltipFieldY;\n    if (this.isDirty("baseAxis")) {\n      this._fixVC();\n    }\n    this._fixPosition();\n    const stacked = this.get("stacked");\n    if (this.isDirty("stacked")) {\n      if (stacked) {\n        if (this._valuesDirty && !this._dataProcessed) {} else {\n          this._stack();\n        }\n      } else {\n        this._unstack();\n      }\n    }\n    if (this._valuesDirty && !this._dataProcessed) {\n      this._dataProcessed = true;\n      if (stacked) {\n        this._stack();\n      }\n      each(this.dataItems, dataItem => {\n        each(this._valueXShowFields, key => {\n          let value = dataItem.get(key);\n          if (value != null) {\n            if (stacked) {\n              value += this.getStackedXValue(dataItem, key);\n            }\n            this._min("minX", value);\n            this._max("maxX", value);\n          }\n        });\n        each(this._valueYShowFields, key => {\n          let value = dataItem.get(key);\n          if (value != null) {\n            if (stacked) {\n              value += this.getStackedYValue(dataItem, key);\n            }\n            this._min("minY", value);\n            this._max("maxY", value);\n          }\n        });\n        xAxis.processSeriesDataItem(dataItem, this._valueXFields);\n        yAxis.processSeriesDataItem(dataItem, this._valueYFields);\n      });\n      xAxis._seriesValuesDirty = true;\n      yAxis._seriesValuesDirty = true;\n      if (!this.get("ignoreMinMax")) {\n        if (this.isPrivateDirty("minX") || this.isPrivateDirty("maxX")) {\n          xAxis.markDirtyExtremes();\n        }\n        if (this.isPrivateDirty("minY") || this.isPrivateDirty("maxY")) {\n          yAxis.markDirtyExtremes();\n        }\n      }\n      this._markStakedDirtyStack();\n      //this.updateLegendMarker(undefined); // causes legend marker to change color instantly when on\n      if (!this.get("tooltipDataItem")) {\n        this.updateLegendValue(undefined);\n      }\n    }\n    if (this.isDirty("vcx") || this.isDirty("vcy")) {\n      this._markStakedDirtyStack();\n    }\n    if (!this._dataGrouped) {\n      xAxis._groupSeriesData(this);\n      yAxis._groupSeriesData(this);\n      this._dataGrouped = true;\n    }\n    if (this._valuesDirty || this.isPrivateDirty("startIndex") || this.isPrivateDirty("adjustedStartIndex") || this.isPrivateDirty("endIndex") || this.isDirty("vcx") || this.isDirty("vcy") || this._stackDirty || this._sizeDirty) {\n      let startIndex = this.startIndex();\n      let endIndex = this.endIndex();\n      let minBulletDistance = this.get("minBulletDistance", 0);\n      if (minBulletDistance > 0 && baseAxis) {\n        if (baseAxis.get("renderer").axisLength() / (endIndex - startIndex) > minBulletDistance) {\n          this._showBullets = true;\n        } else {\n          this._showBullets = false;\n        }\n      }\n      if ((this._psi != startIndex || this._pei != endIndex || this.isDirty("vcx") || this.isDirty("vcy") || this.isPrivateDirty("adjustedStartIndex") || this._stackDirty || this._valuesDirty) && !this._selectionProcessed) {\n        this._selectionProcessed = true;\n        const vcx = this.get("vcx", 1);\n        const vcy = this.get("vcy", 1);\n        const stacked = this.get("stacked", false);\n        const outOfSelection = this.getPrivate("outOfSelection");\n        if (baseAxis === xAxis || !baseAxis) {\n          yAxis._calculateTotals();\n          this.setPrivateRaw("selectionMinY", undefined);\n          this.setPrivateRaw("selectionMaxY", undefined);\n          if (!outOfSelection) {\n            for (let i = startIndex; i < endIndex; i++) {\n              this.processYSelectionDataItem(this.dataItems[i], vcy, stacked);\n            }\n          } else {\n            yAxis.markDirtySelectionExtremes();\n          }\n        }\n        if (baseAxis === yAxis || !baseAxis) {\n          xAxis._calculateTotals();\n          this.setPrivateRaw("selectionMinX", undefined);\n          this.setPrivateRaw("selectionMaxX", undefined);\n          if (!outOfSelection) {\n            for (let i = startIndex; i < endIndex; i++) {\n              this.processXSelectionDataItem(this.dataItems[i], vcx, stacked);\n            }\n          } else {\n            yAxis.markDirtySelectionExtremes();\n          }\n        }\n        if (baseAxis === xAxis || !baseAxis) {\n          if (this.get("valueYShow") !== "valueYWorking") {\n            const selectionMinY = this.getPrivate("selectionMinY");\n            if (selectionMinY != null) {\n              this.setPrivateRaw("minY", selectionMinY);\n              yAxis.markDirtyExtremes();\n            }\n            const selectionMaxY = this.getPrivate("selectionMaxY");\n            if (selectionMaxY != null) {\n              this.setPrivateRaw("maxY", selectionMaxY);\n              yAxis.markDirtyExtremes();\n            }\n          }\n        }\n        if (baseAxis === yAxis || !baseAxis) {\n          if (this.get("valueXShow") !== "valueXWorking") {\n            const selectionMinX = this.getPrivate("selectionMinX");\n            if (selectionMinX != null) {\n              this.setPrivateRaw("minX", selectionMinX);\n              yAxis.markDirtyExtremes();\n            }\n            const selectionMaxX = this.getPrivate("selectionMaxX");\n            if (selectionMaxX != null) {\n              this.setPrivateRaw("maxX", selectionMaxX);\n              xAxis.markDirtyExtremes();\n            }\n          }\n        }\n        if (this.isPrivateDirty("selectionMinX") || this.isPrivateDirty("selectionMaxX")) {\n          xAxis.markDirtySelectionExtremes();\n        }\n        if (this.isPrivateDirty("selectionMinY") || this.isPrivateDirty("selectionMaxY")) {\n          yAxis.markDirtySelectionExtremes();\n        }\n        // this.updateLegendValue(undefined); flickers while panning\n      }\n    }\n  }\n\n  _makeRangeMask() {\n    if (this.axisRanges.length > 0) {\n      let mainContainerMask = this._mainContainerMask;\n      if (mainContainerMask == null) {\n        mainContainerMask = this.children.push(Graphics.new(this._root, {}));\n        this._mainContainerMask = mainContainerMask;\n        mainContainerMask.set("draw", (display, target) => {\n          const parent = this.parent;\n          if (parent) {\n            const w = this._root.container.width();\n            const h = this._root.container.height();\n            display.moveTo(-w, -h);\n            display.lineTo(-w, h * 2);\n            display.lineTo(w * 2, h * 2);\n            display.lineTo(w * 2, -h);\n            display.lineTo(-w, -h);\n            this.axisRanges.each(axisRange => {\n              const fill = axisRange.axisDataItem.get("axisFill");\n              if (parent) {\n                if (fill) {\n                  let draw = fill.get("draw");\n                  if (draw) {\n                    draw(display, target);\n                  }\n                }\n              }\n            });\n          }\n          this.mainContainer._display.mask = mainContainerMask._display;\n        });\n      }\n      mainContainerMask.markDirty();\n      mainContainerMask._markDirtyKey("fill");\n    } else {\n      this.mainContainer._display.mask = null;\n    }\n  }\n  _updateChildren() {\n    super._updateChildren();\n    // save for performance\n    this._x = this.x();\n    this._y = this.y();\n    this._makeRangeMask();\n  }\n  _stack() {\n    const chart = this.chart;\n    if (chart) {\n      const seriesIndex = chart.series.indexOf(this);\n      this._couldStackTo = [];\n      if (seriesIndex > 0) {\n        let series;\n        for (let i = seriesIndex - 1; i >= 0; i--) {\n          series = chart.series.getIndex(i);\n          if (series.get("xAxis") === this.get("xAxis") && series.get("yAxis") === this.get("yAxis") && series.className === this.className) {\n            this._couldStackTo.push(series);\n            if (!series.get("stacked")) {\n              break;\n            }\n          }\n        }\n      }\n      this._stackDataItems();\n    }\n  }\n  _unstack() {\n    Object_each(this._reallyStackedTo, (_key, value) => {\n      delete value._stackedSeries[this.uid];\n    });\n    this._reallyStackedTo = {};\n    each(this.dataItems, dataItem => {\n      dataItem.setRaw("stackToItemY", undefined);\n      dataItem.setRaw("stackToItemX", undefined);\n    });\n  }\n  _stackDataItems() {\n    // this works only with the same number of data @todo: search by date/category?\n    const baseAxis = this.get("baseAxis");\n    const xAxis = this.get("xAxis");\n    const yAxis = this.get("yAxis");\n    let field;\n    let stackToItemKey;\n    if (baseAxis === xAxis) {\n      field = "valueY";\n      stackToItemKey = "stackToItemY";\n    } else if (baseAxis === yAxis) {\n      field = "valueX";\n      stackToItemKey = "stackToItemX";\n    }\n    let len = this._couldStackTo.length;\n    let index = 0;\n    const stackToNegative = this.get("stackToNegative");\n    this._reallyStackedTo = {};\n    each(this.dataItems, dataItem => {\n      for (let s = 0; s < len; s++) {\n        let stackToSeries = this._couldStackTo[s];\n        let stackToItem = stackToSeries.dataItems[index];\n        let value = dataItem.get(field);\n        if (stackToItem) {\n          let stackValue = stackToItem.get(field);\n          if (stackToNegative) {\n            if (Type_isNumber(value)) {\n              if (Type_isNumber(stackValue)) {\n                if (value >= 0 && stackValue >= 0) {\n                  dataItem.setRaw(stackToItemKey, stackToItem);\n                  this._reallyStackedTo[stackToSeries.uid] = stackToSeries;\n                  stackToSeries._stackedSeries[this.uid] = this;\n                  break;\n                }\n                if (value < 0 && stackValue < 0) {\n                  dataItem.setRaw(stackToItemKey, stackToItem);\n                  this._reallyStackedTo[stackToSeries.uid] = stackToSeries;\n                  stackToSeries._stackedSeries[this.uid] = this;\n                  break;\n                }\n              }\n            } else {\n              break;\n            }\n          } else {\n            if (Type_isNumber(value) && Type_isNumber(stackValue)) {\n              dataItem.setRaw(stackToItemKey, stackToItem);\n              this._reallyStackedTo[stackToSeries.uid] = stackToSeries;\n              stackToSeries._stackedSeries[this.uid] = this;\n              break;\n            }\n          }\n        }\n      }\n      index++;\n    });\n  }\n  processXSelectionDataItem(dataItem, vcx, stacked) {\n    each(this.__valueXShowFields, key => {\n      let value = dataItem.get(key);\n      if (value != null) {\n        if (stacked) {\n          value += this.getStackedXValueWorking(dataItem, key);\n        }\n        this._min("selectionMinX", value);\n        this._max("selectionMaxX", value * vcx);\n      }\n    });\n  }\n  processYSelectionDataItem(dataItem, vcy, stacked) {\n    each(this.__valueYShowFields, key => {\n      let value = dataItem.get(key);\n      if (value != null) {\n        if (stacked) {\n          value += this.getStackedYValueWorking(dataItem, key);\n        }\n        this._min("selectionMinY", value);\n        this._max("selectionMaxY", value * vcy);\n      }\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  getStackedYValueWorking(dataItem, key) {\n    const stackToItem = dataItem.get("stackToItemY");\n    if (stackToItem) {\n      const stackedToSeries = stackToItem.component;\n      return stackToItem.get(key, 0) * stackedToSeries.get("vcy", 1) + this.getStackedYValueWorking(stackToItem, key);\n    }\n    return 0;\n  }\n  /**\r\n   * @ignore\r\n   */\n  getStackedXValueWorking(dataItem, key) {\n    const stackToItem = dataItem.get("stackToItemX");\n    if (stackToItem) {\n      const stackedToSeries = stackToItem.component;\n      return stackToItem.get(key, 0) * stackedToSeries.get("vcx", 1) + this.getStackedXValueWorking(stackToItem, key);\n    }\n    return 0;\n  }\n  /**\r\n   * @ignore\r\n   */\n  getStackedYValue(dataItem, key) {\n    const stackToItem = dataItem.get("stackToItemY");\n    if (stackToItem) {\n      return stackToItem.get(key, 0) + this.getStackedYValue(stackToItem, key);\n    }\n    return 0;\n  }\n  /**\r\n   * @ignore\r\n   */\n  getStackedXValue(dataItem, key) {\n    const stackToItem = dataItem.get("stackToItemX");\n    if (stackToItem) {\n      return stackToItem.get(key, 0) + this.getStackedXValue(stackToItem, key);\n    }\n    return 0;\n  }\n  /**\r\n   * @ignore\r\n   */\n  createLegendMarker(_dataItem) {\n    this.updateLegendMarker();\n  }\n  _markDirtyAxes() {\n    this._axesDirty = true;\n    this.markDirty();\n  }\n  _markDataSetDirty() {\n    this._afterDataChange();\n    this._valuesDirty = true;\n    this._dataProcessed = false;\n    this._aggregatesCalculated = false;\n    this.markDirty();\n  }\n  _clearDirty() {\n    super._clearDirty();\n    this._axesDirty = false;\n    this._selectionProcessed = false;\n    this._stackDirty = false;\n    this._dataProcessed = false;\n  }\n  _positionBullet(bullet) {\n    let sprite = bullet.get("sprite");\n    if (sprite) {\n      let dataItem = sprite.dataItem;\n      let locationX = bullet.get("locationX", dataItem.get("locationX", 0.5));\n      let locationY = bullet.get("locationY", dataItem.get("locationY", 0.5));\n      let xAxis = this.get("xAxis");\n      let yAxis = this.get("yAxis");\n      let positionX = xAxis.getDataItemPositionX(dataItem, this._xField, locationX, this.get("vcx", 1));\n      let positionY = yAxis.getDataItemPositionY(dataItem, this._yField, locationY, this.get("vcy", 1));\n      let point = this.getPoint(positionX, positionY);\n      let left = dataItem.get("left", point.x);\n      let right = dataItem.get("right", point.x);\n      let top = dataItem.get("top", point.y);\n      let bottom = dataItem.get("bottom", point.y);\n      let x = 0;\n      let y = 0;\n      let w = right - left;\n      let h = bottom - top;\n      if (this._shouldShowBullet(positionX, positionY)) {\n        sprite.setPrivate("visible", !bullet.getPrivate("hidden"));\n        let field = bullet.get("field");\n        const baseAxis = this.get("baseAxis");\n        const xAxis = this.get("xAxis");\n        const yAxis = this.get("yAxis");\n        if (field != undefined) {\n          let realField;\n          if (baseAxis == xAxis) {\n            if (field == "value") {\n              realField = this._yField;\n            } else if (field == "open") {\n              realField = this._yOpenField;\n            } else if (field == "high") {\n              realField = this._yHighField;\n            } else if (field == "low") {\n              realField = this._yLowField;\n            }\n            if (realField) {\n              positionY = yAxis.getDataItemPositionY(dataItem, realField, 0, this.get("vcy", 1));\n              point = yAxis.get("renderer").positionToPoint(positionY);\n              y = point.y;\n              x = left + w * locationX;\n            }\n          } else {\n            if (field == "value") {\n              realField = this._xField;\n            } else if (field == "open") {\n              realField = this._xOpenField;\n            } else if (field == "high") {\n              realField = this._xHighField;\n            } else if (field == "low") {\n              realField = this._xLowField;\n            }\n            if (realField) {\n              positionX = xAxis.getDataItemPositionX(dataItem, realField, 0, this.get("vcx", 1));\n              point = xAxis.get("renderer").positionToPoint(positionX);\n              x = point.x;\n              y = bottom - h * locationY;\n            }\n          }\n        } else {\n          x = left + w * locationX;\n          y = bottom - h * locationY;\n        }\n        const stacked = bullet.get("stacked");\n        if (stacked) {\n          const chart = this.chart;\n          if (baseAxis == xAxis) {\n            let previousBullet = this._bullets[positionX + "_" + positionY];\n            if (previousBullet) {\n              let previousBounds = previousBullet.bounds();\n              let bounds = sprite.localBounds();\n              let yo = y;\n              y = previousBounds.top;\n              if (stacked == "down") {\n                y = previousBounds.bottom - bounds.top;\n              } else if (stacked == "auto") {\n                if (chart) {\n                  if (yo < chart.plotContainer.height() / 2) {\n                    y = previousBounds.bottom - bounds.top;\n                  } else {\n                    y += bounds.bottom;\n                  }\n                }\n              } else {\n                y += bounds.bottom;\n              }\n            }\n            this._bullets[positionX + "_" + positionY] = sprite;\n          } else {\n            let previousBullet = this._bullets[positionX + "_" + positionY];\n            if (previousBullet) {\n              let previousBounds = previousBullet.bounds();\n              let bounds = sprite.localBounds();\n              let xo = x;\n              x = previousBounds.right;\n              if (stacked == "down") {\n                x = previousBounds.left - bounds.right;\n              } else if (stacked == "auto") {\n                if (chart) {\n                  if (xo < chart.plotContainer.width() / 2) {\n                    x = previousBounds.left - bounds.right;\n                  } else {\n                    x -= bounds.left;\n                  }\n                }\n              } else {\n                x -= bounds.left;\n              }\n            }\n            this._bullets[positionX + "_" + positionY] = sprite;\n          }\n        }\n        if (sprite.isType("Label")) {\n          sprite.setPrivate("maxWidth", Math.abs(w));\n          sprite.setPrivate("maxHeight", Math.abs(h));\n        }\n        sprite.setAll({\n          x,\n          y\n        });\n      } else {\n        sprite.setPrivate("visible", false);\n      }\n    }\n  }\n  _shouldShowBullet(_positionX, _positionY) {\n    return this._showBullets;\n  }\n  /**\r\n   * @ignore\r\n   */\n  setDataSet(id) {\n    if (this._dataSets[id]) {\n      this._handleDataSetChange();\n      this._dataItems = this._dataSets[id];\n      this._markDataSetDirty();\n      this._dataSetId = id;\n      const type = "datasetchanged";\n      if (this.events.isEnabled(type)) {\n        this.events.dispatch(type, {\n          type: type,\n          target: this,\n          id: id\n        });\n      }\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  resetGrouping() {\n    Object_each(this._dataSets, (_key, dataSet) => {\n      if (dataSet != this._mainDataItems) {\n        each(dataSet, dataItem => {\n          this.disposeDataItem(dataItem);\n        });\n      }\n    });\n    this._dataSets = {};\n    this._dataItems = this.mainDataItems;\n  }\n  _handleDataSetChange() {\n    each(this._dataItems, dataItem => {\n      let bullets = dataItem.bullets;\n      if (bullets) {\n        each(bullets, bullet => {\n          if (bullet) {\n            let sprite = bullet.get("sprite");\n            if (sprite) {\n              sprite.setPrivate("visible", false);\n            }\n          }\n        });\n      }\n    });\n    this._selectionProcessed = false; // for totals to be calculated\n  }\n  /**\r\n   * Shows hidden series.\r\n   *\r\n   * @param   duration  Duration of animation in milliseconds\r\n   * @return            Animation promise\r\n   */\n  show(duration) {\n    const _super = Object.create(null, {\n      show: {\n        get: () => super.show\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      this._fixVC();\n      let promises = [];\n      promises.push(_super.show.call(this, duration).then(() => {\n        this._isShowing = false;\n        let xAxis = this.get("xAxis");\n        let yAxis = this.get("yAxis");\n        let baseAxis = this.get("baseAxis");\n        if (yAxis !== baseAxis) {\n          yAxis.markDirtySelectionExtremes();\n        }\n        if (xAxis !== baseAxis) {\n          xAxis.markDirtySelectionExtremes();\n        }\n      }));\n      promises.push(this.bulletsContainer.show(duration));\n      promises.push(this._sequencedShowHide(true, duration));\n      yield Promise.all(promises);\n    });\n  }\n  /**\r\n   * Hides series.\r\n   *\r\n   * @param   duration  Duration of animation in milliseconds\r\n   * @return            Animation promise\r\n   */\n  hide(duration) {\n    const _super = Object.create(null, {\n      hide: {\n        get: () => super.hide\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      this._fixVC();\n      let promises = [];\n      promises.push(_super.hide.call(this, duration).then(() => {\n        this._isHiding = false;\n      }));\n      promises.push(this.bulletsContainer.hide(duration));\n      promises.push(this._sequencedShowHide(false, duration));\n      yield Promise.all(promises);\n    });\n  }\n  /**\r\n   * Shows series\'s data item.\r\n   *\r\n   * @param   dataItem  Data item\r\n   * @param   duration  Animation duration in milliseconds\r\n   * @return            Promise\r\n   */\n  showDataItem(dataItem, duration) {\n    const _super = Object.create(null, {\n      showDataItem: {\n        get: () => super.showDataItem\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const promises = [_super.showDataItem.call(this, dataItem, duration)];\n      if (!Type_isNumber(duration)) {\n        duration = this.get("stateAnimationDuration", 0);\n      }\n      const easing = this.get("stateAnimationEasing");\n      each(this._valueFields, key => {\n        promises.push(dataItem.animate({\n          key: key + "Working",\n          to: dataItem.get(key),\n          duration: duration,\n          easing: easing\n        }).waitForStop());\n      });\n      yield Promise.all(promises);\n    });\n  }\n  /**\r\n   * Hides series\'s data item.\r\n   *\r\n   * @param   dataItem  Data item\r\n   * @param   duration  Animation duration in milliseconds\r\n   * @return            Promise\r\n   */\n  hideDataItem(dataItem, duration) {\n    const _super = Object.create(null, {\n      hideDataItem: {\n        get: () => super.hideDataItem\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const promises = [_super.hideDataItem.call(this, dataItem, duration)];\n      const hiddenState = this.states.create("hidden", {});\n      if (!Type_isNumber(duration)) {\n        duration = hiddenState.get("stateAnimationDuration", this.get("stateAnimationDuration", 0));\n      }\n      const easing = hiddenState.get("stateAnimationEasing", this.get("stateAnimationEasing"));\n      const xAxis = this.get("xAxis");\n      const yAxis = this.get("yAxis");\n      const baseAxis = this.get("baseAxis");\n      const stacked = this.get("stacked");\n      if (baseAxis === xAxis || !baseAxis) {\n        each(this._valueYFields, key => {\n          let min = yAxis.getPrivate("min");\n          let baseValue = yAxis.baseValue();\n          if (Type_isNumber(min) && min > baseValue) {\n            baseValue = min;\n          }\n          if (stacked) {\n            baseValue = 0;\n          }\n          let value = dataItem.get(key);\n          if (value != null) {\n            promises.push(dataItem.animate({\n              key: key + "Working",\n              to: baseValue,\n              duration: duration,\n              easing: easing\n            }).waitForStop());\n          }\n        });\n      }\n      if (baseAxis === yAxis || !baseAxis) {\n        let min = xAxis.getPrivate("min");\n        let baseValue = xAxis.baseValue();\n        if (Type_isNumber(min) && min > baseValue) {\n          baseValue = min;\n        }\n        if (stacked) {\n          baseValue = 0;\n        }\n        each(this._valueXFields, key => {\n          let value = dataItem.get(key);\n          if (value != null) {\n            promises.push(dataItem.animate({\n              key: key + "Working",\n              to: baseValue,\n              duration: duration,\n              easing: easing\n            }).waitForStop());\n          }\n        });\n      }\n      yield Promise.all(promises);\n    });\n  }\n  _markDirtyStack() {\n    this._stackDirty = true;\n    this.markDirty();\n    this._markStakedDirtyStack();\n  }\n  _markStakedDirtyStack() {\n    const stackedSeries = this._stackedSeries;\n    if (stackedSeries) {\n      Object_each(stackedSeries, (_key, value) => {\n        if (!value._stackDirty) {\n          value._markDirtyStack();\n        }\n      });\n    }\n  }\n  _afterChanged() {\n    super._afterChanged();\n    if (this._skipped) {\n      this._markDirtyAxes();\n      this._skipped = false;\n    }\n  }\n  /**\r\n   * Shows a tooltip for specific data item.\r\n   *\r\n   * @param  dataItem  Data item\r\n   */\n  showDataItemTooltip(dataItem) {\n    if (!this.getPrivate("doNotUpdateLegend")) {\n      this.updateLegendMarker(dataItem);\n      this.updateLegendValue(dataItem);\n    }\n    const tooltip = this.get("tooltip");\n    if (tooltip) {\n      if (!this.isHidden() && this.get("visible")) {\n        tooltip._setDataItem(dataItem);\n        if (dataItem) {\n          let locationX = this.get("locationX", 0);\n          let locationY = this.get("locationY", 1);\n          let itemLocationX = dataItem.get("locationX", locationX);\n          let itemLocationY = dataItem.get("locationY", locationY);\n          const xAxis = this.get("xAxis");\n          const yAxis = this.get("yAxis");\n          const vcx = this.get("vcx", 1);\n          const vcy = this.get("vcy", 1);\n          const xPos = xAxis.getDataItemPositionX(dataItem, this._tooltipFieldX, this._aLocationX0 + (this._aLocationX1 - this._aLocationX0) * itemLocationX, vcx);\n          const yPos = yAxis.getDataItemPositionY(dataItem, this._tooltipFieldY, this._aLocationY0 + (this._aLocationY1 - this._aLocationY0) * itemLocationY, vcy);\n          const point = this.getPoint(xPos, yPos);\n          let show = true;\n          each(this._valueFields, field => {\n            if (dataItem.get(field) == null) {\n              show = false;\n            }\n          });\n          if (show) {\n            const chart = this.chart;\n            if (chart && chart.inPlot(point)) {\n              tooltip.label.text.markDirtyText();\n              tooltip.set("tooltipTarget", this._getTooltipTarget(dataItem));\n              tooltip.set("pointTo", this._display.toGlobal({\n                x: point.x,\n                y: point.y\n              }));\n            } else {\n              tooltip._setDataItem(undefined);\n            }\n          } else {\n            tooltip._setDataItem(undefined);\n          }\n        }\n      } else {\n        this.hideTooltip();\n      }\n    }\n  }\n  hideTooltip() {\n    const tooltip = this.get("tooltip");\n    if (tooltip) {\n      tooltip.set("tooltipTarget", this);\n    }\n    return super.hideTooltip();\n  }\n  _getTooltipTarget(dataItem) {\n    if (this.get("seriesTooltipTarget") == "bullet") {\n      const bullets = dataItem.bullets;\n      if (bullets && bullets.length > 0) {\n        const bullet = bullets[0];\n        const sprite = bullet.get("sprite");\n        if (sprite) {\n          return sprite;\n        }\n      }\n    }\n    return this;\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateLegendValue(dataItem) {\n    const legendDataItem = this.get("legendDataItem");\n    if (legendDataItem) {\n      const label = legendDataItem.get("label");\n      if (label) {\n        let txt = "";\n        if (dataItem) {\n          label._setDataItem(dataItem);\n          txt = this.get("legendLabelText", label.get("text", this.get("name", "")));\n        } else {\n          label._setDataItem(this._emptyDataItem);\n          txt = this.get("legendRangeLabelText", this.get("legendLabelText", label.get("text", this.get("name", ""))));\n        }\n        label.set("text", txt);\n      }\n      const valueLabel = legendDataItem.get("valueLabel");\n      if (valueLabel) {\n        let txt = "";\n        if (dataItem) {\n          valueLabel._setDataItem(dataItem);\n          txt = this.get("legendValueText", valueLabel.get("text", ""));\n        } else {\n          valueLabel._setDataItem(this._emptyDataItem);\n          txt = this.get("legendRangeValueText", valueLabel.get("text", ""));\n        }\n        valueLabel.set("text", txt);\n      }\n    }\n  }\n  _getItemReaderLabel() {\n    let text = "X: {" + this._xField;\n    if (this.get("xAxis").isType("DateAxis")) {\n      text += ".formatDate()";\n    }\n    text += "}; Y: {" + this._yField;\n    if (this.get("yAxis").isType("DateAxis")) {\n      text += ".formatDate()";\n    }\n    text += "}";\n    return text;\n  }\n  /**\r\n   * @ignore\r\n   */\n  getPoint(positionX, positionY) {\n    let x = this.get("xAxis").get("renderer").positionToCoordinate(positionX);\n    let y = this.get("yAxis").get("renderer").positionToCoordinate(positionY);\n    // if coordinate is super big, canvas fails to draw line, capping to some big number (won\'t make any visual difference)\n    let max = 999999999;\n    if (y < -max) {\n      y = -max;\n    }\n    if (y > max) {\n      y = max;\n    }\n    if (x < -max) {\n      x = -max;\n    }\n    if (x > max) {\n      x = max;\n    }\n    return {\n      x: x,\n      y: y\n    };\n  }\n  _shouldInclude(_position) {\n    return true;\n  }\n  /**\r\n   * @ignore\r\n   */\n  handleCursorHide() {\n    this.hideTooltip();\n    this.updateLegendValue(undefined);\n    this.updateLegendMarker(undefined);\n  }\n  _afterDataChange() {\n    super._afterDataChange();\n    this.get("xAxis")._markDirtyKey("start");\n    this.get("yAxis")._markDirtyKey("start");\n    this.resetExtremes();\n  }\n  /**\r\n   * Resets cached axis scale values.\r\n   */\n  resetExtremes() {\n    this.setPrivate("selectionMinX", undefined);\n    this.setPrivate("selectionMaxX", undefined);\n    this.setPrivate("selectionMinY", undefined);\n    this.setPrivate("selectionMaxY", undefined);\n    this.setPrivate("minX", undefined);\n    this.setPrivate("minY", undefined);\n    this.setPrivate("maxX", undefined);\n    this.setPrivate("maxY", undefined);\n  }\n  /**\r\n   * Creates and returns an axis range object.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info\r\n   * @param   axisDataItem  Axis data item\r\n   * @return                Axis range\r\n   */\n  createAxisRange(axisDataItem) {\n    return this.axisRanges.push({\n      axisDataItem: axisDataItem\n    });\n  }\n  /**\r\n   * A list of series\'s main (ungrouped) data items.\r\n   *\r\n   * @return  Data items\r\n   */\n  get mainDataItems() {\n    return this._mainDataItems;\n  }\n  /**\r\n   * @ignore\r\n   */\n  _adjustStartIndex(index) {\n    const xAxis = this.get("xAxis");\n    const baseAxis = this.get("baseAxis");\n    if (baseAxis == xAxis && xAxis.isType("DateAxis")) {\n      const baseDuration = xAxis.baseDuration();\n      const minSelection = xAxis.getPrivate("selectionMin", xAxis.getPrivate("min", 0));\n      const dl = baseDuration * this.get("locationX", 0.5);\n      let value = -Infinity;\n      while (value < minSelection) {\n        const dataItem = this.dataItems[index];\n        if (dataItem) {\n          const open = dataItem.open;\n          if (open) {\n            value = open["valueX"];\n          } else {\n            value = dataItem.get("valueX", 0);\n          }\n          value += dl;\n          if (value < minSelection) {\n            index++;\n          } else {\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    return index;\n  }\n}\nObject.defineProperty(XYSeries, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "XYSeries"\n});\nObject.defineProperty(XYSeries, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Series.classNames.concat([XYSeries.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/BaseColumnSeries.js\n\n\n\n\n\n\n/**\r\n * Base class for all "column-based" series\r\n */\nclass BaseColumnSeries extends XYSeries {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_ph", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_pw", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n  }\n  _makeGraphics(listTemplate, dataItem) {\n    return this.makeColumn(dataItem, listTemplate);\n  }\n  _makeFieldNames() {\n    super._makeFieldNames();\n    const xAxis = this.get("xAxis");\n    const yAxis = this.get("yAxis");\n    const categoryAxis = "CategoryAxis";\n    const valueAxis = "ValueAxis";\n    if (xAxis.isType(categoryAxis)) {\n      if (!this.get("openCategoryXField")) {\n        this._xOpenField = this._xField;\n      }\n    }\n    if (xAxis.isType(valueAxis)) {\n      if (!this.get("openValueXField")) {\n        this._xOpenField = this._xField;\n      }\n    }\n    if (yAxis.isType(categoryAxis)) {\n      if (!this.get("openCategoryYField")) {\n        this._yOpenField = this._yField;\n      }\n    }\n    if (yAxis.isType(valueAxis)) {\n      if (!this.get("openValueYField")) {\n        this._yOpenField = this._yField;\n      }\n    }\n  }\n  _prepareChildren() {\n    super._prepareChildren();\n    const xAxis = this.get("xAxis");\n    const yAxis = this.get("yAxis");\n    const len = this.dataItems.length;\n    const startIndex = Math.max(0, this.startIndex() - 2);\n    const endIndex = Math.min(this.endIndex() + 2, len - 1);\n    if (xAxis.inited && yAxis.inited) {\n      for (let i = startIndex; i <= endIndex; i++) {\n        let dataItem = this.dataItems[i];\n        this._createGraphics(dataItem);\n      }\n    }\n  }\n  _updateChildren() {\n    const chart = this.chart;\n    if (chart) {\n      this._ph = chart.plotContainer.height();\n      this._pw = chart.plotContainer.width();\n    }\n    const xAxis = this.get("xAxis");\n    const yAxis = this.get("yAxis");\n    const baseAxis = this.get("baseAxis");\n    const columnsTemplate = this.columns.template;\n    if (this.isDirty("fill")) {\n      if (columnsTemplate.get("fill") == null) {\n        columnsTemplate.set("fill", this.get("fill"));\n      }\n    }\n    if (this.isDirty("stroke")) {\n      if (columnsTemplate.get("stroke") == null) {\n        columnsTemplate.set("stroke", this.get("stroke"));\n      }\n    }\n    let index = 0;\n    let clusterCount = 0;\n    let i = 0;\n    each(baseAxis.series, series => {\n      if (series instanceof BaseColumnSeries) {\n        const stacked = series.get("stacked");\n        if (stacked && i == 0) {\n          clusterCount++;\n        }\n        if (!stacked && series.get("clustered")) {\n          clusterCount++;\n        }\n      }\n      if (series === this) {\n        index = clusterCount - 1;\n      }\n      i++;\n    });\n    if (!this.get("clustered")) {\n      index = 0;\n      clusterCount = 1;\n    }\n    if (clusterCount === 0) {\n      clusterCount = 1;\n      index = 0;\n    }\n    const xRenderer = xAxis.get("renderer");\n    const yRenderer = yAxis.get("renderer");\n    const cellStartLocation = "cellStartLocation";\n    const cellEndLocation = "cellEndLocation";\n    const cellLocationX0 = xRenderer.get(cellStartLocation, 0);\n    const cellLocationX1 = xRenderer.get(cellEndLocation, 1);\n    const cellLocationY0 = yRenderer.get(cellStartLocation, 0);\n    const cellLocationY1 = yRenderer.get(cellEndLocation, 1);\n    this._aLocationX0 = cellLocationX0 + index / clusterCount * (cellLocationX1 - cellLocationX0);\n    this._aLocationX1 = cellLocationX0 + (index + 1) / clusterCount * (cellLocationX1 - cellLocationX0);\n    ;\n    this._aLocationY0 = cellLocationY0 + index / clusterCount * (cellLocationY1 - cellLocationY0);\n    this._aLocationY1 = cellLocationY0 + (index + 1) / clusterCount * (cellLocationY1 - cellLocationY0);\n    if (xAxis.inited && yAxis.inited) {\n      if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty("vcx") || this.isDirty("vcy") || this._sizeDirty) {\n        const len = this.dataItems.length;\n        let startIndex = Math.max(0, this.startIndex() - 2);\n        let endIndex = Math.min(this.endIndex() + 2, len - 1);\n        for (let i = 0; i < startIndex; i++) {\n          this._toggleColumn(this.dataItems[i], false);\n        }\n        let previous = this.dataItems[startIndex];\n        for (let i = startIndex; i <= endIndex; i++) {\n          let dataItem = this.dataItems[i];\n          if (dataItem.get("valueX") != null && dataItem.get("valueY") != null) {\n            previous = dataItem;\n            if (i > 0 && startIndex > 0) {\n              for (let j = i - 1; j >= 0; j--) {\n                let dataItem = this.dataItems[j];\n                if (dataItem.get("valueX") != null && dataItem.get("valueY") != null) {\n                  previous = dataItem;\n                  break;\n                }\n              }\n            }\n            break;\n          } else {\n            this._toggleColumn(dataItem, false);\n          }\n        }\n        for (let i = startIndex; i <= endIndex; i++) {\n          let dataItem = this.dataItems[i];\n          this._updateGraphics(dataItem, previous);\n          if (dataItem.get("valueX") != null && dataItem.get("valueY") != null) {\n            previous = dataItem;\n          }\n        }\n        for (let i = endIndex + 1; i < len; i++) {\n          this._toggleColumn(this.dataItems[i], false);\n        }\n      }\n    } else {\n      this._skipped = true;\n    }\n    this.updateLegendMarker(this.get("tooltipDataItem"));\n    super._updateChildren();\n  }\n  _createGraphics(dataItem) {\n    let graphics = dataItem.get("graphics");\n    if (!graphics) {\n      graphics = this._makeGraphics(this.columns, dataItem);\n      dataItem.set("graphics", graphics);\n      graphics._setDataItem(dataItem);\n      const legendDataItem = dataItem.get("legendDataItem");\n      if (legendDataItem) {\n        const markerRectangle = legendDataItem.get("markerRectangle");\n        if (markerRectangle) {\n          const ds = markerRectangle.states.lookup("default");\n          each(visualSettings, setting => {\n            const value = graphics.get(setting, this.get(setting));\n            markerRectangle.set(setting, value);\n            ds.set(setting, value);\n          });\n        }\n      }\n      let graphicsArray = dataItem.get("rangeGraphics");\n      if (graphicsArray) {\n        each(graphicsArray, graphics => {\n          graphics.dispose();\n        });\n      }\n      graphicsArray = [];\n      dataItem.setRaw("rangeGraphics", graphicsArray);\n      this.axisRanges.each(axisRange => {\n        const container = axisRange.container;\n        const rangeGraphics = this._makeGraphics(axisRange.columns, dataItem);\n        if (graphicsArray) {\n          graphicsArray.push(rangeGraphics);\n        }\n        rangeGraphics.setPrivate("list", axisRange.columns);\n        container.children.push(rangeGraphics);\n      });\n    }\n  }\n  createAxisRange(axisDataItem) {\n    each(this.dataItems, dataItem => {\n      const graphics = dataItem.get("graphics");\n      if (graphics) {\n        graphics.dispose();\n        dataItem.set("graphics", undefined);\n      }\n    });\n    return super.createAxisRange(axisDataItem);\n  }\n  _updateGraphics(dataItem, previousDataItem) {\n    let graphics = dataItem.get("graphics");\n    //if (!graphics) {\n    //\tthis._createGraphics(dataItem);\n    //\tgraphics = dataItem.get("graphics")!;\n    //}\n    const xField = this._xField;\n    const yField = this._yField;\n    const valueX = dataItem.get(xField);\n    const valueY = dataItem.get(yField);\n    if (valueX != null && valueY != null) {\n      const xOpenField = this._xOpenField;\n      const yOpenField = this._yOpenField;\n      const locationX = this.get("locationX", dataItem.get("locationX", 0.5));\n      const locationY = this.get("locationY", dataItem.get("locationY", 0.5));\n      const openLocationX = this.get("openLocationX", dataItem.get("openLocationX", locationX));\n      const openLocationY = this.get("openLocationY", dataItem.get("openLocationY", locationY));\n      const width = graphics.get("width");\n      const height = graphics.get("height");\n      const stacked = this.get("stacked");\n      const xAxis = this.get("xAxis");\n      const yAxis = this.get("yAxis");\n      const baseAxis = this.get("baseAxis");\n      const xStart = xAxis.get("start");\n      const xEnd = xAxis.get("end");\n      const yStart = yAxis.get("start");\n      const yEnd = yAxis.get("end");\n      let l;\n      let r;\n      let t;\n      let b;\n      let vcy = this.get("vcy", 1);\n      let vcx = this.get("vcx", 1);\n      let fitW = false;\n      let fitH = false;\n      if (yAxis.isType("CategoryAxis") && xAxis.isType("CategoryAxis")) {\n        let startLocation = this._aLocationX0 + openLocationX - 0.5;\n        let endLocation = this._aLocationX1 + locationX - 0.5;\n        if (width instanceof Percent) {\n          let offset = (endLocation - startLocation) * (1 - width.value) / 2;\n          startLocation += offset;\n          endLocation -= offset;\n        }\n        l = xAxis.getDataItemPositionX(dataItem, xOpenField, startLocation, vcx);\n        r = xAxis.getDataItemPositionX(dataItem, xField, endLocation, vcx);\n        startLocation = this._aLocationY0 + openLocationY - 0.5;\n        endLocation = this._aLocationY1 + locationY - 0.5;\n        if (height instanceof Percent) {\n          let offset = (endLocation - startLocation) * (1 - height.value) / 2;\n          startLocation += offset;\n          endLocation -= offset;\n        }\n        t = yAxis.getDataItemPositionY(dataItem, yOpenField, startLocation, vcy);\n        b = yAxis.getDataItemPositionY(dataItem, yField, endLocation, vcy);\n        dataItem.setRaw("point", {\n          x: l + (r - l) / 2,\n          y: t + (b - t) / 2\n        });\n      } else if (xAxis === baseAxis) {\n        let startLocation = this._aLocationX0 + openLocationX - 0.5;\n        let endLocation = this._aLocationX1 + locationX - 0.5;\n        if (width instanceof Percent) {\n          let offset = (endLocation - startLocation) * (1 - width.value) / 2;\n          startLocation += offset;\n          endLocation -= offset;\n        }\n        l = xAxis.getDataItemPositionX(dataItem, xOpenField, startLocation, vcx);\n        r = xAxis.getDataItemPositionX(dataItem, xField, endLocation, vcx);\n        t = yAxis.getDataItemPositionY(dataItem, yField, locationY, vcy);\n        if (this._yOpenField !== this._yField) {\n          b = yAxis.getDataItemPositionY(dataItem, yOpenField, openLocationY, vcy);\n        } else {\n          if (stacked) {\n            let stackToItemY = dataItem.get("stackToItemY");\n            if (stackToItemY) {\n              b = yAxis.getDataItemPositionY(stackToItemY, yField, openLocationY, stackToItemY.component.get("vcy"));\n            } else {\n              b = yAxis.basePosition();\n            }\n          } else {\n            b = yAxis.basePosition();\n          }\n        }\n        dataItem.setRaw("point", {\n          x: l + (r - l) / 2,\n          y: t\n        });\n        fitH = true;\n      } else if (yAxis === baseAxis) {\n        let startLocation = this._aLocationY0 + openLocationY - 0.5;\n        let endLocation = this._aLocationY1 + locationY - 0.5;\n        if (height instanceof Percent) {\n          let offset = (endLocation - startLocation) * (1 - height.value) / 2;\n          startLocation += offset;\n          endLocation -= offset;\n        }\n        t = yAxis.getDataItemPositionY(dataItem, yOpenField, startLocation, vcy);\n        b = yAxis.getDataItemPositionY(dataItem, yField, endLocation, vcy);\n        r = xAxis.getDataItemPositionX(dataItem, xField, locationX, vcx);\n        if (this._xOpenField !== this._xField) {\n          l = xAxis.getDataItemPositionX(dataItem, xOpenField, openLocationX, vcx);\n        } else {\n          if (stacked) {\n            let stackToItemX = dataItem.get("stackToItemX");\n            if (stackToItemX) {\n              l = xAxis.getDataItemPositionX(stackToItemX, xField, openLocationX, stackToItemX.component.get("vcx"));\n            } else {\n              l = xAxis.basePosition();\n            }\n          } else {\n            l = xAxis.basePosition();\n          }\n        }\n        fitW = true;\n        dataItem.setRaw("point", {\n          x: r,\n          y: t + (b - t) / 2\n        });\n      }\n      this._updateSeriesGraphics(dataItem, graphics, l, r, t, b, fitW, fitH);\n      if (l < xStart && r < xStart || l > xEnd && r > xEnd || t < yStart && b <= yStart || t >= yEnd && b > yEnd || Type_isNaN(l) || Type_isNaN(t)) {\n        this._toggleColumn(dataItem, false);\n      } else {\n        this._toggleColumn(dataItem, true);\n      }\n      let rangeGraphics = dataItem.get("rangeGraphics");\n      if (rangeGraphics) {\n        each(rangeGraphics, graphics => {\n          this._updateSeriesGraphics(dataItem, graphics, l, r, t, b, fitW, fitH);\n        });\n      }\n      this._applyGraphicsStates(dataItem, previousDataItem);\n    }\n  }\n  _updateSeriesGraphics(dataItem, graphics, l, r, t, b, fitW, fitH) {\n    const width = graphics.get("width");\n    const height = graphics.get("height");\n    const maxWidth = graphics.get("maxWidth");\n    const maxHeight = graphics.get("maxHeight");\n    const ptl = this.getPoint(l, t);\n    const pbr = this.getPoint(r, b);\n    const tooltipPoint = dataItem.get("point");\n    if (tooltipPoint) {\n      const point = this.getPoint(tooltipPoint.x, tooltipPoint.y);\n      tooltipPoint.x = point.x + this._x;\n      tooltipPoint.y = point.y + this._y;\n    }\n    l = ptl.x;\n    r = pbr.x;\n    t = ptl.y;\n    b = pbr.y;\n    if (Type_isNumber(width)) {\n      const offset = (r - l - width) / 2;\n      l += offset;\n      r -= offset;\n    }\n    if (Type_isNumber(maxWidth) && maxWidth < Math.abs(r - l)) {\n      const offset = (r - l - maxWidth) / 2;\n      l += offset;\n      r -= offset;\n    }\n    if (Type_isNumber(height)) {\n      const offset = (b - t - height) / 2;\n      t += offset;\n      b -= offset;\n    }\n    if (Type_isNumber(maxHeight) && maxHeight < Math.abs(b - t)) {\n      const offset = (b - t - maxHeight) / 2;\n      t += offset;\n      b -= offset;\n    }\n    if (this.get("adjustBulletPosition")) {\n      if (fitW) {\n        r = Math.min(Math.max(0, r), this._pw);\n        l = Math.min(Math.max(0, l), this._pw);\n      }\n      if (fitH) {\n        t = Math.min(Math.max(0, t), this._ph);\n        b = Math.min(Math.max(0, b), this._ph);\n      }\n    }\n    dataItem.setRaw("left", l);\n    dataItem.setRaw("right", r);\n    dataItem.setRaw("top", t);\n    dataItem.setRaw("bottom", b);\n    graphics.setPrivate("width", r - l);\n    graphics.setPrivate("height", b - t);\n    graphics.set("x", l);\n    graphics.set("y", b - (b - t));\n  }\n  _handleDataSetChange() {\n    super._handleDataSetChange();\n    each(this._dataItems, dataItem => {\n      this._toggleColumn(dataItem, false);\n    });\n  }\n  _applyGraphicsStates(dataItem, previousDataItem) {\n    const graphics = dataItem.get("graphics");\n    const dropFromOpen = graphics.states.lookup("dropFromOpen");\n    const riseFromOpen = graphics.states.lookup("riseFromOpen");\n    const dropFromPrevious = graphics.states.lookup("dropFromPrevious");\n    const riseFromPrevious = graphics.states.lookup("riseFromPrevious");\n    if (dropFromOpen || dropFromPrevious || riseFromOpen || riseFromPrevious) {\n      const xAxis = this.get("xAxis");\n      const yAxis = this.get("yAxis");\n      const baseAxis = this.get("baseAxis");\n      let open;\n      let close;\n      let previousClose;\n      if (baseAxis === xAxis && yAxis.isType("ValueAxis")) {\n        open = dataItem.get(this._yOpenField);\n        close = dataItem.get(this._yField);\n        previousClose = previousDataItem.get(this._yField);\n      } else if (baseAxis === yAxis && xAxis.isType("ValueAxis")) {\n        open = dataItem.get(this._xOpenField);\n        close = dataItem.get(this._xField);\n        previousClose = previousDataItem.get(this._xField);\n      }\n      if (Type_isNumber(open) && Type_isNumber(close)) {\n        if (close < open) {\n          if (dropFromOpen) {\n            dropFromOpen.apply();\n          }\n        } else {\n          if (riseFromOpen) {\n            riseFromOpen.apply();\n          }\n        }\n        if (Type_isNumber(previousClose)) {\n          if (close < previousClose) {\n            if (dropFromPrevious) {\n              dropFromPrevious.apply();\n            }\n          } else {\n            if (riseFromPrevious) {\n              riseFromPrevious.apply();\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  disposeDataItem(dataItem) {\n    super.disposeDataItem(dataItem);\n    const graphics = dataItem.get("graphics");\n    if (graphics) {\n      this.columns.removeValue(graphics);\n      graphics.dispose();\n    }\n    const rangeGraphics = dataItem.get("rangeGraphics");\n    if (rangeGraphics) {\n      each(rangeGraphics, graphics => {\n        const list = graphics.getPrivate("list");\n        if (list) {\n          list.removeValue(graphics);\n        }\n        graphics.dispose();\n      });\n    }\n  }\n  /**\r\n   * Hides series\'s data item.\r\n   *\r\n   * @param   dataItem  Data item\r\n   * @param   duration  Animation duration in milliseconds\r\n   * @return            Promise\r\n   */\n  hideDataItem(dataItem, duration) {\n    const _super = Object.create(null, {\n      hideDataItem: {\n        get: () => super.hideDataItem\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const promises = [_super.hideDataItem.call(this, dataItem, duration)];\n      const graphics = dataItem.get("graphics");\n      if (graphics) {\n        promises.push(graphics.hide(duration));\n      }\n      const rangeGraphics = dataItem.get("rangeGraphics");\n      if (rangeGraphics) {\n        each(rangeGraphics, graphics => {\n          promises.push(graphics.hide(duration));\n        });\n      }\n      yield Promise.all(promises);\n    });\n  }\n  _toggleColumn(dataItem, visible) {\n    const graphics = dataItem.get("graphics");\n    if (graphics) {\n      graphics.setPrivate("visible", visible);\n    }\n    const rangeGraphics = dataItem.get("rangeGraphics");\n    if (rangeGraphics) {\n      each(rangeGraphics, graphics => {\n        graphics.setPrivate("visible", visible);\n      });\n    }\n    const bullets = dataItem.bullets;\n    if (bullets) {\n      each(bullets, bullet => {\n        bullet.setPrivate("hidden", !visible);\n      });\n    }\n  }\n  /**\r\n   * Shows series\'s data item.\r\n   *\r\n   * @param   dataItem  Data item\r\n   * @param   duration  Animation duration in milliseconds\r\n   * @return            Promise\r\n   */\n  showDataItem(dataItem, duration) {\n    const _super = Object.create(null, {\n      showDataItem: {\n        get: () => super.showDataItem\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const promises = [_super.showDataItem.call(this, dataItem, duration)];\n      const graphics = dataItem.get("graphics");\n      if (graphics) {\n        promises.push(graphics.show(duration));\n      }\n      const rangeGraphics = dataItem.get("rangeGraphics");\n      if (rangeGraphics) {\n        each(rangeGraphics, graphics => {\n          promises.push(graphics.show(duration));\n        });\n      }\n      yield Promise.all(promises);\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateLegendMarker(dataItem) {\n    let legendDataItem = this.get("legendDataItem");\n    if (this.get("useLastColorForLegendMarker")) {\n      if (!dataItem) {\n        const lastDataItem = this.dataItems[this.endIndex() - 1];\n        if (lastDataItem) {\n          dataItem = lastDataItem;\n        }\n      }\n    }\n    if (legendDataItem) {\n      let graphics = this.columns.template;\n      if (dataItem) {\n        let column = dataItem.get("graphics");\n        if (column) {\n          graphics = column;\n        }\n      }\n      const markerRectangle = legendDataItem.get("markerRectangle");\n      if (markerRectangle) {\n        if (!legendDataItem.get("itemContainer").get("disabled")) {\n          const ds = markerRectangle.states.lookup("default");\n          each(visualSettings, setting => {\n            const value = graphics.get(setting, this.get(setting));\n            markerRectangle.set(setting, value);\n            ds.set(setting, value);\n          });\n        }\n      }\n    }\n  }\n  _getTooltipTarget(dataItem) {\n    if (this.get("seriesTooltipTarget") == "bullet") {\n      return super._getTooltipTarget(dataItem);\n    }\n    let column = dataItem.get("graphics");\n    if (column) {\n      return column;\n    }\n    return this;\n  }\n}\nObject.defineProperty(BaseColumnSeries, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "BaseColumnSeries"\n});\nObject.defineProperty(BaseColumnSeries, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: XYSeries.classNames.concat([BaseColumnSeries.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/ColumnSeries.js\n\n\n\n\n\nclass ColumnSeries extends BaseColumnSeries {\n  constructor() {\n    super(...arguments);\n    /**\r\n     * A [[TemplateList]] of all columns in series.\r\n     *\r\n     * `columns.template` can be used to set default settings for all columns,\r\n     * or to change on existing ones.\r\n     */\n    Object.defineProperty(this, "columns", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListTemplate(Template.new({}), () => RoundedRectangle._new(this._root, {\n        position: "absolute",\n        themeTags: mergeTags(this.columns.template.get("themeTags", []), ["series", "column"])\n      }, [this.columns.template]))\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  makeColumn(dataItem, listTemplate) {\n    const column = this.mainContainer.children.push(listTemplate.make());\n    column._setDataItem(dataItem);\n    listTemplate.push(column);\n    return column;\n  }\n  _processAxisRange(axisRange) {\n    super._processAxisRange(axisRange);\n    axisRange.columns = new ListTemplate(Template.new({}), () => RoundedRectangle._new(this._root, {\n      position: "absolute",\n      themeTags: mergeTags(axisRange.columns.template.get("themeTags", []), ["series", "column"])\n    }, [this.columns.template, axisRange.columns.template]));\n  }\n}\nObject.defineProperty(ColumnSeries, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "ColumnSeries"\n});\nObject.defineProperty(ColumnSeries, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: BaseColumnSeries.classNames.concat([ColumnSeries.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYCursor.js\n\n\n\n\n//import { Animations } from "../core/util/Animation";\n\n\n\n\n\n/**\r\n * Creates a chart cursor for an [[XYChart]].\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/cursor/} for more info\r\n * @important\r\n */\nclass XYCursor extends Container {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_alwaysShow", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    /**\r\n     * A [[Grid]] elment that used for horizontal line of the cursor crosshair.\r\n     *\r\n     * @default Grid.new()\r\n     */\n    Object.defineProperty(this, "lineX", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.children.push(Grid.new(this._root, {\n        themeTags: ["x"]\n      }))\n    });\n    /**\r\n     * A [[Grid]] elment that used for horizontal line of the cursor crosshair.\r\n     *\r\n     * @default Grid.new()\r\n     */\n    Object.defineProperty(this, "lineY", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.children.push(Grid.new(this._root, {\n        themeTags: ["y"]\n      }))\n    });\n    /**\r\n     * An element that represents current selection.\r\n     *\r\n     * @default Graphics.new()\r\n     */\n    Object.defineProperty(this, "selection", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.children.push(Graphics.new(this._root, {\n        themeTags: ["selection", "cursor"],\n        layer: 30\n      }))\n    });\n    Object.defineProperty(this, "_movePoint", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_lastPoint", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {\n        x: 0,\n        y: 0\n      }\n    });\n    Object.defineProperty(this, "_lastPoint2", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {\n        x: 0,\n        y: 0\n      }\n    });\n    Object.defineProperty(this, "_tooltipX", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_tooltipY", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    /**\r\n     * A chart cursor is attached to.\r\n     */\n    Object.defineProperty(this, "chart", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_toX", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_toY", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  _afterNew() {\n    this._settings.themeTags = mergeTags(this._settings.themeTags, ["xy", "cursor"]);\n    super._afterNew();\n    this.setAll({\n      "width": p100,\n      height: p100,\n      isMeasured: true,\n      position: "absolute"\n    });\n    this.states.create("hidden", {\n      visible: true,\n      opacity: 0\n    });\n    this._drawLines();\n    this.setPrivateRaw("visible", false);\n    this._disposers.push(this.setTimeout(() => {\n      this.setPrivate("visible", true);\n    }, 500));\n    this._disposers.push(this.lineX.events.on("positionchanged", () => {\n      this._handleXLine();\n    }));\n    this._disposers.push(this.lineY.events.on("positionchanged", () => {\n      this._handleYLine();\n    }));\n    this._disposers.push(this.lineX.events.on("focus", () => this._handleLineFocus()));\n    this._disposers.push(this.lineX.events.on("blur", () => this._handleLineBlur()));\n    this._disposers.push(this.lineY.events.on("focus", () => this._handleLineFocus()));\n    this._disposers.push(this.lineY.events.on("blur", () => this._handleLineBlur()));\n    if (supports("keyboardevents")) {\n      this._disposers.push(Utils_addEventListener(document, "keydown", ev => {\n        this._handleLineMove(getEventKey(ev), ev.ctrlKey);\n      }));\n    }\n  }\n  _setUpTouch() {\n    const chart = this.chart;\n    if (chart) {\n      chart.plotContainer._display.cancelTouch = this.get("behavior") != "none" ? true : false;\n    }\n  }\n  _handleXLine() {\n    let x = this.lineX.x();\n    let visible = true;\n    if (x < 0 || x > this.width()) {\n      visible = false;\n    }\n    this.lineX.setPrivate("visible", visible);\n  }\n  _handleYLine() {\n    let y = this.lineY.y();\n    let visible = true;\n    if (y < 0 || y > this.height()) {\n      visible = false;\n    }\n    this.lineY.setPrivate("visible", visible);\n  }\n  _handleLineMove(key, ctrlKey) {\n    let dir = "";\n    const chart = this.chart;\n    let axis;\n    if (chart && chart.xAxes.length) {\n      if (this._root.focused(this.lineX)) {\n        dir = "positionX";\n        axis = chart.xAxes.getIndex(0);\n      } else if (this._root.focused(this.lineY)) {\n        axis = chart.yAxes.getIndex(0);\n        dir = "positionY";\n      }\n      let m = 1;\n      if (ctrlKey) {\n        m = 5;\n      }\n      if (axis) {\n        let inversed = axis.get("renderer").get("inversed", false);\n        let step;\n        if (key == "ArrowRight" || key == "ArrowDown") {\n          step = 1;\n        } else if (key == "ArrowLeft" || key == "ArrowUp") {\n          step = -1;\n        } else if (key == "Tab") {\n          step = 0;\n        }\n        if (step != null) {\n          if (inversed) {\n            step *= -1;\n          }\n          this.set(dir, axis.nextPosition(step * m));\n        }\n      }\n    }\n  }\n  _handleLineFocus() {\n    this._alwaysShow = this.get("alwaysShow", false);\n    this.setAll({\n      positionX: this.getPrivate("positionX", 0),\n      positionY: this.getPrivate("positionY", 0),\n      alwaysShow: true\n    });\n    this._handleLineMove("Tab");\n  }\n  _handleLineBlur() {\n    if (this.lineX.isFocus() || this.lineY.isFocus()) {\n      this.setAll({\n        positionX: undefined,\n        positionY: undefined,\n        alwaysShow: this._alwaysShow\n      });\n    }\n  }\n  _prepareChildren() {\n    super._prepareChildren();\n    if (this.isDirty("xAxis")) {\n      this._tooltipX = false;\n      const xAxis = this.get("xAxis");\n      if (xAxis) {\n        const tooltip = xAxis.get("tooltip");\n        if (tooltip) {\n          this._tooltipX = true;\n          this._disposers.push(tooltip.on("pointTo", () => {\n            this._updateXLine(tooltip);\n          }));\n        }\n      }\n    }\n    if (this.isDirty("yAxis")) {\n      this._tooltipY = false;\n      const yAxis = this.get("yAxis");\n      if (yAxis) {\n        const tooltip = yAxis.get("tooltip");\n        if (tooltip) {\n          this._tooltipY = true;\n          this._disposers.push(tooltip.on("pointTo", () => {\n            this._updateYLine(tooltip);\n          }));\n        }\n      }\n    }\n  }\n  _handleSyncWith() {\n    const chart = this.chart;\n    if (chart) {\n      const syncWith = this.get("syncWith");\n      const otherCharts = [];\n      if (syncWith) {\n        each(syncWith, cursor => {\n          const chart = cursor.chart;\n          if (chart) {\n            otherCharts.push(chart);\n          }\n        });\n      }\n      chart._otherCharts = otherCharts;\n    }\n  }\n  _updateChildren() {\n    super._updateChildren();\n    this._handleSyncWith();\n    if (this.isDirty("positionX") || this.isDirty("positionY")) {\n      const positionX = this.get("positionX");\n      const positionY = this.get("positionY");\n      if (positionX == null && positionY == null) {\n        this.hide(0);\n      } else {\n        this._movePoint = this.toGlobal(this._getPoint(this.get("positionX", 0), this.get("positionY", 0)));\n        this.handleMove();\n      }\n    }\n  }\n  _updateXLine(tooltip) {\n    let x = round(this._display.toLocal(tooltip.get("pointTo", {\n      x: 0,\n      y: 0\n    })).x, 3);\n    if (this._toX != x) {\n      this.lineX.animate({\n        key: "x",\n        to: x,\n        duration: tooltip.get("animationDuration", 0),\n        easing: tooltip.get("animationEasing")\n      });\n      this._toX = x;\n    }\n  }\n  _updateYLine(tooltip) {\n    let y = round(this._display.toLocal(tooltip.get("pointTo", {\n      x: 0,\n      y: 0\n    })).y, 3);\n    if (this._toY != y) {\n      this.lineY.animate({\n        key: "y",\n        to: y,\n        duration: tooltip.get("animationDuration", 0),\n        easing: tooltip.get("animationEasing")\n      });\n      this._toY = y;\n    }\n  }\n  _drawLines() {\n    this.lineX.set("draw", display => {\n      display.moveTo(0, 0);\n      display.lineTo(0, this.height());\n    });\n    this.lineY.set("draw", display => {\n      display.moveTo(0, 0);\n      display.lineTo(this.width(), 0);\n    });\n  }\n  updateCursor() {\n    if (this.get("alwaysShow")) {\n      this._movePoint = this.toGlobal(this._getPoint(this.get("positionX", 0), this.get("positionY", 0)));\n    }\n    this.handleMove();\n  }\n  _setChart(chart) {\n    this.chart = chart;\n    this._handleSyncWith();\n    const plotContainer = chart.plotContainer;\n    this.events.on("boundschanged", () => {\n      this._disposers.push(this.setTimeout(() => {\n        this.updateCursor();\n      }, 50));\n    });\n    //this._display.interactive = true;\n    if (supports("touchevents")) {\n      this._disposers.push(plotContainer.events.on("click", event => {\n        if (isTouchEvent(event.originalEvent)) {\n          this._handleMove(event);\n        }\n      }));\n      this._setUpTouch();\n    }\n    this._disposers.push(plotContainer.events.on("pointerdown", event => {\n      this._handleCursorDown(event);\n    }));\n    this._disposers.push(plotContainer.events.on("globalpointerup", event => {\n      this._handleCursorUp(event);\n      if (!event.native && !this.isHidden()) {\n        this._handleMove(event);\n      }\n    }));\n    this._disposers.push(plotContainer.events.on("globalpointermove", event => {\n      if (!this.get("syncWith")) {\n        if (keys(plotContainer._downPoints).length == 0 && !event.native && this.isHidden()) {\n          // Ignore mouse movement if it originates on outside element and\n          // we\'re not dragging.\n          return;\n        }\n      }\n      this._handleMove(event);\n      if (Math.hypot(this._lastPoint2.x - event.point.x, this._lastPoint2.y - event.point.y) > 1) {\n        this._handleLineBlur();\n        this._lastPoint2 = event.point;\n      }\n    }));\n    const parent = this.parent;\n    if (parent) {\n      parent.children.moveValue(this.selection);\n    }\n  }\n  _inPlot(point) {\n    const chart = this.chart;\n    if (chart) {\n      return chart.inPlot(point);\n    }\n    return false;\n  }\n  _handleCursorDown(event) {\n    if (event.originalEvent.button == 2) {\n      return;\n    }\n    const rootPoint = event.point;\n    let local = this._display.toLocal(rootPoint);\n    const chart = this.chart;\n    this.selection.set("draw", () => {});\n    if (chart && this._inPlot(local)) {\n      this._downPoint = local;\n      if (this.get("behavior") != "none") {\n        this.selection.show();\n        const type = "selectstarted";\n        if (this.events.isEnabled(type)) {\n          this.events.dispatch(type, {\n            type: type,\n            target: this,\n            originalEvent: event.originalEvent\n          });\n        }\n      }\n      let positionX = this._getPosition(local).x;\n      let positionY = this._getPosition(local).y;\n      this.setPrivate("downPositionX", positionX);\n      this.setPrivate("downPositionY", positionY);\n    }\n  }\n  _handleCursorUp(event) {\n    // TODO: handle multitouch\n    if (this._downPoint) {\n      const behavior = this.get("behavior", "none");\n      if (behavior != "none") {\n        if (behavior.charAt(0) === "z") {\n          this.selection.hide();\n        }\n        const rootPoint = event.point;\n        let local = this._display.toLocal(rootPoint);\n        const downPoint = this._downPoint;\n        const moveThreshold = this.get("moveThreshold", 1);\n        if (local && downPoint) {\n          let dispatch = false;\n          if (behavior === "zoomX" || behavior === "zoomXY" || behavior === "selectX" || behavior === "selectXY") {\n            if (Math.abs(local.x - downPoint.x) > moveThreshold) {\n              dispatch = true;\n            }\n          }\n          if (behavior === "zoomY" || behavior === "zoomXY" || behavior === "selectY" || behavior === "selectXY") {\n            if (Math.abs(local.y - downPoint.y) > moveThreshold) {\n              dispatch = true;\n            }\n          }\n          if (dispatch) {\n            const type = "selectended";\n            if (this.events.isEnabled(type)) {\n              this.events.dispatch(type, {\n                type: type,\n                target: this,\n                originalEvent: event.originalEvent\n              });\n            }\n          } else {\n            const type = "selectcancelled";\n            if (this.events.isEnabled(type)) {\n              this.events.dispatch(type, {\n                type: type,\n                target: this,\n                originalEvent: event.originalEvent\n              });\n            }\n          }\n        }\n      }\n    }\n    this._downPoint = undefined;\n  }\n  _handleMove(event) {\n    if (this.getPrivate("visible")) {\n      const chart = this.chart;\n      if (chart && keys(chart.plotContainer._downPoints).length > 1) {\n        this.set("forceHidden", true);\n        return;\n      } else {\n        this.set("forceHidden", false);\n      }\n      // TODO: handle multitouch\n      const rootPoint = event.point;\n      const lastPoint = this._lastPoint;\n      if (Math.round(lastPoint.x) === Math.round(rootPoint.x) && Math.round(lastPoint.y) === Math.round(rootPoint.y)) {\n        return;\n      }\n      this._lastPoint = rootPoint;\n      this.setPrivate("lastPoint", rootPoint);\n      this.handleMove({\n        x: rootPoint.x,\n        y: rootPoint.y\n      }, false, event.originalEvent);\n    }\n  }\n  _getPosition(point) {\n    return {\n      x: point.x / this.width(),\n      y: point.y / this.height()\n    };\n  }\n  /**\r\n   * Moves the cursor to X/Y coordinates within chart container (`point`).\r\n   *\r\n   * If `skipEvent` parameter is set to `true`, the move will not invoke\r\n   * the `"cursormoved"` event.\r\n   *\r\n   * @param  point      X/Y to move cursor to\r\n   * @param  skipEvent  Do not fire "cursormoved" event\r\n   */\n  handleMove(point, skipEvent, originalEvent) {\n    if (!point) {\n      point = this._movePoint;\n    }\n    const alwaysShow = this.get("alwaysShow");\n    if (!point) {\n      this.hide(0);\n      return;\n    }\n    this._movePoint = point;\n    let local = this._display.toLocal(point);\n    let chart = this.chart;\n    if (chart && (this._inPlot(local) || this._downPoint)) {\n      chart._movePoint = point;\n      if (this.isHidden()) {\n        this.show();\n        const behavior = this.get("behavior", "");\n        if (behavior.charAt(0) == "z") {\n          this.selection.set("draw", () => {});\n        }\n      }\n      let x = local.x;\n      let y = local.y;\n      let xyPos = this._getPosition(local);\n      this.setPrivate("point", local);\n      let snapToSeries = this.get("snapToSeries");\n      if (this._downPoint) {\n        snapToSeries = undefined;\n      }\n      let userPositionX = this.get("positionX");\n      let positionX = xyPos.x;\n      if (Type_isNumber(userPositionX)) {\n        positionX = userPositionX;\n      }\n      let userPositionY = this.get("positionY");\n      let positionY = xyPos.y;\n      if (Type_isNumber(userPositionY)) {\n        positionY = userPositionY;\n      }\n      this.setPrivate("positionX", positionX);\n      this.setPrivate("positionY", positionY);\n      const xy = this._getPoint(positionX, positionY);\n      x = xy.x;\n      y = xy.y;\n      chart.xAxes.each(axis => {\n        axis._handleCursorPosition(positionX, snapToSeries);\n        if (alwaysShow) {\n          axis.handleCursorShow();\n        }\n      });\n      chart.yAxes.each(axis => {\n        axis._handleCursorPosition(positionY, snapToSeries);\n        if (alwaysShow) {\n          axis.handleCursorShow();\n        }\n      });\n      if (!skipEvent) {\n        chart._handleCursorPosition();\n        const type = "cursormoved";\n        if (this.events.isEnabled(type)) {\n          this.events.dispatch(type, {\n            type: type,\n            target: this,\n            point: point,\n            originalEvent: originalEvent\n          });\n        }\n      }\n      this._updateLines(x, y);\n      chart.arrangeTooltips();\n    } else if (!this._downPoint) {\n      if (!alwaysShow) {\n        this.hide(0);\n        const type = "cursorhidden";\n        if (this.events.isEnabled(type)) {\n          this.events.dispatch(type, {\n            type: type,\n            target: this\n          });\n        }\n      }\n    }\n    if (this._downPoint && this.get("behavior") != "none") {\n      this._updateSelection(local);\n    }\n  }\n  _getPoint(positionX, positionY) {\n    return {\n      x: this.width() * positionX,\n      y: this.height() * positionY\n    };\n  }\n  _updateLines(x, y) {\n    if (!this._tooltipX) {\n      this.lineX.set("x", x);\n    }\n    if (!this._tooltipY) {\n      this.lineY.set("y", y);\n    }\n    this._drawLines();\n  }\n  _updateSelection(point) {\n    const selection = this.selection;\n    const behavior = this.get("behavior");\n    const w = this.width();\n    const h = this.height();\n    if (point.x < 0) {\n      point.x = 0;\n    }\n    if (point.x > w) {\n      point.x = w;\n    }\n    if (point.y < 0) {\n      point.y = 0;\n    }\n    if (point.y > h) {\n      point.y = h;\n    }\n    selection.set("draw", display => {\n      const downPoint = this._downPoint;\n      if (downPoint) {\n        if (behavior === "zoomXY" || behavior === "selectXY") {\n          display.moveTo(downPoint.x, downPoint.y);\n          display.lineTo(downPoint.x, point.y);\n          display.lineTo(point.x, point.y);\n          display.lineTo(point.x, downPoint.y);\n          display.lineTo(downPoint.x, downPoint.y);\n        } else if (behavior === "zoomX" || behavior === "selectX") {\n          display.moveTo(downPoint.x, 0);\n          display.lineTo(downPoint.x, h);\n          display.lineTo(point.x, h);\n          display.lineTo(point.x, 0);\n          display.lineTo(downPoint.x, 0);\n        } else if (behavior === "zoomY" || behavior === "selectY") {\n          display.moveTo(0, downPoint.y);\n          display.lineTo(w, downPoint.y);\n          display.lineTo(w, point.y);\n          display.lineTo(0, point.y);\n          display.lineTo(0, downPoint.y);\n        }\n      }\n    });\n  }\n  _onHide() {\n    if (this.isHidden()) {\n      let chart = this.chart;\n      if (chart) {\n        chart.xAxes.each(axis => {\n          axis.handleCursorHide();\n        });\n        chart.yAxes.each(axis => {\n          axis.handleCursorHide();\n        });\n        chart.series.each(series => {\n          series.handleCursorHide();\n        });\n      }\n    }\n    super._onHide();\n  }\n  _onShow() {\n    if (!this.isHidden()) {\n      let chart = this.chart;\n      if (chart) {\n        chart.xAxes.each(axis => {\n          axis.handleCursorShow();\n        });\n        chart.yAxes.each(axis => {\n          axis.handleCursorShow();\n        });\n      }\n    }\n    super._onShow();\n  }\n  _dispose() {\n    super._dispose();\n    this.selection.dispose();\n  }\n}\nObject.defineProperty(XYCursor, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "XYCursor"\n});\nObject.defineProperty(XYCursor, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Container.classNames.concat([XYCursor.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/percent/PercentDefaultTheme.js\n\n\n\n\n/**\r\n * @ignore\r\n */\nclass PercentDefaultTheme extends Theme {\n  setupDefaultRules() {\n    super.setupDefaultRules();\n    const ic = this._root.interfaceColors;\n    const r = this.rule.bind(this);\n    /**\r\n     * ========================================================================\r\n     * charts/percent\r\n     * ========================================================================\r\n     */\n    r("PercentSeries").setAll({\n      legendLabelText: "{category}",\n      legendValueText: "{valuePercentTotal.formatNumber(\'0.00p\')}",\n      colors: ColorSet.new(this._root, {}),\n      width: p100,\n      height: p100\n    });\n    /**\r\n     * ========================================================================\r\n     * charts/pie\r\n     * ========================================================================\r\n     */\n    r("PieChart").setAll({\n      radius: percent(80),\n      startAngle: -90,\n      endAngle: 270\n    });\n    r("PieSeries").setAll({\n      alignLabels: true,\n      startAngle: -90,\n      endAngle: 270\n    });\n    r("PieSeries").states.create("hidden", {\n      endAngle: -90,\n      opacity: 0\n    });\n    r("Slice", ["pie"]).setAll({\n      position: "absolute",\n      isMeasured: false,\n      x: 0,\n      y: 0,\n      toggleKey: "active",\n      tooltipText: "{category}: {valuePercentTotal.formatNumber(\'0.00p\')}",\n      strokeWidth: 1,\n      strokeOpacity: 1,\n      role: "figure",\n      lineJoin: "round"\n    });\n    r("Slice", ["pie"]).states.create("active", {\n      shiftRadius: 20,\n      scale: 1\n    });\n    r("Slice", ["pie"]).states.create("hoverActive", {\n      scale: 1.04\n    });\n    r("Slice", ["pie"]).states.create("hover", {\n      scale: 1.04\n    });\n    r("RadialLabel", ["pie"]).setAll({\n      textType: "aligned",\n      radius: 10,\n      text: "{category}: {valuePercentTotal.formatNumber(\'0.00p\')}",\n      paddingTop: 5,\n      paddingBottom: 5,\n      populateText: true\n    });\n    r("Tick", ["pie"]).setAll({\n      location: 1\n    });\n    /**\r\n     * ========================================================================\r\n     * charts/funnel\r\n     * ========================================================================\r\n     */\n    r("SlicedChart").setAll({\n      paddingLeft: 10,\n      paddingRight: 10,\n      paddingTop: 10,\n      paddingBottom: 10\n    });\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * charts/funnel: Funnel\r\n     * ------------------------------------------------------------------------\r\n     */\n    r("FunnelSeries").setAll({\n      startLocation: 0,\n      endLocation: 1,\n      orientation: "vertical",\n      alignLabels: true,\n      sequencedInterpolation: true\n    });\n    r("FunnelSlice").setAll({\n      interactive: true,\n      expandDistance: 0\n      //tooltipText: "{category}: {valuePercentTotal.formatNumber(\'0.00p\')}"\n    });\n\n    r("FunnelSlice").states.create("hover", {\n      expandDistance: 0.15\n    });\n    r("Label", ["funnel"]).setAll({\n      populateText: true,\n      text: "{category}: {valuePercentTotal.formatNumber(\'0.00p\')}",\n      centerY: p50\n    });\n    r("Label", ["funnel", "horizontal"]).setAll({\n      centerX: 0,\n      centerY: p50,\n      rotation: -90\n    });\n    // Class: Label\n    r("Label", ["funnel", "vertical"]).setAll({\n      centerY: p50,\n      centerX: 0\n    });\n    r("Tick", ["funnel"]).setAll({\n      location: 1\n    });\n    r("FunnelSlice", ["funnel", "link"]).setAll({\n      fillOpacity: 0.5,\n      strokeOpacity: 0,\n      expandDistance: -0.1\n    });\n    r("FunnelSlice", ["funnel", "link", "vertical"]).setAll({\n      height: 10\n    });\n    r("FunnelSlice", ["funnel", "link", "horizontal"]).setAll({\n      width: 10\n    });\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * charts/funnel: Pyramid\r\n     * ------------------------------------------------------------------------\r\n     */\n    r("PyramidSeries").setAll({\n      valueIs: "area"\n    });\n    r("FunnelSlice", ["pyramid", "link"]).setAll({\n      fillOpacity: 0.5\n    });\n    r("FunnelSlice", ["pyramid", "link", "vertical"]).setAll({\n      height: 0\n    });\n    r("FunnelSlice", ["pyramid", "link", "horizontal"]).setAll({\n      width: 0\n    });\n    r("FunnelSlice", ["pyramid"]).setAll({\n      interactive: true,\n      expandDistance: 0\n    });\n    r("FunnelSlice", ["pyramid"]).states.create("hover", {\n      expandDistance: 0.15\n    });\n    r("Label", ["pyramid"]).setAll({\n      populateText: true,\n      text: "{category}: {valuePercentTotal.formatNumber(\'0.00p\')}",\n      centerY: p50\n    });\n    r("Label", ["pyramid", "horizontal"]).setAll({\n      centerX: 0,\n      centerY: p50,\n      rotation: -90\n    });\n    r("Label", ["pyramid", "vertical"]).setAll({\n      centerY: p50,\n      centerX: 0\n    });\n    r("Tick", ["pyramid"]).setAll({\n      location: 1\n    });\n    /**\r\n     * ------------------------------------------------------------------------\r\n     * charts/funnel: Pictorial\r\n     * ------------------------------------------------------------------------\r\n     */\n    // Class: FunnelSlice\n    r("FunnelSlice", ["pictorial"]).setAll({\n      interactive: true,\n      tooltipText: "{category}: {valuePercentTotal.formatNumber(\'0.00p\')}"\n    });\n    r("Label", ["pictorial"]).setAll({\n      populateText: true,\n      text: "{category}: {valuePercentTotal.formatNumber(\'0.00p\')}",\n      centerY: p50\n    });\n    r("Label", ["pictorial", "horizontal"]).setAll({\n      centerX: 0,\n      centerY: p50,\n      rotation: -90\n    });\n    r("Label", ["pictorial", "vertical"]).setAll({\n      centerY: p50,\n      centerX: 0\n    });\n    r("FunnelSlice", ["pictorial", "link"]).setAll({\n      fillOpacity: 0.5,\n      width: 0,\n      height: 0\n    });\n    r("Tick", ["pictorial"]).setAll({\n      location: 0.5\n    });\n    {\n      const rule = r("Graphics", ["pictorial", "background"]);\n      rule.setAll({\n        fillOpacity: 0.2\n      });\n      setColor(rule, "fill", ic, "alternativeBackground");\n    }\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/percent/PercentChart.js\n\n\n/**\r\n * Base class for [[PieChart]].\r\n *\r\n * Also used for percent-based series, like [[FunnelSeries]], [[PyramidSeries]], etc.\r\n *\r\n * @important\r\n */\nclass PercentChart extends SerialChart {\n  _afterNew() {\n    this._defaultThemes.push(PercentDefaultTheme.new(this._root));\n    super._afterNew();\n    this.chartContainer.children.push(this.seriesContainer);\n    this.seriesContainer.children.push(this.bulletsContainer);\n  }\n  _processSeries(series) {\n    super._processSeries(series);\n    this.seriesContainer.children.moveValue(this.bulletsContainer, this.seriesContainer.children.length - 1);\n  }\n}\nObject.defineProperty(PercentChart, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "PercentChart"\n});\nObject.defineProperty(PercentChart, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: SerialChart.classNames.concat([PercentChart.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/pie/PieChart.js\n\n\n\n\n\n/**\r\n * Creates a pie chart.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/percent-charts/pie-chart/} for more info\r\n * @important\r\n */\nclass PieChart extends PercentChart {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_maxRadius", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n  }\n  _afterNew() {\n    super._afterNew();\n    this.seriesContainer.setAll({\n      x: p50,\n      y: p50\n    });\n  }\n  _prepareChildren() {\n    super._prepareChildren();\n    const chartContainer = this.chartContainer;\n    const w = chartContainer.innerWidth();\n    const h = chartContainer.innerHeight();\n    const startAngle = this.get("startAngle", 0);\n    const endAngle = this.get("endAngle", 0);\n    const innerRadius = this.get("innerRadius");\n    let bounds = getArcBounds(0, 0, startAngle, endAngle, 1);\n    const wr = w / (bounds.right - bounds.left);\n    const hr = h / (bounds.bottom - bounds.top);\n    let innerBounds = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    if (innerRadius instanceof Percent) {\n      let value = innerRadius.value;\n      let mr = Math.min(wr, hr);\n      value = Math.max(mr * value, mr - Math.min(h, w)) / mr;\n      innerBounds = getArcBounds(0, 0, startAngle, endAngle, value);\n      this.setPrivateRaw("irModifyer", value / innerRadius.value);\n    }\n    bounds = mergeBounds([bounds, innerBounds]);\n    const prevRadius = this._maxRadius;\n    this._maxRadius = Math.min(wr, hr);\n    const radius = relativeToValue(this.get("radius", 0), this._maxRadius);\n    this.seriesContainer.setAll({\n      dy: -radius * (bounds.bottom + bounds.top) / 2,\n      dx: -radius * (bounds.right + bounds.left) / 2\n    });\n    if (this.isDirty("startAngle") || this.isDirty("endAngle") || prevRadius != this._maxRadius) {\n      this.series.each(series => {\n        series._markDirtyKey("startAngle");\n      });\n    }\n    if (this.isDirty("innerRadius") || this.isDirty("radius")) {\n      this.series.each(series => {\n        series._markDirtyKey("innerRadius");\n      });\n    }\n  }\n  /**\r\n   * Returns outer radius in pixels.\r\n   *\r\n   * If optional series parameter is passed in, it will return outer radius\r\n   * of that particular series.\r\n   *\r\n   * @param   series  Series\r\n   * @return          Radius in pixels\r\n   */\n  radius(series) {\n    let radius = relativeToValue(this.get("radius", 0), this._maxRadius);\n    let innerRadius = relativeToValue(this.get("innerRadius", 0), radius);\n    if (series) {\n      let index = this.series.indexOf(series);\n      let length = this.series.length;\n      let seriesRadius = series.get("radius");\n      if (seriesRadius != null) {\n        return innerRadius + relativeToValue(seriesRadius, radius - innerRadius);\n      } else {\n        return innerRadius + (radius - innerRadius) / length * (index + 1);\n      }\n    }\n    return radius;\n  }\n  /**\r\n   * Returns inner radius in pixels.\r\n   *\r\n   * If optional series parameter is passed in, it will return inner radius\r\n   * of that particular series.\r\n   *\r\n   * @param   series  Series\r\n   * @return          Radius in pixels\r\n   */\n  innerRadius(series) {\n    const radius = this.radius();\n    let innerRadius = relativeToValue(this.get("innerRadius", 0), radius);\n    if (innerRadius < 0) {\n      innerRadius = radius + innerRadius;\n    }\n    if (series) {\n      let index = this.series.indexOf(series);\n      let length = this.series.length;\n      let seriesInnerRadius = series.get("innerRadius");\n      if (seriesInnerRadius != null) {\n        return innerRadius + relativeToValue(seriesInnerRadius, radius - innerRadius);\n      } else {\n        return innerRadius + (radius - innerRadius) / length * index;\n      }\n    }\n    return innerRadius;\n  }\n  _updateSize() {\n    super._updateSize();\n    this.markDirtyKey("radius");\n  }\n}\nObject.defineProperty(PieChart, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "PieChart"\n});\nObject.defineProperty(PieChart, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: PercentChart.classNames.concat([PieChart.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/percent/PercentSeries.js\n\n\n\n\n\n\n/**\r\n * A base class for any percent chart series.\r\n */\nclass PercentSeries extends Series {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "slicesContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.children.push(Container.new(this._root, {\n        position: "absolute",\n        isMeasured: false\n      }))\n    });\n    Object.defineProperty(this, "labelsContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.children.push(Container.new(this._root, {\n        position: "absolute",\n        isMeasured: false\n      }))\n    });\n    Object.defineProperty(this, "ticksContainer", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this.children.push(Container.new(this._root, {\n        position: "absolute",\n        isMeasured: false\n      }))\n    });\n    Object.defineProperty(this, "_lLabels", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "_rLabels", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, "_hLabels", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    /**\r\n     * A [[ListTemplate]] of all slices in series.\r\n     *\r\n     * `slices.template` can also be used to configure slices.\r\n     */\n    Object.defineProperty(this, "slices", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._makeSlices()\n    });\n    /**\r\n     * A [[ListTemplate]] of all slice labels in series.\r\n     *\r\n     * `labels.template` can also be used to configure slice labels.\r\n     */\n    Object.defineProperty(this, "labels", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._makeLabels()\n    });\n    /**\r\n     * A [[ListTemplate]] of all slice ticks in series.\r\n     *\r\n     * `ticks.template` can also be used to configure slice ticks.\r\n     */\n    Object.defineProperty(this, "ticks", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._makeTicks()\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  makeSlice(dataItem) {\n    const slice = this.slicesContainer.children.push(this.slices.make());\n    slice.on("fill", () => {\n      this.updateLegendMarker(dataItem);\n    });\n    slice.on("stroke", () => {\n      this.updateLegendMarker(dataItem);\n    });\n    slice._setDataItem(dataItem);\n    dataItem.set("slice", slice);\n    this.slices.push(slice);\n    return slice;\n  }\n  /**\r\n   * @ignore\r\n   */\n  makeLabel(dataItem) {\n    const label = this.labelsContainer.children.push(this.labels.make());\n    label._setDataItem(dataItem);\n    dataItem.set("label", label);\n    this.labels.push(label);\n    return label;\n  }\n  _shouldMakeBullet(dataItem) {\n    if (dataItem.get("value") != null) {\n      return true;\n    }\n    return false;\n  }\n  /**\r\n   * @ignore\r\n   */\n  makeTick(dataItem) {\n    const tick = this.ticksContainer.children.push(this.ticks.make());\n    tick._setDataItem(dataItem);\n    dataItem.set("tick", tick);\n    this.ticks.push(tick);\n    return tick;\n  }\n  _afterNew() {\n    this.fields.push("category", "fill");\n    super._afterNew();\n  }\n  _onDataClear() {\n    const colors = this.get("colors");\n    if (colors) {\n      colors.reset();\n    }\n  }\n  _prepareChildren() {\n    super._prepareChildren();\n    this._lLabels = [];\n    this._rLabels = [];\n    this._hLabels = [];\n    if (this._valuesDirty) {\n      let sum = 0;\n      let absSum = 0;\n      let valueHigh = 0;\n      let valueLow = Infinity;\n      let count = 0;\n      each(this._dataItems, dataItem => {\n        let valueWorking = dataItem.get("valueWorking", 0);\n        sum += valueWorking;\n        absSum += Math.abs(valueWorking);\n      });\n      each(this._dataItems, dataItem => {\n        let value = dataItem.get("valueWorking", 0);\n        if (value > valueHigh) {\n          valueHigh = value;\n        }\n        if (value < valueLow) {\n          valueLow = value;\n        }\n        count++;\n        let percentTotal = value / absSum;\n        if (absSum == 0) {\n          percentTotal = 0;\n        }\n        dataItem.setRaw("valuePercentTotal", percentTotal * 100);\n      });\n      this.setPrivateRaw("valueLow", valueLow);\n      this.setPrivateRaw("valueHigh", valueHigh);\n      this.setPrivateRaw("valueSum", sum);\n      this.setPrivateRaw("valueAverage", sum / count);\n      this.setPrivateRaw("valueAbsoluteSum", absSum);\n    }\n  }\n  /**\r\n   * Shows hidden series.\r\n   *\r\n   * @param   duration  Animation duration in milliseconds\r\n   * @return            Animation promise\r\n   */\n  show(duration) {\n    const _super = Object.create(null, {\n      show: {\n        get: () => super.show\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      let promises = [];\n      promises.push(_super.show.call(this, duration));\n      promises.push(this._sequencedShowHide(true, duration));\n      yield Promise.all(promises);\n    });\n  }\n  /**\r\n   * Hide whole series.\r\n   *\r\n   * @param   duration  Animation duration in milliseconds\r\n   * @return            Animation promise\r\n   */\n  hide(duration) {\n    const _super = Object.create(null, {\n      hide: {\n        get: () => super.hide\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      let promises = [];\n      promises.push(_super.hide.call(this, duration));\n      promises.push(this._sequencedShowHide(false, duration));\n      yield Promise.all(promises);\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  _updateChildren() {\n    super._updateChildren();\n    if (this._valuesDirty) {\n      each(this._dataItems, dataItem => {\n        dataItem.get("label").text.markDirtyText();\n      });\n    }\n    if (this.isDirty("legendLabelText") || this.isDirty("legendValueText")) {\n      each(this._dataItems, dataItem => {\n        this.updateLegendValue(dataItem);\n      });\n    }\n    this._arrange();\n  }\n  _arrange() {\n    this._arrangeDown(this._lLabels);\n    this._arrangeUp(this._lLabels);\n    this._arrangeDown(this._rLabels);\n    this._arrangeUp(this._rLabels);\n    this._arrangeLeft(this._hLabels);\n    this._arrangeRight(this._hLabels);\n    each(this.dataItems, dataItem => {\n      this._updateTick(dataItem);\n    });\n  }\n  _afterChanged() {\n    super._afterChanged();\n    this._arrange();\n  }\n  processDataItem(dataItem) {\n    super.processDataItem(dataItem);\n    if (dataItem.get("fill") == null) {\n      let colors = this.get("colors");\n      if (colors) {\n        dataItem.setRaw("fill", colors.next());\n      }\n    }\n  }\n  /**\r\n   * Shows series\'s data item.\r\n   *\r\n   * @param   dataItem  Data item\r\n   * @param   duration  Animation duration in milliseconds\r\n   * @return            Promise\r\n   */\n  showDataItem(dataItem, duration) {\n    const _super = Object.create(null, {\n      showDataItem: {\n        get: () => super.showDataItem\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const promises = [_super.showDataItem.call(this, dataItem, duration)];\n      if (!Type_isNumber(duration)) {\n        duration = this.get("stateAnimationDuration", 0);\n      }\n      const easing = this.get("stateAnimationEasing");\n      let value = dataItem.get("value");\n      const animation = dataItem.animate({\n        key: "valueWorking",\n        to: value,\n        duration: duration,\n        easing: easing\n      });\n      if (animation) {\n        promises.push(animation.waitForStop());\n      }\n      const tick = dataItem.get("tick");\n      if (tick) {\n        promises.push(tick.show(duration));\n      }\n      const label = dataItem.get("label");\n      if (label) {\n        promises.push(label.show(duration));\n      }\n      const slice = dataItem.get("slice");\n      if (slice) {\n        promises.push(slice.show(duration));\n      }\n      if (slice.get("active")) {\n        slice.states.applyAnimate("active");\n      }\n      yield Promise.all(promises);\n    });\n  }\n  /**\r\n   * Hides series\'s data item.\r\n   *\r\n   * @param   dataItem  Data item\r\n   * @param   duration  Animation duration in milliseconds\r\n   * @return            Promise\r\n   */\n  hideDataItem(dataItem, duration) {\n    const _super = Object.create(null, {\n      hideDataItem: {\n        get: () => super.hideDataItem\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const promises = [_super.hideDataItem.call(this, dataItem, duration)];\n      const hiddenState = this.states.create("hidden", {});\n      if (!Type_isNumber(duration)) {\n        duration = hiddenState.get("stateAnimationDuration", this.get("stateAnimationDuration", 0));\n      }\n      const easing = hiddenState.get("stateAnimationEasing", this.get("stateAnimationEasing"));\n      const animation = dataItem.animate({\n        key: "valueWorking",\n        to: 0,\n        duration: duration,\n        easing: easing\n      });\n      if (animation) {\n        promises.push(animation.waitForStop());\n      }\n      const tick = dataItem.get("tick");\n      if (tick) {\n        promises.push(tick.hide(duration));\n      }\n      const label = dataItem.get("label");\n      if (label) {\n        promises.push(label.hide(duration));\n      }\n      const slice = dataItem.get("slice");\n      slice.hideTooltip();\n      if (slice) {\n        promises.push(slice.hide(duration));\n      }\n      yield Promise.all(promises);\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n  disposeDataItem(dataItem) {\n    super.disposeDataItem(dataItem);\n    let label = dataItem.get("label");\n    if (label) {\n      this.labels.removeValue(label);\n      label.dispose();\n    }\n    let tick = dataItem.get("tick");\n    if (tick) {\n      this.ticks.removeValue(tick);\n      tick.dispose();\n    }\n    let slice = dataItem.get("slice");\n    if (slice) {\n      this.slices.removeValue(slice);\n      slice.dispose();\n    }\n  }\n  /**\r\n   * Triggers hover on a series data item.\r\n   *\r\n   * @since 5.0.7\r\n   * @param  dataItem  Target data item\r\n   */\n  hoverDataItem(dataItem) {\n    const slice = dataItem.get("slice");\n    if (slice && !slice.isHidden()) {\n      slice.hover();\n    }\n  }\n  /**\r\n   * Triggers un-hover on a series data item.\r\n   *\r\n   * @since 5.0.7\r\n   * @param  dataItem  Target data item\r\n   */\n  unhoverDataItem(dataItem) {\n    const slice = dataItem.get("slice");\n    if (slice) {\n      slice.unhover();\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateLegendMarker(dataItem) {\n    if (dataItem) {\n      const slice = dataItem.get("slice");\n      if (slice) {\n        const legendDataItem = dataItem.get("legendDataItem");\n        if (legendDataItem) {\n          const markerRectangle = legendDataItem.get("markerRectangle");\n          each(visualSettings, setting => {\n            if (slice.get(setting) != null) {\n              markerRectangle.set(setting, slice.get(setting));\n            }\n          });\n        }\n      }\n    }\n  }\n  _arrangeDown(labels) {\n    if (labels) {\n      let next = this._getNextDown();\n      labels.sort((a, b) => {\n        if (a.y > b.y) {\n          return 1;\n        } else if (a.y < b.y) {\n          return -1;\n        } else {\n          return 0;\n        }\n      });\n      each(labels, l => {\n        const bounds = l.label.adjustedLocalBounds();\n        let labelTop = bounds.top;\n        if (l.y + labelTop < next) {\n          l.y = next - labelTop;\n        }\n        l.label.set("y", l.y);\n        next = l.y + bounds.bottom;\n      });\n    }\n  }\n  _getNextUp() {\n    return this.labelsContainer.maxHeight();\n  }\n  _getNextDown() {\n    return 0;\n  }\n  _arrangeUp(labels) {\n    if (labels) {\n      let next = this._getNextUp();\n      labels.sort((a, b) => {\n        if (a.y < b.y) {\n          return 1;\n        } else if (a.y > b.y) {\n          return -1;\n        } else {\n          return 0;\n        }\n      });\n      each(labels, l => {\n        const bounds = l.label.adjustedLocalBounds();\n        let labelBottom = bounds.bottom;\n        if (l.y + labelBottom > next) {\n          l.y = next - labelBottom;\n        }\n        l.label.set("y", l.y);\n        next = l.y + bounds.top;\n      });\n    }\n  }\n  _arrangeRight(labels) {\n    if (labels) {\n      let next = 0;\n      labels.sort((a, b) => {\n        if (a.y > b.y) {\n          return 1;\n        } else if (a.y < b.y) {\n          return -1;\n        } else {\n          return 0;\n        }\n      });\n      each(labels, l => {\n        const bounds = l.label.adjustedLocalBounds();\n        let labelLeft = bounds.left;\n        if (l.y + labelLeft < next) {\n          l.y = next - labelLeft;\n        }\n        l.label.set("x", l.y);\n        next = l.y + bounds.right;\n      });\n    }\n  }\n  _arrangeLeft(labels) {\n    if (labels) {\n      let next = this.labelsContainer.maxWidth();\n      labels.sort((a, b) => {\n        if (a.y < b.y) {\n          return 1;\n        } else if (a.y > b.y) {\n          return -1;\n        } else {\n          return 0;\n        }\n      });\n      each(labels, l => {\n        const bounds = l.label.adjustedLocalBounds();\n        let labelRight = bounds.right;\n        if (l.y + labelRight > next) {\n          l.y = next - labelRight;\n        }\n        l.label.set("x", l.y);\n        next = l.y + bounds.left;\n      });\n    }\n  }\n  _updateSize() {\n    super._updateSize();\n    this.markDirty();\n  }\n  _updateTick(_dataItem) {}\n  _dispose() {\n    super._dispose();\n    const chart = this.chart;\n    if (chart) {\n      chart.series.removeValue(this);\n    }\n  }\n}\nObject.defineProperty(PercentSeries, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "PercentSeries"\n});\nObject.defineProperty(PercentSeries, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Series.classNames.concat([PercentSeries.className])\n});\n;// CONCATENATED MODULE: ./node_modules/d3-shape/src/constant.js\n/* harmony default export */ function constant(x) {\n  return function constant() {\n    return x;\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/d3-shape/src/math.js\nconst abs = Math.abs;\nconst atan2 = Math.atan2;\nconst cos = Math.cos;\nconst math_max = Math.max;\nconst math_min = Math.min;\nconst sin = Math.sin;\nconst sqrt = Math.sqrt;\nconst epsilon = 1e-12;\nconst pi = Math.PI;\nconst halfPi = pi / 2;\nconst math_tau = 2 * pi;\nfunction acos(x) {\n  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n}\nfunction asin(x) {\n  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);\n}\n;// CONCATENATED MODULE: ./node_modules/d3-path/src/path.js\nconst path_pi = Math.PI,\n  path_tau = 2 * path_pi,\n  path_epsilon = 1e-6,\n  tauEpsilon = path_tau - path_epsilon;\nfunction append(strings) {\n  this._ += strings[0];\n  for (let i = 1, n = strings.length; i < n; ++i) {\n    this._ += arguments[i] + strings[i];\n  }\n}\nfunction appendRound(digits) {\n  let d = Math.floor(digits);\n  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);\n  if (d > 15) return append;\n  const k = 10 ** d;\n  return function (strings) {\n    this._ += strings[0];\n    for (let i = 1, n = strings.length; i < n; ++i) {\n      this._ += Math.round(arguments[i] * k) / k + strings[i];\n    }\n  };\n}\nclass Path {\n  constructor(digits) {\n    this._x0 = this._y0 =\n    // start of current subpath\n    this._x1 = this._y1 = null; // end of current subpath\n    this._ = "";\n    this._append = digits == null ? append : appendRound(digits);\n  }\n  moveTo(x, y) {\n    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._append`Z`;\n    }\n  }\n  lineTo(x, y) {\n    this._append`L${this._x1 = +x},${this._y1 = +y}`;\n  }\n  quadraticCurveTo(x1, y1, x, y) {\n    this._append`Q${+x1},${+y1},${this._x1 = +x},${this._y1 = +y}`;\n  }\n  bezierCurveTo(x1, y1, x2, y2, x, y) {\n    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x},${this._y1 = +y}`;\n  }\n  arcTo(x1, y1, x2, y2, r) {\n    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(`negative radius: ${r}`);\n    let x0 = this._x1,\n      y0 = this._y1,\n      x21 = x2 - x1,\n      y21 = y2 - y1,\n      x01 = x0 - x1,\n      y01 = y0 - y1,\n      l01_2 = x01 * x01 + y01 * y01;\n\n    // Is this path empty? Move to (x1,y1).\n    if (this._x1 === null) {\n      this._append`M${this._x1 = x1},${this._y1 = y1}`;\n    }\n\n    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\n    else if (!(l01_2 > path_epsilon)) ;\n\n    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n    // Equivalently, is (x1,y1) coincident with (x2,y2)?\n    // Or, is the radius zero? Line to (x1,y1).\n    else if (!(Math.abs(y01 * x21 - y21 * x01) > path_epsilon) || !r) {\n      this._append`L${this._x1 = x1},${this._y1 = y1}`;\n    }\n\n    // Otherwise, draw an arc!\n    else {\n      let x20 = x2 - x0,\n        y20 = y2 - y0,\n        l21_2 = x21 * x21 + y21 * y21,\n        l20_2 = x20 * x20 + y20 * y20,\n        l21 = Math.sqrt(l21_2),\n        l01 = Math.sqrt(l01_2),\n        l = r * Math.tan((path_pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),\n        t01 = l / l01,\n        t21 = l / l21;\n\n      // If the start tangent is not coincident with (x0,y0), line to.\n      if (Math.abs(t01 - 1) > path_epsilon) {\n        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;\n      }\n      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;\n    }\n  }\n  arc(x, y, r, a0, a1, ccw) {\n    x = +x, y = +y, r = +r, ccw = !!ccw;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(`negative radius: ${r}`);\n    let dx = r * Math.cos(a0),\n      dy = r * Math.sin(a0),\n      x0 = x + dx,\n      y0 = y + dy,\n      cw = 1 ^ ccw,\n      da = ccw ? a0 - a1 : a1 - a0;\n\n    // Is this path empty? Move to (x0,y0).\n    if (this._x1 === null) {\n      this._append`M${x0},${y0}`;\n    }\n\n    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).\n    else if (Math.abs(this._x1 - x0) > path_epsilon || Math.abs(this._y1 - y0) > path_epsilon) {\n      this._append`L${x0},${y0}`;\n    }\n\n    // Is this arc empty? We’re done.\n    if (!r) return;\n\n    // Does the angle go the wrong way? Flip the direction.\n    if (da < 0) da = da % path_tau + path_tau;\n\n    // Is this a complete circle? Draw two arcs to complete the circle.\n    if (da > tauEpsilon) {\n      this._append`A${r},${r},0,1,${cw},${x - dx},${y - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;\n    }\n\n    // Is this arc non-empty? Draw an arc!\n    else if (da > path_epsilon) {\n      this._append`A${r},${r},0,${+(da >= path_pi)},${cw},${this._x1 = x + r * Math.cos(a1)},${this._y1 = y + r * Math.sin(a1)}`;\n    }\n  }\n  rect(x, y, w, h) {\n    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${w = +w}v${+h}h${-w}Z`;\n  }\n  toString() {\n    return this._;\n  }\n}\nfunction path() {\n  return new Path();\n}\n\n// Allow instanceof d3.path\npath.prototype = Path.prototype;\nfunction pathRound(digits = 3) {\n  return new Path(+digits);\n}\n;// CONCATENATED MODULE: ./node_modules/d3-shape/src/path.js\n\nfunction withPath(shape) {\n  let digits = 3;\n  shape.digits = function (_) {\n    if (!arguments.length) return digits;\n    if (_ == null) {\n      digits = null;\n    } else {\n      const d = Math.floor(_);\n      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);\n      digits = d;\n    }\n    return shape;\n  };\n  return () => new Path(digits);\n}\n;// CONCATENATED MODULE: ./node_modules/d3-shape/src/arc.js\n\n\n\nfunction arcInnerRadius(d) {\n  return d.innerRadius;\n}\nfunction arcOuterRadius(d) {\n  return d.outerRadius;\n}\nfunction arcStartAngle(d) {\n  return d.startAngle;\n}\nfunction arcEndAngle(d) {\n  return d.endAngle;\n}\nfunction arcPadAngle(d) {\n  return d && d.padAngle; // Note: optional!\n}\n\nfunction intersect(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var x10 = x1 - x0,\n    y10 = y1 - y0,\n    x32 = x3 - x2,\n    y32 = y3 - y2,\n    t = y32 * x10 - x32 * y10;\n  if (t * t < epsilon) return;\n  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;\n  return [x0 + t * x10, y0 + t * y10];\n}\n\n// Compute perpendicular offset line of length rc.\n// http://mathworld.wolfram.com/Circle-LineIntersection.html\nfunction cornerTangents(x0, y0, x1, y1, r1, rc, cw) {\n  var x01 = x0 - x1,\n    y01 = y0 - y1,\n    lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),\n    ox = lo * y01,\n    oy = -lo * x01,\n    x11 = x0 + ox,\n    y11 = y0 + oy,\n    x10 = x1 + ox,\n    y10 = y1 + oy,\n    x00 = (x11 + x10) / 2,\n    y00 = (y11 + y10) / 2,\n    dx = x10 - x11,\n    dy = y10 - y11,\n    d2 = dx * dx + dy * dy,\n    r = r1 - rc,\n    D = x11 * y10 - x10 * y11,\n    d = (dy < 0 ? -1 : 1) * sqrt(math_max(0, r * r * d2 - D * D)),\n    cx0 = (D * dy - dx * d) / d2,\n    cy0 = (-D * dx - dy * d) / d2,\n    cx1 = (D * dy + dx * d) / d2,\n    cy1 = (-D * dx + dy * d) / d2,\n    dx0 = cx0 - x00,\n    dy0 = cy0 - y00,\n    dx1 = cx1 - x00,\n    dy1 = cy1 - y00;\n\n  // Pick the closer of the two intersection points.\n  // TODO Is there a faster way to determine which intersection to use?\n  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;\n  return {\n    cx: cx0,\n    cy: cy0,\n    x01: -ox,\n    y01: -oy,\n    x11: cx0 * (r1 / r - 1),\n    y11: cy0 * (r1 / r - 1)\n  };\n}\n/* harmony default export */ function arc() {\n  var innerRadius = arcInnerRadius,\n    outerRadius = arcOuterRadius,\n    cornerRadius = constant(0),\n    padRadius = null,\n    startAngle = arcStartAngle,\n    endAngle = arcEndAngle,\n    padAngle = arcPadAngle,\n    context = null,\n    path = withPath(arc);\n  function arc() {\n    var buffer,\n      r,\n      r0 = +innerRadius.apply(this, arguments),\n      r1 = +outerRadius.apply(this, arguments),\n      a0 = startAngle.apply(this, arguments) - halfPi,\n      a1 = endAngle.apply(this, arguments) - halfPi,\n      da = abs(a1 - a0),\n      cw = a1 > a0;\n    if (!context) context = buffer = path();\n\n    // Ensure that the outer radius is always larger than the inner radius.\n    if (r1 < r0) r = r1, r1 = r0, r0 = r;\n\n    // Is it a point?\n    if (!(r1 > epsilon)) context.moveTo(0, 0);\n\n    // Or is it a circle or annulus?\n    else if (da > math_tau - epsilon) {\n      context.moveTo(r1 * cos(a0), r1 * sin(a0));\n      context.arc(0, 0, r1, a0, a1, !cw);\n      if (r0 > epsilon) {\n        context.moveTo(r0 * cos(a1), r0 * sin(a1));\n        context.arc(0, 0, r0, a1, a0, cw);\n      }\n    }\n\n    // Or is it a circular or annular sector?\n    else {\n      var a01 = a0,\n        a11 = a1,\n        a00 = a0,\n        a10 = a1,\n        da0 = da,\n        da1 = da,\n        ap = padAngle.apply(this, arguments) / 2,\n        rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),\n        rc = math_min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),\n        rc0 = rc,\n        rc1 = rc,\n        t0,\n        t1;\n\n      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.\n      if (rp > epsilon) {\n        var p0 = asin(rp / r0 * sin(ap)),\n          p1 = asin(rp / r1 * sin(ap));\n        if ((da0 -= p0 * 2) > epsilon) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;else da0 = 0, a00 = a10 = (a0 + a1) / 2;\n        if ((da1 -= p1 * 2) > epsilon) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;else da1 = 0, a01 = a11 = (a0 + a1) / 2;\n      }\n      var x01 = r1 * cos(a01),\n        y01 = r1 * sin(a01),\n        x10 = r0 * cos(a10),\n        y10 = r0 * sin(a10);\n\n      // Apply rounded corners?\n      if (rc > epsilon) {\n        var x11 = r1 * cos(a11),\n          y11 = r1 * sin(a11),\n          x00 = r0 * cos(a00),\n          y00 = r0 * sin(a00),\n          oc;\n\n        // Restrict the corner radius according to the sector angle. If this\n        // intersection fails, it’s probably because the arc is too small, so\n        // disable the corner radius entirely.\n        if (da < pi) {\n          if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {\n            var ax = x01 - oc[0],\n              ay = y01 - oc[1],\n              bx = x11 - oc[0],\n              by = y11 - oc[1],\n              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),\n              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n            rc0 = math_min(rc, (r0 - lc) / (kc - 1));\n            rc1 = math_min(rc, (r1 - lc) / (kc + 1));\n          } else {\n            rc0 = rc1 = 0;\n          }\n        }\n      }\n\n      // Is the sector collapsed to a line?\n      if (!(da1 > epsilon)) context.moveTo(x01, y01);\n\n      // Does the sector’s outer ring have rounded corners?\n      else if (rc1 > epsilon) {\n        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);\n        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);\n        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);\n          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the outer ring just a circular arc?\n      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);\n\n      // Is there no inner ring, and it’s a circular sector?\n      // Or perhaps it’s an annular sector collapsed due to padding?\n      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);\n\n      // Does the sector’s inner ring (or point) have rounded corners?\n      else if (rc0 > epsilon) {\n        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);\n        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);\n        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);\n          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the inner ring just a circular arc?\n      else context.arc(0, 0, r0, a10, a00, cw);\n    }\n    context.closePath();\n    if (buffer) return context = null, buffer + "" || null;\n  }\n  arc.centroid = function () {\n    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,\n      a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;\n    return [cos(a) * r, sin(a) * r];\n  };\n  arc.innerRadius = function (_) {\n    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc) : innerRadius;\n  };\n  arc.outerRadius = function (_) {\n    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc) : outerRadius;\n  };\n  arc.cornerRadius = function (_) {\n    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc) : cornerRadius;\n  };\n  arc.padRadius = function (_) {\n    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc) : padRadius;\n  };\n  arc.startAngle = function (_) {\n    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc) : startAngle;\n  };\n  arc.endAngle = function (_) {\n    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc) : endAngle;\n  };\n  arc.padAngle = function (_) {\n    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc) : padAngle;\n  };\n  arc.context = function (_) {\n    return arguments.length ? (context = _ == null ? null : _, arc) : context;\n  };\n  return arc;\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Slice.js\n\n\n\n\n\n/**\r\n * Draws a slice shape.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info\r\n */\nclass Slice extends Graphics {\n  constructor() {\n    super(...arguments);\n    /**\r\n     * @ignore\r\n     */\n    Object.defineProperty(this, "ix", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    /**\r\n     * @ignore\r\n     */\n    Object.defineProperty(this, "iy", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_generator", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: arc()\n    });\n  }\n  _getTooltipPoint() {\n    let tooltipX = this.get("tooltipX");\n    let tooltipY = this.get("tooltipY");\n    let x = 0;\n    let y = 0;\n    if (Type_isNumber(tooltipX)) {\n      x = tooltipX;\n    }\n    if (Type_isNumber(tooltipY)) {\n      y = tooltipY;\n    }\n    let radius = this.get("radius", 0);\n    let innerRadius = this.get("innerRadius", 0);\n    let dRadius = this.get("dRadius", 0);\n    let dInnerRadius = this.get("dInnerRadius", 0);\n    radius += dRadius;\n    innerRadius += dInnerRadius;\n    if (innerRadius < 0) {\n      innerRadius = radius + innerRadius;\n    }\n    if (tooltipX instanceof Percent) {\n      x = this.ix * (innerRadius + (radius - innerRadius) * tooltipX.value);\n    }\n    if (tooltipY instanceof Percent) {\n      y = this.iy * (innerRadius + (radius - innerRadius) * tooltipY.value);\n    }\n    if (this.get("arc") >= 360 && innerRadius == 0) {\n      x = 0;\n      y = 0;\n    }\n    return {\n      x,\n      y\n    };\n  }\n  _beforeChanged() {\n    super._beforeChanged();\n    if (this.isDirty("radius") || this.isDirty("arc") || this.isDirty("innerRadius") || this.isDirty("startAngle") || this.isDirty("dRadius") || this.isDirty("dInnerRadius") || this.isDirty("cornerRadius") || this.isDirty("shiftRadius")) {\n      this._clear = true;\n    }\n  }\n  _changed() {\n    super._changed();\n    if (this._clear) {\n      let startAngle = this.get("startAngle", 0);\n      let arc = this.get("arc", 0);\n      const generator = this._generator;\n      if (arc < 0) {\n        startAngle = startAngle + arc;\n        arc = arc * -1;\n      }\n      if (arc > 0.1) {\n        // this fixes bug with full circle when arc is very small\n        generator.cornerRadius(this.get("cornerRadius", 0));\n      }\n      generator.context(this._display);\n      let radius = this.get("radius", 0);\n      let innerRadius = this.get("innerRadius", 0);\n      let dRadius = this.get("dRadius", 0);\n      let dInnerRadius = this.get("dInnerRadius", 0);\n      radius += dRadius;\n      innerRadius += dInnerRadius;\n      if (innerRadius < 0) {\n        innerRadius = radius + innerRadius;\n      }\n      generator({\n        innerRadius: innerRadius,\n        outerRadius: radius,\n        startAngle: (startAngle + 90) * RADIANS,\n        endAngle: (startAngle + arc + 90) * RADIANS\n      });\n      let middleAngle = startAngle + arc / 2;\n      this.ix = Math_cos(middleAngle);\n      this.iy = Math_sin(middleAngle);\n      const shiftRadius = this.get("shiftRadius", 0);\n      this.setRaw("dx", this.ix * shiftRadius);\n      this.setRaw("dy", this.iy * shiftRadius);\n      this.markDirtyPosition();\n    }\n  }\n}\nObject.defineProperty(Slice, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Slice"\n});\nObject.defineProperty(Slice, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Graphics.classNames.concat([Slice.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/RadialText.js\n\n\n/**\r\n * @ignore\r\n */\nclass RadialText extends Text_Text {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_display", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._root._renderer.makeRadialText("", this.textStyle)\n    });\n  }\n  _afterNew() {\n    super._afterNew();\n  }\n  _beforeChanged() {\n    super._beforeChanged();\n    this._display.clear();\n    if (this.isDirty("textType")) {\n      this._display.textType = this.get("textType");\n      this.markDirtyBounds();\n    }\n    if (this.isDirty("radius")) {\n      this._display.radius = this.get("radius");\n      this.markDirtyBounds();\n    }\n    if (this.isDirty("startAngle")) {\n      this._display.startAngle = (this.get("startAngle", 0) + 90) * RADIANS;\n      this.markDirtyBounds();\n    }\n    if (this.isDirty("inside")) {\n      this._display.inside = this.get("inside");\n      this.markDirtyBounds();\n    }\n    if (this.isDirty("orientation")) {\n      this._display.orientation = this.get("orientation");\n      this.markDirtyBounds();\n    }\n    if (this.isDirty("kerning")) {\n      this._display.kerning = this.get("kerning");\n      this.markDirtyBounds();\n    }\n  }\n}\nObject.defineProperty(RadialText, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "RadialText"\n});\nObject.defineProperty(RadialText, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Text_Text.classNames.concat([RadialText.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/RadialLabel.js\n// import * as $object from "../util/Object";\n\n\n\n\n\nclass RadialLabel extends Label {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_flipped", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n  }\n  _afterNew() {\n    this._textKeys.push("textType", "kerning");\n    super._afterNew();\n  }\n  _makeText() {\n    this._text = this.children.push(RadialText.new(this._root, {}));\n  }\n  /**\r\n   * Returns base radius in pixels.\r\n   *\r\n   * @return Base radius\r\n   */\n  baseRadius() {\n    const radiusPrivate = this.getPrivate("radius", 0);\n    const innerRadiusPrivate = this.getPrivate("innerRadius", 0);\n    const baseRadius = this.get("baseRadius", 0);\n    return innerRadiusPrivate + relativeToValue(baseRadius, radiusPrivate - innerRadiusPrivate);\n  }\n  /**\r\n   * Returns radius adjustment in pixels.\r\n   *\r\n   * @return Radius\r\n   */\n  radius() {\n    const inside = this.get("inside", false);\n    return this.baseRadius() + this.get("radius", 0) * (inside ? -1 : 1);\n  }\n  _updateChildren() {\n    super._updateChildren();\n    if (this.isDirty("baseRadius") || this.isPrivateDirty("radius") || this.isPrivateDirty("innerRadius") || this.isDirty("labelAngle") || this.isDirty("radius") || this.isDirty("inside") || this.isDirty("orientation") || this.isDirty("textType")) {\n      const textType = this.get("textType", "adjusted");\n      const inside = this.get("inside", false);\n      const orientation = this.get("orientation");\n      let labelAngle = normalizeAngle(this.get("labelAngle", 0));\n      this._text.set("startAngle", this.get("labelAngle", 0));\n      this._text.set("inside", inside);\n      const sin = Math_sin(labelAngle);\n      const cos = Math_cos(labelAngle);\n      let baseRadius = this.baseRadius();\n      let radius = this.radius();\n      this._display.angle = 0;\n      if (textType == "circular") {\n        this.setAll({\n          paddingTop: 0,\n          paddingBottom: 0,\n          paddingLeft: 0,\n          paddingRight: 0\n        });\n        this.setRaw("x", undefined);\n        this.setRaw("y", undefined);\n        // Circular labels are handled and positioned differently\n        this._text.set("orientation", orientation);\n        this._text.set("radius", radius);\n      } else {\n        if (baseRadius == 0) {\n          labelAngle = 0;\n          radius = 0;\n        }\n        // Positioning of radial/regular labels are teh same\n        let x = radius * cos;\n        let y = radius * sin;\n        if (textType == "radial") {\n          this.setRaw("x", x);\n          this.setRaw("y", y);\n          if (labelAngle < 90 || labelAngle > 270 || orientation != "auto") {\n            this._display.angle = labelAngle; // + 90;\n            this._flipped = false;\n          } else {\n            this._display.angle = labelAngle + 180;\n            this._flipped = true;\n          }\n          this._dirty.rotation = false;\n        } else if (textType == "adjusted") {\n          this.setRaw("centerX", p50);\n          this.setRaw("centerY", p50);\n          this.setRaw("x", x);\n          this.setRaw("y", y);\n        } else if (textType == "regular") {\n          this.setRaw("x", x);\n          this.setRaw("y", y);\n        }\n      }\n      this.markDirtyPosition();\n      this.markDirtyBounds();\n    }\n  }\n  _updatePosition() {\n    const textType = this.get("textType", "regular");\n    const inside = this.get("inside", false);\n    let dx = 0;\n    let dy = 0;\n    let labelAngle = this.get("labelAngle", 0);\n    let bounds = this.localBounds();\n    let w = bounds.right - bounds.left;\n    let h = bounds.bottom - bounds.top;\n    if (textType == "radial") {\n      if (this._flipped) {\n        let centerX = this.get("centerX");\n        if (centerX instanceof Percent) {\n          w = w * (1 - centerX.value * 2);\n        }\n        dx = w * Math_cos(labelAngle);\n        dy = w * Math_sin(labelAngle);\n      }\n    } else if (!inside && textType == "adjusted") {\n      dx = w / 2 * Math_cos(labelAngle);\n      dy = h / 2 * Math_sin(labelAngle);\n    }\n    this.setRaw("dx", dx);\n    this.setRaw("dy", dy);\n    super._updatePosition();\n  }\n  /**\r\n   * @ignore\r\n   */\n  get text() {\n    return this._text;\n  }\n}\nObject.defineProperty(RadialLabel, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "RadialLabel"\n});\nObject.defineProperty(RadialLabel, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Label.classNames.concat([RadialLabel.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/pie/PieSeries.js\n\n\n\n\n\n\n\n\n\n\n/**\r\n * Creates a series for a [[PieChart]].\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/percent-charts/pie-chart/} for more info\r\n * @important\r\n */\nclass PieSeries extends PercentSeries {\n  _makeSlices() {\n    return new ListTemplate(Template.new({}), () => Slice._new(this._root, {\n      themeTags: mergeTags(this.slices.template.get("themeTags", []), ["pie", "series"])\n    }, [this.slices.template]));\n  }\n  _makeLabels() {\n    return new ListTemplate(Template.new({}), () => RadialLabel._new(this._root, {\n      themeTags: mergeTags(this.labels.template.get("themeTags", []), ["pie", "series"])\n    }, [this.labels.template]));\n  }\n  _makeTicks() {\n    return new ListTemplate(Template.new({}), () => Tick._new(this._root, {\n      themeTags: mergeTags(this.ticks.template.get("themeTags", []), ["pie", "series"])\n    }, [this.ticks.template]));\n  }\n  processDataItem(dataItem) {\n    super.processDataItem(dataItem);\n    const slice = this.makeSlice(dataItem);\n    slice.on("scale", () => {\n      this._updateTick(dataItem);\n    });\n    slice.on("shiftRadius", () => {\n      this._updateTick(dataItem);\n    });\n    slice.events.on("positionchanged", () => {\n      this._updateTick(dataItem);\n    });\n    const label = this.makeLabel(dataItem);\n    label.events.on("positionchanged", () => {\n      this._updateTick(dataItem);\n    });\n    this.makeTick(dataItem);\n    slice.events.on("positionchanged", () => {\n      label.markDirty();\n    });\n  }\n  _getNextUp() {\n    const chart = this.chart;\n    if (chart) {\n      return chart._maxRadius;\n    }\n    return this.labelsContainer.maxHeight() / 2;\n  }\n  _getNextDown() {\n    const chart = this.chart;\n    if (chart) {\n      return -chart._maxRadius;\n    }\n    return -this.labelsContainer.maxHeight() / 2;\n  }\n  _prepareChildren() {\n    super._prepareChildren();\n    const chart = this.chart;\n    if (chart) {\n      if (this.isDirty("alignLabels")) {\n        let labelsTemplate = this.labels.template;\n        if (this.get("alignLabels")) {\n          labelsTemplate.set("textType", "aligned");\n        } else {\n          let textType = labelsTemplate.get("textType");\n          if (textType == null || textType == "aligned") {\n            labelsTemplate.set("textType", "adjusted");\n          }\n        }\n      }\n      if (this._valuesDirty || this.isDirty("radius") || this.isDirty("innerRadius") || this.isDirty("startAngle") || this.isDirty("endAngle") || this.isDirty("alignLabels")) {\n        this.markDirtyBounds();\n        const startAngle = this.get("startAngle", chart.get("startAngle", -90));\n        const endAngle = this.get("endAngle", chart.get("endAngle", 270));\n        const arc = endAngle - startAngle;\n        let currentAngle = startAngle;\n        const radius = chart.radius(this);\n        this.setPrivateRaw("radius", radius);\n        let innerRadius = chart.innerRadius(this) * chart.getPrivate("irModifyer", 1);\n        if (innerRadius < 0) {\n          innerRadius = radius + innerRadius;\n        }\n        //if (radius > 0) {\n        each(this._dataItems, dataItem => {\n          this.updateLegendValue(dataItem);\n          let currentArc = arc * dataItem.get("valuePercentTotal") / 100;\n          const slice = dataItem.get("slice");\n          if (slice) {\n            slice.set("radius", radius);\n            slice.set("innerRadius", innerRadius);\n            slice.set("startAngle", currentAngle);\n            slice.set("arc", currentArc);\n            const color = dataItem.get("fill");\n            slice._setDefault("fill", color);\n            slice._setDefault("stroke", color);\n          }\n          let middleAngle = normalizeAngle(currentAngle + currentArc / 2);\n          const label = dataItem.get("label");\n          if (label) {\n            label.setPrivate("radius", radius);\n            label.setPrivate("innerRadius", innerRadius);\n            label.set("labelAngle", middleAngle);\n            if (label.get("textType") == "aligned") {\n              let labelRadius = radius + label.get("radius", 0);\n              let y = radius * Math_sin(middleAngle);\n              if (middleAngle > 90 && middleAngle <= 270) {\n                if (!label.isHidden() && !label.isHiding()) {\n                  this._lLabels.push({\n                    label: label,\n                    y: y\n                  });\n                }\n                labelRadius *= -1;\n                labelRadius -= this.labelsContainer.get("paddingLeft", 0);\n                label.set("centerX", p100);\n                label.setPrivateRaw("left", true);\n              } else {\n                if (!label.isHidden() && !label.isHiding()) {\n                  this._rLabels.push({\n                    label: label,\n                    y: y\n                  });\n                }\n                labelRadius += this.labelsContainer.get("paddingRight", 0);\n                label.set("centerX", 0);\n                label.setPrivateRaw("left", false);\n              }\n              label.set("x", labelRadius);\n              label.set("y", radius * Math_sin(middleAngle));\n            }\n          }\n          currentAngle += currentArc;\n          this._updateTick(dataItem);\n        });\n        //}\n      }\n    }\n  }\n\n  _updateTick(dataItem) {\n    const tick = dataItem.get("tick");\n    const label = dataItem.get("label");\n    const slice = dataItem.get("slice");\n    const location = tick.get("location", 1);\n    if (tick && label && slice) {\n      const radius = (slice.get("shiftRadius", 0) + slice.get("radius", 0)) * slice.get("scale", 1) * location;\n      const labelAngle = label.get("labelAngle", 0);\n      const cos = Math_cos(labelAngle);\n      const sin = Math_sin(labelAngle);\n      const labelsContainer = this.labelsContainer;\n      const pl = labelsContainer.get("paddingLeft", 0);\n      const pr = labelsContainer.get("paddingRight", 0);\n      let x = 0;\n      let y = 0;\n      x = label.x();\n      y = label.y();\n      let points = [];\n      if (x != 0 && y != 0) {\n        if (label.get("textType") == "circular") {\n          const labelRadius = label.radius() - label.get("paddingBottom", 0);\n          const labelAngle = label.get("labelAngle", 0);\n          x = labelRadius * Math_cos(labelAngle);\n          y = labelRadius * Math_sin(labelAngle);\n        }\n        let dx = -pr;\n        if (label.getPrivate("left")) {\n          dx = pl;\n        }\n        points = [{\n          x: slice.x() + radius * cos,\n          y: slice.y() + radius * sin\n        }, {\n          x: x + dx,\n          y: y\n        }, {\n          x: x,\n          y: y\n        }];\n      }\n      tick.set("points", points);\n    }\n  }\n  _positionBullet(bullet) {\n    const sprite = bullet.get("sprite");\n    if (sprite) {\n      const dataItem = sprite.dataItem;\n      const slice = dataItem.get("slice");\n      if (slice) {\n        const innerRadius = slice.get("innerRadius", 0);\n        const radius = slice.get("radius", 0);\n        const startAngle = slice.get("startAngle", 0);\n        const arc = slice.get("arc", 0);\n        const locationX = bullet.get("locationX", 0.5);\n        const locationY = bullet.get("locationY", 0.5);\n        const angle = startAngle + arc * locationX;\n        const r = innerRadius + (radius - innerRadius) * locationY;\n        sprite.setAll({\n          x: Math_cos(angle) * r,\n          y: Math_sin(angle) * r\n        });\n      }\n    }\n  }\n}\nObject.defineProperty(PieSeries, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "PieSeries"\n});\nObject.defineProperty(PieSeries, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: PercentSeries.classNames.concat([PieSeries.className])\n});\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/themes/AnimatedTheme.js\n\n/**\r\n * @ignore\r\n */\nclass AnimatedTheme extends Theme {\n  setupDefaultRules() {\n    super.setupDefaultRules();\n    this.rule("Component").setAll({\n      interpolationDuration: 600\n    });\n    this.rule("Hierarchy").set("animationDuration", 600);\n    this.rule("Scrollbar").set("animationDuration", 600);\n    this.rule("Tooltip").set("animationDuration", 300);\n    this.rule("MapChart").set("animationDuration", 1000);\n    this.rule("MapChart").set("wheelDuration", 300);\n    this.rule("Entity").setAll({\n      stateAnimationDuration: 600\n    });\n    this.rule("Sprite").states.create("default", {\n      stateAnimationDuration: 600\n    });\n    this.rule("Tooltip", ["axis"]).setAll({\n      animationDuration: 200\n    });\n    this.rule("WordCloud").set("animationDuration", 500);\n    this.rule("Polygon").set("animationDuration", 600);\n    this.rule("ArcDiagram").set("animationDuration", 600);\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/themes/Animated.js\n\n/* harmony default export */ const Animated = (AnimatedTheme);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./client/views/pages/chart/Safety.vue?vue&type=script&lang=js\n\n // amChart5 기본 라이브러리\n // 막대, 라인 차트\n // 파이류 차트\n // 차트 애니메이션\n\n/* harmony default export */ const Safetyvue_type_script_lang_js = ({\n  data() {\n    return {\n      policeData: [],\n      crimeData: [],\n      fireData: [],\n      accidentData: [],\n      safetyData: [],\n      casualtyData: []\n    };\n  },\n  mounted() {\n    this.PoliceCount();\n    this.CrimeIncrease();\n    this.FireRatio();\n    this.AccidentIncrease();\n    this.SafetyScore();\n    this.Severity();\n  },\n  watch: {},\n  computed: {},\n  methods: {\n    // police\n    PoliceCount: function () {\n      const vm = this;\n      lib_axios({\n        url: "/PoliceCount.json",\n        method: "post",\n        headers: {\n          "Content-Type": "application/json"\n        },\n        data: {}\n      }).then(function (response) {\n        console.log("policeData - response.data:", response.data);\n        // response.data가 배열인지 확인\n        if (Array.isArray(response.data)) {\n          vm.policeData = response.data;\n          vm.policeChart();\n        } else {\n          console.error("Invalid response format:", response.data);\n          alert("데이터 형식이 올바르지 않습니다.");\n        }\n      }).catch(function (error) {\n        console.error("policeData - error:", error);\n        alert("오류 발생: " + error.message);\n      });\n    },\n    CrimeIncrease: function () {\n      const vm = this;\n      lib_axios({\n        url: "/CrimeIncrease.json",\n        method: "post",\n        headers: {\n          "Content-Type": "application/json"\n        },\n        data: {}\n      }).then(function (response) {\n        console.log("crimeData - response.data:", response.data);\n        // response.data가 배열인지 확인\n        if (Array.isArray(response.data)) {\n          vm.crimeData = response.data;\n          vm.crimeChart();\n        } else {\n          console.error("Invalid response format:", response.data);\n          alert("데이터 형식이 올바르지 않습니다.");\n        }\n      }).catch(function (error) {\n        console.error("crimeData - error:", error);\n        alert("오류 발생: " + error.message);\n      });\n    },\n    //fire\n    FireRatio: function () {\n      const vm = this;\n      lib_axios({\n        url: "/FireRatio.json",\n        method: "post",\n        headers: {\n          "Content-Type": "application/json"\n        },\n        data: {}\n      }).then(function (response) {\n        console.log("fireData - response.data:", response.data);\n        // response.data가 배열인지 확인\n        if (Array.isArray(response.data)) {\n          vm.fireData = response.data;\n          vm.fireChart();\n        } else {\n          console.error("Invalid response format:", response.data);\n          alert("데이터 형식이 올바르지 않습니다.");\n        }\n      }).catch(function (error) {\n        console.error("fireData - error:", error);\n        alert("오류 발생: " + error.message);\n      });\n    },\n    // accident\n    AccidentIncrease: function () {\n      const vm = this;\n      lib_axios({\n        url: "/AccidentIncrease.json",\n        method: "post",\n        headers: {\n          "Content-Type": "application/json"\n        },\n        data: {}\n      }).then(function (response) {\n        console.log("accidentData - response.data:", response.data);\n        // response.data가 배열인지 확인\n        if (Array.isArray(response.data)) {\n          vm.accidentData = response.data;\n          vm.accidentChart();\n        } else {\n          console.error("Invalid response format:", response.data);\n          alert("데이터 형식이 올바르지 않습니다.");\n        }\n      }).catch(function (error) {\n        console.error("accidentData - error:", error);\n        alert("오류 발생: " + error.message);\n      });\n    },\n    // safety\n    SafetyScore: function () {\n      const vm = this;\n      lib_axios({\n        url: "/SafetyScore.json",\n        method: "post",\n        headers: {\n          "Content-Type": "application/json"\n        },\n        data: {}\n      }).then(function (response) {\n        console.log("safetyData - response.data:", response.data);\n        // response.data가 배열인지 확인\n        if (Array.isArray(response.data)) {\n          vm.safetyData = response.data;\n          vm.safetyChart();\n        } else {\n          console.error("Invalid response format:", response.data);\n          alert("데이터 형식이 올바르지 않습니다.");\n        }\n      }).catch(function (error) {\n        console.error("safetyData - error:", error);\n        alert("오류 발생: " + error.message);\n      });\n    },\n    // casualty\n    Severity: function () {\n      const vm = this;\n      lib_axios({\n        url: "/Severity.json",\n        method: "post",\n        headers: {\n          "Content-Type": "application/json"\n        },\n        data: {}\n      }).then(function (response) {\n        console.log("casualtyData - response.data:", response.data);\n        // response.data가 배열인지 확인\n        if (Array.isArray(response.data)) {\n          vm.casualtyData = response.data;\n          vm.casualtyChart();\n        } else {\n          console.error("Invalid response format:", response.data);\n          alert("데이터 형식이 올바르지 않습니다.");\n        }\n      }).catch(function (error) {\n        console.error("casualtyData - error:", error);\n        alert("오류 발생: " + error.message);\n      });\n    },\n    policeChart: function () {\n      const vm = this; // 현재 Vue 인스턴스를 참조하는 변수\n\n      ready(function () {\n        // Create root element\n        var root = Root.new("police");\n\n        // Set themes\n        root.setThemes([Animated.new(root)]);\n\n        // Create chart\n        var chart = root.container.children.push(XYChart.new(root, {\n          panX: false,\n          panY: false,\n          wheelX: "panX",\n          wheelY: "zoomX",\n          paddingLeft: 0,\n          layout: root.verticalLayout\n        }));\n\n        // Add scrollbar\n        /* chart.set("scrollbarX", am5.Scrollbar.new(root, {\r\n            orientation: "horizontal"\r\n        })); */\n\n        var data = vm.policeData.map(item => ({\n          police: item.police,\n          지구대: item.지구대,\n          파출소: item.파출소\n        }));\n\n        // Create axes\n        var xRenderer = AxisRendererX.new(root, {\n          cellStartLocation: 0.1,\n          cellEndLocation: 0.9,\n          minGridDistance: 30,\n          minorGridEnabled: true\n        });\n        var xAxis = chart.xAxes.push(CategoryAxis.new(root, {\n          categoryField: "police",\n          renderer: xRenderer,\n          tooltip: Tooltip.new(root, {})\n        }));\n        xRenderer.grid.template.setAll({\n          location: 1\n        });\n        xRenderer.labels.template.setAll({\n          rotation: 0,\n          // 레이블 회전 각도 설정\n          centerY: p50,\n          centerX: amcharts5_namespaceObject.p150,\n          paddingRight: 0 // 레이블 간 여백 설정\n        });\n\n        xAxis.data.setAll(data);\n        var yAxis = chart.yAxes.push(ValueAxis.new(root, {\n          min: 0,\n          renderer: AxisRendererY.new(root, {\n            strokeOpacity: 0.1\n          })\n        }));\n\n        // Add legend\n        var legend = chart.children.push(Legend.new(root, {\n          centerX: p50,\n          x: p50\n        }));\n\n        // Add series\n        function makeSeries(name, fieldName) {\n          var series = chart.series.push(ColumnSeries.new(root, {\n            name: name,\n            stacked: true,\n            xAxis: xAxis,\n            yAxis: yAxis,\n            valueYField: fieldName,\n            categoryXField: "police"\n          }));\n          series.columns.template.setAll({\n            tooltipText: "{name}, {categoryX}: {valueY}",\n            tooltipY: percent(10)\n          });\n          series.data.setAll(data);\n\n          // Make stuff animate on load\n          series.appear();\n          series.bullets.push(function () {\n            return Bullet.new(root, {\n              sprite: Label.new(root, {\n                text: "{valueY}",\n                fill: root.interfaceColors.get("alternativeText"),\n                centerY: p50,\n                centerX: p50,\n                populateText: true\n              })\n            });\n          });\n          legend.data.push(series);\n        }\n        makeSeries("지구대", "지구대");\n        makeSeries("파출소", "파출소");\n\n        // Make stuff animate on load\n        chart.appear(1000, 100);\n        root._logo.dispose(); //amChart 로고 삭제\n      });\n    },\n\n    crimeChart: function () {\n      const vm = this;\n      ready(function () {\n        // Create root element\n        var root = Root.new("crime");\n\n        // Set themes\n        root.setThemes([Animated.new(root)]);\n\n        // Create chart\n        var chart = root.container.children.push(XYChart.new(root, {\n          panX: false,\n          panY: false,\n          paddingLeft: 0,\n          wheelX: "panX",\n          wheelY: "zoomX",\n          layout: root.verticalLayout\n        }));\n\n        // Add legend\n        var legend = chart.children.push(Legend.new(root, {\n          centerX: p50,\n          x: p50\n        }));\n        var data = vm.crimeData.map(item => ({\n          경찰서: item.경찰서,\n          "2021": item["2021"],\n          "2022": item["2022"]\n        }));\n\n        // Create axes\n        var xRenderer = AxisRendererX.new(root, {\n          cellStartLocation: 0.1,\n          cellEndLocation: 0.9,\n          minGridDistance: 30,\n          minorGridEnabled: true\n        });\n        var xAxis = chart.xAxes.push(CategoryAxis.new(root, {\n          categoryField: "경찰서",\n          renderer: xRenderer,\n          tooltip: Tooltip.new(root, {})\n        }));\n        xRenderer.grid.template.setAll({\n          location: 1\n        });\n        xAxis.data.setAll(data);\n        var yAxis = chart.yAxes.push(ValueAxis.new(root, {\n          renderer: AxisRendererY.new(root, {\n            strokeOpacity: 0.1\n          })\n        }));\n\n        // Add series\n        function makeSeries(name, fieldName) {\n          var series = chart.series.push(ColumnSeries.new(root, {\n            name: name,\n            xAxis: xAxis,\n            yAxis: yAxis,\n            valueYField: fieldName,\n            categoryXField: "경찰서"\n          }));\n          series.columns.template.setAll({\n            tooltipText: "{name}, {categoryX}:{valueY}",\n            width: percent(90),\n            tooltipY: 0,\n            strokeOpacity: 0\n          });\n          series.data.setAll(data);\n          series.appear();\n          series.bullets.push(function () {\n            return Bullet.new(root, {\n              locationY: 0,\n              sprite: Label.new(root, {\n                text: "{valueY}",\n                fill: root.interfaceColors.get("alternativeText"),\n                centerY: 0,\n                centerX: p50,\n                populateText: true\n              })\n            });\n          });\n          legend.data.push(series);\n        }\n        makeSeries("2021", "2021");\n        makeSeries("2022", "2022");\n        chart.appear(1000, 100);\n        root._logo.dispose(); //amChart 로고 삭제\n      });\n    },\n\n    fireChart: function () {\n      const vm = this;\n      ready(function () {\n        // Create root element\n        var root = Root.new("fire");\n\n        // Set themes\n        root.setThemes([Animated.new(root)]);\n\n        // Create chart\n        var chart = root.container.children.push(XYChart.new(root, {\n          panX: true,\n          panY: true,\n          wheelX: "panX",\n          wheelY: "zoomX",\n          pinchZoomX: true,\n          paddingLeft: 0,\n          paddingRight: 0\n        }));\n\n        // Add cursor\n        var cursor = chart.set("cursor", XYCursor.new(root, {}));\n        cursor.lineY.set("visible", false);\n\n        // Create axes\n        var xRenderer = AxisRendererX.new(root, {\n          minGridDistance: 30,\n          minorGridEnabled: true\n        });\n        xRenderer.labels.template.setAll({\n          rotation: 1\n        });\n        xRenderer.grid.template.setAll({\n          location: 1\n        });\n        var xAxis = chart.xAxes.push(CategoryAxis.new(root, {\n          categoryField: "소방서",\n          renderer: xRenderer,\n          tooltip: Tooltip.new(root, {})\n        }));\n        var yRenderer = AxisRendererY.new(root, {\n          strokeOpacity: 0.1\n        });\n        var yAxis = chart.yAxes.push(ValueAxis.new(root, {\n          maxDeviation: 0.3,\n          renderer: yRenderer\n        }));\n\n        // Create series\n        var series = chart.series.push(ColumnSeries.new(root, {\n          name: "Series 1",\n          xAxis: xAxis,\n          yAxis: yAxis,\n          valueYField: "비율",\n          sequencedInterpolation: true,\n          categoryXField: "소방서",\n          tooltip: Tooltip.new(root, {\n            labelText: "{valueY}"\n          })\n        }));\n        series.columns.template.setAll({\n          cornerRadiusTL: 5,\n          cornerRadiusTR: 5,\n          strokeOpacity: 0\n        });\n        series.columns.template.adapters.add("fill", function (fill, target) {\n          return chart.get("colors").getIndex(series.columns.indexOf(target));\n        });\n        series.columns.template.adapters.add("stroke", function (stroke, target) {\n          return chart.get("colors").getIndex(series.columns.indexOf(target));\n        });\n\n        // Set data\n        var data = vm.fireData.map(item => ({\n          소방서: item.소방서,\n          비율: item.비율\n        }));\n        xAxis.data.setAll(data);\n        series.data.setAll(data);\n\n        // Make stuff animate on load\n        series.appear(1000);\n        chart.appear(1000, 100);\n        root._logo.dispose(); //amChart\n      }); // end am5.ready()\n    },\n\n    accidentChart: function () {\n      const vm = this;\n      ready(function () {\n        // Create root element\n        var root = Root.new("accident");\n\n        // Set themes\n        root.setThemes([Animated.new(root)]);\n\n        // Create chart\n        var chart = root.container.children.push(XYChart.new(root, {\n          panX: false,\n          panY: false,\n          paddingLeft: 0,\n          wheelX: "panX",\n          wheelY: "zoomX",\n          layout: root.verticalLayout\n        }));\n\n        // Add legend\n        var legend = chart.children.push(Legend.new(root, {\n          centerX: p50,\n          x: p50\n        }));\n        var data = vm.accidentData.map(item => ({\n          소방서: item.소방서,\n          "2021": item["2021"],\n          "2022": item["2022"]\n        }));\n\n        // Create axes\n        var xRenderer = AxisRendererX.new(root, {\n          cellStartLocation: 0.1,\n          cellEndLocation: 0.9,\n          minGridDistance: 30,\n          minorGridEnabled: true\n        });\n        var xAxis = chart.xAxes.push(CategoryAxis.new(root, {\n          categoryField: "소방서",\n          renderer: xRenderer,\n          tooltip: Tooltip.new(root, {})\n        }));\n        xRenderer.grid.template.setAll({\n          location: 1\n        });\n        xAxis.data.setAll(data);\n        var yAxis = chart.yAxes.push(ValueAxis.new(root, {\n          renderer: AxisRendererY.new(root, {\n            strokeOpacity: 0.1\n          })\n        }));\n\n        // Add series\n        function makeSeries(name, fieldName) {\n          var series = chart.series.push(ColumnSeries.new(root, {\n            name: name,\n            xAxis: xAxis,\n            yAxis: yAxis,\n            valueYField: fieldName,\n            categoryXField: "소방서"\n          }));\n          series.columns.template.setAll({\n            tooltipText: "{name}, {categoryX}:{valueY}",\n            width: percent(90),\n            tooltipY: 0,\n            strokeOpacity: 0\n          });\n          series.data.setAll(data);\n          series.appear();\n          series.bullets.push(function () {\n            return Bullet.new(root, {\n              locationY: 0,\n              sprite: Label.new(root, {\n                text: "{valueY}",\n                fill: root.interfaceColors.get("alternativeText"),\n                centerY: 0,\n                centerX: p50,\n                populateText: true\n              })\n            });\n          });\n          legend.data.push(series);\n        }\n        makeSeries("2021", "2021");\n        makeSeries("2022", "2022");\n        chart.appear(1000, 100);\n        root._logo.dispose(); //amChart 로고 삭제\n      });\n    },\n\n    safetyChart: function () {\n      const vm = this;\n      ready(function () {\n        // Create root element\n        var root = Root.new("safety");\n\n        // Set themes\n        root.setThemes([Animated.new(root)]);\n\n        // Create chart\n        var chart = root.container.children.push(XYChart.new(root, {\n          panX: true,\n          panY: true,\n          wheelX: "panX",\n          wheelY: "zoomX",\n          pinchZoomX: true,\n          paddingLeft: 0\n        }));\n\n        // Add cursor\n        // https://www.amcharts.com/docs/v5/charts/xy-chart/cursor/\n        var cursor = chart.set("cursor", XYCursor.new(root, {}));\n        cursor.lineY.set("visible", false);\n\n        // Create axes\n        // https://www.amcharts.com/docs/v5/charts/xy-chart/axes/\n        var xRenderer = AxisRendererX.new(root, {\n          minGridDistance: 15,\n          minorGridEnabled: true\n        });\n        xRenderer.labels.template.setAll({\n          rotation: 0,\n          centerY: 0,\n          centerX: p50\n        });\n        xRenderer.grid.template.setAll({\n          visible: false,\n          location: 1\n        });\n        var xAxis = chart.xAxes.push(CategoryAxis.new(root, {\n          maxDeviation: 0.3,\n          categoryField: "기관명",\n          renderer: xRenderer,\n          tooltip: Tooltip.new(root, {})\n        }));\n        var yAxis = chart.yAxes.push(ValueAxis.new(root, {\n          maxDeviation: 0.3,\n          renderer: AxisRendererY.new(root, {})\n        }));\n\n        // Create series\n        // https://www.amcharts.com/docs/v5/charts/xy-chart/series/\n        var series = chart.series.push(ColumnSeries.new(root, {\n          xAxis: xAxis,\n          yAxis: yAxis,\n          valueYField: "안전지수",\n          categoryXField: "기관명",\n          adjustBulletPosition: false,\n          tooltip: Tooltip.new(root, {\n            labelText: "{valueY}"\n          })\n        }));\n        series.columns.template.setAll({\n          width: 5\n        });\n        series.bullets.push(function () {\n          return Bullet.new(root, {\n            locationY: 1,\n            sprite: Circle.new(root, {\n              radius: 5,\n              fill: series.get("fill")\n            })\n          });\n        });\n\n        // Set data\n        var data = vm.safetyData.map(item => ({\n          기관명: item.기관명,\n          안전지수: item.안전지수\n        }));\n        xAxis.data.setAll(data);\n        series.data.setAll(data);\n\n        // y축 간격 설정\n        yAxis.set("strictMinMaxStep", true);\n        yAxis.set("baseInterval", {\n          count: 5\n        });\n\n        // Make stuff animate on load\n        // https://www.amcharts.com/docs/v5/concepts/animations/\n        series.appear(1000);\n        chart.appear(1000, 100);\n        root._logo.dispose(); //amChart 로고 삭제\n      }); // end am5.ready()\n    },\n\n    casualtyChart: function () {\n      const vm = this;\n      ready(function () {\n        // Create root element\n        var root = Root.new("casualty");\n\n        // Set themes\n        root.setThemes([Animated.new(root)]);\n\n        // Create chart\n        var chart = root.container.children.push(PieChart.new(root, {\n          endAngle: 270\n        }));\n\n        // Create series\n        var series = chart.series.push(PieSeries.new(root, {\n          valueField: "사고심각도",\n          categoryField: "경찰서",\n          endAngle: 270\n        }));\n        series.states.create("hidden", {\n          endAngle: -90\n        });\n\n        // Set data\n        var data = vm.casualtyData.map(item => ({\n          경찰서: item.경찰서,\n          사고심각도: item.사고심각도\n        }));\n        series.data.setAll(data);\n        series.appear(1000, 100);\n        root._logo.dispose(); //amChart 로고 삭제\n      }); // end am5.ready()\n    }\n  }\n});\n;// CONCATENATED MODULE: ./client/views/pages/chart/Safety.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./client/views/pages/chart/Safety.vue?vue&type=style&index=0&id=d6e86182&lang=css\nvar Safetyvue_type_style_index_0_id_d6e86182_lang_css = __webpack_require__(896);\n;// CONCATENATED MODULE: ./client/views/pages/chart/Safety.vue?vue&type=style&index=0&id=d6e86182&lang=css\n\n;// CONCATENATED MODULE: ./client/views/pages/chart/Safety.vue\n\n\n\n\n;\n\n\nconst Safety_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(Safetyvue_type_script_lang_js, [[\'render\',Safetyvue_type_template_id_d6e86182_render]])\n\n/* harmony default export */ const Safety = (Safety_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./client/views/pages/chart/Environment.vue?vue&type=template&id=5ca0321c\n\nconst Environmentvue_type_template_id_5ca0321c_hoisted_1 = /*#__PURE__*/createStaticVNode("<div class=\\"chart-container-wrapper\\"><div class=\\"chart-column\\" style=\\"padding-left:100px;\\"><h2 style=\\"padding-left:300px;padding-top:30px;\\">대기 수질 환경오염배출사업장 현황</h2><div id=\\"chartdiv1\\" class=\\"chart-container\\"></div></div><div class=\\"chart-column\\" style=\\"padding-right:100px;\\"><h2 style=\\"padding-left:300px;padding-top:30px;\\">2023 월별 폐기물 처리량</h2><div id=\\"chartdiv2\\" class=\\"chart-container\\"></div></div></div>", 1);\nconst Environmentvue_type_template_id_5ca0321c_hoisted_2 = {\n  class: "chart-column2"\n};\nconst Environmentvue_type_template_id_5ca0321c_hoisted_3 = /*#__PURE__*/createBaseVNode("h2", {\n  style: {\n    "padding-left": "890px",\n    "padding-top": "30px"\n  }\n}, "연도별 폐기물 반입현황", -1 /* HOISTED */);\nconst Environmentvue_type_template_id_5ca0321c_hoisted_4 = {\n  class: "dropdown-wrapper"\n};\nconst Environmentvue_type_template_id_5ca0321c_hoisted_5 = {\n  class: "dropdown-and-amount"\n};\nconst Environmentvue_type_template_id_5ca0321c_hoisted_6 = /*#__PURE__*/createBaseVNode("div", {\n  id: "chartdiv3",\n  class: "chart-container"\n}, null, -1 /* HOISTED */);\n\nfunction Environmentvue_type_template_id_5ca0321c_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, null, [Environmentvue_type_template_id_5ca0321c_hoisted_1, createBaseVNode("div", Environmentvue_type_template_id_5ca0321c_hoisted_2, [Environmentvue_type_template_id_5ca0321c_hoisted_3, createBaseVNode("div", Environmentvue_type_template_id_5ca0321c_hoisted_4, [createBaseVNode("div", Environmentvue_type_template_id_5ca0321c_hoisted_5, [withDirectives(createBaseVNode("select", {\n    onChange: _cache[0] || (_cache[0] = (...args) => _ctx.updateChart && _ctx.updateChart(...args)),\n    "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => $data.selectedMonth = $event)\n  }, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList($data.months, month => {\n    return openBlock(), createElementBlock("option", {\n      key: month\n    }, toDisplayString(month), 1 /* TEXT */);\n  }), 128 /* KEYED_FRAGMENT */))], 544 /* HYDRATE_EVENTS, NEED_PATCH */), [[vModelSelect, $data.selectedMonth]]), createBaseVNode("button", {\n    onClick: _cache[2] || (_cache[2] = (...args) => _ctx.showTrashCanStatus && _ctx.showTrashCanStatus(...args))\n  }, "대구 쓰레기통 설치 지역")])]), Environmentvue_type_template_id_5ca0321c_hoisted_6])], 64 /* STABLE_FRAGMENT */);\n}\n;// CONCATENATED MODULE: ./client/views/pages/chart/Environment.vue?vue&type=template&id=5ca0321c\n\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/core/render/Scrollbar.js\n\n\n\n\n\n\n/**\r\n * A control that allows zooming chart\'s axes, or other uses requiring range\r\n * selection.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/scrollbars/} for more info\r\n */\nclass Scrollbar extends Container {\n  constructor() {\n    super(...arguments);\n    /**\r\n     * A thumb elment - a draggable square between the grips, used for panning\r\n     * the selection.\r\n     */\n    Object.defineProperty(this, "thumb", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._makeThumb()\n    });\n    /**\r\n     * Start grip button.\r\n     */\n    Object.defineProperty(this, "startGrip", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._makeButton()\n    });\n    /**\r\n     * End grip button.\r\n     */\n    Object.defineProperty(this, "endGrip", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: this._makeButton()\n    });\n    Object.defineProperty(this, "_thumbBusy", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_startDown", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_endDown", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_thumbDown", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, "_gripDown", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  _addOrientationClass() {\n    this._settings.themeTags = mergeTags(this._settings.themeTags, ["scrollbar", this._settings.orientation]);\n    if (!this._settings.background) {\n      this._settings.background = RoundedRectangle.new(this._root, {\n        themeTags: mergeTags(this._settings.themeTags, ["main", "background"])\n      });\n    }\n  }\n  _makeButton() {\n    return this.children.push(Button.new(this._root, {\n      themeTags: ["resize", "button", this.get("orientation")],\n      icon: Graphics.new(this._root, {\n        themeTags: ["icon"]\n      })\n    }));\n  }\n  _makeThumb() {\n    return this.children.push(RoundedRectangle.new(this._root, {\n      themeTags: ["thumb", this.get("orientation")]\n    }));\n  }\n  _handleAnimation(animation) {\n    if (animation) {\n      this._disposers.push(animation.events.on("stopped", () => {\n        this.setPrivateRaw("isBusy", false);\n        this._thumbBusy = false;\n      }));\n    }\n  }\n  _afterNew() {\n    this._addOrientationClass();\n    super._afterNew();\n    const startGrip = this.startGrip;\n    const endGrip = this.endGrip;\n    const thumb = this.thumb;\n    const background = this.get("background");\n    if (background) {\n      this._disposers.push(background.events.on("click", event => {\n        this.setPrivateRaw("isBusy", true);\n        const point = this._display.toLocal(event.point);\n        const w = this.width();\n        const h = this.height();\n        const orientation = this.get("orientation");\n        let newMiddle;\n        if (orientation == "vertical") {\n          newMiddle = (point.y - thumb.height() / 2) / h;\n        } else {\n          newMiddle = (point.x - thumb.width() / 2) / w;\n        }\n        let newCoordinate;\n        let key;\n        if (orientation == "vertical") {\n          newCoordinate = newMiddle * h;\n          key = "y";\n        } else {\n          newCoordinate = newMiddle * w;\n          key = "x";\n        }\n        const duration = this.get("animationDuration", 0);\n        if (duration > 0) {\n          this._thumbBusy = true;\n          this._handleAnimation(this.thumb.animate({\n            key: key,\n            to: newCoordinate,\n            duration: duration,\n            easing: this.get("animationEasing")\n          }));\n        } else {\n          this.thumb.set(key, newCoordinate);\n          this._root.events.once("frameended", () => {\n            this.setPrivateRaw("isBusy", false);\n          });\n        }\n      }));\n    }\n    this._disposers.push(thumb.events.on("dblclick", event => {\n      if (!isLocalEvent(event.originalEvent, this)) {\n        return;\n      }\n      const duration = this.get("animationDuration", 0);\n      const easing = this.get("animationEasing");\n      this.animate({\n        key: "start",\n        to: 0,\n        duration: duration,\n        easing: easing\n      });\n      this.animate({\n        key: "end",\n        to: 1,\n        duration: duration,\n        easing: easing\n      });\n    }));\n    this._disposers.push(startGrip.events.on("pointerdown", () => {\n      this.setPrivateRaw("isBusy", true);\n      this._startDown = true;\n      this._gripDown = "start";\n    }));\n    this._disposers.push(endGrip.events.on("pointerdown", () => {\n      this.setPrivateRaw("isBusy", true);\n      this._endDown = true;\n      this._gripDown = "end";\n    }));\n    this._disposers.push(thumb.events.on("pointerdown", () => {\n      this.setPrivateRaw("isBusy", true);\n      this._thumbDown = true;\n      this._gripDown = undefined;\n    }));\n    this._disposers.push(startGrip.events.on("globalpointerup", () => {\n      if (this._startDown) {\n        this.setPrivateRaw("isBusy", false);\n        this._released();\n      }\n      this._startDown = false;\n    }));\n    this._disposers.push(endGrip.events.on("globalpointerup", () => {\n      if (this._endDown) {\n        this.setPrivateRaw("isBusy", false);\n        this._released();\n      }\n      this._endDown = false;\n    }));\n    this._disposers.push(thumb.events.on("globalpointerup", () => {\n      if (this._thumbDown) {\n        this.setPrivateRaw("isBusy", false);\n        this._released();\n      }\n      this._thumbDown = false;\n    }));\n    this._disposers.push(startGrip.on("x", () => {\n      this._updateThumb();\n    }));\n    this._disposers.push(endGrip.on("x", () => {\n      this._updateThumb();\n    }));\n    this._disposers.push(startGrip.on("y", () => {\n      this._updateThumb();\n    }));\n    this._disposers.push(endGrip.on("y", () => {\n      this._updateThumb();\n    }));\n    this._disposers.push(thumb.events.on("positionchanged", () => {\n      this._updateGripsByThumb();\n    }));\n    if (this.get("orientation") == "vertical") {\n      startGrip.set("x", 0);\n      endGrip.set("x", 0);\n      this._disposers.push(thumb.adapters.add("y", value => {\n        return Math.max(Math.min(Number(value), this.height() - thumb.height()), 0);\n      }));\n      this._disposers.push(thumb.adapters.add("x", _value => {\n        return this.width() / 2;\n      }));\n      this._disposers.push(startGrip.adapters.add("x", _value => {\n        return this.width() / 2;\n      }));\n      this._disposers.push(endGrip.adapters.add("x", _value => {\n        return this.width() / 2;\n      }));\n      this._disposers.push(startGrip.adapters.add("y", value => {\n        return Math.max(Math.min(Number(value), this.height()), 0);\n      }));\n      this._disposers.push(endGrip.adapters.add("y", value => {\n        return Math.max(Math.min(Number(value), this.height()), 0);\n      }));\n    } else {\n      startGrip.set("y", 0);\n      endGrip.set("y", 0);\n      this._disposers.push(thumb.adapters.add("x", value => {\n        return Math.max(Math.min(Number(value), this.width() - thumb.width()), 0);\n      }));\n      this._disposers.push(thumb.adapters.add("y", _value => {\n        return this.height() / 2;\n      }));\n      this._disposers.push(startGrip.adapters.add("y", _value => {\n        return this.height() / 2;\n      }));\n      this._disposers.push(endGrip.adapters.add("y", _value => {\n        return this.height() / 2;\n      }));\n      this._disposers.push(startGrip.adapters.add("x", value => {\n        return Math.max(Math.min(Number(value), this.width()), 0);\n      }));\n      this._disposers.push(endGrip.adapters.add("x", value => {\n        return Math.max(Math.min(Number(value), this.width()), 0);\n      }));\n    }\n  }\n  _updateChildren() {\n    super._updateChildren();\n    if (this.isDirty("end") || this.isDirty("start") || this._sizeDirty) {\n      this.updateGrips();\n    }\n  }\n  _changed() {\n    super._changed();\n    if (this.isDirty("start") || this.isDirty("end")) {\n      const eventType = "rangechanged";\n      if (this.events.isEnabled(eventType)) {\n        this.events.dispatch(eventType, {\n          type: eventType,\n          target: this,\n          start: this.get("start", 0),\n          end: this.get("end", 1),\n          grip: this._gripDown\n        });\n      }\n    }\n  }\n  _released() {\n    const eventType = "released";\n    if (this.events.isEnabled(eventType)) {\n      this.events.dispatch(eventType, {\n        type: eventType,\n        target: this\n      });\n    }\n  }\n  /**\r\n   * @ignore\r\n   */\n  updateGrips() {\n    const startGrip = this.startGrip;\n    const endGrip = this.endGrip;\n    const orientation = this.get("orientation");\n    const height = this.height();\n    const width = this.width();\n    if (orientation == "vertical") {\n      startGrip.set("y", height * this.get("start", 0));\n      endGrip.set("y", height * this.get("end", 1));\n    } else {\n      startGrip.set("x", width * this.get("start", 0));\n      endGrip.set("x", width * this.get("end", 1));\n    }\n    const valueFunction = this.getPrivate("positionTextFunction");\n    const from = Math.round(this.get("start", 0) * 100);\n    const to = Math.round(this.get("end", 0) * 100);\n    let fromValue;\n    let toValue;\n    if (valueFunction) {\n      fromValue = valueFunction.call(this, this.get("start", 0));\n      toValue = valueFunction.call(this, this.get("end", 0));\n    } else {\n      fromValue = from + "%";\n      toValue = to + "%";\n    }\n    startGrip.set("ariaLabel", this._t("From %1", undefined, fromValue));\n    startGrip.set("ariaValueNow", "" + from);\n    startGrip.set("ariaValueText", from + "%");\n    startGrip.set("ariaValueMin", "0");\n    startGrip.set("ariaValueMax", "100");\n    endGrip.set("ariaLabel", this._t("To %1", undefined, toValue));\n    endGrip.set("ariaValueNow", "" + to);\n    endGrip.set("ariaValueText", to + "%");\n    endGrip.set("ariaValueMin", "0");\n    endGrip.set("ariaValueMax", "100");\n  }\n  _updateThumb() {\n    const thumb = this.thumb;\n    const startGrip = this.startGrip;\n    const endGrip = this.endGrip;\n    const height = this.height();\n    const width = this.width();\n    let x0 = startGrip.x();\n    let x1 = endGrip.x();\n    let y0 = startGrip.y();\n    let y1 = endGrip.y();\n    let start = 0;\n    let end = 1;\n    if (this.get("orientation") == "vertical") {\n      if (Type_isNumber(y0) && Type_isNumber(y1)) {\n        if (!this._thumbBusy && !thumb.isDragging()) {\n          thumb.set("height", y1 - y0);\n          thumb.set("y", y0);\n        }\n        start = y0 / height;\n        end = y1 / height;\n      }\n    } else {\n      if (Type_isNumber(x0) && Type_isNumber(x1)) {\n        if (!this._thumbBusy && !thumb.isDragging()) {\n          thumb.set("width", x1 - x0);\n          thumb.set("x", x0);\n        }\n        start = x0 / width;\n        end = x1 / width;\n      }\n    }\n    if (this.getPrivate("isBusy") && (this.get("start") != start || this.get("end") != end)) {\n      this.set("start", start);\n      this.set("end", end);\n    }\n    const valueFunction = this.getPrivate("positionTextFunction");\n    const from = Math.round(this.get("start", 0) * 100);\n    const to = Math.round(this.get("end", 0) * 100);\n    let fromValue;\n    let toValue;\n    if (valueFunction) {\n      fromValue = valueFunction.call(this, this.get("start", 0));\n      toValue = valueFunction.call(this, this.get("end", 0));\n    } else {\n      fromValue = from + "%";\n      toValue = to + "%";\n    }\n    thumb.set("ariaLabel", this._t("From %1 to %2", undefined, fromValue, toValue));\n    thumb.set("ariaValueNow", "" + from);\n    thumb.set("ariaValueText", from + "%");\n  }\n  _updateGripsByThumb() {\n    const thumb = this.thumb;\n    const startGrip = this.startGrip;\n    const endGrip = this.endGrip;\n    if (this.get("orientation") == "vertical") {\n      const thumbSize = thumb.height();\n      startGrip.set("y", thumb.y());\n      endGrip.set("y", thumb.y() + thumbSize);\n    } else {\n      const thumbSize = thumb.width();\n      startGrip.set("x", thumb.x());\n      endGrip.set("x", thumb.x() + thumbSize);\n    }\n  }\n}\nObject.defineProperty(Scrollbar, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "Scrollbar"\n});\nObject.defineProperty(Scrollbar, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: Container.classNames.concat([Scrollbar.className])\n});\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./client/views/pages/chart/Environment.vue?vue&type=script&lang=js\n\n\n\n\n/* harmony default export */ const Environmentvue_type_script_lang_js = ({\n  data() {\n    return {\n      selectedMonth: \'1월\',\n      months: [\'1월\', \'2월\', \'3월\', \'4월\', \'5월\', \'6월\', \'7월\', \'8월\', \'9월\', \'10월\', \'11월\', \'12월\'],\n      wasteData: [],\n      chartData: [],\n      carryInData: [[{\n        year: "2022",\n        life_waste: 3305,\n        construction_site_waste: 1505,\n        workplace_waste: 330\n      }, {\n        year: "2023",\n        life_waste: 5631,\n        construction_site_waste: 2457,\n        workplace_waste: 283\n      }, {\n        year: "2024",\n        life_waste: 3192,\n        construction_site_waste: 853,\n        workplace_waste: 157\n      }]]\n    };\n  },\n  methods: {\n    loadData() {\n      this.loadPieChartData();\n      this.loadBarChartData();\n      this.loadCarryInData();\n    },\n    loadPieChartData() {\n      lib_axios.post("/wasteList.json", {}).then(response => {\n        console.log("wasteSelectData - response:", response.data);\n        this.wasteData = response.data;\n        this.preparePieChartData();\n      }).catch(error => {\n        console.log("wasteSelectData - error :", error);\n        alert("파이차트 조회 오류");\n      });\n    },\n    loadBarChartData() {\n      lib_axios.post("/processList.json", {}).then(response => {\n        console.log("selectChartData - response:", response.data);\n        this.chartData = response.data;\n        this.prepareBarChart();\n      }).catch(error => {\n        console.log("selectChartData - error :", error);\n        alert("막대차트 조회 오류");\n      });\n    },\n    loadCarryInData() {\n      lib_axios.post("/carryInList.json", {}).then(response => {\n        this.carryInData = response.data;\n        this.createCarryInChart(this.carryInData);\n      }).catch(error => {\n        alert("차트3 조회 오류");\n      });\n    },\n    preparePieChartData() {\n      const groupedData = this.groupDataByInduty();\n      const pieChartData = Object.entries(groupedData).map(([induty, count]) => ({\n        category: induty,\n        value: count\n      }));\n      this.createPieChart(pieChartData);\n    },\n    groupDataByInduty() {\n      const groupedData = {};\n      this.wasteData.forEach(item => {\n        const induty = item.INDUTY;\n        if (groupedData[induty]) {\n          groupedData[induty]++;\n        } else {\n          groupedData[induty] = 1;\n        }\n      });\n      return groupedData;\n    },\n    prepareBarChart() {\n      const barChartData = this.chartData.map(item => ({\n        month: item.month,\n        total_vehicles: item.total_vehicles\n      }));\n      this.createBarChart(barChartData);\n    },\n    createPieChart(data) {\n      var root1 = Root.new("chartdiv1");\n      const theme1 = Theme.new(root1);\n      var chart1 = root1.container.children.push(am5percent.PieChart.new(root1, {\n        layout: root1.verticalLayout\n      }));\n      var series1 = chart1.series.push(am5percent.PieSeries.new(root1, {\n        valueField: "value",\n        categoryField: "category"\n      }));\n      series1.data.setAll(data);\n      series1.appear(1000, 100);\n      root1._logo.dispose();\n    },\n    createBarChart(data) {\n      var root2 = Root.new("chartdiv2");\n      const theme2 = Theme.new(root2);\n      var chart2 = root2.container.children.push(XYChart.new(root2, {\n        panX: true,\n        panY: true,\n        wheelX: "panX",\n        wheelY: "zoomX",\n        pinchZoomX: true,\n        paddingLeft: 0,\n        paddingRight: 1\n      }));\n      var cursor2 = chart2.set("cursor", XYCursor.new(root2, {}));\n      cursor2.lineY.set("visible", false);\n      var xRenderer2 = AxisRendererX.new(root2, {\n        minGridDistance: 30,\n        minorGridEnabled: true\n      });\n      xRenderer2.labels.template.setAll({\n        rotation: 0,\n        centerY: p50,\n        centerX: p100,\n        paddingRight: 15\n      });\n      xRenderer2.grid.template.setAll({\n        location: 1\n      });\n      var xAxis2 = chart2.xAxes.push(CategoryAxis.new(root2, {\n        maxDeviation: 0.3,\n        categoryField: "month",\n        renderer: xRenderer2,\n        tooltip: Tooltip.new(root2, {})\n      }));\n      var yRenderer2 = AxisRendererY.new(root2, {\n        strokeOpacity: 0.1\n      });\n      var yAxis2 = chart2.yAxes.push(ValueAxis.new(root2, {\n        maxDeviation: 0.3,\n        renderer: yRenderer2\n      }));\n      var series2 = chart2.series.push(ColumnSeries.new(root2, {\n        name: "Series 2",\n        xAxis: xAxis2,\n        yAxis: yAxis2,\n        valueYField: "total_vehicles",\n        sequencedInterpolation: true,\n        categoryXField: "month",\n        tooltip: Tooltip.new(root2, {\n          labelText: "{valueY}"\n        })\n      }));\n      series2.columns.template.setAll({\n        cornerRadiusTL: 5,\n        cornerRadiusTR: 5,\n        strokeOpacity: 0\n      });\n      series2.columns.template.adapters.add("fill", function (fill, target) {\n        return chart2.get("colors").getIndex(series2.columns.indexOf(target));\n      });\n      series2.columns.template.adapters.add("stroke", function (stroke, target) {\n        return chart2.get("colors").getIndex(series2.columns.indexOf(target));\n      });\n      xAxis2.data.setAll(data);\n      series2.data.setAll(data);\n      series2.appear(1000);\n      chart2.appear(1000, 100);\n      root2._logo.dispose();\n    },\n    createCarryInChart(data) {\n      var root3 = Root.new("chartdiv3");\n      root3.setThemes([Animated.new(root3)]);\n      var chart3 = root3.container.children.push(XYChart.new(root3, {\n        panX: false,\n        panY: false,\n        paddingLeft: 0,\n        layout: root3.verticalLayout\n      }));\n      chart3.set("scrollbarX", Scrollbar.new(root3, {\n        orientation: "horizontal"\n      }));\n      var xAxis3 = chart3.xAxes.push(CategoryAxis.new(root3, {\n        categoryField: "year",\n        renderer: AxisRendererX.new(root3, {\n          minGridDistance: 30\n        })\n      }));\n      xAxis3.get("renderer").labels.template.setAll({\n        rotation: 0,\n        centerY: p50,\n        centerX: p100,\n        paddingRight: 15,\n        fontSize: 20\n      });\n      var yAxis3 = chart3.yAxes.push(ValueAxis.new(root3, {\n        renderer: AxisRendererY.new(root3, {})\n      }));\n      var series3_1 = chart3.series.push(ColumnSeries.new(root3, {\n        name: "생활폐기물",\n        xAxis: xAxis3,\n        yAxis: yAxis3,\n        valueYField: "life_waste",\n        categoryXField: "year",\n        tooltip: Tooltip.new(root3, {\n          labelText: "{name}: {valueY}"\n        })\n      }));\n      var series3_2 = chart3.series.push(ColumnSeries.new(root3, {\n        name: "건설현장 폐기물",\n        xAxis: xAxis3,\n        yAxis: yAxis3,\n        valueYField: "construction_site_waste",\n        categoryXField: "year",\n        tooltip: Tooltip.new(root3, {\n          labelText: "{name}: {valueY}"\n        })\n      }));\n      var series3_3 = chart3.series.push(ColumnSeries.new(root3, {\n        name: "작업장 폐기물",\n        xAxis: xAxis3,\n        yAxis: yAxis3,\n        valueYField: "workplace_waste",\n        categoryXField: "year",\n        tooltip: Tooltip.new(root3, {\n          labelText: "{name}: {valueY}"\n        })\n      }));\n      var legend = chart3.children.push(Legend.new(root3, {}));\n      legend.data.setAll(chart3.series.values);\n      xAxis3.data.setAll(data);\n      series3_1.data.setAll(data);\n      series3_2.data.setAll(data);\n      series3_3.data.setAll(data);\n      chart3.appear(1000, 100);\n      root3._logo.dispose();\n    }\n  },\n  mounted() {\n    this.loadData();\n  }\n});\n;// CONCATENATED MODULE: ./client/views/pages/chart/Environment.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./client/views/pages/chart/Environment.vue?vue&type=style&index=0&id=5ca0321c&lang=css\nvar Environmentvue_type_style_index_0_id_5ca0321c_lang_css = __webpack_require__(994);\n;// CONCATENATED MODULE: ./client/views/pages/chart/Environment.vue?vue&type=style&index=0&id=5ca0321c&lang=css\n\n;// CONCATENATED MODULE: ./client/views/pages/chart/Environment.vue\n\n\n\n\n;\n\n\nconst Environment_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(Environmentvue_type_script_lang_js, [[\'render\',Environmentvue_type_template_id_5ca0321c_render]])\n\n/* harmony default export */ const Environment = (Environment_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./client/views/pages/chart/Population.vue?vue&type=template&id=2a312308\n\nconst Populationvue_type_template_id_2a312308_hoisted_1 = /*#__PURE__*/createStaticVNode("<div class=\\"container\\"><div class=\\"row\\"><div class=\\"column\\"><h2>연도별 대구 인구 변화</h2><div id=\\"chartdiv1\\" class=\\"chartdiv\\"></div></div><div class=\\"column\\"><h2>대구 남녀 인구변화</h2><div id=\\"chartdiv2\\" class=\\"chartdiv\\"></div></div><div class=\\"column\\"><h2>대구 등록세대수 변화</h2><div id=\\"chartdiv3\\" class=\\"chartdiv\\"></div></div></div></div><hr><div class=\\"container\\"><div class=\\"row\\"><div class=\\"column\\"><h2>대구 인구증감율</h2><div id=\\"chartdiv4\\" class=\\"chartdiv\\"></div></div><div class=\\"column\\"><h2>대구 노인 인구변화</h2><div id=\\"chartdiv5\\" class=\\"chartdiv\\"></div></div><div class=\\"column\\"><h2>대구 지역 인구수</h2><div id=\\"chartdiv6\\" class=\\"chartdiv\\"></div></div></div></div><hr><div class=\\"container\\"><div class=\\"row\\"><div class=\\"column\\"><h1 style=\\"margin-top:12px;\\">대구 인구밀도</h1><br><div class=\\"flex-container\\"><div class=\\"textbox1\\"> 국토교통부 &quot;지적통계&quot;의 행정구역별 국토면적을 이용하여 업데이트 하였음</div><div id=\\"chartdiv7\\" class=\\"chartdiv\\"></div></div></div><div class=\\"column\\"><h2 style=\\"margin-top:12px;\\">대구 외국인 인구변화</h2><br><div class=\\"flex-container\\"><div class=\\"textbox2\\"></div><div id=\\"chartdiv8\\" class=\\"chartdiv\\"></div></div></div></div></div><hr>", 6);\nfunction Populationvue_type_template_id_2a312308_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return Populationvue_type_template_id_2a312308_hoisted_1;\n}\n;// CONCATENATED MODULE: ./node_modules/d3-shape/src/array.js\nvar array_slice = Array.prototype.slice;\n/* harmony default export */ function array(x) {\n  return typeof x === "object" && "length" in x ? x // Array, TypedArray, NodeList, array-like\n  : Array.from(x); // Map, Set, iterable, string, or anything else\n}\n;// CONCATENATED MODULE: ./node_modules/d3-shape/src/curve/linear.js\nfunction Linear(context) {\n  this._context = context;\n}\nLinear.prototype = {\n  areaStart: function () {\n    this._line = 0;\n  },\n  areaEnd: function () {\n    this._line = NaN;\n  },\n  lineStart: function () {\n    this._point = 0;\n  },\n  lineEnd: function () {\n    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function (x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);\n        break;\n      case 1:\n        this._point = 2;\n      // falls through\n      default:\n        this._context.lineTo(x, y);\n        break;\n    }\n  }\n};\n/* harmony default export */ function curve_linear(context) {\n  return new Linear(context);\n}\n;// CONCATENATED MODULE: ./node_modules/d3-shape/src/point.js\nfunction point_x(p) {\n  return p[0];\n}\nfunction point_y(p) {\n  return p[1];\n}\n;// CONCATENATED MODULE: ./node_modules/d3-shape/src/line.js\n\n\n\n\n\n/* harmony default export */ function src_line(x, y) {\n  var defined = constant(true),\n    context = null,\n    curve = curve_linear,\n    output = null,\n    path = withPath(line);\n  x = typeof x === "function" ? x : x === undefined ? point_x : constant(x);\n  y = typeof y === "function" ? y : y === undefined ? point_y : constant(y);\n  function line(data) {\n    var i,\n      n = (data = array(data)).length,\n      d,\n      defined0 = false,\n      buffer;\n    if (context == null) output = curve(buffer = path());\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) output.lineStart();else output.lineEnd();\n      }\n      if (defined0) output.point(+x(d, i, data), +y(d, i, data));\n    }\n    if (buffer) return output = null, buffer + "" || null;\n  }\n  line.x = function (_) {\n    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), line) : x;\n  };\n  line.y = function (_) {\n    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), line) : y;\n  };\n  line.defined = function (_) {\n    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;\n  };\n  line.curve = function (_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;\n  };\n  line.context = function (_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;\n  };\n  return line;\n}\n;// CONCATENATED MODULE: ./node_modules/d3-shape/src/area.js\n\n\n\n\n\n\n/* harmony default export */ function src_area(x0, y0, y1) {\n  var x1 = null,\n    defined = constant(true),\n    context = null,\n    curve = curve_linear,\n    output = null,\n    path = withPath(area);\n  x0 = typeof x0 === "function" ? x0 : x0 === undefined ? point_x : constant(+x0);\n  y0 = typeof y0 === "function" ? y0 : y0 === undefined ? constant(0) : constant(+y0);\n  y1 = typeof y1 === "function" ? y1 : y1 === undefined ? point_y : constant(+y1);\n  function area(data) {\n    var i,\n      j,\n      k,\n      n = (data = array(data)).length,\n      d,\n      defined0 = false,\n      buffer,\n      x0z = new Array(n),\n      y0z = new Array(n);\n    if (context == null) output = curve(buffer = path());\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) {\n          j = i;\n          output.areaStart();\n          output.lineStart();\n        } else {\n          output.lineEnd();\n          output.lineStart();\n          for (k = i - 1; k >= j; --k) {\n            output.point(x0z[k], y0z[k]);\n          }\n          output.lineEnd();\n          output.areaEnd();\n        }\n      }\n      if (defined0) {\n        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);\n        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);\n      }\n    }\n    if (buffer) return output = null, buffer + "" || null;\n  }\n  function arealine() {\n    return src_line().defined(defined).curve(curve).context(context);\n  }\n  area.x = function (_) {\n    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;\n  };\n  area.x0 = function (_) {\n    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;\n  };\n  area.x1 = function (_) {\n    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;\n  };\n  area.y = function (_) {\n    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;\n  };\n  area.y0 = function (_) {\n    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;\n  };\n  area.y1 = function (_) {\n    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;\n  };\n  area.lineX0 = area.lineY0 = function () {\n    return arealine().x(x0).y(y0);\n  };\n  area.lineY1 = function () {\n    return arealine().x(x0).y(y1);\n  };\n  area.lineX1 = function () {\n    return arealine().x(x1).y(y0);\n  };\n  area.defined = function (_) {\n    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;\n  };\n  area.curve = function (_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;\n  };\n  area.context = function (_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;\n  };\n  return area;\n}\n;// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/LineSeries.js\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * Used to plot line and/or area series.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/line-series/} for more info\r\n * @important\r\n */\nclass LineSeries extends XYSeries {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, "_endIndex", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_strokeGenerator", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: src_line()\n    });\n    Object.defineProperty(this, "_fillGenerator", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: src_area()\n    });\n    Object.defineProperty(this, "_legendStroke", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_legendFill", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * A [[TemplateList]] of all line segments in series.\r\n     *\r\n     * `strokes.template` can be used to set default settings for all line\r\n     * segments, or to change on existing ones.\r\n     *\r\n     * @default new ListTemplate<Graphics>\r\n     */\n    Object.defineProperty(this, "strokes", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListTemplate(Template.new({}), () => Graphics._new(this._root, {\n        themeTags: mergeTags(this.strokes.template.get("themeTags", []), ["line", "series", "stroke"])\n      }, [this.strokes.template]))\n    });\n    /**\r\n     * A [[TemplateList]] of all segment fills in series.\r\n     *\r\n     * `fills.template` can be used to set default settings for all segment\r\n     * fills, or to change on existing ones.\r\n     *\r\n     * @default new ListTemplate<Graphics>\r\n     */\n    Object.defineProperty(this, "fills", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListTemplate(Template.new({}), () => Graphics._new(this._root, {\n        themeTags: mergeTags(this.strokes.template.get("themeTags", []), ["line", "series", "fill"])\n      }, [this.fills.template]))\n    });\n    // custom set from data\n    Object.defineProperty(this, "_fillTemplate", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_strokeTemplate", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, "_previousPoint", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [0, 0, 0, 0]\n    });\n    Object.defineProperty(this, "_dindex", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, "_sindex", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n  }\n  _afterNew() {\n    this._fillGenerator.y0(function (p) {\n      return p[3];\n    });\n    this._fillGenerator.x0(function (p) {\n      return p[2];\n    });\n    this._fillGenerator.y1(function (p) {\n      return p[1];\n    });\n    this._fillGenerator.x1(function (p) {\n      return p[0];\n    });\n    super._afterNew();\n  }\n  /**\r\n   * @ignore\r\n   */\n  makeStroke(strokes) {\n    const stroke = this.mainContainer.children.push(strokes.make());\n    strokes.push(stroke);\n    return stroke;\n  }\n  /**\r\n   * @ignore\r\n   */\n  makeFill(fills) {\n    const fill = this.mainContainer.children.push(fills.make());\n    fills.push(fill);\n    return fill;\n  }\n  _updateChildren() {\n    this._strokeTemplate = undefined;\n    this._fillTemplate = undefined;\n    let xAxis = this.get("xAxis");\n    let yAxis = this.get("yAxis");\n    if (this.isDirty("stroke")) {\n      const stroke = this.get("stroke");\n      this.strokes.template.set("stroke", stroke);\n      const legendStroke = this._legendStroke;\n      if (legendStroke) {\n        legendStroke.states.lookup("default").set("stroke", stroke);\n      }\n    }\n    if (this.isDirty("fill")) {\n      const fill = this.get("fill");\n      this.fills.template.set("fill", fill);\n      const legendFill = this._legendFill;\n      if (legendFill) {\n        legendFill.states.lookup("default").set("fill", fill);\n      }\n    }\n    if (this.isDirty("curveFactory")) {\n      const curveFactory = this.get("curveFactory");\n      if (curveFactory) {\n        this._strokeGenerator.curve(curveFactory);\n        this._fillGenerator.curve(curveFactory);\n      }\n    }\n    if (xAxis.inited && yAxis.inited) {\n      if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty("vcx") || this.isDirty("vcy") || this._sizeDirty || this.isDirty("connect") || this.isDirty("curveFactory")) {\n        this.fills.each(fill => {\n          fill.setPrivate("visible", false);\n        });\n        this.strokes.each(fill => {\n          fill.setPrivate("visible", false);\n        });\n        this.axisRanges.each(axisRange => {\n          let fills = axisRange.fills;\n          if (fills) {\n            fills.each(fill => {\n              fill.setPrivate("visible", false);\n            });\n          }\n          let strokes = axisRange.strokes;\n          if (strokes) {\n            strokes.each(stroke => {\n              stroke.setPrivate("visible", false);\n            });\n          }\n        });\n        let startIndex = this.startIndex();\n        let strokeTemplateField = this.strokes.template.get("templateField");\n        let fillTemplateField = this.fills.template.get("templateField");\n        let strokeTemplateFound = true;\n        let fillTemplateFound = true;\n        if (strokeTemplateField) {\n          strokeTemplateFound = false;\n        }\n        if (fillTemplateField) {\n          fillTemplateFound = false;\n        }\n        for (let i = startIndex - 1; i >= 0; i--) {\n          let dataItem = this.dataItems[i];\n          let hasValues = true;\n          let dataContext = dataItem.dataContext;\n          if (strokeTemplateField) {\n            if (dataContext[strokeTemplateField]) {\n              strokeTemplateFound = true;\n            }\n          }\n          if (fillTemplateField) {\n            if (dataContext[fillTemplateField]) {\n              fillTemplateFound = true;\n            }\n          }\n          each(this._valueFields, field => {\n            if (!Type_isNumber(dataItem.get(field))) {\n              hasValues = false;\n            }\n          });\n          if (hasValues && strokeTemplateFound && fillTemplateFound) {\n            startIndex = i;\n            break;\n          }\n        }\n        let len = this.dataItems.length;\n        let endIndex = this.endIndex();\n        if (endIndex < len) {\n          endIndex++;\n          for (let i = endIndex; i < len; i++) {\n            let dataItem = this.dataItems[i];\n            let hasValues = true;\n            each(this._valueFields, field => {\n              if (!Type_isNumber(dataItem.get(field))) {\n                hasValues = false;\n              }\n            });\n            if (hasValues) {\n              endIndex = i + 1;\n              break;\n            }\n          }\n        }\n        if (startIndex > 0) {\n          startIndex--;\n        }\n        this._endIndex = endIndex;\n        this._clearGraphics();\n        this._sindex = 0;\n        this._dindex = startIndex;\n        if (this.dataItems.length == 1) {\n          this._startSegment(0);\n        } else {\n          // this is done to avoid recursion with a lot of segments \n          while (this._dindex < endIndex - 1) {\n            this._startSegment(this._dindex);\n            this._sindex++;\n          }\n        }\n      }\n    } else {\n      this._skipped = true;\n    }\n    super._updateChildren();\n  }\n  _clearGraphics() {\n    this.strokes.clear();\n    this.fills.clear();\n  }\n  _startSegment(dataItemIndex) {\n    let endIndex = this._endIndex;\n    let currentEndIndex = endIndex;\n    const autoGapCount = this.get("autoGapCount");\n    const connect = this.get("connect");\n    const fill = this.makeFill(this.fills);\n    const fillTemplate = this._fillTemplate;\n    const originalTemplate = this.fills.template;\n    if (fillTemplate && fillTemplate != originalTemplate) {\n      fill.template = fillTemplate;\n    }\n    fill.setPrivate("visible", true);\n    const stroke = this.makeStroke(this.strokes);\n    const strokeTemplate = this._strokeTemplate;\n    if (strokeTemplate && strokeTemplate != this.strokes.template) {\n      stroke.template = strokeTemplate;\n    }\n    stroke.setPrivate("visible", true);\n    let xAxis = this.get("xAxis");\n    let yAxis = this.get("yAxis");\n    let baseAxis = this.get("baseAxis");\n    let vcx = this.get("vcx", 1);\n    let vcy = this.get("vcy", 1);\n    let xField = this._xField;\n    let yField = this._yField;\n    let xOpenField = this._xOpenField;\n    let yOpenField = this._yOpenField;\n    const xOpenFieldValue = this.get("openValueXField");\n    const yOpenFieldValue = this.get("openValueYField");\n    if (!xOpenFieldValue) {\n      xOpenField = this._xField;\n    }\n    if (!yOpenFieldValue) {\n      yOpenField = this._yField;\n    }\n    const stacked = this.get("stacked");\n    const basePosX = xAxis.basePosition();\n    const basePosY = yAxis.basePosition();\n    let baseField;\n    if (baseAxis === yAxis) {\n      baseField = this._yField;\n    } else {\n      baseField = this._xField;\n    }\n    const segments = [];\n    let points = [];\n    segments.push(points);\n    const strokeTemplateField = this.strokes.template.get("templateField");\n    const fillTemplateField = this.fills.template.get("templateField");\n    let locationX = this.get("locationX", 0.5);\n    let locationY = this.get("locationY", 0.5);\n    let openLocationX = this.get("openLocationX", locationX);\n    let openLocationY = this.get("openLocationY", locationY);\n    const minDistance = this.get("minDistance", 0);\n    let i;\n    let fillVisible = this.fills.template.get("visible");\n    if (this.axisRanges.length > 0) {\n      fillVisible = true;\n    }\n    let getOpen = false;\n    if (stacked || xOpenFieldValue || yOpenFieldValue) {\n      getOpen = true;\n    }\n    const o = {\n      points,\n      segments,\n      stacked,\n      getOpen,\n      basePosX,\n      basePosY,\n      fillVisible,\n      xField,\n      yField,\n      xOpenField,\n      yOpenField,\n      vcx,\n      vcy,\n      baseAxis,\n      xAxis,\n      yAxis,\n      locationX,\n      locationY,\n      openLocationX,\n      openLocationY,\n      minDistance\n    };\n    let rangeStrokeTemplate = this._strokeTemplate;\n    let rangeFillTemplate = this._fillTemplate;\n    for (i = dataItemIndex; i < currentEndIndex; i++) {\n      this._dindex = i;\n      const dataItem = this._dataItems[i];\n      let valueX = dataItem.get(xField);\n      let valueY = dataItem.get(yField);\n      if (valueX == null || valueY == null) {\n        if (!connect) {\n          points = [];\n          segments.push(points);\n          o.points = points;\n        }\n      } else {\n        this._getPoints(dataItem, o);\n      }\n      if (strokeTemplateField) {\n        let strokeTemplate = dataItem.dataContext[strokeTemplateField];\n        if (strokeTemplate) {\n          if (!(strokeTemplate instanceof Template)) {\n            strokeTemplate = Template.new(strokeTemplate);\n          }\n          this._strokeTemplate = strokeTemplate;\n          if (i > dataItemIndex) {\n            currentEndIndex = i;\n            break;\n          } else {\n            rangeStrokeTemplate = strokeTemplate;\n            stroke.template = strokeTemplate;\n          }\n        }\n      }\n      if (fillTemplateField) {\n        let fillTemplate = dataItem.dataContext[fillTemplateField];\n        if (fillTemplate) {\n          if (!(fillTemplate instanceof Template)) {\n            fillTemplate = Template.new(fillTemplate);\n          }\n          this._fillTemplate = fillTemplate;\n          if (i > dataItemIndex) {\n            currentEndIndex = i;\n            break;\n          } else {\n            rangeFillTemplate = fillTemplate;\n            fill.template = fillTemplate;\n          }\n        }\n      }\n      if (!connect) {\n        let nextItem = this.dataItems[i + 1];\n        if (nextItem) {\n          if (baseAxis.shouldGap(dataItem, nextItem, autoGapCount, baseField)) {\n            points = [];\n            segments.push(points);\n            o.points = points;\n          }\n        }\n      }\n    }\n    fill.setRaw("userData", [dataItemIndex, i]);\n    stroke.setRaw("userData", [dataItemIndex, i]);\n    if (i === endIndex) {\n      this._endLine(points, segments[0][0]);\n    }\n    if (stroke) {\n      this._drawStroke(stroke, segments);\n    }\n    if (fill) {\n      this._drawFill(fill, segments);\n    }\n    this.axisRanges.each(axisRange => {\n      const container = axisRange.container;\n      const fills = axisRange.fills;\n      const fill = this.makeFill(fills);\n      if (container) {\n        container.children.push(fill);\n      }\n      fill.setPrivate("visible", true);\n      this._drawFill(fill, segments);\n      const strokes = axisRange.strokes;\n      const stroke = this.makeStroke(strokes);\n      if (container) {\n        container.children.push(stroke);\n      }\n      if (rangeStrokeTemplate && rangeStrokeTemplate != this.strokes.template) {\n        stroke.template = rangeStrokeTemplate;\n      }\n      if (rangeFillTemplate && rangeFillTemplate != this.fills.template) {\n        fill.template = rangeFillTemplate;\n      }\n      stroke.setPrivate("visible", true);\n      this._drawStroke(stroke, segments);\n      fill.setRaw("userData", [dataItemIndex, i]);\n      stroke.setRaw("userData", [dataItemIndex, i]);\n    });\n  }\n  _getPoints(dataItem, o) {\n    let points = o.points;\n    let itemLocationX = dataItem.get("locationX", o.locationX);\n    let itemLocationY = dataItem.get("locationY", o.locationY);\n    let xPos = o.xAxis.getDataItemPositionX(dataItem, o.xField, itemLocationX, o.vcx);\n    let yPos = o.yAxis.getDataItemPositionY(dataItem, o.yField, itemLocationY, o.vcy);\n    if (this._shouldInclude(xPos)) {\n      const iPoint = this.getPoint(xPos, yPos);\n      const point = [iPoint.x, iPoint.y];\n      iPoint.x += this._x;\n      iPoint.y += this._y;\n      dataItem.set("point", iPoint);\n      if (o.fillVisible) {\n        let xPos0 = xPos;\n        let yPos0 = yPos;\n        if (o.baseAxis === o.xAxis) {\n          yPos0 = o.basePosY;\n        } else if (o.baseAxis === o.yAxis) {\n          xPos0 = o.basePosX;\n        }\n        if (o.getOpen) {\n          let valueX = dataItem.get(o.xOpenField);\n          let valueY = dataItem.get(o.yOpenField);\n          if (valueX != null && valueY != null) {\n            let itemLocationX = dataItem.get("openLocationX", o.openLocationX);\n            let itemLocationY = dataItem.get("openLocationY", o.openLocationY);\n            if (o.stacked) {\n              let stackToItemX = dataItem.get("stackToItemX");\n              let stackToItemY = dataItem.get("stackToItemY");\n              if (stackToItemX) {\n                xPos0 = o.xAxis.getDataItemPositionX(stackToItemX, o.xField, itemLocationX, stackToItemX.component.get("vcx"));\n                if (Type_isNaN(xPos0)) {\n                  xPos0 = o.basePosX;\n                }\n              } else {\n                if (o.yAxis === o.baseAxis) {\n                  xPos0 = o.basePosX;\n                } else {\n                  xPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX, o.vcx);\n                }\n              }\n              if (stackToItemY) {\n                yPos0 = o.yAxis.getDataItemPositionY(stackToItemY, o.yField, itemLocationY, stackToItemY.component.get("vcy"));\n                if (Type_isNaN(yPos0)) {\n                  yPos0 = o.basePosY;\n                }\n              } else {\n                if (o.xAxis === o.baseAxis) {\n                  yPos0 = o.basePosY;\n                } else {\n                  yPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY, o.vcy);\n                }\n              }\n            } else {\n              xPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX, o.vcx);\n              yPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY, o.vcy);\n            }\n          }\n        }\n        let closeIPoint = this.getPoint(xPos0, yPos0);\n        point[2] = closeIPoint.x;\n        point[3] = closeIPoint.y;\n      }\n      if (o.minDistance > 0) {\n        const p0 = point[0];\n        const p1 = point[1];\n        const p2 = point[2];\n        const p3 = point[3];\n        const prev = this._previousPoint;\n        const pp0 = prev[0];\n        const pp1 = prev[1];\n        const pp2 = prev[2];\n        const pp3 = prev[3];\n        if (Math.hypot(p0 - pp0, p1 - pp1) > o.minDistance || p2 && p3 && Math.hypot(p2 - pp2, p3 - pp3) > o.minDistance) {\n          points.push(point);\n          this._previousPoint = point;\n        }\n      } else {\n        points.push(point);\n      }\n    }\n  }\n  _endLine(_points, _firstPoint) {}\n  _drawStroke(graphics, segments) {\n    if (graphics.get("visible") && !graphics.get("forceHidden")) {\n      graphics.set("draw", display => {\n        each(segments, segment => {\n          this._strokeGenerator.context(display);\n          this._strokeGenerator(segment);\n        });\n      });\n    }\n  }\n  _drawFill(graphics, segments) {\n    if (graphics.get("visible") && !graphics.get("forceHidden")) {\n      graphics.set("draw", display => {\n        each(segments, segment => {\n          this._fillGenerator.context(display);\n          this._fillGenerator(segment);\n        });\n      });\n    }\n  }\n  _processAxisRange(axisRange) {\n    super._processAxisRange(axisRange);\n    axisRange.fills = new ListTemplate(Template.new({}), () => Graphics._new(this._root, {\n      themeTags: mergeTags(axisRange.fills.template.get("themeTags", []), ["line", "series", "fill"])\n    }, [this.fills.template, axisRange.fills.template]));\n    axisRange.strokes = new ListTemplate(Template.new({}), () => Graphics._new(this._root, {\n      themeTags: mergeTags(axisRange.strokes.template.get("themeTags", []), ["line", "series", "stroke"])\n    }, [this.strokes.template, axisRange.strokes.template]));\n  }\n  /**\r\n   * @ignore\r\n   */\n  createLegendMarker(_dataItem) {\n    const legendDataItem = this.get("legendDataItem");\n    if (legendDataItem) {\n      const marker = legendDataItem.get("marker");\n      const markerRectangle = legendDataItem.get("markerRectangle");\n      if (markerRectangle) {\n        markerRectangle.setPrivate("visible", false);\n      }\n      marker.set("background", Rectangle.new(marker._root, {\n        fillOpacity: 0,\n        fill: color(0x000000)\n      }));\n      const legendStroke = marker.children.push(Graphics._new(marker._root, {\n        themeTags: ["line", "series", "legend", "marker", "stroke"],\n        interactive: false\n      }, [this.strokes.template]));\n      this._legendStroke = legendStroke;\n      const legendFill = marker.children.push(Graphics._new(marker._root, {\n        themeTags: ["line", "series", "legend", "marker", "fill"]\n      }, [this.fills.template]));\n      this._legendFill = legendFill;\n      const disabledColor = this._root.interfaceColors.get("disabled");\n      legendStroke.states.create("disabled", {\n        fill: disabledColor,\n        stroke: disabledColor\n      });\n      legendFill.states.create("disabled", {\n        fill: disabledColor,\n        stroke: disabledColor\n      });\n      if (this.bullets.length > 0) {\n        const bulletFunction = this.bullets.getIndex(0);\n        if (bulletFunction) {\n          const bullet = bulletFunction(marker._root, this, new DataItem(this, {\n            legend: true\n          }, {}));\n          if (bullet) {\n            const sprite = bullet.get("sprite");\n            if (sprite instanceof Graphics) {\n              sprite.states.create("disabled", {\n                fill: disabledColor,\n                stroke: disabledColor\n              });\n            }\n            if (sprite) {\n              sprite.set("tooltipText", undefined);\n              sprite.set("tooltipHTML", undefined);\n              marker.children.push(sprite);\n              sprite.setAll({\n                x: marker.width() / 2,\n                y: marker.height() / 2\n              });\n              marker.events.on("boundschanged", () => {\n                sprite.setAll({\n                  x: marker.width() / 2,\n                  y: marker.height() / 2\n                });\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n}\nObject.defineProperty(LineSeries, "className", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: "LineSeries"\n});\nObject.defineProperty(LineSeries, "classNames", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: XYSeries.classNames.concat([LineSeries.className])\n});\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./client/views/pages/chart/Population.vue?vue&type=script&lang=js\n\n\n\n\n\n/* harmony default export */ const Populationvue_type_script_lang_js = ({\n  data() {\n    return {\n      dataList: [],\n      chartData: {\n        year: [],\n        Register: [],\n        Register_men: [],\n        Register_women: [],\n        Korean: [],\n        Korean_man: [],\n        Korean_women: [],\n        Foreign: [],\n        Households: [],\n        Foreign_man: [],\n        Foreign_women: [],\n        plus: [],\n        Elderly: [],\n        density: [],\n        pieData: [{\n          region: "달서구",\n          value: 525768\n        }, {\n          region: "수성구",\n          value: 411533\n        }, {\n          region: "남구",\n          value: 141519\n        }, {\n          region: "달성군",\n          value: 263162\n        }, {\n          region: "동구",\n          value: 339530\n        }, {\n          region: "북구",\n          value: 430912\n        }, {\n          region: "서구",\n          value: 159827\n        }, {\n          region: "중구",\n          value: 91034\n        }]\n      }\n    };\n  },\n  methods: {\n    loadData() {\n      lib_axios.post("/chartList.json", {}, {\n        headers: {\n          "Content-Type": "application/json"\n        }\n      }).then(response => {\n        this.dataList = response.data;\n        this.prepareChartData();\n      }).catch(error => {\n        console.log("데이터 조회 오류:", error);\n        alert("조회 오류");\n      });\n    },\n    prepareChartData() {\n      this.dataList.forEach(item => {\n        this.chartData.year.push(item.year);\n        this.chartData.Korean.push({\n          year: item.year,\n          value: item.Korean\n        });\n        this.chartData.Korean_man.push({\n          year: item.year,\n          value: item.Korean_man\n        });\n        this.chartData.Korean_women.push({\n          year: item.year,\n          value: item.Korean_women\n        });\n        this.chartData.Households.push({\n          year: item.year,\n          value: item.Households\n        });\n        this.chartData.plus.push({\n          year: item.year,\n          value: item.plus\n        });\n        this.chartData.Elderly.push({\n          year: item.year,\n          value: item.Elderly\n        });\n        this.chartData.density.push({\n          year: item.year,\n          value: item.density\n        });\n\n        // 다른 데이터도 유사하게 처리\n      });\n\n      // 차트 생성 호출\n      this.createChart("chartdiv1", this.chartData.Korean, "value");\n      this.createGenderChart("chartdiv2", this.chartData.Korean_man, this.chartData.Korean_women);\n      this.createLineChart("chartdiv3", this.chartData.Households);\n      this.createPlusChart("chartdiv4", this.chartData.plus, "value");\n      this.createElderlyChart("chartdiv5", this.chartData.Elderly, "value");\n      this.createPieChart("chartdiv6", this.chartData.pieData);\n      this.createdensityChart("chartdiv7", this.chartData.density, "value");\n\n      // 다른 차트도 유사하게 생성\n    },\n\n    createChart(chartDivId, chartData, valueField) {\n      let root = Root.new(chartDivId);\n      root.setThemes([Animated.new(root)]);\n      let chart = root.container.children.push(XYChart.new(root, {\n        panX: true,\n        panY: true,\n        wheelX: "panX",\n        wheelY: "zoomX",\n        pinchZoomX: true,\n        paddingLeft: 0,\n        paddingRight: 1\n      }));\n      let cursor = chart.set("cursor", XYCursor.new(root, {}));\n      cursor.lineY.set("visible", false);\n      let xRenderer = AxisRendererX.new(root, {\n        minGridDistance: 30,\n        minorGridEnabled: true\n      });\n      xRenderer.labels.template.setAll({\n        centerY: p50,\n        centerX: p100,\n        paddingRight: 15\n      });\n      xRenderer.grid.template.setAll({\n        location: 1\n      });\n      let xAxis = chart.xAxes.push(CategoryAxis.new(root, {\n        maxDeviation: 0.3,\n        categoryField: "year",\n        renderer: xRenderer,\n        tooltip: Tooltip.new(root, {})\n      }));\n      let yRenderer = AxisRendererY.new(root, {\n        strokeOpacity: 0.1\n      });\n      let yAxis = chart.yAxes.push(ValueAxis.new(root, {\n        maxDeviation: 0.3,\n        renderer: yRenderer\n      }));\n      let series = chart.series.push(ColumnSeries.new(root, {\n        name: "Series 1",\n        xAxis: xAxis,\n        yAxis: yAxis,\n        valueYField: valueField,\n        sequencedInterpolation: true,\n        categoryXField: "year",\n        tooltip: Tooltip.new(root, {\n          labelText: "{valueY}"\n        })\n      }));\n      series.columns.template.setAll({\n        cornerRadiusTL: 5,\n        cornerRadiusTR: 5,\n        strokeOpacity: 0\n      });\n      series.columns.template.adapters.add("fill", (fill, target) => chart.get("colors").getIndex(series.columns.indexOf(target)));\n      series.columns.template.adapters.add("stroke", (stroke, target) => chart.get("colors").getIndex(series.columns.indexOf(target)));\n      xAxis.data.setAll(chartData);\n      series.data.setAll(chartData);\n      series.appear(1000);\n      chart.appear(1000, 100);\n      root._logo.dispose();\n    },\n    createGenderChart(chartDivId, maleData, femaleData) {\n      let root = Root.new(chartDivId);\n      root.setThemes([Animated.new(root)]);\n      let chart = root.container.children.push(XYChart.new(root, {\n        panX: true,\n        panY: true,\n        wheelX: "panX",\n        wheelY: "zoomX",\n        pinchZoomX: true,\n        paddingLeft: 0,\n        paddingRight: 1\n      }));\n      let cursor = chart.set("cursor", XYCursor.new(root, {}));\n      cursor.lineY.set("visible", false);\n      let xRenderer = AxisRendererX.new(root, {\n        minGridDistance: 30,\n        minorGridEnabled: true\n      });\n      xRenderer.labels.template.setAll({\n        centerY: p50,\n        centerX: p100,\n        paddingRight: 15\n      });\n      xRenderer.grid.template.setAll({\n        location: 1\n      });\n      let xAxis = chart.xAxes.push(CategoryAxis.new(root, {\n        maxDeviation: 0.3,\n        categoryField: "year",\n        renderer: xRenderer,\n        tooltip: Tooltip.new(root, {})\n      }));\n      let yRenderer = AxisRendererY.new(root, {\n        strokeOpacity: 0.1\n      });\n      let yAxis = chart.yAxes.push(ValueAxis.new(root, {\n        maxDeviation: 0.3,\n        renderer: yRenderer\n      }));\n      let maleSeries = chart.series.push(ColumnSeries.new(root, {\n        name: "남자",\n        xAxis: xAxis,\n        yAxis: yAxis,\n        valueYField: "value",\n        sequencedInterpolation: true,\n        categoryXField: "year",\n        tooltip: Tooltip.new(root, {\n          labelText: "{valueY}"\n        })\n      }));\n      let femaleSeries = chart.series.push(ColumnSeries.new(root, {\n        name: "여자",\n        xAxis: xAxis,\n        yAxis: yAxis,\n        valueYField: "value",\n        sequencedInterpolation: true,\n        categoryXField: "year",\n        tooltip: Tooltip.new(root, {\n          labelText: "{valueY}"\n        })\n      }));\n      maleSeries.columns.template.setAll({\n        cornerRadiusTL: 5,\n        cornerRadiusTR: 5,\n        strokeOpacity: 0,\n        fill: color(0x0000ff) // 파란색\n      });\n\n      femaleSeries.columns.template.setAll({\n        cornerRadiusTL: 5,\n        cornerRadiusTR: 5,\n        strokeOpacity: 0,\n        fill: color(0xff0000) // 빨간색\n      });\n\n      xAxis.data.setAll(maleData.map((data, index) => ({\n        year: data.year,\n        maleValue: data.value,\n        femaleValue: femaleData[index].value\n      })));\n      maleSeries.data.setAll(maleData);\n      femaleSeries.data.setAll(femaleData);\n      maleSeries.appear(1000);\n      femaleSeries.appear(1000);\n      chart.appear(1000, 100);\n\n      // Legend 추가\n      let legend = chart.children.push(Legend.new(root, {\n        centerX: p50,\n        x: p50\n      }));\n      legend.data.setAll([maleSeries, femaleSeries]);\n      root._logo.dispose();\n    },\n    createLineChart(chartDivId, chartData) {\n      let root = Root.new(chartDivId);\n      root.setThemes([Animated.new(root)]);\n      let chart = root.container.children.push(XYChart.new(root, {\n        panX: true,\n        panY: true,\n        wheelX: "panX",\n        wheelY: "zoomX",\n        pinchZoomX: true,\n        paddingLeft: 0,\n        paddingRight: 1\n      }));\n      let cursor = chart.set("cursor", XYCursor.new(root, {}));\n      cursor.lineY.set("visible", false);\n      let xRenderer = AxisRendererX.new(root, {\n        minGridDistance: 30,\n        minorGridEnabled: true\n      });\n      xRenderer.labels.template.setAll({\n        centerY: p50,\n        centerX: p100,\n        paddingRight: 15\n      });\n      xRenderer.grid.template.setAll({\n        location: 1\n      });\n      let xAxis = chart.xAxes.push(CategoryAxis.new(root, {\n        maxDeviation: 0.3,\n        categoryField: "year",\n        renderer: xRenderer,\n        tooltip: Tooltip.new(root, {})\n      }));\n      let yRenderer = AxisRendererY.new(root, {\n        strokeOpacity: 0.1\n      });\n      let yAxis = chart.yAxes.push(ValueAxis.new(root, {\n        maxDeviation: 0.3,\n        renderer: yRenderer\n      }));\n      let series = chart.series.push(LineSeries.new(root, {\n        name: "Households",\n        xAxis: xAxis,\n        yAxis: yAxis,\n        valueYField: "value",\n        sequencedInterpolation: true,\n        categoryXField: "year",\n        tooltip: Tooltip.new(root, {\n          labelText: "{valueY}"\n        })\n      }));\n      xAxis.data.setAll(chartData.map(data => ({\n        year: data.year,\n        value: data.value\n      })));\n      series.data.setAll(chartData);\n      series.appear(1000);\n      chart.appear(1000, 100);\n      root._logo.dispose();\n    },\n    createPlusChart(chartDivId, chartData, valueField) {\n      let root = Root.new(chartDivId);\n      root.setThemes([Animated.new(root)]);\n      let chart = root.container.children.push(XYChart.new(root, {\n        panX: true,\n        panY: true,\n        wheelX: "panX",\n        wheelY: "zoomX",\n        pinchZoomX: true,\n        paddingLeft: 0,\n        paddingRight: 1\n      }));\n      let cursor = chart.set("cursor", XYCursor.new(root, {}));\n      cursor.lineY.set("visible", false);\n      let xRenderer = AxisRendererX.new(root, {\n        minGridDistance: 30,\n        minorGridEnabled: true\n      });\n      xRenderer.labels.template.setAll({\n        centerY: p50,\n        centerX: p100,\n        paddingRight: 15\n      });\n      xRenderer.grid.template.setAll({\n        location: 1\n      });\n      let xAxis = chart.xAxes.push(CategoryAxis.new(root, {\n        maxDeviation: 0.3,\n        categoryField: "year",\n        renderer: xRenderer,\n        tooltip: Tooltip.new(root, {})\n      }));\n      let yRenderer = AxisRendererY.new(root, {\n        strokeOpacity: 0.1\n      });\n      let yAxis = chart.yAxes.push(ValueAxis.new(root, {\n        maxDeviation: 0.3,\n        renderer: yRenderer\n      }));\n      let series = chart.series.push(ColumnSeries.new(root, {\n        name: "Series 1",\n        xAxis: xAxis,\n        yAxis: yAxis,\n        valueYField: valueField,\n        sequencedInterpolation: true,\n        categoryXField: "year",\n        tooltip: Tooltip.new(root, {\n          labelText: "{valueY}"\n        })\n      }));\n      series.columns.template.setAll({\n        cornerRadiusTL: 5,\n        cornerRadiusTR: 5,\n        strokeOpacity: 0\n      });\n      series.columns.template.adapters.add("fill", (fill, target) => chart.get("colors").getIndex(series.columns.indexOf(target)));\n      series.columns.template.adapters.add("stroke", (stroke, target) => chart.get("colors").getIndex(series.columns.indexOf(target)));\n      xAxis.data.setAll(chartData);\n      series.data.setAll(chartData);\n      series.appear(1000);\n      chart.appear(1000, 100);\n      root._logo.dispose();\n    },\n    createElderlyChart(chartDivId, chartData, valueField) {\n      let root = Root.new(chartDivId);\n      root.setThemes([Animated.new(root)]);\n      let chart = root.container.children.push(XYChart.new(root, {\n        panX: true,\n        panY: true,\n        wheelX: "panX",\n        wheelY: "zoomX",\n        pinchZoomX: true,\n        paddingLeft: 0,\n        paddingRight: 1\n      }));\n      let cursor = chart.set("cursor", XYCursor.new(root, {}));\n      cursor.lineY.set("visible", false);\n      let xRenderer = AxisRendererX.new(root, {\n        minGridDistance: 30,\n        minorGridEnabled: true\n      });\n      xRenderer.labels.template.setAll({\n        centerY: p50,\n        centerX: p100,\n        paddingRight: 15\n      });\n      xRenderer.grid.template.setAll({\n        location: 1\n      });\n      let xAxis = chart.xAxes.push(CategoryAxis.new(root, {\n        maxDeviation: 0.3,\n        categoryField: "year",\n        renderer: xRenderer,\n        tooltip: Tooltip.new(root, {})\n      }));\n      let yRenderer = AxisRendererY.new(root, {\n        strokeOpacity: 0.1\n      });\n      let yAxis = chart.yAxes.push(ValueAxis.new(root, {\n        maxDeviation: 0.3,\n        renderer: yRenderer\n      }));\n      let series = chart.series.push(ColumnSeries.new(root, {\n        name: "Series 2",\n        xAxis: xAxis,\n        yAxis: yAxis,\n        valueYField: valueField,\n        sequencedInterpolation: true,\n        categoryXField: "year",\n        tooltip: Tooltip.new(root, {\n          labelText: "{valueY}"\n        })\n      }));\n      series.columns.template.setAll({\n        cornerRadiusTL: 5,\n        cornerRadiusTR: 5,\n        strokeOpacity: 0\n      });\n      series.columns.template.adapters.add("fill", (fill, target) => chart.get("colors").getIndex(series.columns.indexOf(target)));\n      series.columns.template.adapters.add("stroke", (stroke, target) => chart.get("colors").getIndex(series.columns.indexOf(target)));\n      xAxis.data.setAll(chartData);\n      series.data.setAll(chartData);\n      series.appear(1000);\n      chart.appear(1000, 100);\n      root._logo.dispose();\n    },\n    createPieChart(chartDivId, pieData) {\n      let root = Root.new(chartDivId);\n      root.setThemes([Animated.new(root)]);\n      let chart = root.container.children.push(PieChart.new(root, {\n        layout: root.verticalLayout\n      }));\n      let series = chart.series.push(PieSeries.new(root, {\n        valueField: "value",\n        categoryField: "region"\n      }));\n      series.data.setAll(pieData);\n      series.appear(1000, 100);\n      root._logo.dispose();\n    }\n  },\n  mounted() {\n    this.loadData();\n  }\n});\n;// CONCATENATED MODULE: ./client/views/pages/chart/Population.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./client/views/pages/chart/Population.vue?vue&type=style&index=0&id=2a312308&lang=css\nvar Populationvue_type_style_index_0_id_2a312308_lang_css = __webpack_require__(137);\n;// CONCATENATED MODULE: ./client/views/pages/chart/Population.vue?vue&type=style&index=0&id=2a312308&lang=css\n\n;// CONCATENATED MODULE: ./client/views/pages/chart/Population.vue\n\n\n\n\n;\n\n\nconst Population_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(Populationvue_type_script_lang_js, [[\'render\',Populationvue_type_template_id_2a312308_render]])\n\n/* harmony default export */ const Population = (Population_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./client/views/pages/chart/Welfare.vue?vue&type=template&id=cbce9910\nfunction Welfarevue_type_template_id_cbce9910_render(_ctx, _cache) {\n  return null;\n}\n;// CONCATENATED MODULE: ./client/views/pages/chart/Welfare.vue\n\nconst script = {}\n\n;\nconst Welfare_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(script, [[\'render\',Welfarevue_type_template_id_cbce9910_render]])\n\n/* harmony default export */ const Welfare = (Welfare_exports_);\n;// CONCATENATED MODULE: ./client/views/pages/AppRouter.js\n\n\n\n\n\n\nconst routes = [/* 메인화면 */\n{\n  path: "/",\n  name: "Main",\n  component: Main\n}, /* 차트 */\n{\n  path: \'/safety.page\',\n  name: \'Safety\',\n  component: Safety\n}, {\n  path: \'/environment.page\',\n  name: \'Environment\',\n  component: Environment\n}, {\n  path: \'/population.page\',\n  name: \'Population\',\n  component: Population\n}, {\n  path: \'/welfare.page\',\n  name: \'Welfare\',\n  component: Welfare\n}];\nconst AppRouter = createRouter({\n  history: createWebHistory(),\n  routes\n});\n/* harmony default export */ const pages_AppRouter = (AppRouter);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./client/views/pages/App.vue?vue&type=template&id=0e182e1d\n\nconst Appvue_type_template_id_0e182e1d_hoisted_1 = {\n  class: "main-warp"\n};\nfunction Appvue_type_template_id_0e182e1d_render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_Header = resolveComponent("Header");\n  const _component_router_view = resolveComponent("router-view");\n  return openBlock(), createElementBlock("div", null, [runtime_core_esm_bundler_createVNode(_component_Header), createBaseVNode("div", Appvue_type_template_id_0e182e1d_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_router_view)])]);\n}\n;// CONCATENATED MODULE: ./client/views/pages/App.vue?vue&type=template&id=0e182e1d\n\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./client/views/layout/Header.vue?vue&type=template&id=56192826\n\nconst Headervue_type_template_id_56192826_hoisted_1 = {\n  class: "nav"\n};\nfunction Headervue_type_template_id_56192826_render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_router_link = resolveComponent("router-link");\n  return openBlock(), createElementBlock("header", null, [createCommentVNode(" 네비바 "), createBaseVNode("div", Headervue_type_template_id_56192826_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_router_link, {\n    class: "home",\n    to: "/"\n  }, {\n    default: withCtx(() => [createTextVNode("everyDaegu")]),\n    _: 1 /* STABLE */\n  }), createBaseVNode("ul", null, [createBaseVNode("li", null, [runtime_core_esm_bundler_createVNode(_component_router_link, {\n    to: "/population.page"\n  }, {\n    default: withCtx(() => [createTextVNode("인구")]),\n    _: 1 /* STABLE */\n  })]), createBaseVNode("li", null, [runtime_core_esm_bundler_createVNode(_component_router_link, {\n    to: "/welfare.page"\n  }, {\n    default: withCtx(() => [createTextVNode("복지")]),\n    _: 1 /* STABLE */\n  })]), createBaseVNode("li", null, [runtime_core_esm_bundler_createVNode(_component_router_link, {\n    to: "/safety.page"\n  }, {\n    default: withCtx(() => [createTextVNode("안전")]),\n    _: 1 /* STABLE */\n  })]), createBaseVNode("li", null, [runtime_core_esm_bundler_createVNode(_component_router_link, {\n    to: "/environment.page"\n  }, {\n    default: withCtx(() => [createTextVNode("환경")]),\n    _: 1 /* STABLE */\n  })]), createCommentVNode(" <li><a href=\\"#\\">관리자</a></li> ")])])]);\n}\n;// CONCATENATED MODULE: ./client/views/layout/Header.vue?vue&type=template&id=56192826\n\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./client/views/layout/Header.vue?vue&type=script&lang=js\n/* harmony default export */ const Headervue_type_script_lang_js = ({\n  data() {\n    return {};\n  },\n  methods: {},\n  watch: {},\n  computed: {},\n  components: {},\n  mounted() {\n    console.log("Header mounted");\n  }\n});\n;// CONCATENATED MODULE: ./client/views/layout/Header.vue?vue&type=script&lang=js\n \n;// CONCATENATED MODULE: ./client/views/layout/Header.vue\n\n\n\n\n;\nconst Header_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(Headervue_type_script_lang_js, [[\'render\',Headervue_type_template_id_56192826_render]])\n\n/* harmony default export */ const Header = (Header_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./client/views/pages/App.vue?vue&type=script&lang=js\n\nconst App = {\n  data: () => {\n    return {};\n  },\n  methods: {},\n  watch: {},\n  computed: {},\n  components: {\n    Header: Header\n  },\n  mounted: () => {\n    console.log(\'Vue mounted\');\n  }\n};\n/* harmony default export */ const Appvue_type_script_lang_js = (App);\n;// CONCATENATED MODULE: ./client/views/pages/App.vue?vue&type=script&lang=js\n \n;// CONCATENATED MODULE: ./client/views/pages/App.vue\n\n\n\n\n;\nconst App_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(Appvue_type_script_lang_js, [[\'render\',Appvue_type_template_id_0e182e1d_render]])\n\n/* harmony default export */ const pages_App = (App_exports_);\n;// CONCATENATED MODULE: ./client/views/index.js\n/**\r\n * @author : 하석형\r\n * @since : 2023.08.24\r\n * @dscription : Vue를 활용한 Client단 구현의 시작점(Index) Component 입니다.\r\n */\n\n\n\n\n// const vue = createApp(App).mount(\'#root\');\nconst vue = createApp(pages_App).use(pages_AppRouter).mount(\'#root\');\n\n//# sourceURL=webpack:///./client/views/index.js_+_189_modules?')},705:module=>{"use strict";eval('\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = "";\n      var needLayer = typeof item[5] !== "undefined";\n      if (item[4]) {\n        content += "@supports (".concat(item[4], ") {");\n      }\n      if (item[2]) {\n        content += "@media ".concat(item[2], " {");\n      }\n      if (needLayer) {\n        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += "}";\n      }\n      if (item[2]) {\n        content += "}";\n      }\n      if (item[4]) {\n        content += "}";\n      }\n      return content;\n    }).join("");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === "string") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== "undefined") {\n        if (typeof item[5] === "undefined") {\n          item[5] = layer;\n        } else {\n          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = "".concat(supports);\n        } else {\n          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/api.js?')},738:module=>{"use strict";eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/noSourceMaps.js?")},21:(__unused_webpack_module,exports)=>{"use strict";eval("var __webpack_unused_export__;\n\n\n__webpack_unused_export__ = ({\n  value: true\n});\n// runtime helper for setting properties on components\n// in a tree-shakable way\nexports.Z = (sfc, props) => {\n  const target = sfc.__vccOpts || sfc;\n  for (const [key, val] of props) {\n    target[key] = val;\n  }\n  return target;\n};\n\n//# sourceURL=webpack:///./node_modules/vue-loader/dist/exportHelper.js?")},120:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(738);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(705);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `\n.chart-container-wrapper {\r\n    display: flex;\r\n    margin: 30px;\n}\n.chart-column {\r\n    flex: auto;\n}\n.chart-container {\r\n    width: 90%;\r\n    height: 500px;\n}\n.chart-column2 {\r\n    width: 90%;\r\n    padding-top: 30px;\r\n    padding-left: 100px;\n}\n.dropdown-wrapper {\r\n    padding-left: 30px;\n}\n.dropdown-and-amount {\r\n    display: flex;\r\n    align-items: center;\n}\n.dropdown-wrapper select {\r\n    padding: 7px;\r\n    font-size: 15px;\n}\n.dropdown-wrapper p {\r\n    margin-left: 20px;\n}\n.dropdown-wrapper button {\r\n    margin-left: 20px;\r\n    padding: 7px 10px;\r\n    font-size: 15px;\n}\r\n  `, ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack:///./client/views/pages/chart/Environment.vue?./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet%5B1%5D.rules%5B6%5D.use%5B0%5D')},781:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(738);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(705);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `\n.container {\r\n    width: 100%;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\n}\n.row {\r\n    display: flex;\r\n    flex-direction: row;\r\n    width: 100%;\r\n    justify-content: center;\n}\n.column {\r\n    flex: 100%;\r\n    padding: 20px;\r\n    text-align: center;\n}\n.chartdiv {\r\n    width: 95%;\r\n    height: 250px;\n}\n.textbox1, .textbox2 {\r\n    margin-left: 20px;\r\n    word-wrap: break-word; /* 긴 단어 줄바꿈 */\r\n    padding: 10px;\r\n    background-color: #ccc; /* 박스 배경색 */\r\n    border-radius: 10px; /* 모서리 둥글게 */\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\n}\n.flex-container {\r\n  display: flex;\r\n  padding: 10px;\n}\n.textbox1{\r\n    width: 20%; \r\n    margin-right: 40px;\n}\n.textbox2{\r\n    width: 15%;\n}\r\n`, ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack:///./client/views/pages/chart/Population.vue?./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet%5B1%5D.rules%5B6%5D.use%5B0%5D')},202:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(738);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(705);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `\n.policediv{\r\n    width: 95%;\r\n    height: 250px;\n}\n.crimediv{\r\n    width: 95%;\r\n    height: 250px;\n}\n.firediv {\r\n    width: 92%;\r\n    height: 220px;\n}\n.accidentdiv{\r\n    width: 94%;\r\n    height: 250px;\n}\n.casualtydiv{\r\n    width: 65%;\r\n    height: 150px;\r\n    margin-left: 20px;\n}\n.safediv{\r\n    width: 65%;\r\n    height: 150px;\n}\n.textbox1{\r\n    width: 20%; \r\n    margin-right: 40px;\n}\n.textbox2{\r\n    width: 15%;\n}\r\n/* h1, h2 왼쪽 정렬 */\n.column h1, .column h2 {\r\n  text-align: left;\n}\n.textbox1, .textbox2 {\r\n    margin-left: 20px;\r\n    word-wrap: break-word; /* 긴 단어 줄바꿈 */\r\n    padding: 10px;\r\n    background-color: #ccc; /* 박스 배경색 */\r\n    border-radius: 10px; /* 모서리 둥글게 */\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\n}\n.container {\r\n    width: 100%;\r\n    display: flex; \r\n    justify-content: center;\r\n    padding: 10px;\n}\n.row {\r\n    display: flex;\r\n    flex-direction: row;\r\n    width: 100%;\r\n    justify-content: center;\n}\n.column {\r\n    flex: 100%;\r\n    padding: 20px;\n}\n.flex-container {\r\n  display: flex;\r\n  padding: 10px;\n}\r\n\r\n`, ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack:///./client/views/pages/chart/Safety.vue?./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet%5B1%5D.rules%5B6%5D.use%5B0%5D')},651:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(738);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(705);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `\n.layout[data-v-d4956396] {\r\n    width: 100vw;\r\n    height: 100vh;\r\n    margin: 0;\r\n    text-align: center;\r\n    display: grid;\r\n    grid-template-columns: 20% 80%;\r\n    gap: 8px;\n}\n.sidebar[data-v-d4956396] { \r\n    grid-column: 1 / 2;\n}\n.mapSection[data-v-d4956396] { \r\n    grid-column: 2 / 3;\r\n    height: 100%;\n}\n.main_dropdown[data-v-d4956396] {\r\n    width: 90%;\r\n    text-align: center;\r\n    height: 3%;\n}\ndetails[data-v-d4956396] {\r\n    font-size: 1.8rem;\n}\nsummary[data-v-d4956396] {\r\n    margin-bottom: 1rem;\n}\n.main-button[data-v-d4956396], .safety-categories[data-v-d4956396] {\r\n    display: grid;\r\n    grid-template-columns: 1fr 1fr;\r\n    gap: 1rem;\r\n    padding-bottom: 1rem;\r\n    border-bottom: 1px solid #3333;\n}\n.main-button button[data-v-d4956396], .safety-categories button[data-v-d4956396] {\r\n    width: 100%;\r\n    padding: 1rem 0;\r\n    border: 1px solid #3333;\r\n    margin-right: 1rem;\r\n    word-break: keep-all;\r\n    cursor: pointer;\r\n    font-size: 1.2rem;\n}\n.legend[data-v-d4956396] {\r\n    position: absolute;\r\n    top: 70px; \r\n    right: 20px;\r\n    z-index: 1; \r\n    background-color: #fff;\r\n    padding: 10px;\r\n    border: 1px solid #ccc;\r\n    border-radius: 5px;\r\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n.legend h3[data-v-d4956396] {\r\n    margin: 0 0 10px;\r\n    font-size: 16px;\n}\n.legend-item[data-v-d4956396] {\r\n    display: flex;\r\n    align-items: center;\r\n    margin-bottom: 5px;\n}\n.legend-color[data-v-d4956396] {\r\n    display: inline-block;\r\n    width: 20px;\r\n    height: 20px;\r\n    margin-right: 5px;\n}\n.legend-label[data-v-d4956396] {\r\n    font-size: 14px;\n}\r\n`, ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack:///./client/views/pages/main/Main.vue?./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet%5B1%5D.rules%5B6%5D.use%5B0%5D')},994:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(120);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(23)/* [\"default\"] */ .Z)\nvar update = add(\"6d99e336\", content, false, {});\n// Hot Module Replacement\nif(false) {}\n\n//# sourceURL=webpack:///./client/views/pages/chart/Environment.vue?./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet%5B1%5D.rules%5B6%5D.use%5B0%5D")},137:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(781);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(23)/* [\"default\"] */ .Z)\nvar update = add(\"dbb14966\", content, false, {});\n// Hot Module Replacement\nif(false) {}\n\n//# sourceURL=webpack:///./client/views/pages/chart/Population.vue?./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet%5B1%5D.rules%5B6%5D.use%5B0%5D")},896:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(202);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(23)/* [\"default\"] */ .Z)\nvar update = add(\"e51a1a1a\", content, false, {});\n// Hot Module Replacement\nif(false) {}\n\n//# sourceURL=webpack:///./client/views/pages/chart/Safety.vue?./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet%5B1%5D.rules%5B6%5D.use%5B0%5D")},628:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(651);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(23)/* [\"default\"] */ .Z)\nvar update = add(\"26b544c9\", content, false, {});\n// Hot Module Replacement\nif(false) {}\n\n//# sourceURL=webpack:///./client/views/pages/main/Main.vue?./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet%5B1%5D.rules%5B6%5D.use%5B0%5D")},23:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  Z: () => (/* binding */ addStylesClient)\n});\n\n;// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/listToStyles.js\n/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nfunction listToStyles(parentId, list) {\n  var styles = [];\n  var newStyles = {};\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = item[0];\n    var css = item[1];\n    var media = item[2];\n    var sourceMap = item[3];\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    };\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = {\n        id: id,\n        parts: [part]\n      });\n    } else {\n      newStyles[id].parts.push(part);\n    }\n  }\n  return styles;\n}\n;// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/addStylesClient.js\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\n\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\nvar options = null\nvar ssrIdKey = 'data-vue-ssr-id'\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nfunction addStylesClient (parentId, list, _isProduction, _options) {\n  isProduction = _isProduction\n\n  options = _options || {}\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[' + ssrIdKey + '~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n  if (options.ssrId) {\n    styleElement.setAttribute(ssrIdKey, obj.id)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/vue-style-loader/lib/addStylesClient.js_+_1_modules?")}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={id:e,exports:{}};return __webpack_modules__[e](t,t.exports,__webpack_require__),t.exports}__webpack_require__.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(84)})();